diff -Naur splash2/codes/apps/barnes/code.C splash2-modified/codes/apps/barnes/code.C
--- splash2/codes/apps/barnes/code.C	1994-10-19 14:22:32.000000000 -0400
+++ splash2-modified/codes/apps/barnes/code.C	2007-03-09 01:25:06.000000000 -0500
@@ -21,7 +21,7 @@
     -h : Print out input file description
 
     Input parameters should be placed in a file and redirected through
-    standard input.  There are a total of twelve parameters, and all of 
+    standard input.  There are a total of twelve parameters, and all of
     them have default values.
 
     1) infile (char*) : The name of an input file that contains particle
@@ -52,7 +52,7 @@
        Default is 0.05.
     7) tol (double) : The cell subdivision tolerance.
        Default is 1.0.
-    8) fcells (double) : Number of cells created = fcells * number of 
+    8) fcells (double) : Number of cells created = fcells * number of
        leaves.
        Default is 2.0.
     9) fleaves (double) : Number of leaves created = fleaves * nbody.
@@ -69,10 +69,7 @@
 
 #define global  /* nada */
 
-#include "code.h"
-#include "defs.h"
-#include <math.h>
-#include <time.h>
+#include "stdinc.h"
 
 string defv[] = {                 /* DEFAULT PARAMETER VALUES              */
     /* file names for input/output                                         */
@@ -96,24 +93,157 @@
     "NPROC=1",                    /* number of processors                  */
 };
 
-void SlaveStart ();
-void stepsystem (unsigned int ProcessId);
-void ComputeForces ();
-void Help();
-FILE *fopen();
-
-main(argc, argv)
-int argc;
-string argv[];
+/* The more complicated 3D case */
+#define NUM_DIRECTIONS 32
+#define BRC_FUC 0
+#define BRC_FRA 1
+#define BRA_FDA 2
+#define BRA_FRC 3
+#define BLC_FDC 4
+#define BLC_FLA 5
+#define BLA_FUA 6
+#define BLA_FLC 7
+#define BUC_FUA 8
+#define BUC_FLC 9
+#define BUA_FUC 10
+#define BUA_FRA 11
+#define BDC_FDA 12
+#define BDC_FRC 13
+#define BDA_FDC 14
+#define BDA_FLA 15
+
+#define FRC_BUC 16
+#define FRC_BRA 17
+#define FRA_BDA 18
+#define FRA_BRC 19
+#define FLC_BDC 20
+#define FLC_BLA 21
+#define FLA_BUA 22
+#define FLA_BLC 23
+#define FUC_BUA 24
+#define FUC_BLC 25
+#define FUA_BUC 26
+#define FUA_BRA 27
+#define FDC_BDA 28
+#define FDC_BRC 29
+#define FDA_BDC 30
+#define FDA_BLA 31
+
+static long Child_Sequence[NUM_DIRECTIONS][NSUB] =
+{
+	{ 2, 5, 6, 1, 0, 3, 4, 7},  /* BRC_FUC */
+ { 2, 5, 6, 1, 0, 7, 4, 3},  /* BRC_FRA */
+ { 1, 6, 5, 2, 3, 0, 7, 4},  /* BRA_FDA */
+ { 1, 6, 5, 2, 3, 4, 7, 0},  /* BRA_FRC */
+ { 6, 1, 2, 5, 4, 7, 0, 3},  /* BLC_FDC */
+ { 6, 1, 2, 5, 4, 3, 0, 7},  /* BLC_FLA */
+ { 5, 2, 1, 6, 7, 4, 3, 0},  /* BLA_FUA */
+ { 5, 2, 1, 6, 7, 0, 3, 4},  /* BLA_FLC */
+ { 1, 2, 5, 6, 7, 4, 3, 0},  /* BUC_FUA */
+ { 1, 2, 5, 6, 7, 0, 3, 4},  /* BUC_FLC */
+ { 6, 5, 2, 1, 0, 3, 4, 7},  /* BUA_FUC */
+ { 6, 5, 2, 1, 0, 7, 4, 3},  /* BUA_FRA */
+ { 5, 6, 1, 2, 3, 0, 7, 4},  /* BDC_FDA */
+ { 5, 6, 1, 2, 3, 4, 7, 0},  /* BDC_FRC */
+ { 2, 1, 6, 5, 4, 7, 0, 3},  /* BDA_FDC */
+ { 2, 1, 6, 5, 4, 3, 0, 7},  /* BDA_FLA */
+
+ { 3, 4, 7, 0, 1, 2, 5, 6},  /* FRC_BUC */
+ { 3, 4, 7, 0, 1, 6, 5, 2},  /* FRC_BRA */
+ { 0, 7, 4, 3, 2, 1, 6, 5},  /* FRA_BDA */
+ { 0, 7, 4, 3, 2, 5, 6, 1},  /* FRA_BRC */
+ { 7, 0, 3, 4, 5, 6, 1, 2},  /* FLC_BDC */
+ { 7, 0, 3, 4, 5, 2, 1, 6},  /* FLC_BLA */
+ { 4, 3, 0, 7, 6, 5, 2, 1},  /* FLA_BUA */
+ { 4, 3, 0, 7, 6, 1, 2, 5},  /* FLA_BLC */
+ { 0, 3, 4, 7, 6, 5, 2, 1},  /* FUC_BUA */
+ { 0, 3, 4, 7, 6, 1, 2, 5},  /* FUC_BLC */
+ { 7, 4, 3, 0, 1, 2, 5, 6},  /* FUA_BUC */
+ { 7, 4, 3, 0, 1, 6, 5, 2},  /* FUA_BRA */
+ { 4, 7, 0, 3, 2, 1, 6, 5},  /* FDC_BDA */
+ { 4, 7, 0, 3, 2, 5, 6, 1},  /* FDC_BRC */
+ { 3, 0, 7, 4, 5, 6, 1, 2},  /* FDA_BDC */
+ { 3, 0, 7, 4, 5, 2, 1, 6},  /* FDA_BLA */
+};
+
+static long Direction_Sequence[NUM_DIRECTIONS][NSUB] =
+{
+	{ FRC_BUC, BRA_FRC, FDA_BDC, BLA_FUA, BUC_FLC, FUA_BUC, BRA_FRC, FDA_BLA },
+ /* BRC_FUC */
+ { FRC_BUC, BRA_FRC, FDA_BDC, BLA_FUA, BRA_FDA, FRC_BRA, BUC_FUA, FLC_BDC },
+ /* BRC_FRA */
+ { FRA_BDA, BRC_FRA, FUC_BUA, BLC_FDC, BDA_FLA, FDC_BDA, BRC_FRA, FUC_BLC },
+ /* BRA_FDA */
+ { FRA_BDA, BRC_FRA, FUC_BUA, BLC_FDC, BUC_FLC, FUA_BUC, BRA_FRC, FDA_BLA },
+ /* BRA_FRC */
+ { FLC_BDC, BLA_FLC, FUA_BUC, BRA_FDA, BDC_FRC, FDA_BDC, BLA_FLC, FUA_BRA },
+ /* BLC_FDC */
+ { FLC_BDC, BLA_FLC, FUA_BUC, BRA_FDA, BLA_FUA, FLC_BLA, BDC_FDA, FRC_BUC },
+ /* BLC_FLA */
+ { FLA_BUA, BLC_FLA, FDC_BDA, BRC_FUC, BUA_FRA, FUC_BUA, BLC_FLA, FDC_BRC },
+ /* BLA_FUA */
+ { FLA_BUA, BLC_FLA, FDC_BDA, BRC_FUC, BLC_FDC, FLA_BLC, BUA_FUC, FRA_BDA },
+ /* BLA_FLC */
+ { FUC_BLC, BUA_FUC, FRA_BRC, BDA_FLA, BUA_FRA, FUC_BUA, BLC_FLA, FDC_BRC },
+ /* BUC_FUA */
+ { FUC_BLC, BUA_FUC, FRA_BRC, BDA_FLA, BLC_FDC, FLA_BLC, BUA_FUC, FRA_BDA },
+ /* BUC_FLC */
+ { FUA_BRA, BUC_FUA, FLC_BLA, BDC_FRC, BUC_FLC, FUA_BUC, BRA_FRC, FDA_BLA },
+ /* BUA_FUC */
+ { FUA_BRA, BUC_FUA, FLC_BLA, BDC_FRC, BRA_FDA, FRC_BRA, BUC_FUA, FLC_BDC },
+ /* BUA_FRA */
+ { FDC_BRC, BDA_FDC, FLA_BLC, BUA_FRA, BDA_FLA, FDC_BDA, BRC_FRA, FUC_BLC },
+ /* BDC_FDA */
+ { FDC_BRC, BDA_FDC, FLA_BLC, BUA_FRA, BUC_FLC, FUA_BUC, BRA_FRC, FDA_BLA },
+ /* BDC_FRC */
+ { FDA_BLA, BDC_FDA, FRC_BRA, BUC_FLC, BDC_FRC, FDA_BDC, BLA_FLC, FUA_BRA },
+ /* BDA_FDC */
+ { FDA_BLA, BDC_FDA, FRC_BRA, BUC_FLC, BLA_FUA, FLC_BLA, BDC_FDA, FRC_BUC },
+ /* BDA_FLA */
+
+ { BUC_FLC, FUA_BUC, BRA_FRC, FDA_BLA, FUC_BLC, BUA_FUC, FRA_BRC, BDA_FLA },
+ /* FRC_BUC */
+ { BUC_FLC, FUA_BUC, BRA_FRC, FDA_BLA, FRA_BDA, BRC_FRA, FUC_BUA, BLC_FDC },
+ /* FRC_BRA */
+ { BRA_FDA, FRC_BRA, BUC_FUA, FLC_BDC, FDA_BLA, BDC_FDA, FRC_BRA, BUC_FLC },
+ /* FRA_BDA */
+ { BRA_FDA, FRC_BRA, BUC_FUA, FLC_BDC, FRC_BUC, BRA_FRC, FDA_BDC, BLA_FUA },
+ /* FRA_BRC */
+ { BLC_FDC, FLA_BLC, BUA_FUC, FRA_BDA, FDC_BRC, BDA_FDC, FLA_BLC, BUA_FRA },
+ /* FLC_BDC */
+ { BLC_FDC, FLA_BLC, BUA_FUC, FRA_BDA, FLA_BUA, BLC_FLA, FDC_BDA, BRC_FUC },
+ /* FLC_BLA */
+ { BLA_FUA, FLC_BLA, BDC_FDA, FRC_BUC, FUA_BRA, BUC_FUA, FLC_BLA, BDC_FRC },
+ /* FLA_BUA */
+ { BLA_FUA, FLC_BLA, BDC_FDA, FRC_BUC, FLC_BDC, BLA_FLC, FUA_BUC, BRA_FDA },
+ /* FLA_BLC */
+ { BUC_FLC, FUA_BUC, BRA_FRC, FDA_BLA, FUA_BRA, BUC_FUA, FLC_BLA, BDC_FRC },
+ /* FUC_BUA */
+ { BUC_FLC, FUA_BUC, BRA_FRC, FDA_BLA, FLC_BDC, BLA_FLC, FUA_BUC, BRA_FDA },
+ /* FUC_BLC */
+ { BUA_FRA, FUC_BUA, BLC_FLA, FDC_BRC, FUC_BLC, BUA_FUC, FRA_BRC, BDA_FLA },
+ /* FUA_BUC */
+ { BUA_FRA, FUC_BUA, BLC_FLA, FDC_BRC, FRA_BDA, BRC_FRA, FUC_BUA, BLC_FDC },
+ /* FUA_BRA */
+ { BDC_FRC, FDA_BDC, BLA_FLC, FUA_BRA, FDA_BLA, BDC_FDA, FRC_BRA, BUC_FLC },
+ /* FDC_BDA */
+ { BDC_FRC, FDA_BDC, BLA_FLC, FUA_BRA, FRC_BUC, BRA_FRC, FDA_BDC, BLA_FUA },
+ /* FDC_BRC */
+ { BDA_FLA, FDC_BDA, BRC_FRA, FUC_BLC, FDC_BRC, BDA_FDC, FLA_BLC, BUA_FRA },
+ /* FDA_BDC */
+ { BDA_FLA, FDC_BDA, BRC_FRA, FUC_BLC, FLA_BUA, BLC_FLA, FDC_BDA, BRC_FUC },
+ /* FDA_BLA */
+};
+
+int main (int argc, string argv[])
 {
-   unsigned ProcessId = 0;
-   int c;
+   long c;
 
    while ((c = getopt(argc, argv, "h")) != -1) {
      switch(c) {
-      case 'h': 
-	Help(); 
-	exit(-1); 
+      case 'h':
+	Help();
+	exit(-1);
 	break;
       default:
 	fprintf(stderr, "Only valid option is \"-h\".\n");
@@ -122,8 +252,8 @@
      }
    }
 
-   ANLinit();
-   initparam(argv, defv);
+   Global = NULL;
+   initparam(defv);
    startrun();
    initoutput();
    tab_init();
@@ -132,58 +262,48 @@
    Global->partitiontime = 0;
    Global->treebuildtime = 0;
    Global->forcecalctime = 0;
-
-   /* Create the slave processes: number of processors less one,
-      since the master will do work as well */
    Global->current_id = 0;
-   for(ProcessId = 1; ProcessId < NPROC; ProcessId++) {
-      CREATE(SlaveStart);
-   }
 
-   /* Make the master do slave work so we don't waste the processor */
    CLOCK(Global->computestart);
-   printf("COMPUTESTART  = %12u\n",Global->computestart);
-   SlaveStart();
 
-   CLOCK(Global->computeend);
+   printf("COMPUTESTART  = %12lu\n",Global->computestart);
 
-   WAIT_FOR_END(NPROC-1);
+   CREATE(SlaveStart, NPROC);
 
-   printf("COMPUTEEND    = %12u\n",Global->computeend);
-   printf("COMPUTETIME   = %12u\n",Global->computeend - Global->computestart);
-   printf("TRACKTIME     = %12u\n",Global->tracktime); 
-   printf("PARTITIONTIME = %12u\t%5.2f\n",Global->partitiontime,
+   WAIT_FOR_END(NPROC);
+
+   CLOCK(Global->computeend);
+
+   printf("COMPUTEEND    = %12lu\n",Global->computeend);
+   printf("COMPUTETIME   = %12lu\n",Global->computeend - Global->computestart);
+   printf("TRACKTIME     = %12lu\n",Global->tracktime);
+   printf("PARTITIONTIME = %12lu\t%5.2f\n",Global->partitiontime,
 	  ((float)Global->partitiontime)/Global->tracktime);
-   printf("TREEBUILDTIME = %12u\t%5.2f\n",Global->treebuildtime, 
+   printf("TREEBUILDTIME = %12lu\t%5.2f\n",Global->treebuildtime,
 	  ((float)Global->treebuildtime)/Global->tracktime);
-   printf("FORCECALCTIME = %12u\t%5.2f\n",Global->forcecalctime,
+   printf("FORCECALCTIME = %12lu\t%5.2f\n",Global->forcecalctime,
 	  ((float)Global->forcecalctime)/Global->tracktime);
-   printf("RESTTIME      = %12u\t%5.2f\n",
-	  Global->tracktime - Global->partitiontime - 
-	  Global->treebuildtime - Global->forcecalctime, 
+   printf("RESTTIME      = %12lu\t%5.2f\n",
+	  Global->tracktime - Global->partitiontime -
+	  Global->treebuildtime - Global->forcecalctime,
 	  ((float)(Global->tracktime-Global->partitiontime-
 		   Global->treebuildtime-Global->forcecalctime))/
 	  Global->tracktime);
    MAIN_END;
 }
-
+
 /*
  * ANLINIT : initialize ANL macros
  */
-ANLinit()
+void ANLinit()
 {
    MAIN_INITENV(,70000000,);
    /* Allocate global, shared memory */
 
    Global = (struct GlobalMemory *) G_MALLOC(sizeof(struct GlobalMemory));
    if (Global==NULL) error("No initialization for Global\n");
-    
-   BARINIT(Global->Barload);
-   BARINIT(Global->Bartree);
-   BARINIT(Global->Barcom);
-   BARINIT(Global->Baraccel);
-   BARINIT(Global->Barstart);
-   BARINIT(Global->Barpos);
+
+   BARINIT(Global->Barrier, NPROC);
 
    LOCKINIT(Global->CountLock);
    LOCKINIT(Global->io_lock);
@@ -192,12 +312,12 @@
 /*
  * INIT_ROOT: Processor 0 reinitialize the global root at each time step
  */
-init_root (ProcessId)
-   unsigned int ProcessId;
+void init_root()
 {
-   int i;
+   long i;
 
    Global->G_root=Local[0].ctab;
+   Global->G_root->seqnum = 0;
    Type(Global->G_root) = CELL;
    Done(Global->G_root) = FALSE;
    Level(Global->G_root) = IMAX >> 1;
@@ -207,11 +327,10 @@
    Local[0].mynumcell=1;
 }
 
-int Log_base_2(number)
-int number;
+long Log_base_2(long number)
 {
-   int cumulative;
-   int out;
+   long cumulative;
+   long out;
 
    cumulative = 1;
    for (out = 0; out < 20; out++) {
@@ -223,7 +342,7 @@
       }
    }
 
-   fprintf(stderr,"Log_base_2: couldn't find log2 of %d\n", number);
+   fprintf(stderr,"Log_base_2: couldn't find log2 of %ld\n", number);
    exit(-1);
 }
 
@@ -231,14 +350,12 @@
  * TAB_INIT : allocate body and cell data space
  */
 
-tab_init()
+void tab_init()
 {
-   cellptr pc;
-   int i;
-   char *starting_address, *ending_address;
+   long i;
 
    /*allocate leaf/cell space */
-   maxleaf = (int) ((double) fleaves * nbody);
+   maxleaf = (long) ((double) fleaves * nbody);
    maxcell = fcells * maxleaf;
    for (i = 0; i < NPROC; ++i) {
       Local[i].ctab = (cellptr) G_MALLOC((maxcell / NPROC) * sizeof(cell));
@@ -246,10 +363,10 @@
    }
 
    /*allocate space for personal lists of body pointers */
-   maxmybody = (nbody+maxleaf*MAX_BODIES_PER_LEAF)/NPROC; 
+   maxmybody = (nbody+maxleaf*MAX_BODIES_PER_LEAF)/NPROC;
    Local[0].mybodytab = (bodyptr*) G_MALLOC(NPROC*maxmybody*sizeof(bodyptr));
    /* space is allocated so that every */
-   /* process can have a maximum of maxmybody pointers to bodies */ 
+   /* process can have a maximum of maxmybody pointers to bodies */
    /* then there is an array of bodies called bodytab which is  */
    /* allocated in the distribution generation or when the distr. */
    /* file is read */
@@ -267,13 +384,15 @@
  */
 void SlaveStart()
 {
-   unsigned int ProcessId;
+   long ProcessId;
 
    /* Get unique ProcessId */
    LOCK(Global->CountLock);
      ProcessId = Global->current_id++;
    UNLOCK(Global->CountLock);
 
+   BARINCLUDE(Global->Barrier);
+
 /* POSSIBLE ENHANCEMENT:  Here is where one might pin processes to
    processors to avoid migration */
 
@@ -286,24 +405,24 @@
    Local[ProcessId].mycelltab = Local[0].mycelltab + (maxmycell * ProcessId);
    Local[ProcessId].myleaftab = Local[0].myleaftab + (maxmyleaf * ProcessId);
 /* POSSIBLE ENHANCEMENT:  Here is where one might distribute the
-   data across physically distributed memories as desired. 
+   data across physically distributed memories as desired.
 
    One way to do this is as follows:
 
-   int i;
+   long i;
 
    if (ProcessId == 0) {
      for (i=0;i<NPROC;i++) {
-       Place all addresses x such that 
+       Place all addresses x such that
          &(Local[i]) <= x < &(Local[i])+
            sizeof(struct local_memory) on node i
-       Place all addresses x such that 
+       Place all addresses x such that
          &(Local[i].mybodytab) <= x < &(Local[i].mybodytab)+
            maxmybody * sizeof(bodyptr) - 1 on node i
-       Place all addresses x such that 
+       Place all addresses x such that
          &(Local[i].mycelltab) <= x < &(Local[i].mycelltab)+
            maxmycell * sizeof(cellptr) - 1 on node i
-       Place all addresses x such that 
+       Place all addresses x such that
          &(Local[i].myleaftab) <= x < &(Local[i].myleaftab)+
            maxmyleaf * sizeof(leafptr) - 1 on node i
      }
@@ -322,24 +441,22 @@
    /* main loop */
    while (Local[ProcessId].tnow < tstop + 0.1 * dtime) {
       stepsystem(ProcessId);
+//      printtree(Global->G_root);
+//      printf("Going to next step!!!\n");
    }
 }
 
-
+
 /*
  * STARTRUN: startup hierarchical N-body code.
  */
 
-startrun()
+void startrun()
 {
-   string getparam();
-   int getiparam();
-   bool getbparam();
-   double getdparam();
-   int seed;
+   long seed;
 
    infile = getparam("in");
-   if (*infile != NULL) {
+   if (*infile != '\0'/*NULL*/) {
       inputdata();
    }
    else {
@@ -365,10 +482,11 @@
    Local[0].nstep = 0;
    pranset(seed);
    testdata();
+   ANLinit();
    setbound();
    Local[0].tout = Local[0].tnow + dtout;
 }
-
+
 /*
  * TESTDATA: generate Plummer model initial conditions for test runs,
  * scaled to units such that M = -4E = G = 1 (Henon, Hegge, etc).
@@ -377,23 +495,21 @@
 
 #define MFRAC  0.999                /* mass cut off at MFRAC of total */
 
-testdata()
+void testdata()
 {
-   real rsc, vsc, sqrt(), xrand(), pow(), rsq, r, v, x, y;
+   real rsc, vsc, r, v, x, y;
    vector cmr, cmv;
    register bodyptr p;
-   int rejects = 0;
-   int k;
-   int halfnbody, i;
+   long rejects = 0;
+   long halfnbody, i;
    float offset;
    register bodyptr cp;
-   double tmp;
 
    headline = "Hack code: Plummer model";
    Local[0].tnow = 0.0;
    bodytab = (bodyptr) G_MALLOC(nbody * sizeof(body));
    if (bodytab == NULL) {
-      error("testdata: not enuf memory\n");
+      error("testdata: not enough memory\n");
    }
    rsc = 9 * PI / 16;
    vsc = sqrt(1.0 / rsc);
@@ -413,7 +529,7 @@
       while (r > 9.0) {
 	 rejects++;
 	 r = 1 / sqrt(pow(xrand(0.0, MFRAC), -2.0/3.0) - 1);
-      }        
+      }
       pickshell(Pos(p), rsc * r);
       ADDV(cmr, cmr, Pos(p));
       do {
@@ -436,11 +552,11 @@
 
       cp = p - halfnbody;
       for (i = 0; i < NDIM; i++){
-	 Pos(p)[i] = Pos(cp)[i] + offset; 
-	 ADDV(cmr, cmr, Pos(p));
+	 Pos(p)[i] = Pos(cp)[i] + offset;
 	 Vel(p)[i] = Vel(cp)[i];
-	 ADDV(cmv, cmv, Vel(p));
       }
+      ADDV(cmr, cmr, Pos(p));
+      ADDV(cmv, cmv, Vel(p));
    }
 
    DIVVS(cmr, cmr, (real) nbody);
@@ -456,12 +572,10 @@
  * PICKSHELL: pick a random point on a sphere of specified radius.
  */
 
-pickshell(vec, rad)
-   real vec[];                     /* coordinate vector chosen */
-   real rad;                       /* radius of chosen point */
+void pickshell(real vec[], real rad)
 {
-   register int k;
-   double rsq, xrand(), sqrt(), rsc;
+   register long k;
+   double rsq, rsc;
 
    do {
       for (k = 0; k < NDIM; k++) {
@@ -474,13 +588,12 @@
    MULVS(vec, vec, rsc);
 }
 
-
 
-int intpow(i,j)
-  int i,j;
-{   
-    int k;
-    int temp = 1;
+
+long intpow(long i, long j)
+{
+    long k;
+    long temp = 1;
 
     for (k = 0; k < j; k++)
         temp = temp*i;
@@ -492,20 +605,16 @@
  * STEPSYSTEM: advance N-body system one time-step.
  */
 
-void
-stepsystem (ProcessId)
-   unsigned int ProcessId;
+void stepsystem(long ProcessId)
 {
-    int i;
+    long i;
     real Cavg;
     bodyptr p,*pp;
-    vector acc1, dacc, dvel, vel1, dpos;
-    int intpow();
-    unsigned int time;
-    unsigned int trackstart, trackend;
-    unsigned int partitionstart, partitionend;
-    unsigned int treebuildstart, treebuildend;
-    unsigned int forcecalcstart, forcecalcend;
+    vector dvel, vel1, dpos;
+    long trackstart, trackend;
+    long partitionstart, partitionend;
+    long treebuildstart, treebuildend;
+    long forcecalcstart, forcecalcend;
 
     if (Local[ProcessId].nstep == 2) {
 /* POSSIBLE ENHANCEMENT:  Here is where one might reset the
@@ -517,7 +626,7 @@
     }
 
     if (ProcessId == 0) {
-       init_root(ProcessId);
+       init_root();
     }
     else {
        Local[ProcessId].mynumcell = 0;
@@ -526,7 +635,7 @@
 
 
     /* start at same time */
-    BARRIER(Global->Barstart,NPROC);
+    BARRIER(Global->Barrier,NPROC);
 
     if ((ProcessId == 0) && (Local[ProcessId].nstep >= 2)) {
         CLOCK(treebuildstart);
@@ -534,7 +643,6 @@
 
     /* load bodies into tree   */
     maketree(ProcessId);
-
     if ((ProcessId == 0) && (Local[ProcessId].nstep >= 2)) {
         CLOCK(treebuildend);
         Global->treebuildtime += treebuildend - treebuildstart;
@@ -543,8 +651,8 @@
     Housekeep(ProcessId);
 
     Cavg = (real) Cost(Global->G_root) / (real)NPROC ;
-    Local[ProcessId].workMin = (int) (Cavg * ProcessId);
-    Local[ProcessId].workMax = (int) (Cavg * (ProcessId + 1)
+    Local[ProcessId].workMin = (long) (Cavg * ProcessId);
+    Local[ProcessId].workMax = (long) (Cavg * (ProcessId + 1)
 				      + (ProcessId == (NPROC - 1)));
 
     if ((ProcessId == 0) && (Local[ProcessId].nstep >= 2)) {
@@ -575,12 +683,12 @@
     for (pp = Local[ProcessId].mybodytab;
 	 pp < Local[ProcessId].mybodytab+Local[ProcessId].mynbody; pp++) {
        p = *pp;
-       MULVS(dvel, Acc(p), dthf);              
-       ADDV(vel1, Vel(p), dvel);               
-       MULVS(dpos, vel1, dtime);               
-       ADDV(Pos(p), Pos(p), dpos);             
-       ADDV(Vel(p), vel1, dvel);               
-        
+       MULVS(dvel, Acc(p), dthf);
+       ADDV(vel1, Vel(p), dvel);
+       MULVS(dpos, vel1, dtime);
+       ADDV(Pos(p), Pos(p), dpos);
+       ADDV(Vel(p), vel1, dvel);
+
        for (i = 0; i < NDIM; i++) {
           if (Pos(p)[i]<Local[ProcessId].min[i]) {
 	     Local[ProcessId].min[i]=Pos(p)[i];
@@ -604,7 +712,7 @@
     /* bar needed to make sure that every process has computed its min */
     /* and max coordinates, and has accumulated them into the global   */
     /* min and max, before the new dimensions are computed	       */
-    BARRIER(Global->Barpos,NPROC);
+    BARRIER(Global->Barrier,NPROC);
 
     if ((ProcessId == 0) && (Local[ProcessId].nstep >= 2)) {
         CLOCK(trackend);
@@ -627,22 +735,20 @@
     Local[ProcessId].tnow = Local[ProcessId].tnow + dtime;
 }
 
-
 
-void
-ComputeForces (ProcessId)
-   unsigned int ProcessId;
+
+void ComputeForces(long ProcessId)
 {
    bodyptr p,*pp;
-   vector acc1, dacc, dvel, vel1, dpos;
+   vector acc1, dacc, dvel;
 
    for (pp = Local[ProcessId].mybodytab;
-	pp < Local[ProcessId].mybodytab+Local[ProcessId].mynbody;pp++) {  
+	pp < Local[ProcessId].mybodytab+Local[ProcessId].mynbody;pp++) {
       p = *pp;
       SETV(acc1, Acc(p));
       Cost(p)=0;
       hackgrav(p,ProcessId);
-      Local[ProcessId].myn2bcalc += Local[ProcessId].myn2bterm; 
+      Local[ProcessId].myn2bcalc += Local[ProcessId].myn2bterm;
       Local[ProcessId].mynbccalc += Local[ProcessId].mynbcterm;
       if (!Local[ProcessId].skipself) {       /*   did we miss self-int?  */
 	 Local[ProcessId].myselfint++;        /*   count another goofup   */
@@ -656,45 +762,35 @@
    }
 }
 
-/* 
- * FIND_MY_INITIAL_BODIES: puts into mybodytab the initial list of bodies 
- * assigned to the processor.  
+/*
+ * FIND_MY_INITIAL_BODIES: puts into mybodytab the initial list of bodies
+ * assigned to the processor.
  */
 
-find_my_initial_bodies(btab, nbody, ProcessId)
-bodyptr btab;
-int nbody;
-unsigned int ProcessId;
-{
-  int Myindex;
-  int intpow();
-  int equalbodies;
-  int extra,offset,i;
+void find_my_initial_bodies(bodyptr btab, long nbody, long ProcessId)
+{
+  long extra,offset,i;
 
   Local[ProcessId].mynbody = nbody / NPROC;
   extra = nbody % NPROC;
   if (ProcessId < extra) {
-    Local[ProcessId].mynbody++;    
+    Local[ProcessId].mynbody++;
     offset = Local[ProcessId].mynbody * ProcessId;
   }
   if (ProcessId >= extra) {
-    offset = (Local[ProcessId].mynbody+1) * extra + (ProcessId - extra) 
-       * Local[ProcessId].mynbody; 
+    offset = (Local[ProcessId].mynbody+1) * extra + (ProcessId - extra)
+       * Local[ProcessId].mynbody;
   }
   for (i=0; i < Local[ProcessId].mynbody; i++) {
      Local[ProcessId].mybodytab[i] = &(btab[offset+i]);
   }
-  BARRIER(Global->Barstart,NPROC);
+  BARRIER(Global->Barrier,NPROC);
 }
 
 
-find_my_bodies(mycell, work, direction, ProcessId)
-  nodeptr mycell;
-  int work;
-  int direction;
-  unsigned ProcessId;
+void find_my_bodies(nodeptr mycell, long work, long direction, long ProcessId)
 {
-   int i;
+   long i;
    leafptr l;
    nodeptr qptr;
 
@@ -703,9 +799,9 @@
       for (i = 0; i < l->num_bodies; i++) {
 	 if (work >= Local[ProcessId].workMin - .1) {
 	    if((Local[ProcessId].mynbody+2) > maxmybody) {
-	       error("find_my_bodies: Processor %d needs more than %d bodies; increase fleaves\n",ProcessId, maxmybody); 
+	       error("find_my_bodies: Processor %ld needs more than %ld bodies; increase fleaves\n", ProcessId, maxmybody);
 	    }
-	    Local[ProcessId].mybodytab[Local[ProcessId].mynbody++] = 
+	    Local[ProcessId].mybodytab[Local[ProcessId].mynbody++] =
 	       Bodyp(l)[i];
 	 }
 	 work += Cost(Bodyp(l)[i]);
@@ -733,10 +829,9 @@
  * variables) between each time step.
  */
 
-Housekeep(ProcessId)
-unsigned ProcessId;
+void Housekeep(long ProcessId)
 {
-   Local[ProcessId].myn2bcalc = Local[ProcessId].mynbccalc 
+   Local[ProcessId].myn2bcalc = Local[ProcessId].mynbccalc
       = Local[ProcessId].myselfint = 0;
    SETVS(Local[ProcessId].min,1E99);
    SETVS(Local[ProcessId].max,-1E99);
@@ -746,9 +841,9 @@
  * SETBOUND: Compute the initial size of the root of the tree; only done
  * before first time step, and only processor 0 does it
  */
-setbound()
+void setbound()
 {
-   int i;
+   long i;
    real side ;
    bodyptr p;
 
@@ -762,7 +857,7 @@
 	 if (Pos(p)[i]>Local[0].max[i])  Local[0].max[i]=Pos(p)[i] ;
       }
    }
-    
+
    SUBV(Local[0].max,Local[0].max,Local[0].min);
    for (i=0; i<NDIM;i++) if (side<Local[0].max[i]) side=Local[0].max[i];
    ADDVS(Global->rmin,Local[0].min,-side/100000.0);
@@ -771,8 +866,7 @@
    SETVS(Global->min,1E99);
 }
 
-void
-Help () 
+void Help()
 {
    printf("There are a total of twelve parameters, and all of them have default values.\n");
    printf("\n");
diff -Naur splash2/codes/apps/barnes/code.H splash2-modified/codes/apps/barnes/code.H
--- splash2/codes/apps/barnes/code.H	1994-10-19 14:21:13.000000000 -0400
+++ splash2-modified/codes/apps/barnes/code.H	2007-03-08 16:32:14.000000000 -0500
@@ -21,9 +21,7 @@
 #ifndef _CODE_H_
 #define _CODE_H_
 
-#include "defs.h"
-
-#define PAD_SIZE (PAGE_SIZE / (sizeof(int)))
+#define PAD_SIZE (PAGE_SIZE / (sizeof(long)))
 
 /* Defined by the input file */
 global string headline; 	/* message describing calculation */
@@ -32,7 +30,7 @@
 global real dtime; 		/* timestep for leapfrog integrator */
 global real dtout; 		/* time between data outputs */
 global real tstop; 		/* time to stop calculation */
-global int nbody; 		/* number of bodies in system */
+global long nbody; 		/* number of bodies in system */
 global real fcells; 		/* ratio of cells/leaves allocated */
 global real fleaves; 		/* ratio of leaves/bodies allocated */
 global real tol; 		/* accuracy parameter: 0.0 => exact */
@@ -40,23 +38,23 @@
 global real eps; 		/* potential softening parameter */
 global real epssq; 		/* square of previous */
 global real dthf; 		/* half time step */
-global int NPROC; 		/* Number of Processors */
+global long NPROC;		/* Number of Processors */
 
-global int maxcell;		/* max number of cells allocated */
-global int maxleaf;		/* max number of leaves allocated */
-global int maxmybody;		/* max no. of bodies allocated per processor */
-global int maxmycell;		/* max num. of cells to be allocated */
-global int maxmyleaf;		/* max num. of leaves to be allocated */
+global long maxcell;		/* max number of cells allocated */
+global long maxleaf;		/* max number of leaves allocated */
+global long maxmybody;		/* max no. of bodies allocated per processor */
+global long maxmycell;		/* max num. of cells to be allocated */
+global long maxmyleaf;		/* max num. of leaves to be allocated */
 global bodyptr bodytab; 	/* array size is exactly nbody bodies */
 
 global struct CellLockType {
     ALOCKDEC(CL,MAXLOCK)        /* locks on the cells*/
 } *CellLock;
-    
+
 struct GlobalMemory  {	/* all this info is for the whole system */
-    int n2bcalc;       /* total number of body/cell interactions  */
-    int nbccalc;       /* total number of body/body interactions  */
-    int selfint;       /* number of self interactions             */
+    long n2bcalc;       /* total number of body/cell interactions  */
+    long nbccalc;       /* total number of body/body interactions  */
+    long selfint;       /* number of self interactions             */
     real mtot;         /* total mass of N-body system             */
     real etot[3];      /* binding, kinetic, potential energy      */
     matrix keten;      /* kinetic energy tensor                   */
@@ -68,57 +66,52 @@
     vector min;        /* temporary lower-left corner of the box  */
     vector max;        /* temporary upper right corner of the box */
     real rsize;        /* side-length of integer coordinate box   */
-    BARDEC(Barstart)   /* barrier at the beginning of stepsystem  */
-    BARDEC(Bartree)    /* barrier after loading the tree          */
-    BARDEC(Barcom)     /* barrier after computing the c. of m.    */
-    BARDEC(Barload)    
-    BARDEC(Baraccel)   /* barrier after accel and before output   */
-    BARDEC(Barpos)     /* barrier after computing the new pos     */
+    BARDEC(Barrier)   /* barrier at the beginning of stepsystem  */
     LOCKDEC(CountLock) /* Lock on the shared variables            */
     LOCKDEC(NcellLock) /* Lock on the counter of array of cells for loadtree */
     LOCKDEC(NleafLock)/* Lock on the counter of array of leaves for loadtree */
     LOCKDEC(io_lock)
-    unsigned int createstart,createend,computestart,computeend;
-    unsigned int trackstart, trackend, tracktime;
-    unsigned int partitionstart, partitionend, partitiontime;
-    unsigned int treebuildstart, treebuildend, treebuildtime;
-    unsigned int forcecalcstart, forcecalcend, forcecalctime;
-    unsigned int current_id;
-    volatile int k; /*for memory allocation in code.C */
+    unsigned long createstart,createend,computestart,computeend;
+    unsigned long trackstart, trackend, tracktime;
+    unsigned long partitionstart, partitionend, partitiontime;
+    unsigned long treebuildstart, treebuildend, treebuildtime;
+    unsigned long forcecalcstart, forcecalcend, forcecalctime;
+    long current_id;
+    volatile long k; /*for memory allocation in code.C */
 };
 global struct GlobalMemory *Global;
 
 /* This structure is needed because under the sproc model there is no
- * per processor private address space. 
+ * per processor private address space.
  */
 struct local_memory {
    /* Use padding so that each processor's variables are on their own page */
-   int pad_begin[PAD_SIZE];
+   long pad_begin[PAD_SIZE];
 
    real tnow;        	/* current value of simulation time */
    real tout;         	/* time next output is due */
-   int nstep;      	/* number of integration steps so far */
+   long nstep;      	/* number of integration steps so far */
 
-   int workMin, workMax;/* interval of cost to be treated by a proc */
+   long workMin, workMax;/* interval of cost to be treated by a proc */
 
    vector min, max; 	/* min and max of coordinates for each Proc. */
 
-   int mynumcell; 	/* num. of cells used for this proc in ctab */
-   int mynumleaf; 	/* num. of leaves used for this proc in ctab */
-   int mynbody;   	/* num bodies allocated to the processor */
+   long mynumcell; 	/* num. of cells used for this proc in ctab */
+   long mynumleaf; 	/* num. of leaves used for this proc in ctab */
+   long mynbody;   	/* num bodies allocated to the processor */
    bodyptr* mybodytab;	/* array of bodies allocated / processor */
-   int myncell; 	/* num cells allocated to the processor */
+   long myncell; 	/* num cells allocated to the processor */
    cellptr* mycelltab;	/* array of cellptrs allocated to the processor */
-   int mynleaf; 	/* number of leaves allocated to the processor */
+   long mynleaf; 	/* number of leaves allocated to the processor */
    leafptr* myleaftab; 	/* array of leafptrs allocated to the processor */
    cellptr ctab;	/* array of cells used for the tree. */
    leafptr ltab;	/* array of cells used for the tree. */
 
-   int myn2bcalc; 	/* body-body force calculations for each processor */
-   int mynbccalc; 	/* body-cell force calculations for each processor */
-   int myselfint; 	/* count self-interactions for each processor */
-   int myn2bterm; 	/* count body-body terms for a body */
-   int mynbcterm; 	/* count body-cell terms for a body */
+   long myn2bcalc; 	/* body-body force calculations for each processor */
+   long mynbccalc; 	/* body-cell force calculations for each processor */
+   long myselfint; 	/* count self-interactions for each processor */
+   long myn2bterm; 	/* count body-body terms for a body */
+   long mynbcterm; 	/* count body-cell terms for a body */
    bool skipself; 	/* true if self-interaction skipped OK */
    bodyptr pskip;       /* body to skip in force evaluation */
    vector pos0;         /* point at which to evaluate field */
@@ -129,7 +122,7 @@
    nodeptr pmem;	/* remember particle data */
 
    nodeptr Current_Root;
-   int Root_Coords[NDIM];
+   long Root_Coords[NDIM];
 
    real mymtot;      	/* total mass of N-body system */
    real myetot[3];   	/* binding, kinetic, potential energy */
@@ -138,8 +131,25 @@
    vector mycmphase[2];	/* center of mass coordinates */
    vector myamvec;   	/* angular momentum vector */
 
-   int pad_end[PAD_SIZE];
+   long pad_end[PAD_SIZE];
 };
 global struct local_memory Local[MAX_PROC];
 
+void SlaveStart(void);
+void stepsystem(long ProcessId);
+void ComputeForces(long ProcessId);
+void Help(void);
+void ANLinit(void);
+void init_root(void);
+void tab_init(void);
+void startrun(void);
+void testdata(void);
+void pickshell(real vec[], real rad);
+void find_my_initial_bodies(bodyptr btab, long nbody, long ProcessId);
+void find_my_bodies(nodeptr mycell, long work, long direction, long ProcessId);
+void Housekeep(long ProcessId);
+void setbound(void);
+long  Log_base_2(long number);
+long  intpow(long i, long j);
+
 #endif
diff -Naur splash2/codes/apps/barnes/code_io.C splash2-modified/codes/apps/barnes/code_io.C
--- splash2/codes/apps/barnes/code_io.C	1994-11-01 13:52:28.000000000 -0500
+++ splash2-modified/codes/apps/barnes/code_io.C	2007-03-08 16:32:27.000000000 -0500
@@ -15,30 +15,26 @@
 /*************************************************************************/
 
 /*
- * CODE_IO.C: 
+ * CODE_IO.C:
  */
 EXTERN_ENV
 #define global extern
-    
-#include "code.h"
 
-void in_int (), in_real (), in_vector ();
-void out_int (), out_real (), out_vector ();
-void diagnostics (unsigned int ProcessId);
-    
+#include "stdinc.h"
+
 /*
  * INPUTDATA: read initial conditions from input file.
  */
-    
-inputdata ()
+
+void inputdata ()
 {
    stream instr;
    permanent char headbuf[128];
-   int ndim,counter=0;
+   long ndim;
    real tnow;
    bodyptr p;
-   int i;
-    
+   long i;
+
    fprintf(stderr,"reading input file : %s\n",infile);
    fflush(stderr);
    instr = fopen(infile, "r");
@@ -48,10 +44,10 @@
    headline = headbuf;
    in_int(instr, &nbody);
    if (nbody < 1)
-      error("inputdata: nbody = %d is absurd\n", nbody);
+      error("inputdata: nbody = %ld is absurd\n", nbody);
    in_int(instr, &ndim);
    if (ndim != NDIM)
-      error("inputdata: NDIM = %d ndim = %d is absurd\n", NDIM,ndim);
+      error("inputdata: NDIM = %ld ndim = %ld is absurd\n", NDIM, ndim);
    in_real(instr, &tnow);
    for (i = 0; i < MAX_PROC; i++) {
       Local[i].tnow = tnow;
@@ -64,7 +60,7 @@
       Cost(p) = 1;
       Phi(p) = 0.0;
       CLRV(Acc(p));
-   } 
+   }
    for (p = bodytab; p < bodytab+nbody; p++)
       in_real(instr, &Mass(p));
    for (p = bodytab; p < bodytab+nbody; p++)
@@ -73,18 +69,18 @@
       in_vector(instr, Vel(p));
    fclose(instr);
 }
-
+
 /*
  * INITOUTPUT: initialize output routines.
  */
 
 
-initoutput()
+void initoutput()
 {
    printf("\n\t\t%s\n\n", headline);
    printf("%10s%10s%10s%10s%10s%10s%10s%10s\n",
 	  "nbody", "dtime", "eps", "tol", "dtout", "tstop","fcells","NPROC");
-   printf("%10d%10.5f%10.4f%10.2f%10.3f%10.3f%10.2f%10d\n\n",
+   printf("%10ld%10.5f%10.4f%10.2f%10.3f%10.3f%10.2f%10ld\n\n",
 	  nbody, dtime, eps, tol, dtout, tstop, fcells, NPROC);
 }
 
@@ -92,18 +88,14 @@
  * STOPOUTPUT: finish up after a run.
  */
 
-
+
 /*
  * OUTPUT: compute diagnostics and output data.
  */
 
-void
-output (ProcessId)
-   unsigned int ProcessId;
-{
-   int nttot, nbavg, ncavg,k;
-   double cputime();
-   bodyptr p, *pp;
+void output(long ProcessId)
+{
+   long nttot, nbavg, ncavg,k;
    vector tempv1,tempv2;
 
    if ((Local[ProcessId].tout - 0.01 * dtime) <= Local[ProcessId].tnow) {
@@ -121,12 +113,12 @@
       ADDM(Global->peten, Global-> peten, Local[ProcessId].mypeten);
       for (k=0;k<3;k++) Global->etot[k] +=  Local[ProcessId].myetot[k];
       ADDV(Global->amvec, Global-> amvec, Local[ProcessId].myamvec);
-        
+
       MULVS(tempv1, Global->cmphase[0],Global->mtot);
       MULVS(tempv2, Local[ProcessId].mycmphase[0], Local[ProcessId].mymtot);
       ADDV(tempv1, tempv1, tempv2);
-      DIVVS(Global->cmphase[0], tempv1, Global->mtot+Local[ProcessId].mymtot); 
-        
+      DIVVS(Global->cmphase[0], tempv1, Global->mtot+Local[ProcessId].mymtot);
+
       MULVS(tempv1, Global->cmphase[1],Global->mtot);
       MULVS(tempv2, Local[ProcessId].mycmphase[1], Local[ProcessId].mymtot);
       ADDV(tempv1, tempv1, tempv2);
@@ -134,25 +126,23 @@
       Global->mtot +=Local[ProcessId].mymtot;
       UNLOCK(Global->CountLock);
    }
-    
-   BARRIER(Global->Baraccel,NPROC);
-    
+
+   BARRIER(Global->Barrier,NPROC);
+
    if (ProcessId==0) {
       nttot = Global->n2bcalc + Global->nbccalc;
-      nbavg = (int) ((real) Global->n2bcalc / (real) nbody);
-      ncavg = (int) ((real) Global->nbccalc / (real) nbody);
+      nbavg = (long) ((real) Global->n2bcalc / (real) nbody);
+      ncavg = (long) ((real) Global->nbccalc / (real) nbody);
    }
 }
 
 
-
+
 /*
  * DIAGNOSTICS: compute set of dynamical diagnostics.
  */
 
-void
-diagnostics (ProcessId)
-   unsigned int ProcessId;
+void diagnostics(long ProcessId)
 {
    register bodyptr p,*pp;
    real velsq;
@@ -166,8 +156,8 @@
    CLRV(Local[ProcessId].mycmphase[0]);
    CLRV(Local[ProcessId].mycmphase[1]);
    CLRV(Local[ProcessId].myamvec);
-   for (pp = Local[ProcessId].mybodytab+Local[ProcessId].mynbody -1; 
-	pp >= Local[ProcessId].mybodytab; pp--) { 
+   for (pp = Local[ProcessId].mybodytab+Local[ProcessId].mynbody -1;
+	pp >= Local[ProcessId].mybodytab; pp--) {
       p= *pp;
       Local[ProcessId].mymtot += Mass(p);
       DOTVP(velsq, Vel(p), Vel(p));
@@ -187,70 +177,59 @@
       MULVS(tmpv, tmpv, Mass(p));
       ADDV(Local[ProcessId].myamvec, Local[ProcessId].myamvec, tmpv);
    }
-   Local[ProcessId].myetot[0] = Local[ProcessId].myetot[1] 
+   Local[ProcessId].myetot[0] = Local[ProcessId].myetot[1]
       + Local[ProcessId].myetot[2];
    if (Local[ProcessId].mymtot!=0){
-      DIVVS(Local[ProcessId].mycmphase[0], Local[ProcessId].mycmphase[0], 
+      DIVVS(Local[ProcessId].mycmphase[0], Local[ProcessId].mycmphase[0],
 	    Local[ProcessId].mymtot);
-      DIVVS(Local[ProcessId].mycmphase[1], Local[ProcessId].mycmphase[1], 
+      DIVVS(Local[ProcessId].mycmphase[1], Local[ProcessId].mycmphase[1],
 	    Local[ProcessId].mymtot);
    }
 }
 
-
+
 
 /*
  * Low-level input and output operations.
  */
 
-void in_int(str, iptr)
-  stream str;
-  int *iptr;
+void in_int(stream str, long *iptr)
 {
-   if (fscanf(str, "%d", iptr) != 1)
-      error("in_int: input conversion error\n");
+   if (fscanf(str, "%ld", iptr) != 1)
+      error("in_int: input conversion print_error\n");
 }
 
-void in_real(str, rptr)
-  stream str;
-  real *rptr;
+void in_real(stream str, real *rptr)
 {
    double tmp;
 
    if (fscanf(str, "%lf", &tmp) != 1)
-      error("in_real: input conversion error\n");
+      error("in_real: input conversion print_error\n");
    *rptr = tmp;
 }
 
-void in_vector(str, vec)
-  stream str;
-  vector vec;
+void in_vector(stream str, vector vec)
 {
    double tmpx, tmpy, tmpz;
 
    if (fscanf(str, "%lf%lf%lf", &tmpx, &tmpy, &tmpz) != 3)
-      error("in_vector: input conversion error\n");
+      error("in_vector: input conversion print_error\n");
    vec[0] = tmpx;    vec[1] = tmpy;    vec[2] = tmpz;
 }
 
-void out_int(str, ival)
-  stream str;
-  int ival;
+void out_int(stream str, long ival)
 {
-   fprintf(str, "  %d\n", ival);
+   fprintf(str, "  %ld\n", ival);
 }
 
-void out_real(str, rval)
-  stream str;
-  real rval;
+void out_real(stream str, real rval)
 {
    fprintf(str, " %21.14E\n", rval);
 }
 
-void out_vector(str, vec)
-  stream str;
-  vector vec;
+void out_vector(stream str, vector vec)
 {
    fprintf(str, " %21.14E %21.14E", vec[0], vec[1]);
    fprintf(str, " %21.14E\n",vec[2]);
 }
+
diff -Naur splash2/codes/apps/barnes/code_io.H splash2-modified/codes/apps/barnes/code_io.H
--- splash2/codes/apps/barnes/code_io.H	1969-12-31 19:00:00.000000000 -0500
+++ splash2-modified/codes/apps/barnes/code_io.H	2007-03-08 16:31:46.000000000 -0500
@@ -0,0 +1,15 @@
+#ifndef _CODE_IO_H_
+#define _CODE_IO_H_
+
+void inputdata(void);
+void initoutput(void);
+void output(long ProcessId);
+void diagnostics(long ProcessId);
+void in_int(stream str, long *iptr);
+void in_real(stream str, real *rptr);
+void in_vector(stream str, vector vec);
+void out_int(stream str, long ival);
+void out_real(stream str, real rval);
+void out_vector(stream str, vector vec);
+
+#endif
diff -Naur splash2/codes/apps/barnes/defs.H splash2-modified/codes/apps/barnes/defs.H
--- splash2/codes/apps/barnes/defs.H	1994-10-19 14:21:13.000000000 -0400
+++ splash2-modified/codes/apps/barnes/defs.H	2007-03-09 01:10:04.000000000 -0500
@@ -17,12 +17,7 @@
 #ifndef _DEFS_H_
 #define _DEFS_H_
 
-#include "stdinc.h"
-#include <assert.h>
-
-#include <ulocks.h>
-
-#include "vectmath.h"
+//#include <assert.h>
 
 #define MAX_PROC 128
 #define MAX_BODIES_PER_LEAF 10
@@ -31,148 +26,6 @@
 
 #define NSUB (1 << NDIM)        /* subcells per cell */
 
-/* The more complicated 3D case */
-#define NUM_DIRECTIONS 32
-#define BRC_FUC 0
-#define BRC_FRA 1
-#define BRA_FDA 2
-#define BRA_FRC 3
-#define BLC_FDC 4
-#define BLC_FLA 5
-#define BLA_FUA 6
-#define BLA_FLC 7
-#define BUC_FUA 8
-#define BUC_FLC 9
-#define BUA_FUC 10
-#define BUA_FRA 11
-#define BDC_FDA 12
-#define BDC_FRC 13
-#define BDA_FDC 14
-#define BDA_FLA 15
-
-#define FRC_BUC 16
-#define FRC_BRA 17
-#define FRA_BDA 18
-#define FRA_BRC 19
-#define FLC_BDC 20
-#define FLC_BLA 21
-#define FLA_BUA 22
-#define FLA_BLC 23
-#define FUC_BUA 24
-#define FUC_BLC 25
-#define FUA_BUC 26
-#define FUA_BRA 27
-#define FDC_BDA 28
-#define FDC_BRC 29
-#define FDA_BDC 30
-#define FDA_BLA 31
-
-static int Child_Sequence[NUM_DIRECTIONS][NSUB] =
-{
-  { 2, 5, 6, 1, 0, 3, 4, 7},  /* BRC_FUC */
-  { 2, 5, 6, 1, 0, 7, 4, 3},  /* BRC_FRA */
-  { 1, 6, 5, 2, 3, 0, 7, 4},  /* BRA_FDA */
-  { 1, 6, 5, 2, 3, 4, 7, 0},  /* BRA_FRC */
-  { 6, 1, 2, 5, 4, 7, 0, 3},  /* BLC_FDC */
-  { 6, 1, 2, 5, 4, 3, 0, 7},  /* BLC_FLA */
-  { 5, 2, 1, 6, 7, 4, 3, 0},  /* BLA_FUA */
-  { 5, 2, 1, 6, 7, 0, 3, 4},  /* BLA_FLC */
-  { 1, 2, 5, 6, 7, 4, 3, 0},  /* BUC_FUA */
-  { 1, 2, 5, 6, 7, 0, 3, 4},  /* BUC_FLC */
-  { 6, 5, 2, 1, 0, 3, 4, 7},  /* BUA_FUC */
-  { 6, 5, 2, 1, 0, 7, 4, 3},  /* BUA_FRA */
-  { 5, 6, 1, 2, 3, 0, 7, 4},  /* BDC_FDA */
-  { 5, 6, 1, 2, 3, 4, 7, 0},  /* BDC_FRC */
-  { 2, 1, 6, 5, 4, 7, 0, 3},  /* BDA_FDC */
-  { 2, 1, 6, 5, 4, 3, 0, 7},  /* BDA_FLA */
-
-  { 3, 4, 7, 0, 1, 2, 5, 6},  /* FRC_BUC */
-  { 3, 4, 7, 0, 1, 6, 5, 2},  /* FRC_BRA */
-  { 0, 7, 4, 3, 2, 1, 6, 5},  /* FRA_BDA */
-  { 0, 7, 4, 3, 2, 5, 6, 1},  /* FRA_BRC */
-  { 7, 0, 3, 4, 5, 6, 1, 2},  /* FLC_BDC */
-  { 7, 0, 3, 4, 5, 2, 1, 6},  /* FLC_BLA */
-  { 4, 3, 0, 7, 6, 5, 2, 1},  /* FLA_BUA */
-  { 4, 3, 0, 7, 6, 1, 2, 5},  /* FLA_BLC */
-  { 0, 3, 4, 7, 6, 5, 2, 1},  /* FUC_BUA */
-  { 0, 3, 4, 7, 6, 1, 2, 5},  /* FUC_BLC */
-  { 7, 4, 3, 0, 1, 2, 5, 6},  /* FUA_BUC */
-  { 7, 4, 3, 0, 1, 6, 5, 2},  /* FUA_BRA */
-  { 4, 7, 0, 3, 2, 1, 6, 5},  /* FDC_BDA */
-  { 4, 7, 0, 3, 2, 5, 6, 1},  /* FDC_BRC */
-  { 3, 0, 7, 4, 5, 6, 1, 2},  /* FDA_BDC */
-  { 3, 0, 7, 4, 5, 2, 1, 6},  /* FDA_BLA */
-};
-
-static int Direction_Sequence[NUM_DIRECTIONS][NSUB] =
-{
-  { FRC_BUC, BRA_FRC, FDA_BDC, BLA_FUA, BUC_FLC, FUA_BUC, BRA_FRC, FDA_BLA },
- /* BRC_FUC */
-  { FRC_BUC, BRA_FRC, FDA_BDC, BLA_FUA, BRA_FDA, FRC_BRA, BUC_FUA, FLC_BDC },
- /* BRC_FRA */
-  { FRA_BDA, BRC_FRA, FUC_BUA, BLC_FDC, BDA_FLA, FDC_BDA, BRC_FRA, FUC_BLC },
- /* BRA_FDA */
-  { FRA_BDA, BRC_FRA, FUC_BUA, BLC_FDC, BUC_FLC, FUA_BUC, BRA_FRC, FDA_BLA },
- /* BRA_FRC */
-  { FLC_BDC, BLA_FLC, FUA_BUC, BRA_FDA, BDC_FRC, FDA_BDC, BLA_FLC, FUA_BRA },
- /* BLC_FDC */
-  { FLC_BDC, BLA_FLC, FUA_BUC, BRA_FDA, BLA_FUA, FLC_BLA, BDC_FDA, FRC_BUC },
- /* BLC_FLA */
-  { FLA_BUA, BLC_FLA, FDC_BDA, BRC_FUC, BUA_FRA, FUC_BUA, BLC_FLA, FDC_BRC },
- /* BLA_FUA */
-  { FLA_BUA, BLC_FLA, FDC_BDA, BRC_FUC, BLC_FDC, FLA_BLC, BUA_FUC, FRA_BDA },
- /* BLA_FLC */
-  { FUC_BLC, BUA_FUC, FRA_BRC, BDA_FLA, BUA_FRA, FUC_BUA, BLC_FLA, FDC_BRC },
- /* BUC_FUA */
-  { FUC_BLC, BUA_FUC, FRA_BRC, BDA_FLA, BLC_FDC, FLA_BLC, BUA_FUC, FRA_BDA },
- /* BUC_FLC */
-  { FUA_BRA, BUC_FUA, FLC_BLA, BDC_FRC, BUC_FLC, FUA_BUC, BRA_FRC, FDA_BLA },
- /* BUA_FUC */
-  { FUA_BRA, BUC_FUA, FLC_BLA, BDC_FRC, BRA_FDA, FRC_BRA, BUC_FUA, FLC_BDC },
- /* BUA_FRA */
-  { FDC_BRC, BDA_FDC, FLA_BLC, BUA_FRA, BDA_FLA, FDC_BDA, BRC_FRA, FUC_BLC },
- /* BDC_FDA */
-  { FDC_BRC, BDA_FDC, FLA_BLC, BUA_FRA, BUC_FLC, FUA_BUC, BRA_FRC, FDA_BLA },
- /* BDC_FRC */
-  { FDA_BLA, BDC_FDA, FRC_BRA, BUC_FLC, BDC_FRC, FDA_BDC, BLA_FLC, FUA_BRA },
- /* BDA_FDC */
-  { FDA_BLA, BDC_FDA, FRC_BRA, BUC_FLC, BLA_FUA, FLC_BLA, BDC_FDA, FRC_BUC },
- /* BDA_FLA */
-
-  { BUC_FLC, FUA_BUC, BRA_FRC, FDA_BLA, FUC_BLC, BUA_FUC, FRA_BRC, BDA_FLA },
- /* FRC_BUC */
-  { BUC_FLC, FUA_BUC, BRA_FRC, FDA_BLA, FRA_BDA, BRC_FRA, FUC_BUA, BLC_FDC },
- /* FRC_BRA */
-  { BRA_FDA, FRC_BRA, BUC_FUA, FLC_BDC, FDA_BLA, BDC_FDA, FRC_BRA, BUC_FLC },
- /* FRA_BDA */
-  { BRA_FDA, FRC_BRA, BUC_FUA, FLC_BDC, FRC_BUC, BRA_FRC, FDA_BDC, BLA_FUA },
- /* FRA_BRC */
-  { BLC_FDC, FLA_BLC, BUA_FUC, FRA_BDA, FDC_BRC, BDA_FDC, FLA_BLC, BUA_FRA },
- /* FLC_BDC */
-  { BLC_FDC, FLA_BLC, BUA_FUC, FRA_BDA, FLA_BUA, BLC_FLA, FDC_BDA, BRC_FUC },
- /* FLC_BLA */
-  { BLA_FUA, FLC_BLA, BDC_FDA, FRC_BUC, FUA_BRA, BUC_FUA, FLC_BLA, BDC_FRC },
- /* FLA_BUA */
-  { BLA_FUA, FLC_BLA, BDC_FDA, FRC_BUC, FLC_BDC, BLA_FLC, FUA_BUC, BRA_FDA },
- /* FLA_BLC */
-  { BUC_FLC, FUA_BUC, BRA_FRC, FDA_BLA, FUA_BRA, BUC_FUA, FLC_BLA, BDC_FRC },
- /* FUC_BUA */
-  { BUC_FLC, FUA_BUC, BRA_FRC, FDA_BLA, FLC_BDC, BLA_FLC, FUA_BUC, BRA_FDA },
- /* FUC_BLC */
-  { BUA_FRA, FUC_BUA, BLC_FLA, FDC_BRC, FUC_BLC, BUA_FUC, FRA_BRC, BDA_FLA },
- /* FUA_BUC */
-  { BUA_FRA, FUC_BUA, BLC_FLA, FDC_BRC, FRA_BDA, BRC_FRA, FUC_BUA, BLC_FDC },
- /* FUA_BRA */
-  { BDC_FRC, FDA_BDC, BLA_FLC, FUA_BRA, FDA_BLA, BDC_FDA, FRC_BRA, BUC_FLC },
- /* FDC_BDA */
-  { BDC_FRC, FDA_BDC, BLA_FLC, FUA_BRA, FRC_BUC, BRA_FRC, FDA_BDC, BLA_FUA },
- /* FDC_BRC */
-  { BDA_FLA, FDC_BDA, BRC_FRA, FUC_BLC, FDC_BRC, BDA_FDC, FLA_BLC, BUA_FRA },
- /* FDA_BDC */
-  { BDA_FLA, FDC_BDA, BRC_FRA, FUC_BLC, FLA_BUA, BLC_FLA, FDC_BDA, BRC_FUC },
- /* FDA_BLA */
-};
-
 /*
  * BODY and CELL data structures are used to represent the tree:
  *
@@ -199,13 +52,13 @@
  */
 
 typedef struct _node {
-   short type;                 /* code for node type: body or cell */
+   long type;                 /* code for node type: body or cell */
    real mass;                  /* total mass of node */
    vector pos;                 /* position of node */
-   int cost;                   /* number of interactions computed */
-   int level;
+   long cost;                   /* number of interactions computed */
+   long level;
    struct _node *parent;       /* ptr to parent of this node in tree */
-   int child_num;              /* Index that this node should be put
+   long child_num;              /* Index that this node should be put
 				  at in parent cell */
 } node;
 
@@ -218,7 +71,7 @@
 #define Level(x) (((nodeptr) (x))->level)
 #define Parent(x) (((nodeptr) (x))->parent)
 #define ChildNum(x) (((nodeptr) (x))->child_num)
-
+
 /*
  * BODY: data structure used to represent particles.
  */
@@ -230,13 +83,13 @@
 #define BODY 01                 /* type code for bodies */
 
 typedef struct _body {
-   short type;
+   long type;
    real mass;                  /* mass of body */
    vector pos;                 /* position of body */
-   int cost;                   /* number of interactions computed */
-   int level;
-   leafptr parent;		
-   int child_num;              /* Index that this node should be put */
+   long cost;                   /* number of interactions computed */
+   long level;
+   leafptr parent;
+   long child_num;              /* Index that this node should be put */
    vector vel;                 /* velocity of body */
    vector acc;                 /* acceleration of body */
    real phi;                   /* potential at body */
@@ -253,20 +106,20 @@
 #define CELL 02                 /* type code for cells */
 
 typedef struct _cell {
-   short type;
+   long type;
    real mass;                  /* total mass of cell */
    vector pos;                 /* cm. position of cell */
-   int cost;                   /* number of interactions computed */
-   int level;
-   cellptr parent;		
-   int child_num;              /* Index [0..8] that this node should be put */
-   int processor;		/* Used by partition code */
+   long cost;                   /* number of interactions computed */
+   long level;
+   cellptr parent;
+   long child_num;              /* Index [0..8] that this node should be put */
+   long processor;		/* Used by partition code */
    struct _cell *next, *prev;    /* Used in the partition array */
-   unsigned long seqnum;
+   long seqnum;
 #ifdef QUADPOLE
    matrix quad;                /* quad. moment of cell */
 #endif
-   volatile short int done;    /* flag to tell when the c.of.m is ready */
+   volatile long done;          /* flag to tell when the c.of.m is ready */
    nodeptr subp[NSUB];         /* descendents of cell */
 } cell;
 
@@ -279,21 +132,21 @@
 #define LEAF 03                 /* type code for leaves */
 
 typedef struct _leaf {
-   short type;
+   long type;
    real mass;                  /* total mass of leaf */
    vector pos;                 /* cm. position of leaf */
-   int cost;                   /* number of interactions computed */
-   int level;
-   cellptr parent;		
-   int child_num;              /* Index [0..8] that this node should be put */
-   int processor;		/* Used by partition code */
+   long cost;                   /* number of interactions computed */
+   long level;
+   cellptr parent;
+   long child_num;              /* Index [0..8] that this node should be put */
+   long processor;		/* Used by partition code */
    struct _leaf *next, *prev;    /* Used in the partition array */
-   unsigned long seqnum;
+   long seqnum;
 #ifdef QUADPOLE
    matrix quad;                /* quad. moment of leaf */
 #endif
-   volatile short int done;    /* flag to tell when the c.of.m is ready */
-   unsigned int num_bodies;
+   volatile long done;          /* flag to tell when the c.of.m is ready */
+   long num_bodies;
    bodyptr bodyp[MAX_BODIES_PER_LEAF];         /* bodies of leaf */
 } leaf;
 
@@ -308,8 +161,8 @@
  * Integerized coordinates: used to mantain body-tree.
  */
 
-#define MAXLEVEL (8*sizeof(int)-2)
-#define IMAX  (1 << MAXLEVEL)    /* highest bit of int coord */
+#define MAXLEVEL ((8L * (long)sizeof(long)) - 2L)
+#define IMAX  (1L << MAXLEVEL)    /* highest bit of int coord */
 
 #endif
 
diff -Naur splash2/codes/apps/barnes/getparam.C splash2-modified/codes/apps/barnes/getparam.C
--- splash2/codes/apps/barnes/getparam.C	1994-10-19 14:21:13.000000000 -0400
+++ splash2-modified/codes/apps/barnes/getparam.C	2007-03-08 16:31:46.000000000 -0500
@@ -15,9 +15,10 @@
 /*************************************************************************/
 
 /*
- * GETPARAM.C: 
+ * GETPARAM.C:
  */
 EXTERN_ENV
+#define global extern
 
 #include "stdinc.h"
 
@@ -27,8 +28,7 @@
  * INITPARAM: ignore arg vector, remember defaults.
  */
 
-initparam(argv, defv)
-  string *argv, *defv;
+void initparam(string *defv)
 {
    defaults = defv;
 }
@@ -37,13 +37,11 @@
  * GETPARAM: export version prompts user for value.
  */
 
-string getparam(name)
-  string name;                        /* name of parameter */
+string getparam(string name)
 {
-   int scanbind(), i, strlen(), leng;
-   string extrvalue(), def;
-   char buf[128], *strcpy();
-   char* temp;
+   long i, leng;
+   string def;
+   char buf[128];
 
    if (defaults == NULL)
       error("getparam: called before initparam\n");
@@ -60,40 +58,35 @@
       return (def);
    }
 }
-
+
 /*
- * GETIPARAM, ..., GETDPARAM: get int, long, bool, or double parameters.
+ * GETIPARAM, ..., GETDPARAM: get long, long, bool, or double parameters.
  */
 
-int getiparam(name)
-  string name;                        /* name of parameter */
+long getiparam(string name)
 {
-   string getparam(), val;
-   int atoi();
+   string val;
 
-   for (val = ""; *val == NULL;) {
+   for (val = ""; *val == '\0';) {
       val = getparam(name);
    }
    return (atoi(val));
 }
 
-long getlparam(name)
-  string name;                        /* name of parameter */
+long getlparam(string name)
 {
-   string getparam(), val;
-   long atol();
+   string val;
 
-   for (val = ""; *val == NULL; )
+   for (val = ""; *val == '\0'; )
       val = getparam(name);
    return (atol(val));
 }
 
-bool getbparam(name)
-  string name;                        /* name of parameter */
+bool getbparam(string name)
 {
-   string getparam(), val;
-    
-   for (val = ""; *val == NULL; )
+   string val;
+
+   for (val = ""; *val == '\0'; )
       val = getparam(name);
    if (strchr("tTyY1", *val) != NULL) {
       return (TRUE);
@@ -104,30 +97,25 @@
    error("getbparam: %s=%s not bool\n", name, val);
 }
 
-double getdparam(name)
-  string name;                        /* name of parameter */
+double getdparam(string name)
 {
-   string getparam(), val;
-   double atof();
+   string val;
 
-   for (val = ""; *val == NULL; ) {
+   for (val = ""; *val == '\0'; ) {
       val = getparam(name);
    }
    return (atof(val));
 }
 
-
+
 
 /*
  * SCANBIND: scan binding vector for name, return index.
  */
 
-int scanbind(bvec, name)
-  string bvec[];
-  string name;
+long scanbind(string bvec[], string name)
 {
-   int i;
-   bool matchname();
+   long i;
 
    for (i = 0; bvec[i] != NULL; i++)
       if (matchname(bvec[i], name))
@@ -139,8 +127,7 @@
  * MATCHNAME: determine if "name=value" matches "name".
  */
 
-bool matchname(bind, name)
-  string bind, name;
+bool matchname(string bind, string name)
 {
    char *bp, *np;
 
@@ -150,20 +137,19 @@
       bp++;
       np++;
    }
-   return (*bp == '=' && *np == NULL);
+   return (*bp == '=' && *np == '\0');
 }
 
 /*
  * EXTRVALUE: extract value from name=value string.
  */
 
-string extrvalue(arg)
-  string arg;                        /* string of the form "name=value" */
+string extrvalue(string arg)
 {
    char *ap;
 
    ap = (char *) arg;
-   while (*ap != NULL)
+   while (*ap != '\0')
       if (*ap++ == '=')
 	 return ((string) ap);
    return (NULL);
diff -Naur splash2/codes/apps/barnes/getparam.H splash2-modified/codes/apps/barnes/getparam.H
--- splash2/codes/apps/barnes/getparam.H	1969-12-31 19:00:00.000000000 -0500
+++ splash2-modified/codes/apps/barnes/getparam.H	2007-03-08 16:31:46.000000000 -0500
@@ -0,0 +1,14 @@
+#ifndef _GETPARAM_H_
+#define _GETPARAM_H_
+
+void initparam(string *defv);
+string getparam(string name);
+long getiparam(string name);
+long getlparam(string name);
+bool getbparam(string name);
+double getdparam(string name);
+long scanbind(string bvec[], string name);
+bool matchname(string bind, string name);
+string extrvalue(string arg);
+
+#endif
diff -Naur splash2/codes/apps/barnes/grav.C splash2-modified/codes/apps/barnes/grav.C
--- splash2/codes/apps/barnes/grav.C	1994-10-19 14:21:13.000000000 -0400
+++ splash2-modified/codes/apps/barnes/grav.C	2007-03-08 16:31:46.000000000 -0500
@@ -15,25 +15,20 @@
 /*************************************************************************/
 
 /*
- * GRAV.C: 
+ * GRAV.C:
  */
 
 EXTERN_ENV
 #define global extern
 
-#include "code.h"
+#include "stdinc.h"
 
 /*
  * HACKGRAV: evaluate grav field at a given particle.
  */
-  
-hackgrav(p,ProcessId)
-  bodyptr p;
-  unsigned ProcessId;
 
+void hackgrav(bodyptr p, long ProcessId)
 {
-   extern gravsub();
-
    Local[ProcessId].pskip = p;
    SETV(Local[ProcessId].pos0, Pos(p));
    Local[ProcessId].phi0 = 0.0;
@@ -41,7 +36,7 @@
    Local[ProcessId].myn2bterm = 0;
    Local[ProcessId].mynbcterm = 0;
    Local[ProcessId].skipself = FALSE;
-   hackwalk(gravsub, ProcessId);
+   hackwalk(ProcessId);
    Phi(p) = Local[ProcessId].phi0;
    SETV(Acc(p), Local[ProcessId].acc0);
 #ifdef QUADPOLE
@@ -51,34 +46,29 @@
 #endif
 }
 
-
+
 
 /*
- * GRAVSUB: compute a single body-body or body-cell interaction.
+ * GRAVSUB: compute a single body-body or body-cell longeraction.
  */
 
-gravsub(p, ProcessId, level)
-  register nodeptr p;               /* body or cell to interact with     */
-  unsigned ProcessId;
-  int level;
+void gravsub(register nodeptr p, long ProcessId)
 {
-    double sqrt();
     real drabs, phii, mor3;
-    vector ai, quaddr;
-    real dr5inv, phiquad, drquaddr;
+    vector ai;
 
     if (p != Local[ProcessId].pmem) {
         SUBV(Local[ProcessId].dr, Pos(p), Local[ProcessId].pos0);
         DOTVP(Local[ProcessId].drsq, Local[ProcessId].dr, Local[ProcessId].dr);
     }
-    
+
     Local[ProcessId].drsq += epssq;
     drabs = sqrt((double) Local[ProcessId].drsq);
     phii = Mass(p) / drabs;
     Local[ProcessId].phi0 -= phii;
     mor3 = phii / Local[ProcessId].drsq;
     MULVS(ai, Local[ProcessId].dr, mor3);
-    ADDV(Local[ProcessId].acc0, Local[ProcessId].acc0, ai); 
+    ADDV(Local[ProcessId].acc0, Local[ProcessId].acc0, ai);
     if(Type(p) != BODY) {                  /* a body-cell/leaf interaction? */
        Local[ProcessId].mynbcterm++;
 #ifdef QUADPOLE
@@ -90,7 +80,7 @@
        phiquad = 5.0 * phiquad / Local[ProcessId].drsq;
        MULVS(ai, Local[ProcessId].dr, phiquad);
        SUBV(Local[ProcessId].acc0, Local[ProcessId].acc0, ai);
-       MULVS(quaddr, quaddr, dr5inv);   
+       MULVS(quaddr, quaddr, dr5inv);
        SUBV(Local[ProcessId].acc0, Local[ProcessId].acc0, quaddr);
 #endif
     }
@@ -103,11 +93,7 @@
  * HACKWALK: walk the tree opening cells too close to a given point.
  */
 
-local proced hacksub;
-
-hackwalk(sub, ProcessId)
-  proced sub;                                /* routine to do calculation */
-  unsigned ProcessId;
+void hackwalk(long ProcessId)
 {
     walksub(Global->G_root, Global->rsize * Global->rsize, ProcessId);
 }
@@ -116,17 +102,13 @@
  * WALKSUB: recursive routine to do hackwalk operation.
  */
 
-walksub(n, dsq, ProcessId)
-   nodeptr n;                        /* pointer into body-tree    */
-   real dsq;                         /* size of box squared       */
-   unsigned ProcessId;
+void walksub(nodeptr n, real dsq, long ProcessId)
 {
-   bool subdivp();
    nodeptr* nn;
    leafptr l;
    bodyptr p;
-   int i;
-    
+   long i;
+
    if (subdivp(n, dsq, ProcessId)) {
       if (Type(n) == CELL) {
 	 for (nn = Subp(n); nn < Subp(n) + NSUB; nn++) {
@@ -158,13 +140,11 @@
  * Side effects: sets  pmem,dr, and drsq.
  */
 
-bool subdivp(p, dsq, ProcessId)
-   register nodeptr p;                      /* body/cell to be tested    */
-   real dsq;                                /* size of cell squared      */
-   unsigned ProcessId;
+bool subdivp(register nodeptr p, real dsq, long ProcessId)
 {
    SUBV(Local[ProcessId].dr, Pos(p), Local[ProcessId].pos0);
    DOTVP(Local[ProcessId].drsq, Local[ProcessId].dr, Local[ProcessId].dr);
    Local[ProcessId].pmem = p;
    return (tolsq * Local[ProcessId].drsq < dsq);
 }
+
diff -Naur splash2/codes/apps/barnes/grav.H splash2-modified/codes/apps/barnes/grav.H
--- splash2/codes/apps/barnes/grav.H	1969-12-31 19:00:00.000000000 -0500
+++ splash2-modified/codes/apps/barnes/grav.H	2007-03-08 16:31:46.000000000 -0500
@@ -0,0 +1,10 @@
+#ifndef _GRAV_H_
+#define _GRAV_H_
+
+void hackgrav(bodyptr p, long ProcessId);
+void gravsub(register nodeptr p, long ProcessId);
+void hackwalk(long ProcessId);
+void walksub(nodeptr n, real dsq, long ProcessId);
+bool subdivp(register nodeptr p, real dsq, long ProcessId);
+
+#endif
diff -Naur splash2/codes/apps/barnes/load.C splash2-modified/codes/apps/barnes/load.C
--- splash2/codes/apps/barnes/load.C	1994-10-19 14:21:13.000000000 -0400
+++ splash2-modified/codes/apps/barnes/load.C	2007-03-09 01:20:32.000000000 -0500
@@ -17,60 +17,45 @@
 EXTERN_ENV
 #define global extern
 
-#include "code.h"
-#include "defs.h"
-
-bool intcoord();
-cellptr makecell(unsigned int ProcessId);
-leafptr makeleaf(unsigned int ProcessId);
-cellptr SubdivideLeaf(leafptr le, cellptr parent, unsigned int l,
-		      unsigned int ProcessId);
-
-cellptr InitCell(cellptr parent, unsigned int ProcessId);
-leafptr InitLeaf(cellptr parent, unsigned int ProcessId);
-nodeptr loadtree(bodyptr p, cellptr root, unsigned int ProcessId);
+#include "stdinc.h"
 
 /*
  * MAKETREE: initialize tree structure for hack force calculation.
  */
 
-maketree(ProcessId)
-   unsigned ProcessId;
+void maketree(long ProcessId)
 {
    bodyptr p, *pp;
 
    Local[ProcessId].myncell = 0;
    Local[ProcessId].mynleaf = 0;
    if (ProcessId == 0) {
-      Local[ProcessId].mycelltab[Local[ProcessId].myncell++] = Global->G_root; 
+      Local[ProcessId].mycelltab[Local[ProcessId].myncell++] = Global->G_root;
    }
    Local[ProcessId].Current_Root = (nodeptr) Global->G_root;
-   for (pp = Local[ProcessId].mybodytab; 
+   for (pp = Local[ProcessId].mybodytab;
 	pp < Local[ProcessId].mybodytab+Local[ProcessId].mynbody; pp++) {
       p = *pp;
       if (Mass(p) != 0.0) {
-	 Local[ProcessId].Current_Root 
-	    = (nodeptr) loadtree(p, (cellptr) Local[ProcessId].Current_Root, 
+	 Local[ProcessId].Current_Root
+	    = (nodeptr) loadtree(p, (cellptr) Local[ProcessId].Current_Root,
 				 ProcessId);
       }
       else {
 	 LOCK(Global->io_lock);
-	 fprintf(stderr, "Process %d found body %d to have zero mass\n",
-		 ProcessId, (int) p);	
+	 fprintf(stderr, "Process %ld found body %ld to have zero mass\n",
+		 ProcessId, (long) p);
 	 UNLOCK(Global->io_lock);
       }
    }
-   BARRIER(Global->Bartree,NPROC);
-   hackcofm( 0, ProcessId );
-   BARRIER(Global->Barcom,NPROC);
+   BARRIER(Global->Barrier,NPROC);
+   hackcofm(ProcessId );
+   BARRIER(Global->Barrier,NPROC);
 }
 
-cellptr InitCell(parent, ProcessId)
-   cellptr parent;
-   unsigned ProcessId;
+cellptr InitCell(cellptr parent, long ProcessId)
 {
    cellptr c;
-   int i, Mycell;
 
    c = makecell(ProcessId);
    c->processor = ProcessId;
@@ -85,12 +70,9 @@
    return (c);
 }
 
-leafptr InitLeaf(parent, ProcessId)
-   cellptr parent;
-   unsigned ProcessId;
+leafptr InitLeaf(cellptr parent, long ProcessId)
 {
    leafptr l;
-   int i, Mycell;
 
    l = makeleaf(ProcessId);
    l->processor = ProcessId;
@@ -105,59 +87,57 @@
    return (l);
 }
 
-printtree (n)
-   nodeptr n;
+void printtree(nodeptr n)
 {
-   int k;
+   long k;
    cellptr c;
    leafptr l;
    bodyptr p;
    nodeptr tmp;
-   unsigned long nseq;
-   int xp[NDIM];
+   long nseq;
 
    switch (Type(n)) {
     case CELL:
       c = (cellptr) n;
       nseq = c->seqnum;
-      printf("Cell : Cost = %d, ", Cost(c));
+      printf("Cell : Cost = %ld, ", Cost(c));
       PRTV("Pos", Pos(n));
       printf("\n");
       for (k = 0; k < NSUB; k++) {
-	 printf("Child #%d: ", k);
+	 printf("Child #%ld: ", k);
 	 if (Subp(c)[k] == NULL) {
 	    printf("NONE");
 	 }
 	 else {
 	    if (Type(Subp(c)[k]) == CELL) {
 	       nseq = ((cellptr) Subp(c)[k])->seqnum;
-	       printf("C: Cost = %d, ", Cost(Subp(c)[k]));
+	       printf("C: Cost = %ld, ", Cost(Subp(c)[k]));
 	    }
 	    else {
 	       nseq = ((leafptr) Subp(c)[k])->seqnum;
-	       printf("L: # Bodies = %2d, Cost = %d, ", 
+	       printf("L: # Bodies = %2ld, Cost = %ld, ",
 		      ((leafptr) Subp(c)[k])->num_bodies, Cost(Subp(c)[k]));
-	    }	
+	    }
 	    tmp = Subp(c)[k];
 	    PRTV("Pos", Pos(tmp));
 	 }
 	 printf("\n");
       }
       for (k=0;k<NSUB;k++) {
-	 if (Subp(c)[k] != NULL) {	    
+	 if (Subp(c)[k] != NULL) {
 	    printtree(Subp(c)[k]);
 	 }
-      }      
+      }
       break;
     case LEAF:
       l = (leafptr) n;
       nseq = l->seqnum;
-      printf("Leaf : # Bodies = %2d, Cost = %d, ", l->num_bodies, Cost(l));
+      printf("Leaf : # Bodies = %2ld, Cost = %ld, ", l->num_bodies, Cost(l));
       PRTV("Pos", Pos(n));
       printf("\n");
       for (k = 0; k < l->num_bodies; k++) {
 	 p = Bodyp(l)[k];
-	 printf("Body #%2d: Num = %2d, Level = %o, ",
+	 printf("Body #%2ld: Num = %2ld, Level = %ld, ",
 		p - bodytab, k, Level(p));
 	 PRTV("Pos",Pos(p));
 	 printf("\n");
@@ -175,18 +155,13 @@
  * LOADTREE: descend tree and insert particle.
  */
 
-nodeptr
-loadtree(p, root, ProcessId)
-   bodyptr p;                        /* body to load into tree */
-   cellptr root;
-   unsigned ProcessId;
+nodeptr loadtree(bodyptr p, cellptr root, long ProcessId)
 {
-   int l, xq[NDIM], xp[NDIM], xor[NDIM], subindex(), flag;
-   int i, j, root_level;
+   long l, xp[NDIM], xor[NDIM], flag;
+   long i, j, root_level;
    bool valid_root;
-   int kidIndex;
+   long kidIndex;
    volatile nodeptr *volatile qptr, mynode;
-   cellptr c;
    leafptr le;
 
    intcoord(xp, Pos(p));
@@ -220,7 +195,7 @@
 	       }
 	    }
 	    if (!valid_root) {
-	       printf("P%d body %d\n", ProcessId, p - bodytab);
+	       printf("P%ld body %ld\n", ProcessId, p - bodytab);
 	       root = Global->G_root;
 	    }
 	 }
@@ -232,13 +207,12 @@
    qptr = &Subp(mynode)[kidIndex];
 
    l = Level(mynode) >> 1;
-
    flag = TRUE;
    while (flag) {                           /* loop descending tree     */
       if (l == 0) {
 	 error("not enough levels in tree\n");
       }
-      if (*qptr == NULL) { 
+      if (*qptr == NULL) {
 	 /* lock the parent cell */
 	 ALOCK(CellLock->CL, ((cellptr) mynode)->seqnum % MAXLOCK);
 	 if (*qptr == NULL) {
@@ -285,22 +259,22 @@
    SETV(Local[ProcessId].Root_Coords, xp);
    return Parent((leafptr) *qptr);
 }
-
+
 
 /* * INTCOORD: compute integerized coordinates.  * Returns: TRUE
 unless rp was out of bounds.  */
 
-bool intcoord(xp, rp)
-  int xp[NDIM];                  /* integerized coordinate vector [0,IMAX) */
-  vector rp;                     /* real coordinate vector (system coords) */
+/* integerized coordinate vector [0,IMAX) */
+/* real coordinate vector (system coords) */
+bool intcoord(long xp[NDIM], vector rp)
 {
-   int k;
+   long k;
    bool inb;
-   double xsc, floor();
-    
+   double xsc;
+
    inb = TRUE;
    for (k = 0; k < NDIM; k++) {
-      xsc = (rp[k] - Global->rmin[k]) / Global->rsize; 
+      xsc = (rp[k] - Global->rmin[k]) / Global->rsize;
       if (0.0 <= xsc && xsc < 1.0) {
 	 xp[k] = floor(IMAX * xsc);
       }
@@ -315,13 +289,13 @@
  * SUBINDEX: determine which subcell to select.
  */
 
-int subindex(x, l)
-  int x[NDIM];                       /* integerized coordinates of particle */
-  int l;                             /* current level of tree */
-{
-   int i, k;
-   int yes;
-    
+/* integerized coordinates of particle */
+/* current level of tree */
+long subindex(long x[NDIM], long l)
+{
+   long i, k;
+   long yes;
+
    i = 0;
    yes = FALSE;
    if (x[0] & l) {
@@ -329,7 +303,7 @@
       yes = TRUE;
    }
    for (k = 1; k < NDIM; k++) {
-      if (((x[k] & l) && !yes) || (!(x[k] & l) && yes)) { 
+      if (((x[k] & l) && !yes) || (!(x[k] & l) && yes)) {
 	 i += NSUB >> (k + 1);
 	 yes = TRUE;
       }
@@ -339,32 +313,28 @@
    return (i);
 }
 
-
+
 
 /*
  * HACKCOFM: descend tree finding center-of-mass coordinates.
  */
 
-hackcofm(nc, ProcessId)
-  int nc;
-  unsigned ProcessId;
+void hackcofm(long ProcessId)
 {
-   int i,Myindex;
+   long i;
    nodeptr r;
    leafptr l;
    leafptr* ll;
    bodyptr p;
    cellptr q;
    cellptr *cc;
-   vector tmpv, dr;
-   real drsq;
-   matrix drdr, Idrsq, tmpm;
+   vector tmpv;
 
    /* get a cell using get*sub.  Cells are got in reverse of the order in */
    /* the cell array; i.e. reverse of the order in which they were created */
    /* this way, we look at child cells before parents			 */
-    
-   for (ll = Local[ProcessId].myleaftab + Local[ProcessId].mynleaf - 1; 
+
+   for (ll = Local[ProcessId].myleaftab + Local[ProcessId].mynleaf - 1;
 	ll >= Local[ProcessId].myleaftab; ll--) {
       l = *ll;
       Mass(l) = 0.0;
@@ -395,7 +365,7 @@
 #endif
       Done(l)=TRUE;
    }
-   for (cc = Local[ProcessId].mycelltab+Local[ProcessId].myncell-1; 
+   for (cc = Local[ProcessId].mycelltab+Local[ProcessId].myncell-1;
 	cc >= Local[ProcessId].mycelltab; cc--) {
       q = *cc;
       Mass(q) = 0.0;
@@ -436,19 +406,14 @@
       Done(q)=TRUE;
    }
 }
-
-cellptr
-SubdivideLeaf (le, parent, l, ProcessId)
-   leafptr le;
-   cellptr parent;
-   unsigned int l;
-   unsigned int ProcessId;
+
+cellptr SubdivideLeaf(leafptr le, cellptr parent, long l, long ProcessId)
 {
    cellptr c;
-   int i, index;
-   int xp[NDIM];
+   long i, index;
+   long xp[NDIM];
    bodyptr bodies[MAX_BODIES_PER_LEAF];
-   int num_bodies;
+   long num_bodies;
    bodyptr p;
 
    /* first copy leaf's bodies to temp array, so we can reuse the leaf */
@@ -500,14 +465,13 @@
  * MAKECELL: allocation routine for cells.
  */
 
-cellptr makecell(ProcessId)
-   unsigned ProcessId;
+cellptr makecell(long ProcessId)
 {
    cellptr c;
-   int i, Mycell;
-    
+   long i, Mycell;
+
    if (Local[ProcessId].mynumcell == maxmycell) {
-      error("makecell: Proc %d needs more than %d cells; increase fcells\n", 
+      error("makecell: Proc %ld needs more than %ld cells; increase fcells\n",
 	    ProcessId,maxmycell);
    }
    Mycell = Local[ProcessId].mynumcell++;
@@ -527,14 +491,13 @@
  * MAKELEAF: allocation routine for leaves.
  */
 
-leafptr makeleaf(ProcessId)
-   unsigned ProcessId;
+leafptr makeleaf(long ProcessId)
 {
    leafptr le;
-   int i, Myleaf;
-    
+   long i, Myleaf;
+
    if (Local[ProcessId].mynumleaf == maxmyleaf) {
-      error("makeleaf: Proc %d needs more than %d leaves; increase fleaves\n",
+      error("makeleaf: Proc %ld needs more than %ld leaves; increase fleaves\n",
 	    ProcessId,maxmyleaf);
    }
    Myleaf = Local[ProcessId].mynumleaf++;
diff -Naur splash2/codes/apps/barnes/load.H splash2-modified/codes/apps/barnes/load.H
--- splash2/codes/apps/barnes/load.H	1969-12-31 19:00:00.000000000 -0500
+++ splash2-modified/codes/apps/barnes/load.H	2007-03-08 16:31:46.000000000 -0500
@@ -0,0 +1,17 @@
+#ifndef _LOAD_H_
+#define _LOAD_H_
+
+void maketree(long ProcessId);
+cellptr InitCell(cellptr parent, long ProcessId);
+leafptr InitLeaf(cellptr parent, long ProcessId);
+void printtree(nodeptr n);
+nodeptr loadtree(bodyptr p, cellptr root, long ProcessId);
+bool intcoord(long xp[NDIM], vector rp);
+long subindex(long x[NDIM], long l);
+void hackcofm(long ProcessId);
+cellptr SubdivideLeaf(leafptr le, cellptr parent, long l, long ProcessId);
+cellptr makecell(long ProcessId);
+leafptr makeleaf(long ProcessId);
+
+
+#endif
diff -Naur splash2/codes/apps/barnes/makefile splash2-modified/codes/apps/barnes/makefile
--- splash2/codes/apps/barnes/makefile	1994-10-17 17:50:50.000000000 -0400
+++ splash2-modified/codes/apps/barnes/makefile	1969-12-31 19:00:00.000000000 -0500
@@ -1,43 +0,0 @@
-TARGET = BARNES
-FILES = code.C code_io.C load.C grav.C getparam.C util.C \
-	code.H defs.H stdinc.H vectmath.H
-CS = code.c code_io.c load.c grav.c getparam.c util.c 
-OBJS = code.o code_io.o load.o grav.o getparam.o util.o
-CFLAGS = -O2 -Olimit 2000
-LDFLAGS = -lmpc -lm
-MACROS = ../../null_macros/c.m4.null
-M4 = m4 -s -Ulen -Uindex
-
-x = *
-
-$(TARGET): $(OBJS)
-	cc $(OBJS) $(CFLAGS) -o $(TARGET) $(LDFLAGS)
-
-.SUFFIXES:
-.SUFFIXES:	.o .c .C .h .H
-
-.H.h:
-	$(M4) ${MACROS} $*.H > $*.h
-
-.C.c:
-	$(M4) $(MACROS) $*.C > $*.c
-
-.c.o:
-	cc -c $(CFLAGS) $*.c
-
-.C.o:
-	$(M4) $(MACROS) $*.C > $*.c
-	cc -c $(CFLAGS) $*.c
-
-code.h: code.H defs.h
-defs.h: defs.H stdinc.h vectmath.h
-stdinc.h: stdinc.H 
-vectmath.h : vectmath.H
-
-code.o: code.C code.h defs.h
-code_io.o: code_io.C code.h
-getparam.o: getparam.C stdinc.h
-grav.o: grav.C code.h
-load.o: load.C code.h defs.h
-util.o: util.C stdinc.h
-
diff -Naur splash2/codes/apps/barnes/Makefile splash2-modified/codes/apps/barnes/Makefile
--- splash2/codes/apps/barnes/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ splash2-modified/codes/apps/barnes/Makefile	2007-03-08 16:31:46.000000000 -0500
@@ -0,0 +1,13 @@
+TARGET = BARNES
+OBJS = code.o code_io.o load.o grav.o getparam.o util.o
+
+include ../../Makefile.config
+
+stdinc.h: code.h defs.h util.h vectmath.h load.h code_io.h grav.h getparam.h stdinc.H 
+code.o: code.C stdinc.h
+code_io.o: code_io.C stdinc.h
+getparam.o: getparam.C stdinc.h
+grav.o: grav.C stdinc.h
+load.o: load.C stdinc.h
+util.o: util.C stdinc.h
+
diff -Naur splash2/codes/apps/barnes/stdinc.H splash2-modified/codes/apps/barnes/stdinc.H
--- splash2/codes/apps/barnes/stdinc.H	1994-10-19 14:21:13.000000000 -0400
+++ splash2-modified/codes/apps/barnes/stdinc.H	2007-03-08 16:31:46.000000000 -0500
@@ -21,12 +21,14 @@
 #ifndef _STDINC_H_
 #define _STDINC_H_
 
-/*
- * If not already loaded, include stdio.h.
- */
-
+#include <math.h>
 #include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+#include <sys/times.h>
 
+#define error(msg, ...)	printf(msg, ##__VA_ARGS__);
 /*
  * STREAM: a replacement for FILE *.
  */
@@ -34,18 +36,10 @@
 typedef FILE *stream;
 
 /*
- * NULL: denotes a pointer to no object.
- */
-
-#ifndef NULL
-#define NULL 0
-#endif
-
-/*
  * BOOL, TRUE and FALSE: standard names for logical values.
  */
 
-typedef int bool;
+typedef long bool;
 
 #ifndef TRUE
 
@@ -58,7 +52,7 @@
  * BYTE: a short name for a handy chunk of bits.
  */
 
-typedef unsigned char byte;
+typedef char byte;
 
 /*
  * STRING: for null-terminated strings which are not taken apart.
@@ -78,7 +72,7 @@
  */
 
 typedef void (*proced)();
-typedef int (*iproc)();
+typedef long (*iproc)();
 typedef real (*rproc)();
 
 /*
@@ -113,4 +107,13 @@
 
 #define   ABS(x)       (((x) < 0) ? -(x) : (x))
 
+#include "vectmath.h"
+#include "defs.h"
+#include "code.h"
+#include "util.h"
+#include "load.h"
+#include "code_io.h"
+#include "grav.h"
+#include "getparam.h"
+
 #endif
diff -Naur splash2/codes/apps/barnes/util.C splash2-modified/codes/apps/barnes/util.C
--- splash2/codes/apps/barnes/util.C	1994-10-19 14:21:13.000000000 -0400
+++ splash2-modified/codes/apps/barnes/util.C	2007-03-09 01:28:05.000000000 -0500
@@ -14,7 +14,9 @@
 /*                                                                       */
 /*************************************************************************/
 
-#include <stdio.h>
+EXTERN_ENV
+#define global extern
+
 #include "stdinc.h"
 
 #define HZ 60.0
@@ -23,30 +25,22 @@
 #define MASK (0x7FFFFFFF)
 #define TWOTO31 2147483648.0
 
-local int A = 1;
-local int B = 0;
-local int randx = 1;
-local int lastrand;   /* the last random number */
+local long A = 1;
+local long B = 0;
+local long randx = 1;
+local long lastrand;   /* the last random number */
 
 /*
  * XRAND: generate floating-point random number.
  */
 
-double prand();
-
-double xrand(xl, xh)
-  double xl, xh;		/* lower, upper bounds on number */
+double xrand(double xl, double xh)
 {
-   long random ();
-   double x;
-
    return (xl + (xh - xl) * prand());
 }
 
-void pranset(int seed)
+void pranset(long seed)
 {
-   int proc;
-  
    A = 1;
    B = 0;
    randx = (A*seed+B) & MASK;
@@ -54,8 +48,7 @@
    B = (MULT*B + ADD) & MASK;
 }
 
-double 
-prand()
+double prand()
 /*
 	Return a random double in [0, 1.0)
 */
@@ -68,32 +61,11 @@
 /*
  * CPUTIME: compute CPU time in min.
  */
-
-#include <sys/types.h>
-#include <sys/times.h>
-
-
 double cputime()
 {
    struct tms buffer;
 
-   if (times(&buffer) == -1)
+   if (times(&buffer) == (clock_t)-1)
       error("times() call failed\n");
    return (buffer.tms_utime / (60.0 * HZ));
 }
-
-/*
- * ERROR: scream and die quickly.
- */
-
-error(msg, a1, a2, a3, a4)
-  char *msg, *a1, *a2, *a3, *a4;
-{
-   extern int errno;
-
-   fprintf(stderr, msg, a1, a2, a3, a4);
-   if (errno != 0)
-      perror("Error");
-   exit(0);
-}
-
diff -Naur splash2/codes/apps/barnes/util.H splash2-modified/codes/apps/barnes/util.H
--- splash2/codes/apps/barnes/util.H	1969-12-31 19:00:00.000000000 -0500
+++ splash2-modified/codes/apps/barnes/util.H	2007-03-08 16:31:46.000000000 -0500
@@ -0,0 +1,9 @@
+#ifndef _UTIL_H_
+#define _UTIL_H_
+
+double xrand(double xl, double xh);
+void pranset(long seed);
+double prand(void);
+double cputime(void);
+
+#endif
diff -Naur splash2/codes/apps/barnes/vectmath.H splash2-modified/codes/apps/barnes/vectmath.H
--- splash2/codes/apps/barnes/vectmath.H	1994-10-19 14:21:13.000000000 -0400
+++ splash2-modified/codes/apps/barnes/vectmath.H	2007-03-08 16:31:47.000000000 -0500
@@ -23,7 +23,7 @@
 
 
 
-#  define NDIM 3
+#define NDIM 3L
 
 typedef real vector[NDIM], matrix[NDIM][NDIM];
 
@@ -33,25 +33,25 @@
 
 #define CLRV(v)                   /* CLeaR Vector */                        \
 {                                                                        \
-    register int _i;                                                        \
+    register long _i;                                                        \
     for (_i = 0; _i < NDIM; _i++)                                        \
         (v)[_i] = 0.0;                                                        \
 }
 
 #define UNITV(v,j)                /* UNIT Vector */                        \
 {                                                                        \
-    register int _i;                                                        \
+    register long _i;                                                        \
     for (_i = 0; _i < NDIM; _i++)                                        \
         (v)[_i] = (_i == (j) ? 1.0 : 0.0);                                \
 }
 
 #define SETV(v,u)                /* SET Vector */                        \
 {                                                                         \
-    register int _i;                                                         \
+    register long _i;                                                         \
     for (_i = 0; _i < NDIM; _i++)                                         \
         (v)[_i] = (u)[_i];                                                 \
 }
-
+
 
 #define ADDV(v,u,w)                /* ADD Vector */                        \
 {                                                                        \
@@ -77,10 +77,10 @@
     *_vp   = (*_up  ) * (s);                                                \
 }
 
-
+
 #define DIVVS(v,u,s)           /* DIVide Vector by Scalar */                \
 {                                                                        \
-    register int _i;                                                        \
+    register long _i;                                                        \
     for (_i = 0; _i < NDIM; _i++)                                        \
         (v)[_i] = (u)[_i] / (s);                                        \
 }
@@ -98,7 +98,7 @@
 #define ABSV(s,v)                /* ABSolute value of a Vector */        \
 {                                                                        \
     double _tmp, sqrt();                                                \
-    register int _i;                                                        \
+    register long _i;                                                        \
     _tmp = 0.0;                                                               \
     for (_i = 0; _i < NDIM; _i++)                                        \
         _tmp += (v)[_i] * (v)[_i];                                        \
@@ -108,13 +108,13 @@
 #define DISTV(s,u,v)           /* DISTance between Vectors */                \
 {                                                                        \
     double _tmp, sqrt();                                                \
-    register int _i;                                                        \
+    register long _i;                                                        \
     _tmp = 0.0;                                                               \
     for (_i = 0; _i < NDIM; _i++)                                        \
         _tmp += ((u)[_i]-(v)[_i]) * ((u)[_i]-(v)[_i]);                        \
     (s) = sqrt(_tmp);                                                   \
 }
-
+
 
 
 #define CROSSVP(v,u,w)            /* CROSS Vector Product */           \
@@ -127,39 +127,39 @@
 
 #define INCADDV(v,u)             /* INCrementally ADD Vector */         \
 {                                                                        \
-    register int _i;                                                    \
+    register long _i;                                                    \
     for (_i = 0; _i < NDIM; _i++)                                       \
         (v)[_i] += (u)[_i];                                             \
 }
 
 #define INCSUBV(v,u)             /* INCrementally SUBtract Vector */    \
 {                                                                        \
-    register int _i;                                                    \
+    register long _i;                                                    \
     for (_i = 0; _i < NDIM; _i++)                                       \
         (v)[_i] -= (u)[_i];                                             \
 }
 
 #define INCMULVS(v,s)  /* INCrementally MULtiply Vector by Scalar */        \
 {                                                                        \
-    register int _i;                                                    \
+    register long _i;                                                    \
     for (_i = 0; _i < NDIM; _i++)                                       \
         (v)[_i] *= (s);                                                 \
 }
 
 #define INCDIVVS(v,s)   /* INCrementally DIVide Vector by Scalar */        \
 {                                                                        \
-    register int _i;                                                    \
+    register long _i;                                                    \
     for (_i = 0; _i < NDIM; _i++)                                       \
         (v)[_i] /= (s);                                                 \
 }
-
+
 /*
  * Matrix operations.
  */
 
 #define CLRM(p)                    /* CLeaR Matrix */                        \
 {                                                                        \
-    register int _i, _j;                                                \
+    register long _i, _j;                                                \
     for (_i = 0; _i < NDIM; _i++)                                        \
         for (_j = 0; _j < NDIM; _j++)                                        \
             (p)[_i][_j] = 0.0;                                                \
@@ -167,7 +167,7 @@
 
 #define SETMI(p)                /* SET Matrix to Identity */                \
 {                                                                        \
-    register int _i, _j;                                                \
+    register long _i, _j;                                                \
     for (_i = 0; _i < NDIM; _i++)                                        \
         for (_j = 0; _j < NDIM; _j++)                                        \
             (p)[_i][_j] = (_i == _j ? 1.0 : 0.0);                        \
@@ -175,7 +175,7 @@
 
 #define SETM(p,q)                /* SET Matrix */                        \
 {                                                                        \
-    register int _i, _j;                                                \
+    register long _i, _j;                                                \
     for (_i = 0; _i < NDIM; _i++)                                        \
         for (_j = 0; _j < NDIM; _j++)                                        \
             (p)[_i][_j] = (q)[_i][_j];                                        \
@@ -183,7 +183,7 @@
 
 #define TRANM(p,q)            /* TRANspose Matrix */                        \
 {                                                                        \
-    register int _i, _j;                                                \
+    register long _i, _j;                                                \
     for (_i = 0; _i < NDIM; _i++)                                        \
         for (_j = 0; _j < NDIM; _j++)                                        \
             (p)[_i][_j] = (q)[_j][_i];                                        \
@@ -191,7 +191,7 @@
 
 #define ADDM(p,q,r)                /* ADD Matrix */                        \
 {                                                                        \
-    register int _i, _j;                                                \
+    register long _i, _j;                                                \
     for (_i = 0; _i < NDIM; _i++)                                        \
         for (_j = 0; _j < NDIM; _j++)                                        \
             (p)[_i][_j] = (q)[_i][_j] + (r)[_i][_j];                        \
@@ -199,15 +199,15 @@
 
 #define SUBM(p,q,r)            /* SUBtract Matrix */                        \
 {                                                                        \
-    register int _i, _j;                                                \
+    register long _i, _j;                                                \
     for (_i = 0; _i < NDIM; _i++)                                        \
         for (_j = 0; _j < NDIM; _j++)                                        \
             (p)[_i][_j] = (q)[_i][_j] - (r)[_i][_j];                        \
 }
-
+
 #define MULM(p,q,r)            /* Multiply Matrix */                        \
 {                                                                        \
-    register int _i, _j, _k;                                                \
+    register long _i, _j, _k;                                                \
     for (_i = 0; _i < NDIM; _i++)                                        \
         for (_j = 0; _j < NDIM; _j++) {                                      \
             (p)[_i][_j] = 0.0;                                                \
@@ -218,7 +218,7 @@
 
 #define MULMS(p,q,s)          /* MULtiply Matrix by Scalar */                \
 {                                                                        \
-    register int _i, _j;                                                \
+    register long _i, _j;                                                \
     for (_i = 0; _i < NDIM; _i++)                                        \
         for (_j = 0; _j < NDIM; _j++)                                        \
             (p)[_i][_j] = (q)[_i][_j] * (s);                                \
@@ -226,7 +226,7 @@
 
 #define DIVMS(p,q,s)         /* DIVide Matrix by Scalar */                \
 {                                                                        \
-    register int _i, _j;                                                \
+    register long _i, _j;                                                \
     for (_i = 0; _i < NDIM; _i++)                                        \
         for (_j = 0; _j < NDIM; _j++)                                        \
             (p)[_i][_j] = (q)[_i][_j] / (s);                                \
@@ -234,7 +234,7 @@
 
 #define MULMV(v,p,u)       /* MULtiply Matrix by Vector */                \
 {                                                                        \
-    register int _i, _j;                                                \
+    register long _i, _j;                                                \
     for (_i = 0; _i < NDIM; _i++) {                                        \
         (v)[_i] = 0.0;                                                        \
         for (_j = 0; _j < NDIM; _j++)                                        \
@@ -244,7 +244,7 @@
 
 #define OUTVP(p,v,u)         /* OUTer Vector Product */                \
 {                                                                        \
-    register int _i, _j;                                                \
+    register long _i, _j;                                                \
     for (_i = 0; _i < NDIM; _i++)                                        \
         for (_j = 0; _j < NDIM; _j++)                                        \
             (p)[_i][_j] = (v)[_i] * (u)[_j];                                \
@@ -252,33 +252,33 @@
 
 #define TRACEM(s,p)         /* TRACE of Matrix */                        \
 {                                                                        \
-    register int _i;                                                        \
+    register long _i;                                                        \
     (s) = 0.0;                                                                \
     for (_i = 0.0; _i < NDIM; _i++)                                        \
         (s) += (p)[_i][_i];                                                \
 }
-
+
 /*
  * Misc. impure operations.
  */
 
 #define SETVS(v,s)                /* SET Vector to Scalar */                \
 {                                                                        \
-    register int _i;                                                        \
+    register long _i;                                                        \
     for (_i = 0; _i < NDIM; _i++)                                        \
         (v)[_i] = (s);                                                        \
 }
 
 #define ADDVS(v,u,s)             /* ADD Vector and Scalar */                \
 {                                                                        \
-    register int _i;                                                        \
+    register long _i;                                                        \
     for (_i = 0; _i < NDIM; _i++)                                        \
         (v)[_i] = (u)[_i] + (s);                                        \
 }
 
 #define SETMS(p,s)                /* SET Matrix to Scalar */                \
 {                                                                        \
-    register int _i, _j;                                                \
+    register long _i, _j;                                                \
     for (_i = 0; _i < NDIM; _i++)                                        \
         for (_j = 0; _j < NDIM; _j++)                                        \
             (p)[_i][_j] = (s);                                                \
diff -Naur splash2/codes/apps/fmm/box.C splash2-modified/codes/apps/fmm/box.C
--- splash2/codes/apps/fmm/box.C	1994-10-17 20:46:54.000000000 -0400
+++ splash2-modified/codes/apps/fmm/box.C	2007-03-09 21:37:05.000000000 -0500
@@ -27,19 +27,17 @@
 
 box *Grid = NULL;
 
-void ZeroBox(int my_id, box *b);
-void PrintExpansionTerms();
+void ZeroBox(long my_id, box *b);
 
 void
-CreateBoxes (int my_id, int num_boxes) 
+CreateBoxes (long my_id, long num_boxes)
 {
-   int cluster_no;
-   int i;
-   
+   long i;
+
    LOCK(G_Memory->mal_lock);
    Local[my_id].B_Heap = (box *) G_MALLOC(num_boxes * sizeof(box));
 
-/* POSSIBLE ENHANCEMENT:  Here is where one might distribute the 
+/* POSSIBLE ENHANCEMENT:  Here is where one might distribute the
    B_Heap data across physically distributed memories as desired.
 
    One way to do this is as follows:
@@ -70,11 +68,11 @@
 
 
 void
-FreeBoxes (int my_id)
+FreeBoxes (long my_id)
 {
-   int i;
+   long i;
    box *b_array;
-     
+
    b_array = Local[my_id].B_Heap;
    for (i = 0; i < Local[my_id].Index_B_Heap; i++)
       ZeroBox(my_id, &b_array[i]);
@@ -83,10 +81,10 @@
 
 
 void
-ZeroBox (int my_id, box *b)
+ZeroBox (long my_id, box *b)
 {
-   int i;
-  
+   long i;
+
    b->type = CHILDLESS;
    b->num_particles = 0;
    for (i = 0; i < MAX_PARTICLES_PER_BOX; i++)
@@ -108,7 +106,7 @@
 
 
 /*
- *  InitBox (int my_id, real x_center, real y_center, real length, int level, box *parent)
+ *  InitBox (long my_id, real x_center, real y_center, real length, long level, box *parent)
  *
  *  Args : the x_center and y_center of the center of the box;
  *         the length of the box;
@@ -118,15 +116,15 @@
  *  Returns : the address of the newly created box.
  *
  *  Side Effects : Initializes num_particles to 0, all other pointers to NULL,
- *    and sets the box ID to a unique number. It also creates the space for 
+ *    and sets the box ID to a unique number. It also creates the space for
  *    the two expansion arrays.
  *
  */
 box *
-InitBox (int my_id, real x_center, real y_center, real length, box *parent)
+InitBox (long my_id, real x_center, real y_center, real length, box *parent)
 {
    box *b;
-  
+
    if (Local[my_id].Index_B_Heap == Local[my_id].Max_B_Heap) {
       LockedPrint("ERROR (P%d) : Ran out of boxes\n", my_id);
       exit(-1);
@@ -157,8 +155,6 @@
 void
 PrintBox (box *b)
 {
-   int i;
-  
    LOCK(G_Memory->io_lock);
    fflush(stdout);
    if (b != NULL) {
@@ -166,9 +162,9 @@
       printf("  X center       = %.40g\n", b->x_center);
       printf("  Y center       = %.40g\n", b->y_center);
       printf("  Length         = %.40g\n", b->length);
-      printf("  Level          = %d\n", b->level);
+      printf("  Level          = %ld\n", b->level);
       printf("  Type           = %d\n", b->type);
-      printf("  Child Num      = %d\n", b->child_num);
+      printf("  Child Num      = %ld\n", b->child_num);
       if (b->parent == NULL)
 	 printf("  Parent         = NONE\n");
       else
@@ -191,11 +187,11 @@
       PrintBoxArrayIds(b->v_list, b->num_v_list);
       printf("  W List IDs : ");
       PrintBoxArrayIds(b->w_list, b->num_w_list);
-      printf("  # of Particles = %d\n", b->num_particles);
+      printf("  # of Particles = %ld\n", b->num_particles);
       printf("  Particles' IDs : ");
       PrintParticleArrayIds(b->particles, b->num_particles);
-      printf("  Assigned Process ID : %d\n", b->proc);
-      printf("  Cost : %d\n", b->cost);
+      printf("  Assigned Process ID : %ld\n", b->proc);
+      printf("  Cost : %ld\n", b->cost);
       printf("\n");
    }
    else
@@ -205,22 +201,22 @@
 
 
 /*
- *  PrintBoxArrayIds (box_node *b_array[], int array_length)
+ *  PrintBoxArrayIds (box_node *b_array[], long array_length)
  *
  *  Args : the address of the box array, b_array;
  *         the length of the array, array_length.
- * 
+ *
  *  Returns : nothing.
  *
- *  Side Effects : Prints to stdout just the id numbers for every box in 
+ *  Side Effects : Prints to stdout just the id numbers for every box in
  *    b_array.
  *
  */
 void
-PrintBoxArrayIds (box *b_array[], int array_length)
+PrintBoxArrayIds (box *b_array[], long array_length)
 {
-   int i;
-   int tab_count;
+   long i;
+   long tab_count;
 
    tab_count = 0;
    for (i = 0; i < array_length; i++) {
@@ -249,18 +245,18 @@
 void
 PrintExpansionTerms (complex expansion[])
 {
-   int i;
-   int tab_count = 0;
-  
+   long i;
+   long tab_count = 0;
+
    for (i = 0; i < Expansion_Terms; i++) {
       if (tab_count == 0) {
 	 printf("\n");
 	 tab_count = TERMS_PER_LINE;
       }
       if (expansion[i].i >= (real) 0.0)
-	 printf("\ta%d = %.3e + %.3ei", i, expansion[i].r, expansion[i].i);
+	 printf("\ta%ld = %.3e + %.3ei", i, expansion[i].r, expansion[i].i);
       else
-	 printf("\ta%d = %.3e - %.3ei", i, expansion[i].r, -expansion[i].i);
+	 printf("\ta%ld = %.3e - %.3ei", i, expansion[i].r, -expansion[i].i);
       tab_count -= 1;
    }
    printf("\n");
@@ -268,9 +264,9 @@
 
 
 void
-ListIterate (int my_id, box *b, box **list, int length, list_function function)
+ListIterate (long my_id, box *b, box **list, long length, list_function function)
 {
-   int i;
+   long i;
 
    for (i = 0; i < length; i++) {
       if (list[i] == NULL) {
@@ -283,7 +279,7 @@
 
 
 /*
- *  AdjacentBoxes (int my_id, box *b1, box *b2)
+ *  AdjacentBoxes (box *b1, box *b2)
  *
  *  Args : two potentially adjacent boxes, b1 and b2.
  *
@@ -298,34 +294,34 @@
  *
  *     NOTE : By this definition, parents are NOT adjacent to their children.
  */
-int
-AdjacentBoxes (int my_id, box *b1, box *b2)
+long
+AdjacentBoxes (box *b1, box *b2)
 {
    real exact_separation;
    real x_separation;
    real y_separation;
-   int ret_val;
-      
+   long ret_val;
+
    exact_separation = (b1->length / (real) 2.0) + (b2->length / (real) 2.0);
    x_separation = (real) fabs((double)(b1->x_center - b2->x_center));
    y_separation = (real) fabs((double)(b1->y_center - b2->y_center));
-  
-   if ((x_separation == exact_separation) && 
+
+   if ((x_separation == exact_separation) &&
        (y_separation <= exact_separation))
       ret_val = TRUE;
    else
-      if ((y_separation == exact_separation) && 
+      if ((y_separation == exact_separation) &&
 	  (x_separation <= exact_separation))
 	 ret_val = TRUE;
       else
 	 ret_val = FALSE;
-  
+
    return ret_val;
 }
 
 
-/*  
- *  WellSeparatedBoxes (int my_id, box *b1, box *b2)
+/*
+ *  WellSeparatedBoxes (box *b1, box *b2)
  *
  *  Args : Two potentially well separated boxes, b1 and b2.
  *
@@ -341,14 +337,14 @@
  *     twice the length of the biggest box.
  *
  */
-int
-WellSeparatedBoxes (int my_id, box *b1, box *b2)
+long
+WellSeparatedBoxes (box *b1, box *b2)
 {
    real min_ws_distance;
    real x_separation;
    real y_separation;
-   int ret_val;
-      
+   long ret_val;
+
    if (b1->length > b2->length)
       min_ws_distance = b1->length * (real) 2.0;
    else
@@ -356,7 +352,7 @@
 
    x_separation = (real) fabs((double)(b1->x_center - b2->x_center));
    y_separation = (real) fabs((double)(b1->y_center - b2->y_center));
-    
+
    if ((x_separation >= min_ws_distance) || (y_separation >= min_ws_distance))
       ret_val = TRUE;
    else
diff -Naur splash2/codes/apps/fmm/box.H splash2-modified/codes/apps/fmm/box.H
--- splash2/codes/apps/fmm/box.H	1994-10-17 20:46:54.000000000 -0400
+++ splash2-modified/codes/apps/fmm/box.H	2007-03-09 21:37:14.000000000 -0500
@@ -35,7 +35,7 @@
 typedef struct _Box box;
 typedef struct _Box_Node box_node;
 
-typedef void (*list_function)(int my_id, box *list_box, box *b);
+typedef void (*list_function)(long my_id, box *list_box, box *b);
 
 typedef enum { CHILDLESS, PARENT } box_type;
 
@@ -46,7 +46,7 @@
  *       the ID of the processor that created the box)
  *    2.- 3. An x and y position for its center
  *    4. The length of the box (measured as the length of one of its sides)
- *    5. The level of ancestry of the box (how many parents do you have to 
+ *    5. The level of ancestry of the box (how many parents do you have to
  *       visit before the first box is found?)
  *    6. The number of particles in the box
  *    7. A list of those particles
@@ -71,39 +71,39 @@
   real x_center;
   real y_center;
   real length;
-  int level;
+  long level;
   box_type type;
   particle *particles[MAX_PARTICLES_PER_BOX + 1];
-  int num_particles;
+  long num_particles;
   box *parent;
-  int child_num;
+  long child_num;
   box *shadow[NUM_OFFSPRING];
   box *children[NUM_OFFSPRING];
-  int num_children;
+  long num_children;
   box *siblings[MAX_SIBLINGS];
-  int num_siblings;
+  long num_siblings;
   box *colleagues[MAX_COLLEAGUES];
-  int num_colleagues;
+  long num_colleagues;
   box *u_list[MAX_U_LIST];
-  int num_u_list;
+  long num_u_list;
   box *v_list[MAX_V_LIST];
-  int num_v_list;
+  long num_v_list;
   box *w_list[MAX_W_LIST];
-  int num_w_list;
+  long num_w_list;
   complex mp_expansion[MAX_EXPANSION_TERMS];
   complex local_expansion[MAX_EXPANSION_TERMS];
   complex x_expansion[MAX_EXPANSION_TERMS];
-  int exp_lock_index;
-  int particle_lock_index;
-  volatile int construct_synch;
-  volatile int interaction_synch;
-  int proc;
-  int cost;
-  int u_cost;
-  int v_cost;
-  int w_cost;
-  int p_cost;
-  int subtree_cost;
+  long exp_lock_index;
+  long particle_lock_index;
+  volatile long construct_synch;
+  volatile long interaction_synch;
+  long proc;
+  long cost;
+  long u_cost;
+  long v_cost;
+  long w_cost;
+  long p_cost;
+  long subtree_cost;
   box *next;
   box *prev;
   box *link1;
@@ -120,17 +120,15 @@
 
 extern box *Grid;
 
-extern void CreateBoxes(int my_id, int num_boxes);
-extern void FreeBoxes(int my_id);
-extern box *InitBox(int my_id, real x_center, real y_center, real length,
-		    box *parent);
+extern void CreateBoxes(long my_id, long num_boxes);
+extern void FreeBoxes(long my_id);
+extern box *InitBox(long my_id, real x_center, real y_center, real length, box *parent);
 extern void PrintBox(box *b);
-extern void PrintBoxArrayIds(box *b_array[], int array_length);
+extern void PrintBoxArrayIds(box *b_array[], long array_length);
 extern void PrintExpansionTerms(complex expansion[]);
 
-extern void ListIterate(int my_id, box *b, box **list, int length,
-			list_function function);
-extern int AdjacentBoxes(int my_id, box *b1, box *b2);
-extern int WellSeparatedBoxes(int my_id, box *b1, box *b2);
+extern void ListIterate(long my_id, box *b, box **list, long length, list_function function);
+extern long AdjacentBoxes(box *b1, box *b2);
+extern long WellSeparatedBoxes(box *b1, box *b2);
 
 #endif /* _Box_H */
diff -Naur splash2/codes/apps/fmm/construct_grid.C splash2-modified/codes/apps/fmm/construct_grid.C
--- splash2/codes/apps/fmm/construct_grid.C	1994-10-17 20:46:54.000000000 -0400
+++ splash2-modified/codes/apps/fmm/construct_grid.C	2007-03-20 00:33:31.000000000 -0400
@@ -15,7 +15,7 @@
 /*************************************************************************/
 
 #include <stdio.h>
-#include <values.h>
+#include <float.h>
 #include "defs.h"
 #include "memory.h"
 #include "particle.h"
@@ -27,48 +27,43 @@
 #define MY_NUM_PARTICLES (Local[my_id].Num_Particles)
 #define MY_MAX_PARTICLES (Local[my_id].Max_Particles)
 
-void DetermineGridSize(int my_id);
-void DetermineLocalGridSize(int my_id);
-void MergeLocalGridSize(int my_id);
-void ConstructLocalGrid(int my_id);
-box *InitGrid(int my_id);
-void InsertParticlesInTree(int my_id, particle **p_list, int num_of_particles,
-			   box *root);
-box *FindHome(int my_id, particle *p, box *current_home);
-box *FindInitialRoot(int my_id, particle *p, box *current_home);
-box *CreateChild(int my_id, box *pb, int new_child_num);
-void SubdivideBox(int my_id, box *b);
-void MergeLocalGrid(int my_id);
-void MLGHelper(int my_id, box *local_box, box *global_box, box *global_parent);
-void MergeLocalParticles(int my_id, particle **p_array, int num_of_particles,
-			 box *pb);
-void SplitParticles(int my_id, particle **p_array, int length,
-		    particle **p_dist, int num_p_dist[NUM_OFFSPRING], box *pb);
-box *CreateLeaf(int my_id, box *pb, int new_child_num, particle **p_array,
-		int length);
-void InsertParticlesInLeaf(int my_id, particle **p_array, int length, box *b);
-int InsertBoxInGrid(int my_id, box *b, box *pb);
-int RemoveBoxFromGrid(int my_id, box *b, box *pb);
-void InsertSubtreeInPartition(int my_id, box *b);
-void CleanupGrid(int my_id);
-void SetSiblings(int my_id, box *b);
-void SetColleagues(int my_id, box *b);
-void ConstructGridLists(int my_id, box *b);
-void ConstructInteractionLists(int my_id, box *b);
-void SetVList(int my_id, box *b);
-void SetUList(int my_id, box *b);
-void SetUListHelper(int my_id, box *b, box *pb);
-int AncestorBox(int my_id, box *b, box *ancestor_box);
-void SetWList(int my_id, box *b);
-void InsertNonAdjChildren(int my_id, box *b, box *pb);
+void DetermineGridSize(long my_id);
+void DetermineLocalGridSize(long my_id);
+void MergeLocalGridSize(long my_id);
+void ConstructLocalGrid(long my_id);
+box *InitGrid(long my_id);
+void InsertParticlesInTree(long my_id, particle **p_list, long num_of_particles, box *root);
+box *FindHome(long my_id, particle *p, box *current_home);
+box *FindInitialRoot(particle *p, box *current_home);
+box *CreateChild(long my_id, box *pb, long new_child_num);
+void SubdivideBox(long my_id, box *b);
+void MergeLocalGrid(long my_id);
+void MLGHelper(long my_id, box *local_box, box *global_box, box *global_parent);
+void MergeLocalParticles(long my_id, particle **p_array, long num_of_particles, box *pb);
+void SplitParticles(particle **p_array, long length, particle **p_dist, long num_p_dist[NUM_OFFSPRING], box *pb);
+box *CreateLeaf(long my_id, box *pb, long new_child_num, particle **p_array, long length);
+void InsertParticlesInLeaf(long my_id, particle **p_array, long length, box *b);
+long InsertBoxInGrid(long my_id, box *b, box *pb);
+long RemoveBoxFromGrid(box *b, box *pb);
+void InsertSubtreeInPartition(long my_id, box *b);
+void CleanupGrid(long my_id);
+void SetSiblings(box *b);
+void SetColleagues(long my_id, box *b);
+void ConstructGridLists(long my_id, box *b);
+void ConstructInteractionLists(long my_id, box *b);
+void SetVList(long my_id, box *b);
+void SetUList(long my_id, box *b);
+void SetUListHelper(long my_id, box *b, box *pb);
+long AncestorBox(box *b, box *ancestor_box);
+void SetWList(long my_id, box *b);
+void InsertNonAdjChildren(long my_id, box *b, box *pb);
 
 
 void
-ConstructGrid (int my_id, time_info *local_time, int time_all)
-{
-   unsigned long init, start, finish;
-   int i;
-  
+ConstructGrid (long my_id, time_info *local_time, long time_all)
+{
+   unsigned long init = 0, start = 0, finish;
+
    if (time_all)
       CLOCK(init);
    DetermineGridSize(my_id);   /* Finds the four corners of the grid. */
@@ -91,15 +86,15 @@
    if (time_all) {
       local_time[MY_TIME_STEP].other_time = start - init;
       local_time[MY_TIME_STEP].construct_time = finish - start;
-   }	
+   }
 }
 
 
 void
-ConstructLists (int my_id, time_info *local_time, int time_all)
+ConstructLists (long my_id, time_info *local_time, long time_all)
 {
    unsigned long start, finish;
-  
+
    if (time_all)
       CLOCK(start);
    PartitionIterate(my_id, ConstructGridLists, TOP);
@@ -110,19 +105,19 @@
 
    if (time_all) {
       local_time[MY_TIME_STEP].list_time = finish - start;
-   }	
+   }
 }
 
 
 void
-DestroyGrid (int my_id, time_info *local_time, int time_all)
+DestroyGrid (long my_id, time_info *local_time, long time_all)
 {
    box *b_scan, *tb;
    particle *p;
-   int i;
-   int particle_cost;
-   unsigned long start, finish;
-  
+   long i;
+   long particle_cost;
+   unsigned long start = 0, finish;
+
    if (time_all)
       CLOCK(start);
    b_scan = Local[my_id].Childless_Partition;
@@ -133,8 +128,7 @@
       particle_cost = tb->cost / tb->num_particles;
       for (i = 0; i < tb->num_particles; i++) {
 	 if (MY_MAX_PARTICLES <= MY_NUM_PARTICLES) {
-	    LockedPrint("ERROR (P%d) : Too many particles in local array\n",
-			my_id);
+	    LockedPrint("ERROR (P%d) : Too many particles in local array\n", my_id);
 	    exit(-1);
 	 }
 	 p = tb->particles[i];
@@ -147,12 +141,12 @@
    if (time_all) {
       CLOCK(finish);
       local_time[MY_TIME_STEP].other_time += finish - start;
-   }	
+   }
 }
 
 
 /*
- *  PrintGrid (int my_id)
+ *  PrintGrid (long my_id)
  *
  *  Args : none.
  *
@@ -162,7 +156,7 @@
  *
  */
 void
-PrintGrid (int my_id)
+PrintGrid (long my_id)
 {
    if (Grid != NULL) {
       if (my_id == 0) {
@@ -185,7 +179,7 @@
 
 
 void
-DetermineGridSize (int my_id)
+DetermineGridSize (long my_id)
 {
    DetermineLocalGridSize(my_id);	/* Processor looks at its own particles and
 				   finds the x and y max and min */
@@ -200,11 +194,11 @@
    other before looking at the current best max and min. This speeds up the
    running time of the algorithm from 2n to 3/2n. */
 void
-DetermineLocalGridSize (int my_id)
+DetermineLocalGridSize (long my_id)
 {
    real x_pos1, x_pos2, y_pos1, y_pos2;
    real x_max_challenger, x_min_challenger, y_max_challenger, y_min_challenger;
-   int i;
+   long i;
 
    Local[my_id].Local_X_Max = -MAX_REAL;
    Local[my_id].Local_X_Min = MAX_REAL;
@@ -222,7 +216,7 @@
       else {
 	 x_max_challenger = x_pos2;
 	 x_min_challenger = x_pos1;
-      }      
+      }
       if (y_pos1 > y_pos2) {
 	 y_max_challenger = y_pos1;
 	 y_min_challenger = y_pos2;
@@ -257,15 +251,15 @@
 }
 
 
-/* Each processor writes its best to a global 
+/* Each processor writes its best to a global
    array, then they read everyone else's and find the absolute best. */
 void
-MergeLocalGridSize (int my_id)
+MergeLocalGridSize (long my_id)
 {
    real *my_f_array, *their_f_array;
    real x_max_challenger, x_min_challenger, y_max_challenger, y_min_challenger;
-   int i;
-  
+   long i;
+
    my_f_array = G_Memory->f_array[my_id];
    my_f_array[0] = Local[my_id].Local_X_Max;
    my_f_array[1] = Local[my_id].Local_X_Min;
@@ -292,23 +286,23 @@
 
 
 void
-ConstructLocalGrid (int my_id)
+ConstructLocalGrid (long my_id)
 {
    Local[my_id].Local_Grid = InitGrid(my_id); /* Create the root box */
-   InsertParticlesInTree(my_id, MY_PARTICLES, MY_NUM_PARTICLES, 
+   InsertParticlesInTree(my_id, MY_PARTICLES, MY_NUM_PARTICLES,
 			 Local[my_id].Local_Grid);
    /* Put all of your particles into your local tree */
 }
 
 
 box *
-InitGrid (int my_id)
+InitGrid (long my_id)
 {
    real x_length, y_length;
    real grid_length, grid_x_center, grid_y_center;
-   int exp;
+   long exp;
    box *ret_box;
-  
+
    frexp(Local[my_id].Local_X_Max, &exp);
    if (Local[my_id].Local_X_Max > 0)
       Local[my_id].Local_X_Max = ldexp(1.0, exp);
@@ -337,7 +331,7 @@
       if (Local[my_id].Local_Y_Min > 0)
 	 Local[my_id].Local_Y_Min = ldexp(1.0, exp - 1);
    }
-  
+
    x_length = Local[my_id].Local_X_Max - Local[my_id].Local_X_Min;
    y_length = Local[my_id].Local_Y_Max - Local[my_id].Local_Y_Min;
    if (x_length > y_length)
@@ -362,12 +356,12 @@
    into one child, in which case that child must be subdivided as well, and so
    on until there is more than one child. */
 void
-InsertParticlesInTree (int my_id, particle **p_list, int num_of_particles, box *root)
+InsertParticlesInTree (long my_id, particle **p_list, long num_of_particles, box *root)
 {
    particle *p;
    box *dest_box;
-   int i, j;
-  
+   long i, j;
+
    dest_box = root;
    for (i = 0; i < num_of_particles; i++) {
       p = p_list[i];
@@ -385,17 +379,17 @@
 }
 
 
-/* This function compares the particles position to the center of the parent 
-   (or cell) box and chooses the appropriate child to move down to, until 
-   either a child box or a null pointer is reached. In the first case, the box 
+/* This function compares the particles position to the center of the parent
+   (or cell) box and chooses the appropriate child to move down to, until
+   either a child box or a null pointer is reached. In the first case, the box
    is returned, and in the second, a new child box is created for the parent,
    and that box is returned. */
 box *
-FindHome (int my_id, particle *p, box *current_home)
+FindHome (long my_id, particle *p, box *current_home)
 {
    box *pb;
 
-   pb = FindInitialRoot(my_id, p, current_home);
+   pb = FindInitialRoot(p, current_home);
    while (pb->type == PARENT) {
       if (p->pos.y > pb->y_center) {
 	 if (p->pos.x > pb->x_center) {
@@ -427,9 +421,9 @@
 
 
 box *
-FindInitialRoot (int my_id, particle *p, box *current_home)
+FindInitialRoot (particle *p, box *current_home)
 {
-   int found;
+   long found;
    real x_center_distance, y_center_distance;
 
    found = FALSE;
@@ -447,8 +441,8 @@
 	 found = TRUE;
    }
    return current_home;
-}    
-  
+}
+
 
 
 /* Simply creates a new box and sets the parent and child pointers correctly.
@@ -457,34 +451,34 @@
    right. That's how I know how to set the location of the child box's center
    just by knowing the child number. */
 box *
-CreateChild (int my_id, box *pb, int new_child_num)
+CreateChild (long my_id, box *pb, long new_child_num)
 {
    real child_length, child_offset;
    box *ret_box;
-  
+
    child_length = pb->length / (real) NUM_DIMENSIONS;
-   child_offset = pb->length / (real) NUM_OFFSPRING;  
+   child_offset = pb->length / (real) NUM_OFFSPRING;
    if (new_child_num == 0) {
-      pb->children[0] = InitBox(my_id, (pb->x_center + child_offset), 
-				(pb->y_center + child_offset), child_length, 
+      pb->children[0] = InitBox(my_id, (pb->x_center + child_offset),
+				(pb->y_center + child_offset), child_length,
 				pb);
       pb->shadow[0] = pb->children[0];
    }
    if (new_child_num == 1) {
-      pb->children[1] = InitBox(my_id, (pb->x_center - child_offset), 
-				(pb->y_center + child_offset), child_length, 
+      pb->children[1] = InitBox(my_id, (pb->x_center - child_offset),
+				(pb->y_center + child_offset), child_length,
 				pb);
       pb->shadow[1] = pb->children[1];
    }
    if (new_child_num == 2) {
-      pb->children[2] = InitBox(my_id, (pb->x_center - child_offset), 
-				(pb->y_center - child_offset), child_length, 
+      pb->children[2] = InitBox(my_id, (pb->x_center - child_offset),
+				(pb->y_center - child_offset), child_length,
 				pb);
       pb->shadow[2] = pb->children[2];
    }
    if (new_child_num == 3) {
-      pb->children[3] = InitBox(my_id, (pb->x_center + child_offset), 
-				(pb->y_center - child_offset), child_length, 
+      pb->children[3] = InitBox(my_id, (pb->x_center + child_offset),
+				(pb->y_center - child_offset), child_length,
 				pb);
       pb->shadow[3] = pb->children[3];
    }
@@ -495,14 +489,14 @@
 }
 
 
-/* Looks at all the particles of the parent box and distributes them amongst 
+/* Looks at all the particles of the parent box and distributes them amongst
    the children. If the child does not exist, one is created. */
 void
-SubdivideBox (int my_id, box *b)
+SubdivideBox (long my_id, box *b)
 {
    particle *p;
    box *child;
-   int i;
+   long i;
 
    for (i = 0; i < b->num_particles; i++) {
       p = b->particles[i];
@@ -541,20 +535,20 @@
 /* Each processor keeps track of the boxes that it has inserted into the tree.
    This list is called a partition because when construction is over, every box
    in the global tree will also reside in one and only one of the processors'
-   partitions. This is needed for list construction (which you don't have to 
+   partitions. This is needed for list construction (which you don't have to
    worry about) and cost zone computation (which you will). */
 void
-MergeLocalGrid (int my_id)
+MergeLocalGrid (long my_id)
 {
    MLGHelper(my_id, Local[my_id].Local_Grid, Grid, NULL);
 }
 
 
 void
-MLGHelper (int my_id, box *local_box, box *global_box, box *global_parent)
+MLGHelper (long my_id, box *local_box, box *global_box, box *global_parent)
 {
-   int success;
-   int i;
+   long success;
+   long i;
 
    success = FALSE;
    while (success == FALSE) {
@@ -572,9 +566,9 @@
 	       }
 	    }
 	    else {
-	       success = RemoveBoxFromGrid(my_id, global_box, global_parent);
+	       success = RemoveBoxFromGrid(global_box, global_parent);
 	       if (success == TRUE) {
-		  InsertParticlesInTree(my_id, global_box->particles, 
+		  InsertParticlesInTree(my_id, global_box->particles,
 					global_box->num_particles, local_box);
 		  success = InsertBoxInGrid(my_id, local_box, global_parent);
 	       }
@@ -592,9 +586,9 @@
 	       success = TRUE;
 	    }
 	    else {
-	       success = RemoveBoxFromGrid(my_id, global_box, global_parent);
+	       success = RemoveBoxFromGrid(global_box, global_parent);
 	       if (success == TRUE) {
-		  InsertParticlesInLeaf(my_id, global_box->particles, 
+		  InsertParticlesInLeaf(my_id, global_box->particles,
 					global_box->num_particles, local_box);
 		  success = InsertBoxInGrid(my_id, local_box, global_parent);
 	       }
@@ -612,16 +606,15 @@
 
 
 void
-MergeLocalParticles (int my_id, particle **p_array, int num_of_particles, box *pb)
+MergeLocalParticles (long my_id, particle **p_array, long num_of_particles, box *pb)
 {
    particle *(p_dist)[NUM_OFFSPRING][MAX_PARTICLES_PER_BOX];
-   int num_p_dist[NUM_OFFSPRING];
+   long num_p_dist[NUM_OFFSPRING];
    box *child;
-   box *new_box;
-   int success;
-   int i, j, k;
+   long success;
+   long i;
 
-   SplitParticles(my_id, p_array, num_of_particles, 
+   SplitParticles(p_array, num_of_particles,
 		  (particle **) p_dist, num_p_dist, pb);
    for (i= 0; i < NUM_OFFSPRING; i++) {
       if (num_p_dist[i] > 0) {
@@ -636,7 +629,7 @@
 	       success = TRUE;
 	    }
 	    else {
-	       success = RemoveBoxFromGrid(my_id, child, pb);
+	       success = RemoveBoxFromGrid(child, pb);
 	       if (success == TRUE) {
 		  InsertParticlesInLeaf(my_id, p_dist[i], num_p_dist[i], child);
 		  success = InsertBoxInGrid(my_id, child, pb);
@@ -654,12 +647,12 @@
 
 
 void
-SplitParticles (int my_id, particle **p_array, int length, particle **p_dist,
-		int num_p_dist[NUM_OFFSPRING], box *pb)
+SplitParticles (particle **p_array, long length, particle **p_dist,
+		long num_p_dist[NUM_OFFSPRING], box *pb)
 {
    particle *p;
-   int i;
-  
+   long i;
+
    for (i = 0; i < NUM_OFFSPRING; i++)
       num_p_dist[i] = 0;
    for (i = 0; i < length; i++) {
@@ -667,46 +660,46 @@
       if (p->pos.y > pb->y_center) {
 	 if (p->pos.x > pb->x_center)
 	    *(p_dist + num_p_dist[0]++) = p;
-	 else 
+	 else
 	    *(p_dist + MAX_PARTICLES_PER_BOX + num_p_dist[1]++) = p;
-      }		
+      }
       else {
 	 if (p->pos.x > pb->x_center)
 	    *(p_dist + (3 * MAX_PARTICLES_PER_BOX) + num_p_dist[3]++) = p;
-	 else 
+	 else
 	    *(p_dist + (2 * MAX_PARTICLES_PER_BOX) + num_p_dist[2]++) = p;
-      }	  
+      }
    }
 }
 
 
 box *
-CreateLeaf (int my_id, box *pb, int new_child_num, particle **p_array, int length)
+CreateLeaf (long my_id, box *pb, long new_child_num, particle **p_array, long length)
 {
    real child_length, child_offset;
-   box *ret_box;
-   int i;
-    
+   box *ret_box = NULL;
+   long i;
+
    child_length = pb->length / (real) NUM_DIMENSIONS;
-   child_offset = pb->length / (real) NUM_OFFSPRING;  
+   child_offset = pb->length / (real) NUM_OFFSPRING;
    if (new_child_num == 0) {
-      ret_box = InitBox(my_id, (pb->x_center + child_offset), 
-			(pb->y_center + child_offset), child_length, 
+      ret_box = InitBox(my_id, (pb->x_center + child_offset),
+			(pb->y_center + child_offset), child_length,
 			pb);
    }
    if (new_child_num == 1) {
-      ret_box = InitBox(my_id, (pb->x_center - child_offset), 
-			(pb->y_center + child_offset), child_length, 
+      ret_box = InitBox(my_id, (pb->x_center - child_offset),
+			(pb->y_center + child_offset), child_length,
 			pb);
    }
    if (new_child_num == 2) {
-      ret_box = InitBox(my_id, (pb->x_center - child_offset), 
-			(pb->y_center - child_offset), child_length, 
+      ret_box = InitBox(my_id, (pb->x_center - child_offset),
+			(pb->y_center - child_offset), child_length,
 			pb);
    }
    if (new_child_num == 3) {
-      ret_box = InitBox(my_id, (pb->x_center + child_offset), 
-			(pb->y_center - child_offset), child_length, 
+      ret_box = InitBox(my_id, (pb->x_center + child_offset),
+			(pb->y_center - child_offset), child_length,
 			pb);
    }
    ret_box->child_num = new_child_num;
@@ -719,11 +712,11 @@
 
 
 void
-InsertParticlesInLeaf (int my_id, particle **p_array, int length, box *b)
+InsertParticlesInLeaf (long my_id, particle **p_array, long length, box *b)
 {
-   int i, j;
-   int offset;
-  
+   long i, j;
+   long offset;
+
    if ((length + b->num_particles) > MAX_PARTICLES_PER_BOX) {
       for (i = b->num_particles, j = length - 1; i < MAX_PARTICLES_PER_BOX;
 	   i++, j--)
@@ -741,11 +734,11 @@
 }
 
 
-int
-InsertBoxInGrid (int my_id, box *b, box *pb)
+long
+InsertBoxInGrid (long my_id, box *b, box *pb)
 {
-   int success;
-  
+   long success;
+
    if (pb == NULL) {
       LOCK(G_Memory->single_lock);
       if (Grid == NULL) {
@@ -774,11 +767,11 @@
 }
 
 
-int
-RemoveBoxFromGrid (int my_id, box *b, box *pb)
+long
+RemoveBoxFromGrid (box *b, box *pb)
 {
-   int success;
-  
+   long success;
+
    if (pb == NULL) {
       LOCK(G_Memory->single_lock);
       if (Grid == b) {
@@ -806,11 +799,11 @@
 
 
 void
-InsertSubtreeInPartition (int my_id, box *b)
+InsertSubtreeInPartition (long my_id, box *b)
 {
-   int i;
+   long i;
    box *child;
-  
+
    if (b->proc == my_id) {
       InsertBoxInPartition(my_id, b);
    }
@@ -827,10 +820,9 @@
 
 
 void
-CleanupGrid (int my_id)
+CleanupGrid (long my_id)
 {
    box *b_scan, *tb;
-   int i;
 
    b_scan = Local[my_id].Childless_Partition;
    while (b_scan != NULL) {
@@ -856,19 +848,19 @@
 
 
 void
-ConstructGridLists (int my_id, box *b)
+ConstructGridLists (long my_id, box *b)
 {
-   SetSiblings(my_id, b);
+   SetSiblings(b);
    SetColleagues(my_id, b);
 }
 
 
 void
-SetSiblings (int my_id, box *b)
+SetSiblings (box *b)
 {
    box *pb, *sb;
-   int i;
-  
+   long i;
+
    b->num_siblings = 0;
    pb = b->parent;
    if (pb != NULL) {
@@ -882,10 +874,10 @@
 
 
 void
-SetColleagues (int my_id, box *b)
+SetColleagues (long my_id, box *b)
 {
    box *pb, *cb, *cousin;
-   int i, j;
+   long i, j;
 
    b->num_colleagues = 0;
    pb = b->parent;
@@ -901,7 +893,7 @@
 	 for (j = 0; j < NUM_OFFSPRING; j++) {
 	    cousin = cb->children[j];
 	    if (cousin != NULL) {
-	       if (AdjacentBoxes(my_id, b, cousin) == TRUE)
+	       if (AdjacentBoxes(b, cousin) == TRUE)
 		  b->colleagues[b->num_colleagues++] = cousin;
 	    }
 	 }
@@ -918,7 +910,7 @@
 
 
 /*
- *  ConstructInteractionLists (int my_id, box *b)
+ *  ConstructInteractionLists (long my_id, box *b)
  *
  *  Args : a box, b.
  *
@@ -929,7 +921,7 @@
  *
  */
 void
-ConstructInteractionLists (int my_id, box *b)
+ConstructInteractionLists (long my_id, box *b)
 {
 
    SetVList(my_id, b);
@@ -942,11 +934,11 @@
 
 
 void
-SetVList (int my_id, box *b)
+SetVList (long my_id, box *b)
 {
    box *pb, *cb, *cousin;
-   int i, j;
-  
+   long i, j;
+
    b->num_v_list = 0;
    pb = b->parent;
    if (pb != NULL) {
@@ -955,17 +947,17 @@
 	 for (j = 0; j < NUM_OFFSPRING; j++) {
 	    cousin = cb->children[j];
 	    if (cousin != NULL) {
-	       if (WellSeparatedBoxes(my_id, b, cousin) == TRUE)
+	       if (WellSeparatedBoxes(b, cousin) == TRUE)
 		  b->v_list[b->num_v_list++] = cousin;
 	    }
 	 }
       }
    }
-}  
+}
 
 
 /*
- *  SetUList (int my_id, box *b)
+ *  SetUList (long my_id, box *b)
  *
  *  Args : a box, b.
  *
@@ -977,7 +969,7 @@
  *
  */
 void
-SetUList (int my_id, box *b)
+SetUList (long my_id, box *b)
 {
    b->num_u_list = 0;
    SetUListHelper(my_id, b, Grid);
@@ -986,7 +978,7 @@
 
 
 /*
- *  SetUListHelper (int my_id, box *b, box *pb)
+ *  SetUListHelper (long my_id, box *b, box *pb)
  *
  *  Args : a box, b, and a parent box, pb.
  *
@@ -998,22 +990,22 @@
  *
  */
 void
-SetUListHelper (int my_id, box *b, box *pb)
+SetUListHelper (long my_id, box *b, box *pb)
 {
    box *child;
-   int i;
+   long i;
 
    for (i = 0; i < NUM_OFFSPRING; i++) {
       child = pb->children[i];
       if (child != NULL) {
-	 if (AdjacentBoxes(my_id, b, child) == TRUE) {
+	 if (AdjacentBoxes(b, child) == TRUE) {
 	    if (child->type == CHILDLESS)
 	       b->u_list[b->num_u_list++] = child;
 	    else
 	       SetUListHelper(my_id, b, child);
 	 }
 	 else {
-	    if (AncestorBox(my_id, b, child) == TRUE)
+	    if (AncestorBox(b, child) == TRUE)
 	       SetUListHelper(my_id, b, child);
 	 }
       }
@@ -1023,7 +1015,7 @@
 
 
 /*
- *  AncestorBox (int my_id, box *b, box *ancestor_box)
+ *  AncestorBox (box *b, box *ancestor_box)
  *
  *  Args : a box, b, and its possible ancestor box, ancestor_box.
  *
@@ -1031,18 +1023,18 @@
  *
  *  Side Effects : none.
  *
- *  Comments : A box is NOT the ancestor of himself. So, AncestorBox(my_id, b,b)
+ *  Comments : A box is NOT the ancestor of himself. So, AncestorBox(b,b)
  *    always returns FALSE. So, ancestor_box is indeed the ancestor of b
  *    if their sizes are not equal and if b's center lies within the boundaries
  *    of ancestor_box.
  *
  */
-int
-AncestorBox (int my_id, box *b, box *ancestor_box)
+long
+AncestorBox (box *b, box *ancestor_box)
 {
    real x_center_distance;
    real y_center_distance;
-   int ret_val = TRUE;
+   long ret_val = TRUE;
 
    if (b->length != ancestor_box->length) {
 
@@ -1061,7 +1053,7 @@
 
 
 /*
- *  SetWList (int my_id, box *b)
+ *  SetWList (long my_id, box *b)
  *
  *  Args : a box, b.
  *
@@ -1075,10 +1067,10 @@
  *
  */
 void
-SetWList (int my_id, box *b)
+SetWList (long my_id, box *b)
 {
    box *co_search;
-   int i;
+   long i;
 
    b->num_w_list = 0;
    for (i = 0; i < b->num_colleagues; i++) {
@@ -1091,7 +1083,7 @@
 
 
 /*
- *  InsertNonAdjChildren (int my_id, box *b, box *pb)
+ *  InsertNonAdjChildren (long my_id, box *b, box *pb)
  *
  *  Args : a parent box, pb, and the box with the weak iteraction list, b.
  *
@@ -1105,15 +1097,15 @@
  *
  */
 void
-InsertNonAdjChildren (int my_id, box *b, box *pb)
+InsertNonAdjChildren (long my_id, box *b, box *pb)
 {
-   int i;
+   long i;
    box *child;
 
    for (i = 0; i < pb->num_children; i++) {
       child = pb->children[i];
       if (child != NULL) {
-	 if (AdjacentBoxes(my_id, b, child) == TRUE) {
+	 if (AdjacentBoxes(b, child) == TRUE) {
 	    if (child->type == PARENT)
 	       InsertNonAdjChildren(my_id, b, child);
 	 }
@@ -1121,7 +1113,7 @@
 	    b->w_list[b->num_w_list++] = child;
       }
    }
-  
+
 }
 
 
diff -Naur splash2/codes/apps/fmm/construct_grid.H splash2-modified/codes/apps/fmm/construct_grid.H
--- splash2/codes/apps/fmm/construct_grid.H	1994-10-17 20:46:54.000000000 -0400
+++ splash2-modified/codes/apps/fmm/construct_grid.H	2007-03-09 18:16:22.000000000 -0500
@@ -17,9 +17,9 @@
 #ifndef _Construct_Grid_H
 #define _Construct_Grid_H 1
 
-extern void ConstructGrid(int my_id, time_info *local_time, int time_all);
-extern void ConstructLists(int my_id, time_info *local_time, int time_all);
-extern void DestroyGrid(int my_id, time_info *local_time, int time_all);
-extern void PrintGrid(int my_id);
+extern void ConstructGrid(long my_id, time_info *local_time, long time_all);
+extern void ConstructLists(long my_id, time_info *local_time, long time_all);
+extern void DestroyGrid(long my_id, time_info *local_time, long time_all);
+extern void PrintGrid(long my_id);
 
 #endif /* _Construct_Grid_H */
diff -Naur splash2/codes/apps/fmm/cost_zones.C splash2-modified/codes/apps/fmm/cost_zones.C
--- splash2/codes/apps/fmm/cost_zones.C	1994-10-17 20:46:54.000000000 -0400
+++ splash2-modified/codes/apps/fmm/cost_zones.C	2007-03-09 21:27:00.000000000 -0500
@@ -24,14 +24,14 @@
 
 typedef enum { RIGHT, LEFT, UP, DOWN } direction;
 
-static int Child_Sequence[NUM_DIRECTIONS][NUM_OFFSPRING] = 
+static long Child_Sequence[NUM_DIRECTIONS][NUM_OFFSPRING] =
 {
    { 0, 1, 2, 3 },
    { 2, 3, 0, 1 },
    { 0, 3, 2, 1 },
    { 2, 1, 0, 3 },
 };
-static int Direction_Sequence[NUM_DIRECTIONS][NUM_OFFSPRING] =
+static long Direction_Sequence[NUM_DIRECTIONS][NUM_OFFSPRING] =
 {
    { UP, RIGHT, RIGHT, DOWN },
    { DOWN, LEFT, LEFT, UP },
@@ -39,16 +39,13 @@
    { LEFT, DOWN, DOWN, RIGHT },
 };
 
-void ComputeSubTreeCosts(int my_id, box *b);
-void CostZonesHelper(int my_id, box *b, int work, direction dir);
+void ComputeSubTreeCosts(long my_id, box *b);
+void CostZonesHelper(long my_id, box *b, long work, direction dir);
 
 
 void
-CostZones (int my_id)
+CostZones (long my_id)
 {
-   int i;
-   box *b;
-  
    PartitionIterate(my_id, ComputeSubTreeCosts, BOTTOM);
    BARRIER(G_Memory->synch, Number_Of_Processors);
    Local[my_id].Total_Work = Grid->subtree_cost;
@@ -67,19 +64,16 @@
 
 
 void
-ComputeSubTreeCosts (int my_id, box *b)
+ComputeSubTreeCosts (long my_id, box *b)
 {
    box *pb;
-   box *sb;
-   int i;
-   box *cb;
 
    if (b->type == PARENT) {
       while (b->interaction_synch != b->num_children) {
       }
    }
    b->interaction_synch = 0;
-   ComputeCostOfBox(my_id, b);
+   ComputeCostOfBox(b);
    b->subtree_cost += b->cost;
    pb = b->parent;
    if (pb != NULL) {
@@ -92,13 +86,12 @@
 
 
 void
-CostZonesHelper (int my_id, box *b, int work, direction dir)
+CostZonesHelper (long my_id, box *b, long work, direction dir)
 {
    box *cb;
-   int i;
-   int parent_cost;
-   int *next_child;
-   int *child_dir;
+   long i;
+   long *next_child;
+   long *child_dir;
 
    if (b->type == CHILDLESS) {
       if (work >= Local[my_id].Min_Work)
diff -Naur splash2/codes/apps/fmm/cost_zones.H splash2-modified/codes/apps/fmm/cost_zones.H
--- splash2/codes/apps/fmm/cost_zones.H	1994-10-17 20:46:54.000000000 -0400
+++ splash2-modified/codes/apps/fmm/cost_zones.H	2007-03-09 18:16:49.000000000 -0500
@@ -17,6 +17,6 @@
 #ifndef _Cost_Zones_H
 #define _Cost_Zones_H 1
 
-extern void CostZones(int my_id);
+extern void CostZones(long my_id);
 
 #endif /* _Cost_Zones_H */
diff -Naur splash2/codes/apps/fmm/defs.C splash2-modified/codes/apps/fmm/defs.C
--- splash2/codes/apps/fmm/defs.C	1994-10-17 20:46:54.000000000 -0400
+++ splash2-modified/codes/apps/fmm/defs.C	2007-03-09 18:17:03.000000000 -0500
@@ -20,10 +20,10 @@
 #include "defs.h"
 #include "memory.h"
 
-int Number_Of_Processors;
+long Number_Of_Processors;
 double Timestep_Dur;
 real Softening_Param;
-int Expansion_Terms;
+long Expansion_Terms;
 
 
 real
@@ -31,7 +31,7 @@
 {
    double shifter;
    double frac;
-   int exp;
+   long exp;
    double shifted_frac;
    double new_frac;
    double temp;
@@ -65,14 +65,14 @@
 
 
 void
-LockedPrint (char *format, ...)
+LockedPrint (char *format_str, ...)
 {
    va_list ap;
 
-   va_start(ap, format);
+   va_start(ap, format_str);
    LOCK(G_Memory->io_lock);
    fflush(stdout);
-   vfprintf(stdout, format, ap);
+   vfprintf(stdout, format_str, ap);
    fflush(stdout);
    UNLOCK(G_Memory->io_lock);
    va_end(ap);
diff -Naur splash2/codes/apps/fmm/defs.H splash2-modified/codes/apps/fmm/defs.H
--- splash2/codes/apps/fmm/defs.H	1994-10-17 20:46:54.000000000 -0400
+++ splash2-modified/codes/apps/fmm/defs.H	2007-03-20 00:23:12.000000000 -0400
@@ -33,7 +33,8 @@
 #define NUM_DIMENSIONS 2
 #define NUM_DIM_POW_2 4
 
-#define DBL_MIN        2.225073858507201e-308 /* min > 0 val of "double" */
+#undef DBL_MIN
+#define DBL_MIN        2.2250738585072014e-308 /* min > 0 val of "double" */
 
 #define TIME_ALL 1  /* non-0 means time each phase within a time step */
 #define MY_TIMING (Local[my_id].Timing)
@@ -41,7 +42,7 @@
 
 #define MAX_REAL DBL_MAX
 #define MIN_REAL DBL_MIN
-#define REAL_DIG DBL_DIG
+#define REAL_DIG __DBL_DIG__
 
 #define MAX_PROCS 64
 
@@ -128,7 +129,7 @@
 #define CACHE_SIZE 16  /* should be in bytes */
 
 #define PAGE_SIZE 4096
-#define PAD_SIZE (PAGE_SIZE / (sizeof(int)))
+#define PAD_SIZE (PAGE_SIZE / (sizeof(long)))
 
 typedef enum { FALSE = 0, TRUE = 1 } bool;
 
@@ -136,8 +137,8 @@
  * precision, simply change double to float and recompile! */
 typedef double real;
 
-typedef struct _Complex complex;
-struct _Complex {
+typedef struct __Complex complex;
+struct __Complex {
   real r;
   real i;
 };
@@ -161,10 +162,10 @@
   unsigned long total_time;
 };
 
-extern int Number_Of_Processors;
+extern long Number_Of_Processors;
 extern double Timestep_Dur;
 extern real Softening_Param;
-extern int Expansion_Terms;
+extern long Expansion_Terms;
 
 extern real RoundReal(real val);
 extern void PrintComplexNum(complex *c);
diff -Naur splash2/codes/apps/fmm/fmm.C splash2-modified/codes/apps/fmm/fmm.C
--- splash2/codes/apps/fmm/fmm.C	1994-10-17 21:04:38.000000000 -0400
+++ splash2-modified/codes/apps/fmm/fmm.C	2007-03-09 23:08:36.000000000 -0500
@@ -32,33 +32,33 @@
       There are a total of nine parameters, with parameters
       three through seven having no default values.
 
-      1) Cluster Type : Particles are distributed either in one cluster, 
-         or two interacting clusters of size (# of particles)/ 2. 
+      1) Cluster Type : Particles are distributed either in one cluster,
+         or two interacting clusters of size (# of particles)/ 2.
          These two options are selected by the strings "one cluster" or
          "two cluster". The default is for two clusters.
-      2) Distribution Type : Particles are distributed in a cluster 
-         either in a spherical uniform distribution, or according to 
-         the Plummer model which typically has a large percentage of the 
-         particles close to the center of the sphere and fewer particles 
-         farther from the center.  There two options are selected by 
-         the strings "uniform" or "plummer". The default is for a 
+      2) Distribution Type : Particles are distributed in a cluster
+         either in a spherical uniform distribution, or according to
+         the Plummer model which typically has a large percentage of the
+         particles close to the center of the sphere and fewer particles
+         farther from the center.  There two options are selected by
+         the strings "uniform" or "plummer". The default is for a
          plummer distribution.
       3) Number Of Particles : Should be an integer greater than 0.
       4) Precision : A measure of how accurate the calculation should be.
-         A precision of 1e-3 means that the results will be accurate to 
-         within three decimal places regardless of the relative magnitude 
-         of the positions.  The precision should be a real number greater 
+         A precision of 1e-3 means that the results will be accurate to
+         within three decimal places regardless of the relative magnitude
+         of the positions.  The precision should be a real number greater
          than 0.
       5) Number of Processors : Should be an integer greater than 0.
       6) Number of Time Steps : Should be an integer greater than 0.
       7) Duration of a Time Step : How long each time step lasts.
          Should be a double greater than 0.
-      8) Softening Parameter : This value sets the minimum distance in 
-         each direction that two particles can be separated by.  If two 
-         particles are closer than this, the distance used for the 
-         calculation is changed to the softening parameter. The particle 
-         positions themselves are NOT changed. This number should be a 
-         real number greater than 0 and defaults to DBL_MIN or FLT_MIN, 
+      8) Softening Parameter : This value sets the minimum distance in
+         each direction that two particles can be separated by.  If two
+         particles are closer than this, the distance used for the
+         calculation is changed to the softening parameter. The particle
+         positions themselves are NOT changed. This number should be a
+         real number greater than 0 and defaults to DBL_MIN or FLT_MIN,
          depending on what type of data is being used.
       9) Partitioning Scheme : Sets which type of partitioning scheme
          is used. There are currently two : "cost zones" and "orb".
@@ -70,6 +70,7 @@
 #include <math.h>
 #include <errno.h>
 #include <stdlib.h>
+#include <string.h>
 #include "defs.h"
 #include "memory.h"
 #include "particle.h"
@@ -95,29 +96,28 @@
 
 static partition_alg Partition_Flag;
 static real Precision;
-static int Time_Steps;
+static long Time_Steps;
 static cluster_type Cluster;
 static model_type Model;
-int do_stats = 0;
-int do_output = 0;
-unsigned int starttime;
-unsigned int endtime;
-
-void ParallelExecute();
-void StepSimulation(int my_id, time_info *local_time, int time_all);
-void PartitionGrid(int my_id, time_info *local_time, int time_all);
-void GetArguments();
-void PrintTimes();
-void Help();
+long do_stats = 0;
+long do_output = 0;
+unsigned long starttime;
+unsigned long endtime;
+
+void ParallelExecute(void);
+void StepSimulation(long my_id, time_info *local_time, long time_all);
+void PartitionGrid(long my_id, time_info *local_time, long time_all);
+void GetArguments(void);
+void PrintTimes(void);
+void Help(void);
 
 
-void
+int
 main (int argc, char *argv[])
 {
-   int i;
-   int c;
+   long c;
    extern char *optarg;
-  
+
    CLOCK(starttime);
 
    while ((c = getopt(argc, argv, "osh")) != -1) {
@@ -131,15 +131,18 @@
    MAIN_INITENV(,40000000);
 
    GetArguments();
-   InitGlobalMemory();    
+   InitGlobalMemory();
    InitExpTables();
    CreateDistribution(Cluster, Model);
 
-   for (i = 1; i < Number_Of_Processors; i++) {
+/*   for (i = 1; i < Number_Of_Processors; i++) {
       CREATE(ParallelExecute);
    }
    ParallelExecute();
-   WAIT_FOR_END(Number_Of_Processors - 1);
+   WAIT_FOR_END(Number_Of_Processors - 1);*/
+   CREATE(ParallelExecute, Number_Of_Processors);
+   WAIT_FOR_END(Number_Of_Processors);
+
    printf("Finished FMM\n");
    PrintTimes();
    if (do_output) {
@@ -149,26 +152,24 @@
 }
 
 
-void 
+void
 ParallelExecute ()
 {
-   int my_id;
-   int num_boxes;
-   box *b, *b_list;
-   int i;
-   int start_index, end_index;
-   unsigned long start, finish;
+   long my_id;
+   long num_boxes;
+   unsigned long start, finish = 0;
    time_info *local_time;
-   int time_all = 0;
+   long time_all = 0;
    time_info *timing;
-   unsigned int local_init_done;
-    
+   unsigned long local_init_done = 0;
+
+   BARINCLUDE(G_Memory->synch);
    local_time = (time_info *) malloc(sizeof(struct _Time_Info) * MAX_TIME_STEPS);
    BARRIER(G_Memory->synch, Number_Of_Processors);
    LOCK(G_Memory->count_lock);
      my_id = G_Memory->id;
      G_Memory->id++;
-   UNLOCK(G_Memory->count_lock);   
+   UNLOCK(G_Memory->count_lock);
 
 /* POSSIBLE ENHANCEMENT:  Here is where one might pin processes to
    processors to avoid migration */
@@ -213,12 +214,12 @@
         if (do_stats || my_id == 0) {
           CLOCK(local_init_done);
         }
-      } 
+      }
 
       if (MY_TIME_STEP == 0) {
 	 CLOCK(start);
       }
-      else      
+      else
 	 start = finish;
       ConstructGrid(my_id,local_time,time_all);
       ConstructLists(my_id,local_time,time_all);
@@ -231,7 +232,7 @@
    }
    if (my_id == 0) {
       CLOCK(endtime);
-   } 
+   }
    BARRIER(G_Memory->synch, Number_Of_Processors);
    for (MY_TIME_STEP = 0; MY_TIME_STEP < Time_Steps; MY_TIME_STEP++) {
      timing = &(MY_TIMING[MY_TIME_STEP]);
@@ -250,47 +251,43 @@
 
 
 void
-PartitionGrid (int my_id, time_info *local_time, int time_all)
+PartitionGrid (long my_id, time_info *local_time, long time_all)
 {
-   unsigned long start, finish;
+   unsigned long start = 0, finish;
 
    if (time_all)
       CLOCK(start);
    if (Partition_Flag == COST_ZONES)
       CostZones(my_id);
-   else {
-   }
-   if (time_all)
-      CLOCK(finish);
-
    if (time_all) {
+      CLOCK(finish);
       local_time[MY_TIME_STEP].partition_time = finish - start;
    }
 }
 
 
 void
-StepSimulation (int my_id, time_info *local_time, int time_all)
+StepSimulation (long my_id, time_info *local_time, long time_all)
 {
    unsigned long start, finish;
    unsigned long upward_end, interaction_end, downward_end, barrier_end;
-  
-   if (time_all) 
+
+   if (time_all)
       CLOCK(start);
    PartitionIterate(my_id, UpwardPass, BOTTOM);
-   if (time_all) 
+   if (time_all)
       CLOCK(upward_end);
    PartitionIterate(my_id, ComputeInteractions, BOTTOM);
-   if (time_all) 
+   if (time_all)
       CLOCK(interaction_end);
    BARRIER(G_Memory->synch, Number_Of_Processors);
-   if (time_all) 
+   if (time_all)
       CLOCK(barrier_end);
    PartitionIterate(my_id, DownwardPass, TOP);
-   if (time_all) 
+   if (time_all)
       CLOCK(downward_end);
    PartitionIterate(my_id, ComputeParticlePositions, CHILDREN);
-   if (time_all) 
+   if (time_all)
       CLOCK(finish);
 
    if (time_all) {
@@ -326,7 +323,7 @@
 	 exit(-1);
       }
    }
-    
+
    gets(input);
    if (strcmp(input, "uniform") == 0)
       Model = UNIFORM;
@@ -348,7 +345,7 @@
       fprintf(stderr, "If you need help, type \"nbody -help\".\n");
       exit(-1);
    }
-  
+
    Precision = atof(gets(input));
    if (Precision == 0.0) {
       fprintf(stderr, "ERROR: The precision has no default value.\n");
@@ -357,10 +354,9 @@
    }
    /* Determine number of multipole expansion terms needed for specified
     * precision and flag an error if it is too precise */
-   Expansion_Terms = (int) ceil(-(log(Precision) / log(BASE)));
+   Expansion_Terms = (long) ceil(-(log(Precision) / log(BASE)));
    if (Expansion_Terms > MAX_EXPANSION_TERMS) {
-      fprintf(stderr, "ERROR: %g (%d terms) is too great a precision.\n",
-	      Precision, Expansion_Terms);
+      fprintf(stderr, "ERROR: %g (%ld terms) is too great a precision.\n", Precision, Expansion_Terms);
       fprintf(stderr, "If you need help, type \"nbody -help\".\n");
       exit(-1);
    }
@@ -433,7 +429,7 @@
 void
 PrintTimes ()
 {
-   int i, j;
+   long i, j;
    time_info *timing;
    FILE *fp;
    double t_total_time = 0;
@@ -455,8 +451,8 @@
    double intra_time;
    double other_time;
    double overall_total = 0;
-   int P;
-   int init_done;
+   long P;
+   long init_done;
 
    if ((fp = fopen("times", "w")) == NULL) {
       fprintf(stderr, "Error opening output file\n");
@@ -464,13 +460,12 @@
       exit(-1);
    }
    fprintf(fp, "TIMING:\n");
-   fprintf(fp, "%d\t%d\t%.2e\t%d\n", Number_Of_Processors, Total_Particles,
-	   Precision, Time_Steps);
+   fprintf(fp, "%ld\t%ld\t%.2e\t%ld\n", Number_Of_Processors, Total_Particles, Precision, Time_Steps);
    for (i = 0; i < Time_Steps; i++) {
-      fprintf(fp, "Time Step %d\n", i);
+      fprintf(fp, "Time Step %ld\n", i);
       for (j = 0; j < Number_Of_Processors; j++) {
 	 timing = &(Local[j].Timing[i]);
-	 fprintf(fp, "Processor %d\n", j);
+	 fprintf(fp, "Processor %ld\n", j);
 	 fprintf(fp, "\tTotal Time = %lu\n", timing->total_time);
 	 if (do_stats) {
 	    fprintf(fp, "\tTree Construction Time = %lu\n",
@@ -492,7 +487,7 @@
    printf("                                   PROCESS STATISTICS\n");
    printf("             Track        Tree        List        Part        Pass       Inter        Bar        Intra       Other\n");
    printf(" Proc        Time         Time        Time        Time        Time       Time         Time       Time        Time\n");
-   total_time = tree_time = list_time = part_time = pass_time = 
+   total_time = tree_time = list_time = part_time = pass_time =
    inter_time = bar_time = intra_time = other_time = 0;
    for (i = 2; i < Time_Steps; i++) {
      timing = &(Local[0].Timing[i]);
@@ -522,7 +517,7 @@
      overall_total = total_time;
    }
    for (j = 1; j < Number_Of_Processors; j++) {
-     total_time = tree_time = list_time = part_time = pass_time = 
+     total_time = tree_time = list_time = part_time = pass_time =
      inter_time = bar_time = intra_time = other_time = 0;
      for (i = 2; i < Time_Steps; i++) {
        timing = &(Local[j].Timing[i]);
@@ -537,7 +532,7 @@
        other_time += timing->other_time;
      }
      if (do_stats) {
-       printf(" %4d %12.0f%12.0f%12.0f%12.0f%12.0f%12.0f%12.0f%12.0f%12.0f\n",
+       printf(" %4ld %12.0f%12.0f%12.0f%12.0f%12.0f%12.0f%12.0f%12.0f%12.0f\n",
                j,total_time,tree_time,list_time,part_time,pass_time,
                inter_time,bar_time,intra_time,other_time);
      }
@@ -572,24 +567,18 @@
        }
      }
      printf("                                   TIMING INFORMATION\n");
-     printf("Start time                        : %16d\n",
-             starttime);
-     printf("Initialization finish time        : %16d\n",
-             init_done);
-     printf("Overall finish time               : %16d\n",
-             endtime);
-     printf("Total time with initialization    : %16d\n",
-             endtime - starttime);
-     printf("Total time without initialization : %16d\n",
-             (int) (overall_total));
+     printf("Start time                        : %16lu\n", starttime);
+     printf("Initialization finish time        : %16lu\n", init_done);
+     printf("Overall finish time               : %16lu\n", endtime);
+     printf("Total time with initialization    : %16lu\n", endtime - starttime);
+     printf("Total time without initialization : %16lu\n", (long) (overall_total));
      printf("\n");
 
-     printf("Total time for steps %d to %d : %12.0f\n",3,Time_Steps,
-             overall_total);
+     printf("Total time for steps %ld to %ld : %12.0f\n", 3L, Time_Steps, overall_total);
      printf("\n");
    }
 }
-  
+
 
 void
 Help ()
diff -Naur splash2/codes/apps/fmm/interactions.C splash2-modified/codes/apps/fmm/interactions.C
--- splash2/codes/apps/fmm/interactions.C	1994-10-17 20:46:55.000000000 -0400
+++ splash2-modified/codes/apps/fmm/interactions.C	2007-03-09 21:28:12.000000000 -0500
@@ -29,24 +29,24 @@
 static complex One;
 static complex Zero;
 
-void InitExp(int my_id, box *b);
-void ComputeMPExp(int my_id, box *b);
-void ShiftMPExp(int my_id, box *cb, box *pb);
-void UListInteraction(int my_id, box *b1, box *b2);
-void VListInteraction(int my_id, box *source_box, box *dest_box);
-void WAndXListInteractions(int my_id, box *b1, box *b2);
-void WListInteraction(int my_id, box *source_box, box *dest_box);
-void XListInteraction(int my_id, box *source_box, box *dest_box);
-void ComputeSelfInteraction(int my_id, box *b);
-void ShiftLocalExp(int my_id, box *pb, box *cb);
-void EvaluateLocalExp(int my_id, box *b);
+void InitExp(box *b);
+void ComputeMPExp(box *b);
+void ShiftMPExp(box *cb, box *pb);
+void UListInteraction(long my_id, box *b1, box *b2);
+void VListInteraction(long my_id, box *source_box, box *dest_box);
+void WAndXListInteractions(long my_id, box *b1, box *b2);
+void WListInteraction(box *source_box, box *dest_box);
+void XListInteraction(box *source_box, box *dest_box);
+void ComputeSelfInteraction(box *b);
+void ShiftLocalExp(box *pb, box *cb);
+void EvaluateLocalExp(box *b);
 
 
 void
 InitExpTables ()
 {
-   int i;
-   int j;
+   long i;
+   long j;
 
    for (i = 1; i < MAX_EXPANSION_TERMS + 1; i++) {
       Inv[i] = ((real) 1) / (real) i;
@@ -71,32 +71,29 @@
 void
 PrintExpTables ()
 {
-   int i;
-   int j;
-  
+   long i;
+   long j;
+
    printf("Table for the functions f(i) = 1 / i and g(i) = i / (i + 1)\n");
    printf("i\t\tf(i)\t\tg(i)\t\t\n");
    for (i = 1; i < MAX_EXPANSION_TERMS; i++)
-      printf("%d\t\t%e\t%f\t\n", i, Inv[i], OverInc[i]);
+      printf("%ld\t\t%e\t%f\t\n", i, Inv[i], OverInc[i]);
    printf("\n\nTable for the function h(i,j) = i choose j\n");
    printf("i\tj\th(i,j)\n");
    for (i = 0; i < (2 * MAX_EXPANSION_TERMS); i++) {
       for (j = 0; j <= i; j++)
-	 printf("%d\t%d\t%g\n", i, j, C[i][j]);
+	 printf("%ld\t%ld\t%g\n", i, j, C[i][j]);
       printf("\n");
    }
 }
 
-  
+
 void
-UpwardPass (int my_id, box *b)
+UpwardPass (long my_id, box *b)
 {
-   int i;
-   box *cb;
-
-   InitExp(my_id, b);
+   InitExp(b);
    if (b->type == CHILDLESS) {
-      ComputeMPExp(my_id, b);
+      ComputeMPExp(b);
       ALOCK(G_Memory->lock_array, b->exp_lock_index);
       b->interaction_synch = 1;
       AULOCK(G_Memory->lock_array, b->exp_lock_index);
@@ -107,7 +104,7 @@
       }
    }
    if (b->parent != NULL) {
-      ShiftMPExp(my_id, b, b->parent);
+      ShiftMPExp(b, b->parent);
       ALOCK(G_Memory->lock_array, b->parent->exp_lock_index);
       b->parent->interaction_synch += 1;
       AULOCK(G_Memory->lock_array, b->parent->exp_lock_index);
@@ -116,11 +113,11 @@
 
 
 void
-ComputeInteractions (int my_id, box *b)
+ComputeInteractions (long my_id, box *b)
 {
    b->cost = 0;
    if (b->type == CHILDLESS) {
-      ComputeSelfInteraction(my_id, b);
+      ComputeSelfInteraction(b);
       ListIterate(my_id, b, b->u_list, b->num_u_list, UListInteraction);
       ListIterate(my_id, b, b->w_list, b->num_w_list, WAndXListInteractions);
    }
@@ -129,18 +126,16 @@
 
 
 void
-DownwardPass (int my_id, box *b)
+DownwardPass (long my_id, box *b)
 {
-   int i;
-  
    if (b->parent != NULL) {
       while (b->parent->interaction_synch != 0) {
 	 /* wait */;
       }
-      ShiftLocalExp(my_id, b->parent, b);
+      ShiftLocalExp(b->parent, b);
    }
    if (b->type == CHILDLESS) {
-      EvaluateLocalExp(my_id, b);
+      EvaluateLocalExp(b);
       b->interaction_synch = 0;
    }
    else {
@@ -152,7 +147,7 @@
 
 
 void
-ComputeParticlePositions (int my_id, box *b)
+ComputeParticlePositions (long my_id, box *b)
 {
    particle *p;
    vector force;
@@ -161,8 +156,8 @@
    vector delta_vel;
    vector avg_vel;
    vector delta_pos;
-   int i;
-  
+   long i;
+
    for (i = 0; i < b->num_particles; i++) {
       p = b->particles[i];
       force.x = p->field.r * p->charge;
@@ -185,10 +180,10 @@
 
 
 void
-InitExp (int my_id, box *b)
+InitExp (box *b)
 {
-   int i;
-  
+   long i;
+
    for (i = 0; i < Expansion_Terms; i++) {
       b->mp_expansion[i].r = 0.0;
       b->mp_expansion[i].i = 0.0;
@@ -201,7 +196,7 @@
 
 
 /*
- *  ComputeMPExp (int my_id, box *b)
+ *  ComputeMPExp (long my_id, box *b)
  *
  *  Args : a box, b.
  *
@@ -217,7 +212,7 @@
  *
  */
 void
-ComputeMPExp (int my_id, box *b)
+ComputeMPExp (box *b)
 {
    particle *p;
    complex charge;
@@ -227,10 +222,9 @@
    complex z0_pow_n;
    complex temp;
    complex result_exp[MAX_EXPANSION_TERMS];
-   int comp_cost;
-   int i;
-   int j;
-    
+   long i;
+   long j;
+
    box_pos.r = b->x_center;
    box_pos.i = b->y_center;
    for (i = 0; i < Expansion_Terms; i++) {
@@ -250,7 +244,7 @@
 	 COMPLEX_MUL(temp, z0_pow_n, charge);
 	 COMPLEX_ADD(result_exp[j], result_exp[j], temp);
 	 COMPLEX_MUL(z0_pow_n, z0_pow_n, z0);
-      }    
+      }
    }
    ALOCK(G_Memory->lock_array, b->exp_lock_index);
    for (i = 0; i < Expansion_Terms; i++) {
@@ -258,11 +252,11 @@
       b->mp_expansion[i].i = result_exp[i].i;
    }
    AULOCK(G_Memory->lock_array, b->exp_lock_index);
-}  
+}
 
 
 void
-ShiftMPExp (int my_id, box *cb, box *pb)
+ShiftMPExp (box *cb, box *pb)
 {
    complex z0;
    complex z0_inv;
@@ -273,10 +267,9 @@
    complex child_pos;
    complex parent_pos;
    complex temp;
-   int comp_cost;
-   int i;
-   int j;
-    
+   long i;
+   long j;
+
    child_pos.r = cb->x_center;
    child_pos.i = cb->y_center;
    parent_pos.r = pb->x_center;
@@ -316,7 +309,7 @@
 
 
 void
-UListInteraction (int my_id, box *source_box, box *dest_box)
+UListInteraction (long my_id, box *source_box, box *dest_box)
 {
    complex result;
    complex temp_vector;
@@ -327,9 +320,9 @@
    real y_sep;
    real dest_x;
    real dest_y;
-   int i;
-   int j;
-  
+   long i;
+   long j;
+
    for (i = 0; i < dest_box->num_particles; i++) {
       result.r = (real) 0.0;
       result.i = (real) 0.0;
@@ -347,17 +340,17 @@
 	 COMPLEX_SUB(result, result, temp_result);
       }
       result.i = -result.i;
-      COMPLEX_ADD((dest_box->particles[i]->field), 
+      COMPLEX_ADD((dest_box->particles[i]->field),
 		  (dest_box->particles[i]->field), result);
    }
 
-   dest_box->cost += U_LIST_COST(source_box->num_particles, 
+   dest_box->cost += U_LIST_COST(source_box->num_particles,
 				 dest_box->num_particles);
 }
 
 
 void
-VListInteraction (int my_id, box *source_box, box *dest_box)
+VListInteraction (long my_id, box *source_box, box *dest_box)
 {
    complex z0;
    complex z0_inv;
@@ -367,8 +360,8 @@
    complex source_pos;
    complex dest_pos;
    complex temp;
-   int i;
-   int j;
+   long i;
+   long j;
 
    if (source_box->type == CHILDLESS) {
       while (source_box->interaction_synch != 1) {
@@ -390,7 +383,7 @@
    z0_pow_minus_n[0].r = One.r;
    z0_pow_minus_n[0].i = One.i;
    temp_exp[0].r = source_box->mp_expansion[0].r;
-   temp_exp[0].i = source_box->mp_expansion[0].i;  
+   temp_exp[0].i = source_box->mp_expansion[0].i;
    for (i = 1; i < Expansion_Terms; i++) {
       COMPLEX_MUL(z0_pow_minus_n[i], z0_pow_minus_n[i - 1], z0_inv);
       COMPLEX_MUL(temp_exp[i], z0_pow_minus_n[i], source_box->mp_expansion[i]);
@@ -423,31 +416,31 @@
 	 COMPLEX_MUL(temp, temp, source_box->mp_expansion[0]);
 	 COMPLEX_SUB(result_exp, result_exp, temp);
       }
-      COMPLEX_ADD((dest_box->local_expansion[i]), 
+      COMPLEX_ADD((dest_box->local_expansion[i]),
 		  (dest_box->local_expansion[i]), result_exp);
    }
    dest_box->cost += V_LIST_COST(Expansion_Terms);
-}  
+}
 
 
 void
-WAndXListInteractions (int my_id, box *b1, box *b2)
+WAndXListInteractions (long my_id, box *b1, box *b2)
 {
-   WListInteraction(my_id, b1, b2);
-   XListInteraction(my_id, b2, b1);
+   WListInteraction(b1, b2);
+   XListInteraction(b2, b1);
 }
 
 
 void
-WListInteraction (int my_id, box *source_box, box *dest_box)
+WListInteraction (box *source_box, box *dest_box)
 {
    complex z0;
    complex z0_inv;
    complex result;
    complex source_pos;
    complex particle_pos;
-   int i;
-   int j;
+   long i;
+   long j;
 
    if (source_box->type == CHILDLESS) {
       while (source_box->interaction_synch != 1) {
@@ -473,16 +466,16 @@
 	 COMPLEX_ADD(result, result, (source_box->mp_expansion[j]));
 	 COMPLEX_MUL(result, result, z0_inv);
       }
-      COMPLEX_ADD((dest_box->particles[i]->field), 
+      COMPLEX_ADD((dest_box->particles[i]->field),
 		  (dest_box->particles[i]->field), result);
    }
-  
+
    dest_box->cost += W_LIST_COST(dest_box->num_particles, Expansion_Terms);
 }
 
 
 void
-XListInteraction (int my_id, box *source_box, box *dest_box)
+XListInteraction (box *source_box, box *dest_box)
 {
    complex z0;
    complex z0_inv;
@@ -492,9 +485,9 @@
    complex dest_pos;
    complex charge;
    complex temp;
-   int i;
-   int j;
-    
+   long i;
+   long j;
+
    dest_pos.r = dest_box->x_center;
    dest_pos.i = dest_box->y_center;
    for (i = 0; i < Expansion_Terms; i++) {
@@ -518,7 +511,7 @@
    }
    ALOCK(G_Memory->lock_array, dest_box->exp_lock_index);
    for (i = 0; i < Expansion_Terms; i++) {
-      COMPLEX_SUB((dest_box->x_expansion[i]), 
+      COMPLEX_SUB((dest_box->x_expansion[i]),
 		  (dest_box->x_expansion[i]), result_exp[i]);
    }
    AULOCK(G_Memory->lock_array, dest_box->exp_lock_index);
@@ -527,7 +520,7 @@
 
 
 void
-ComputeSelfInteraction (int my_id, box *b)
+ComputeSelfInteraction (box *b)
 {
    complex results[MAX_PARTICLES_PER_BOX];
    complex temp_vector;
@@ -536,9 +529,8 @@
    real denom;
    real x_sep;
    real y_sep;
-   int comp_cost;
-   int i;
-   int j;
+   long i;
+   long j;
 
    for (i = 0; i < b->num_particles; i++) {
       results[i].r = (real) 0.0;
@@ -583,9 +575,9 @@
    b->cost += SELF_COST(b->num_particles);
 }
 
-  
+
 void
-ShiftLocalExp (int my_id, box *pb, box *cb)
+ShiftLocalExp (box *pb, box *cb)
 {
    complex z0;
    complex z0_inv;
@@ -596,8 +588,8 @@
    complex child_pos;
    complex parent_pos;
    complex temp;
-   int i;
-   int j;
+   long i;
+   long j;
 
    child_pos.r = cb->x_center;
    child_pos.i = cb->y_center;
@@ -614,7 +606,7 @@
 		  pb->x_expansion[i]);
       COMPLEX_MUL(temp_exp[i], z0_pow_n, pb->local_expansion[i]);
       COMPLEX_MUL(z0_pow_n, z0_pow_n, z0);
-   }    
+   }
    for (i = 0; i < Expansion_Terms; i++) {
       result_exp[i].r = (real) 0.0;
       result_exp[i].i = (real) 0.0;
@@ -629,7 +621,7 @@
    }
    ALOCK(G_Memory->lock_array, cb->exp_lock_index);
    for (i = 0; i < Expansion_Terms; i++) {
-      COMPLEX_ADD((cb->local_expansion[i]), (cb->local_expansion[i]), 
+      COMPLEX_ADD((cb->local_expansion[i]), (cb->local_expansion[i]),
 		  result_exp[i]);
    }
    AULOCK(G_Memory->lock_array, cb->exp_lock_index);
@@ -637,16 +629,16 @@
 
 
 void
-EvaluateLocalExp (int my_id, box *b)
+EvaluateLocalExp (box *b)
 {
    complex z0;
    complex result;
    complex source_pos;
    complex particle_pos;
    complex temp;
-   int i;
-   int j;
-    
+   long i;
+   long j;
+
    source_pos.r = b->x_center;
    source_pos.i = b->y_center;
    for (i = 0; i < b->num_particles; i++) {
diff -Naur splash2/codes/apps/fmm/interactions.H splash2-modified/codes/apps/fmm/interactions.H
--- splash2/codes/apps/fmm/interactions.H	1994-10-17 20:46:55.000000000 -0400
+++ splash2-modified/codes/apps/fmm/interactions.H	2007-03-09 21:28:55.000000000 -0500
@@ -19,12 +19,12 @@
 
 #include "box.h"
 
-extern void InitExpTables();
-extern void PrintExpTables();
-extern void UpwardPass(int my_id, box *b);
-extern void ComputeInteractions(int my_id, box *b);
-extern void DownwardPass(int my_id, box *b);
-extern void ComputeParticlePositions(int my_id, box *b);
+extern void InitExpTables(void);
+extern void PrintExpTables(void);
+extern void UpwardPass(long my_id, box *b);
+extern void ComputeInteractions(long my_id, box *b);
+extern void DownwardPass(long my_id, box *b);
+extern void ComputeParticlePositions(long my_id, box *b);
 
 #endif /* _Interactions_H */
 
diff -Naur splash2/codes/apps/fmm/makefile splash2-modified/codes/apps/fmm/makefile
--- splash2/codes/apps/fmm/makefile	1994-10-17 20:48:03.000000000 -0400
+++ splash2-modified/codes/apps/fmm/makefile	1969-12-31 19:00:00.000000000 -0500
@@ -1,57 +0,0 @@
-TARGET = FMM
-OBJS = defs.o memory.o particle.o box.o partition_grid.o \
-       cost_zones.o construct_grid.o interactions.o fmm.o 
-CFLAGS = -O2 -Olimit 2000 -w 
-LDFLAGS = -lmpc -lm
-MACROS = ../../null_macros/c.m4.null
-
-x = *
-
-$(TARGET): $(OBJS)
-	cc $(OBJS) $(CFLAGS) -o $(TARGET) $(LDFLAGS)
-
-.SUFFIXES:
-.SUFFIXES:	.o .c .C .h .H
-
-.H.h:
-	m4 ${MACROS} $*.H > $*.h
-
-.C.c:
-	m4 $(MACROS) $*.C > $*.c
-
-.c.o:
-	cc -c $(CFLAGS) $*.c
-
-.C.o:
-	m4 $(MACROS) $*.C > $*.c
-	cc -c $(CFLAGS) $*.c
-
-defs.c: defs.h
-box.c: box.h
-construct_grid.c: construct_grid.h
-cost_zones.c: cost_zones.h
-interactions.c: interactions.h
-memory.c: memory.h
-particle.c: particle.h
-partition_grid.c: partition_grid.h
-
-fmm.o: fmm.C defs.h memory.h particle.h box.h \
-        partition_grid.h cost_zones.h construct_grid.h
-interactions.o: interactions.C defs.h memory.h \
-        particle.h box.h partition_grid.h interactions.h
-shell.o: shell.C defs.h memory.h particle.h box.h \
-        partition_grid.h interactions.h
-construct_grid.o: construct_grid.C defs.h memory.h \
-        particle.h box.h partition_grid.h construct_grid.h
-cost_zones.o: cost_zones.C defs.h memory.h box.h \
-        partition_grid.h cost_zones.h
-orb.o: orb.C defs.h memory.h box.h partition_grid.h orb.h
-partition_grid.o: partition_grid.C defs.h memory.h box.h \
-        partition_grid.h
-box.o: box.C defs.h memory.h particle.h box.h
-particle.o: particle.C defs.h memory.h particle.h
-memory.o: memory.C defs.h memory.h
-defs.o: defs.C defs.h memory.h
-memory.h: defs.h particle.h box.h
-
-
diff -Naur splash2/codes/apps/fmm/Makefile splash2-modified/codes/apps/fmm/Makefile
--- splash2/codes/apps/fmm/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ splash2-modified/codes/apps/fmm/Makefile	2007-03-09 18:28:56.000000000 -0500
@@ -0,0 +1,26 @@
+TARGET = FMM
+OBJS = box.o construct_grid.o cost_zones.o defs.o fmm.o interactions.o memory.o particle.o partition_grid.o
+
+include ../../Makefile.config
+
+defs.c: defs.h
+box.c: box.h
+construct_grid.c: construct_grid.h
+cost_zones.c: cost_zones.h
+interactions.c: interactions.h
+memory.c: memory.h
+particle.c: particle.h
+partition_grid.c: partition_grid.h
+
+fmm.o: fmm.C defs.h memory.h particle.h box.h partition_grid.h cost_zones.h construct_grid.h interactions.h
+interactions.o: interactions.C defs.h memory.h particle.h box.h partition_grid.h interactions.h
+shell.o: shell.C defs.h memory.h particle.h box.h partition_grid.h interactions.h
+construct_grid.o: construct_grid.C defs.h memory.h particle.h box.h partition_grid.h construct_grid.h
+cost_zones.o: cost_zones.C defs.h memory.h box.h partition_grid.h cost_zones.h
+#orb.o: orb.C defs.h memory.h box.h partition_grid.h orb.h
+partition_grid.o: partition_grid.C defs.h memory.h box.h partition_grid.h
+box.o: box.C defs.h memory.h particle.h box.h
+particle.o: particle.C defs.h memory.h particle.h
+memory.o: memory.C defs.h memory.h
+defs.o: defs.C defs.h memory.h
+memory.h: defs.h particle.h box.h
diff -Naur splash2/codes/apps/fmm/memory.C splash2-modified/codes/apps/fmm/memory.C
--- splash2/codes/apps/fmm/memory.C	1994-10-17 20:46:55.000000000 -0400
+++ splash2-modified/codes/apps/fmm/memory.C	2007-03-20 00:34:03.000000000 -0400
@@ -14,6 +14,7 @@
 /*                                                                       */
 /*************************************************************************/
 
+#include <float.h>
 #include "defs.h"
 #include "memory.h"
 
@@ -35,12 +36,9 @@
 void
 InitGlobalMemory ()
 {
-   int i;
-
    G_Memory = (g_mem *) G_MALLOC(sizeof(g_mem));
-   G_Memory->i_array = (int *) G_MALLOC(Number_Of_Processors * sizeof(int));
-   G_Memory->d_array = (double *) G_MALLOC(Number_Of_Processors
-					 * sizeof(double));
+   G_Memory->i_array = (long *) G_MALLOC(Number_Of_Processors * sizeof(long));
+   G_Memory->d_array = (double *) G_MALLOC(Number_Of_Processors * sizeof(double));
    if (G_Memory == NULL) {
       printf("Ran out of global memory in InitGlobalMemory\n");
       exit(-1);
@@ -52,7 +50,7 @@
    LOCKINIT(G_Memory->single_lock);
    LOCKINIT(G_Memory->count_lock);
    ALOCKINIT(G_Memory->lock_array, MAX_LOCKS);
-   BARINIT(G_Memory->synch);
+   BARINIT(G_Memory->synch, Number_Of_Processors);
    G_Memory->max_x = -MAX_REAL;
    G_Memory->min_x = MAX_REAL;
    G_Memory->max_y = -MAX_REAL;
diff -Naur splash2/codes/apps/fmm/memory.H splash2-modified/codes/apps/fmm/memory.H
--- splash2/codes/apps/fmm/memory.H	1994-10-17 20:46:55.000000000 -0400
+++ splash2-modified/codes/apps/fmm/memory.H	2007-03-09 20:50:26.000000000 -0500
@@ -33,35 +33,35 @@
    LOCKDEC(mal_lock)
    LOCKDEC(single_lock)
    LOCKDEC(count_lock)
-   int count;
+   long count;
    ALOCKDEC(lock_array, MAX_LOCKS)
    BARDEC(synch)
-   volatile int *i_array;
+   volatile long *i_array;
    volatile double *d_array;
    real f_array[MAX_PROCS][NUM_DIM_POW_2];
    real max_x;
    real min_x;
    real max_y;
    real min_y;
-   int id;
+   long id;
 };
 extern g_mem *G_Memory;
 
 typedef struct _Local_Memory local_memory;
 struct _Local_Memory {
-   int pad_begin[PAD_SIZE];
+   long pad_begin[PAD_SIZE];
 
    box *B_Heap;
-   int Index_B_Heap;
-   int Max_B_Heap;
+   long Index_B_Heap;
+   long Max_B_Heap;
 
    particle **Particles;
-   int Num_Particles;
-   int Max_Particles;
+   long Num_Particles;
+   long Max_Particles;
 
    box *Childless_Partition;
    box *Parent_Partition[MAX_LEVEL];
-   int Max_Parent_Level;
+   long Max_Parent_Level;
 
    box *Local_Grid;
    real Local_X_Max;
@@ -69,19 +69,19 @@
    real Local_Y_Max;
    real Local_Y_Min;
 
-   int Total_Work;
-   int Min_Work;
-   int Max_Work;
+   long Total_Work;
+   long Min_Work;
+   long Max_Work;
 
-   int Time_Step;
+   long Time_Step;
    double Time;
-   unsigned int init_done_times;
+   unsigned long init_done_times;
    time_info Timing[MAX_TIME_STEPS];
-   
-   int pad_end[PAD_SIZE];
+
+   long pad_end[PAD_SIZE];
 };
 extern local_memory Local[MAX_PROCS];
 
-extern void InitGlobalMemory();
+extern void InitGlobalMemory(void);
 
 #endif /* _Memory_H */
diff -Naur splash2/codes/apps/fmm/particle.C splash2-modified/codes/apps/fmm/particle.C
--- splash2/codes/apps/fmm/particle.C	1994-11-17 21:39:59.000000000 -0500
+++ splash2-modified/codes/apps/fmm/particle.C	2007-03-20 01:25:20.000000000 -0400
@@ -15,6 +15,8 @@
 /*************************************************************************/
 
 #include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
 #include "defs.h"
 #include "memory.h"
 #include "particle.h"
@@ -23,10 +25,14 @@
 #define MAX_FRAC 0.999
 #define RANDOM_SIZE 256
 
+#if !defined(M_PI)
+#define M_PI           3.14159265358979323846
+#endif
+
 /* How many particles can fit on one line */
 #define PARTICLES_PER_LINE 8
 
-int Total_Particles;
+long Total_Particles;
 
 /* Used to keep track of all the particles. Array in is order of inc id. */
 static particle **Particle_List;
@@ -40,23 +46,22 @@
 CreateDistribution (cluster_type cluster, model_type model)
 {
    particle *particle_array;
-   int global_num_particles;
+   long global_num_particles;
    particle *new_particle;
-   char particle_state[RANDOM_SIZE];
+//   char particle_state[RANDOM_SIZE];
    real charge;
    real r_scale;
    real v_scale;
    vector r_sum;
    vector v_sum;
-   int end_limit;
-   int i;
-   int j;
+   long end_limit = 0;
+   long i;
    real temp_r;
-   real radius;
+   real radius = 0.0;
    real x_vel;
    real y_vel;
    real vel;
-   real offset;
+   real offset = 0.0;
    particle *twin_particle;
 
    particle_array = (particle *) G_MALLOC(Total_Particles * sizeof(particle));
@@ -71,20 +76,18 @@
    r_sum.y = (real) 0.0;
    v_sum.x = (real) 0.0;
    v_sum.y = (real) 0.0;
-   initstate(0, particle_state, RANDOM_SIZE);
-  
+//   initstate(0, particle_state, RANDOM_SIZE);
+
    switch (cluster) {
     case ONE_CLUSTER:
       end_limit = Total_Particles;
       switch (model) {
        case UNIFORM:
-	 printf("Creating a one cluster, uniform distribution for %d ",
-		Total_Particles);
+	 printf("Creating a one cluster, uniform distribution for %ld ", Total_Particles);
 	 printf("particles\n");
 	 break;
        case PLUMMER:
-	 printf("Creating a one cluster, non uniform distribution for %d ",
-		Total_Particles);
+	 printf("Creating a one cluster, non uniform distribution for %ld ", Total_Particles);
 	 printf("particles\n");
 	 break;
       }
@@ -93,19 +96,17 @@
       end_limit = (Total_Particles / 2) + (Total_Particles & 0x1);
       switch (model) {
        case UNIFORM:
-	 printf("Creating a two cluster, uniform distribution for %d ",
-		Total_Particles);
+	 printf("Creating a two cluster, uniform distribution for %ld ", Total_Particles);
 	 printf("particles\n");
 	 break;
        case PLUMMER:
-	 printf("Creating a two cluster, non uniform distribution for %d ",
-		Total_Particles);
+	 printf("Creating a two cluster, non uniform distribution for %ld ", Total_Particles);
 	 printf("particles\n");
 	 break;
       }
       break;
    }
-   setstate(particle_state);
+//   setstate(particle_state);
    global_num_particles = 0;
    charge = 1.0 / Total_Particles;
    charge /= Total_Particles;
@@ -117,7 +118,7 @@
 	    new_particle->pos.x = XRand(-1.0, 1.0);
 	    new_particle->pos.y = XRand(-1.0, 1.0);
 	    temp_r = DOT_PRODUCT((new_particle->pos), (new_particle->pos));
-	 } 
+	 }
 	 while (temp_r > (real) 1.0);
 	 radius = sqrt(temp_r);
 	 break;
@@ -173,12 +174,10 @@
 
 
 void
-CreateParticleList (int my_id, int length)
+CreateParticleList (long my_id, long length)
 {
-   int cluster_no;
-   
    LOCK(G_Memory->mal_lock);
-   Local[my_id].Particles = (particle **) G_MALLOC(length 
+   Local[my_id].Particles = (particle **) G_MALLOC(length
 						   * sizeof(particle *));
 
 /* POSSIBLE ENHANCEMENT:  Here is where one might distribute the
@@ -205,10 +204,10 @@
 
 
 void
-InitParticleList (int my_id, int num_assigned, int starting_id)
+InitParticleList (long my_id, long num_assigned, long starting_id)
 {
-   int i;
-   
+   long i;
+
    for (i = 0; i < num_assigned; i++)
       Local[my_id].Particles[i] = Particle_List[i + starting_id];
    Local[my_id].Num_Particles = num_assigned;
@@ -229,7 +228,7 @@
 PrintParticle (particle *p)
 {
    if (p != NULL) {
-      printf("P %6d :", p->id);
+      printf("P %6ld :", p->id);
       printf("  Pos    = ");
       PrintVector(&(p->pos));
    }
@@ -241,7 +240,7 @@
 void
 PrintAllParticles ()
 {
-   int i;
+   long i;
 
    fflush(stdout);
    printf("                                   PARTICLE POSITIONS\n\n");
@@ -253,11 +252,11 @@
 
 
 void
-PrintParticleArrayIds (particle **p_array, int num_particles) 
+PrintParticleArrayIds (particle **p_array, long num_particles)
 {
-   int tab_count = PARTICLES_PER_LINE;
-   int i = 0;
-    
+   long tab_count = PARTICLES_PER_LINE;
+   long i = 0;
+
    if (num_particles == 0)
       printf("NONE\n");
    else {
@@ -266,7 +265,7 @@
 	    tab_count = PARTICLES_PER_LINE;
 	    printf("\n");
 	 }
-	 printf("\tP%d", p_array[i]->id);
+	 printf("\tP%ld", p_array[i]->id);
 	 tab_count -= 1;
       }
       printf("\n");
@@ -275,7 +274,7 @@
 
 
 /*
- *  InitParticle (int my_id, real x_pos, real y_pos, real charge)
+ *  InitParticle (long my_id, real x_pos, real y_pos, real charge)
  *
  *  Args : the x_pos, y_pos, and charge (in eV) of the particle.
  *
@@ -289,7 +288,7 @@
 InitParticle (real charge, real mass)
 {
    particle *p;
-   static int particle_id = 0;
+   static long particle_id = 0;
 
    p = Particle_List[particle_id];
    p->id = particle_id++;
@@ -314,7 +313,7 @@
 {
    real temp_r;
    real r_scale;
-    
+
    do {
       v->x = XRand(-1.0, 1.0);
       v->y = XRand(-1.0, 1.0);
@@ -331,7 +330,7 @@
 {
    real ret_val;
 
-   ret_val = low  + (high - low) * ((real) random() / 2147483647.0);
+   ret_val = low  + (high - low) * ((real) rand/*om*/() / 2147483647.0);
    return ret_val;
 }
 
diff -Naur splash2/codes/apps/fmm/particle.H splash2-modified/codes/apps/fmm/particle.H
--- splash2/codes/apps/fmm/particle.H	1994-10-17 20:46:55.000000000 -0400
+++ splash2-modified/codes/apps/fmm/particle.H	2007-03-09 19:14:04.000000000 -0500
@@ -31,18 +31,18 @@
  *    3. A charge
  *    4. The field that acts on it due to every other particle
  *
- *  The force is what the algorithm actually calculates. 
+ *  The force is what the algorithm actually calculates.
  */
-struct _Particle 
+struct _Particle
 {
-  int id;
+  long id;
   real charge;
   real mass;
   vector pos;
   vector acc;
   vector vel;
   complex field;
-  int cost;
+  long cost;
   real box;
 };
 
@@ -54,14 +54,14 @@
   particle_node *next;
 };
 
-extern int Total_Particles;
+extern long Total_Particles;
 
-extern void CreateParticleList(int my_id, int length);
-extern void InitParticleList(int my_id, int num_assigned, int starting_id);
+extern void CreateParticleList(long my_id, long length);
+extern void InitParticleList(long my_id, long num_assigned, long starting_id);
 extern void CreateDistribution(cluster_type cluster, model_type model);
 extern void PrintParticle(particle *p);
-extern void PrintAllParticles();
-extern void PrintParticleArrayIds(particle **p_array, int num_particles);
+extern void PrintAllParticles(void);
+extern void PrintParticleArrayIds(particle **p_array, long num_particles);
 
 
 #endif /* _Particle_H */
diff -Naur splash2/codes/apps/fmm/partition_grid.C splash2-modified/codes/apps/fmm/partition_grid.C
--- splash2/codes/apps/fmm/partition_grid.C	1994-10-17 20:46:55.000000000 -0400
+++ splash2-modified/codes/apps/fmm/partition_grid.C	2007-03-09 19:03:29.000000000 -0500
@@ -27,24 +27,24 @@
 typedef struct _Id_Info id_info;
 struct _Id_Info
 {
-   int id;
-   int num;
+   long id;
+   long num;
 };
 
 typedef struct _Cost_Info cost_info;
 struct _Cost_Info
 {
-   int cost;
-   int num;
+   long cost;
+   long num;
 };
 
-int CheckBox(int my_id, box *b, int partition_level);
+long CheckBox(long my_id, box *b, long partition_level);
 
 void
-InitPartition (int my_id)
+InitPartition (long my_id)
 {
-   int i;
-  
+   long i;
+
    Local[my_id].Childless_Partition = NULL;
    for (i = 0; i < MAX_LEVEL; i++) {
       Local[my_id].Parent_Partition[i] = NULL;
@@ -54,11 +54,11 @@
 
 
 void
-PartitionIterate (int my_id, partition_function function,
+PartitionIterate (long my_id, partition_function function,
 		  partition_start position)
 {
    box *b;
-   int i;
+   long i;
 
    if (position == CHILDREN) {
       b = Local[my_id].Childless_Partition;
@@ -101,10 +101,10 @@
 
 
 void
-InsertBoxInPartition (int my_id, box *b)
+InsertBoxInPartition (long my_id, box *b)
 {
    box *level_list;
-  
+
    if (b->type == CHILDLESS) {
       b->prev = NULL;
       if (Local[my_id].Childless_Partition != NULL)
@@ -124,10 +124,10 @@
       }
    }
 }
-      
+
 
 void
-RemoveBoxFromPartition (int my_id, box *b)
+RemoveBoxFromPartition (long my_id, box *b)
 {
    if (b->type == CHILDLESS) {
       if (b->prev != NULL)
@@ -144,7 +144,7 @@
 	 Local[my_id].Parent_Partition[b->level] = b->next;
       if (b->next != NULL)
 	 b->next->prev = b->prev;
-      if ((b->level == Local[my_id].Max_Parent_Level) && 
+      if ((b->level == Local[my_id].Max_Parent_Level) &&
 	  (Local[my_id].Parent_Partition[b->level] == NULL)) {
 	 while (Local[my_id].Parent_Partition[Local[my_id].Max_Parent_Level]
 		== NULL)
@@ -155,25 +155,25 @@
 
 
 void
-ComputeCostOfBox (int my_id, box *b)
+ComputeCostOfBox (box *b)
 {
-   int different_costs;
-   int i;
-   int j;
-   int new_cost;
+   long different_costs;
+   long i;
+   long j;
+   long new_cost;
    cost_info cost_list[MAX_PARTICLES_PER_BOX];
    cost_info winner;
-   int winner_index;
-   int cost_index[MAX_PARTICLES_PER_BOX];
+   long winner_index;
+   long cost_index[MAX_PARTICLES_PER_BOX];
 
    if (b->type == PARENT)
-      b->cost = ((b->num_v_list * V_LIST_COST(Expansion_Terms)) 
+      b->cost = ((b->num_v_list * V_LIST_COST(Expansion_Terms))
 		 / DIVISOR(Expansion_Terms)) + 1;
    else {
       different_costs = 0;
       for (i = 0; i < b->num_particles; i++) {
 	 new_cost = b->particles[i]->cost;
-	 for (j = 0; j < different_costs; j++) {        
+	 for (j = 0; j < different_costs; j++) {
 	    if (new_cost == cost_list[j].cost)
 	       break;
 	 }
@@ -217,15 +217,15 @@
 
 
 void
-CheckPartition (int my_id)
+CheckPartition (long my_id)
 {
-   int i;
+   long i;
    box *b;
-   int NE, NoP, CB, PB;
-   int Q1, Q2, Q3, Q4;
-   int PC, CC;
+   long NE, NoP, CB, PB;
+   long Q1, Q2, Q3, Q4;
+   long PC, CC;
    real xpos, ypos;
-      
+
    NE = NoP = CB = PB = Q1 = Q2 = Q3 = Q4 = PC = CC = 0;
    for (i = 0; i <= Local[my_id].Max_Parent_Level; i++) {
       b = Local[my_id].Parent_Partition[i];
@@ -263,34 +263,30 @@
 }
 
 
-int
-CheckBox (int my_id, box *b, int partition_level)
+long
+CheckBox (long my_id, box *b, long partition_level)
 {
-   int num_errors;
-   int i;
+   long num_errors;
 
    num_errors = 0;
    if (b->type == CHILDLESS) {
       if (partition_level != -1) {
 	 LOCK(G_Memory->io_lock);
-	 printf("ERROR : CHILDLESS box in parent partition (B%f P%d %d)\n",
-		b->id, my_id, b->proc);
+	 printf("ERROR : CHILDLESS box in parent partition (B%f P%ld %ld)\n", b->id, my_id, b->proc);
 	 fflush(stdout);
 	 UNLOCK(G_Memory->io_lock);
 	 num_errors += 1;
       }
       if (b->num_children != 0) {
 	 LOCK(G_Memory->io_lock);
-	 printf("ERROR : CHILDLESS box has children (B%f P%d)\n",
-		b->id, my_id);
+	 printf("ERROR : CHILDLESS box has children (B%f P%ld)\n", b->id, my_id);
 	 fflush(stdout);
 	 UNLOCK(G_Memory->io_lock);
 	 num_errors += 1;
       }
       if (b->num_particles == 0) {
 	 LOCK(G_Memory->io_lock);
-	 printf("ERROR : CHILDLESS box has no particles (B%f P%d)\n",
-		b->id, my_id);
+	 printf("ERROR : CHILDLESS box has no particles (B%f P%ld)\n", b->id, my_id);
 	 fflush(stdout);
 	 UNLOCK(G_Memory->io_lock);
 	 num_errors += 1;
@@ -298,7 +294,7 @@
       if (b->particles[b->num_particles - 1] == NULL) {
 	 LOCK(G_Memory->io_lock);
 	 printf("ERROR : CHILDLESS box has fewer particles than expected ");
-	 printf("(B%f P%d)\n", b->id, my_id);
+	 printf("(B%f P%ld)\n", b->id, my_id);
 	 fflush(stdout);
 	 UNLOCK(G_Memory->io_lock);
 	 num_errors += 1;
@@ -306,7 +302,7 @@
       if (b->particles[b->num_particles] != NULL) {
 	 LOCK(G_Memory->io_lock);
 	 printf("ERROR : CHILDLESS box has more particles than expected ");
-	 printf("(B%f P%d)\n", b->id, my_id);
+	 printf("(B%f P%ld)\n", b->id, my_id);
 	 fflush(stdout);
 	 UNLOCK(G_Memory->io_lock);
 	 num_errors += 1;
@@ -315,7 +311,7 @@
    else {
       if (partition_level == -1) {
 	 LOCK(G_Memory->io_lock);
-	 printf("ERROR : PARENT box in childless partition (B%f P%d %d)\n", 
+	 printf("ERROR : PARENT box in childless partition (B%f P%ld %ld)\n",
 		b->id, my_id, b->proc);
 	 fflush(stdout);
 	 UNLOCK(G_Memory->io_lock);
@@ -325,8 +321,7 @@
 	 if (partition_level != b->level) {
 	    LOCK(G_Memory->io_lock);
 	    printf("ERROR : PARENT box in wrong partition level ");
-	    printf("(%d vs %d) (B%f P%d)\n", b->level, partition_level,
-		   b->id, my_id);
+	    printf("(%ld vs %ld) (B%f P%ld)\n", b->level, partition_level, b->id, my_id);
 	    fflush(stdout);
 	    UNLOCK(G_Memory->io_lock);
 	    num_errors += 1;
@@ -334,16 +329,14 @@
       }
       if (b->num_children == 0) {
 	 LOCK(G_Memory->io_lock);
-	 printf("ERROR : PARENT box has no children (B%f P%d)\n",
-		b->id, my_id);
+	 printf("ERROR : PARENT box has no children (B%f P%ld)\n", b->id, my_id);
 	 fflush(stdout);
 	 UNLOCK(G_Memory->io_lock);
 	 num_errors += 1;
       }
       if (b->num_particles != 0) {
 	 LOCK(G_Memory->io_lock);
-	 printf("ERROR : PARENT box has particles (B%f P%d)\n",
-		b->id, my_id);
+	 printf("ERROR : PARENT box has particles (B%f P%ld)\n", b->id, my_id);
 	 fflush(stdout);
 	 UNLOCK(G_Memory->io_lock);
 	 num_errors += 1;
@@ -353,11 +346,9 @@
       if (b != Grid) {
 	 LOCK(G_Memory->io_lock);
 	 if (b->type == CHILDLESS)
-	    printf("ERROR : Extra CHILDLESS box in partition (B%f P%d)\n", 
-		   b->id, my_id);
+	    printf("ERROR : Extra CHILDLESS box in partition (B%f P%ld)\n", b->id, my_id);
 	 else
-	    printf("ERROR : Extra PARENT box in partition (B%f P%d)\n", 
-		   b->id, my_id);
+	    printf("ERROR : Extra PARENT box in partition (B%f P%ld)\n", b->id, my_id);
 	 fflush(stdout);
 	 UNLOCK(G_Memory->io_lock);
 	 num_errors += 1;
@@ -367,11 +358,9 @@
       if (b->parent->children[b->child_num] != b) {
 	 LOCK(G_Memory->io_lock);
 	 if (b->type == CHILDLESS)
-	    printf("ERROR : Extra CHILDLESS box in partition (B%f P%d)\n", 
-		   b->id, my_id);
+	    printf("ERROR : Extra CHILDLESS box in partition (B%f P%ld)\n", b->id, my_id);
 	 else
-	    printf("ERROR : Extra PARENT box in partition (B%f P%d)\n", 
-		   b->id, my_id);
+	    printf("ERROR : Extra PARENT box in partition (B%f P%ld)\n", b->id, my_id);
 	 fflush(stdout);
 	 UNLOCK(G_Memory->io_lock);
 	 num_errors += 1;
diff -Naur splash2/codes/apps/fmm/partition_grid.H splash2-modified/codes/apps/fmm/partition_grid.H
--- splash2/codes/apps/fmm/partition_grid.H	1994-10-17 20:46:55.000000000 -0400
+++ splash2-modified/codes/apps/fmm/partition_grid.H	2007-03-09 19:04:19.000000000 -0500
@@ -21,17 +21,17 @@
 #include "box.h"
 
 /* Void function type */
-typedef void (*partition_function)(int my_id, box *b);
+typedef void (*partition_function)(long my_id, box *b);
 
 typedef enum { TOP, BOTTOM, CHILDREN } partition_start;
 typedef enum { ORB, COST_ZONES } partition_alg;
 
-extern void InitPartition(int my_id);
-extern void PartitionIterate(int my_id, partition_function function,
+extern void InitPartition(long my_id);
+extern void PartitionIterate(long my_id, partition_function function,
 			     partition_start position);
-extern void InsertBoxInPartition(int my_id, box *b);
-extern void RemoveBoxFromPartition(int my_id, box *b);
-extern void ComputeCostOfBox(int my_id, box *b);
-extern void CheckPartition(int my_id);
+extern void InsertBoxInPartition(long my_id, box *b);
+extern void RemoveBoxFromPartition(long my_id, box *b);
+extern void ComputeCostOfBox(box *b);
+extern void CheckPartition(long my_id);
 
 #endif /* _Partition_H */
diff -Naur splash2/codes/apps/ocean/contiguous_partitions/decs.H splash2-modified/codes/apps/ocean/contiguous_partitions/decs.H
--- splash2/codes/apps/ocean/contiguous_partitions/decs.H	1994-10-15 00:06:22.000000000 -0400
+++ splash2-modified/codes/apps/ocean/contiguous_partitions/decs.H	2007-03-19 23:48:07.000000000 -0400
@@ -27,21 +27,25 @@
 #define DOWNRIGHT         7
 #define PAGE_SIZE      4096
 
-extern struct multi_struct {
+struct multi_struct {
    double err_multi;
-} *multi;
+};
 
-extern struct global_struct {
-   int id;
-   int starttime;
-   int trackstart;
+extern struct multi_struct *multi;
+
+struct global_struct {
+   long id;
+   long starttime;
+   long trackstart;
    double psiai;
    double psibi;
-} *global;
+};
+
+extern struct global_struct *global;
 
 extern double eig2;
 extern double ysca;
-extern int jmm1;
+extern long jmm1;
 extern double pi;
 extern double t0;
 
@@ -67,16 +71,19 @@
 extern double ****q_multi;
 extern double ****rhs_multi;
 
-extern struct locks_struct {
+struct locks_struct {
    LOCKDEC(idlock)
    LOCKDEC(psiailock)
    LOCKDEC(psibilock)
    LOCKDEC(donelock)
    LOCKDEC(error_lock)
    LOCKDEC(bar_lock)
-} *locks;
- 
-extern struct bars_struct {
+};
+
+extern struct locks_struct *locks;
+
+struct bars_struct {
+#if defined(MULTIPLE_BARRIERS)
    BARDEC(iteration)
    BARDEC(gsudn)
    BARDEC(p_setup)
@@ -97,50 +104,57 @@
    BARDEC(sl_phase_9)
    BARDEC(sl_phase_10)
    BARDEC(error_barrier)
-} *bars;
+#else
+   BARDEC(barrier)
+#endif
+};
+
+extern struct bars_struct *bars;
 
 extern double factjacob;
 extern double factlap;
 
-extern struct Global_Private {
+struct Global_Private {
   char pad[PAGE_SIZE];
-  int *rel_num_x;
-  int *rel_num_y;
-  int *eist;
-  int *ejst;
-  int *oist;
-  int *ojst;
-  int *rlist;
-  int *rljst;
-  int *rlien;
-  int *rljen;
-  int rownum;
-  int colnum;
-  int neighbors[8];
+  long *rel_num_x;
+  long *rel_num_y;
+  long *eist;
+  long *ejst;
+  long *oist;
+  long *ojst;
+  long *rlist;
+  long *rljst;
+  long *rlien;
+  long *rljen;
+  long rownum;
+  long colnum;
+  long neighbors[8];
   double multi_time;
   double total_time;
-} *gp;
+};
+
+extern struct Global_Private *gp;
 
 extern double *i_int_coeff;
 extern double *j_int_coeff;
-extern int xprocs;
-extern int yprocs;
+extern long xprocs;
+extern long yprocs;
 
-extern int numlev;
-extern int *imx;
-extern int *jmx;
+extern long numlev;
+extern long *imx;
+extern long *jmx;
 extern double *lev_res;
 extern double *lev_tol;
 extern double maxwork;
-extern int *xpts_per_proc;
-extern int *ypts_per_proc;
-extern int minlevel;
+extern long *xpts_per_proc;
+extern long *ypts_per_proc;
+extern long minlevel;
 extern double outday0;
 extern double outday1;
 extern double outday2;
 extern double outday3;
 
-extern int nprocs;
+extern long nprocs;
 extern double h1;
 extern double h3;
 extern double h;
@@ -150,9 +164,65 @@
 extern double f0;
 extern double beta;
 extern double gpr;
-extern int im;
-extern int jm;
-extern int do_stats;
-extern int do_output;
-extern int *multi_times;
-extern int *total_times;
+extern long im;
+extern long jm;
+extern long do_stats;
+extern long do_output;
+extern long *multi_times;
+extern long *total_times;
+
+/*
+ * jacobcalc.C
+ */
+void jacobcalc(double ***x, double ***y, double ***z, long pid, long firstrow, long lastrow, long firstcol, long lastcol);
+
+/*
+ * jacobcalc2.C
+ */
+void jacobcalc2(double ****x, double ****y, double ****z, long psiindex, long pid, long firstrow, long lastrow, long firstcol, long lastcol);
+
+/*
+ * laplacalc.C
+ */
+void laplacalc(long procid, double ****x, double ****z, long psiindex, long firstrow, long lastrow, long firstcol, long lastcol);
+
+/*
+ * linkup.C
+ */
+void link_all(void);
+void linkup(double **row_ptr);
+void link_multi(void);
+
+/*
+ * main.C
+ */
+long log_2(long number);
+void printerr(char *s);
+
+/*
+ * multi.C
+ */
+void multig(long my_id);
+void relax(long k, double *err, long color, long my_num);
+void rescal(long kf, long my_num);
+void intadd(long kc, long my_num);
+void putz(long k, long my_num);
+void copy_borders(long k, long pid);
+void copy_rhs_borders(long k, long procid);
+void copy_red(long k, long procid);
+void copy_black(long k, long procid);
+
+/*
+ * slave1.C
+ */
+void slave(void);
+
+/*
+ * slave2.C
+ */
+void slave2(long procid, long firstrow, long lastrow, long numrows, long firstcol, long lastcol, long numcols);
+
+/*
+ * subblock.C
+ */
+void subblock(void);
diff -Naur splash2/codes/apps/ocean/contiguous_partitions/jacobcalc2.C splash2-modified/codes/apps/ocean/contiguous_partitions/jacobcalc2.C
--- splash2/codes/apps/ocean/contiguous_partitions/jacobcalc2.C	1994-10-15 00:06:22.000000000 -0400
+++ splash2-modified/codes/apps/ocean/contiguous_partitions/jacobcalc2.C	2007-03-12 20:22:18.000000000 -0400
@@ -14,7 +14,7 @@
 /*                                                                       */
 /*************************************************************************/
 
-/* Does the arakawa jacobian calculation (of the x and y matrices, 
+/* Does the arakawa jacobian calculation (of the x and y matrices,
    putting the results in the z matrix) for a subblock. */
 
 EXTERN_ENV
@@ -24,18 +24,7 @@
 #include <time.h>
 #include "decs.h"
 
-void jacobcalc2(x,y,z,psiindex,pid,firstrow,lastrow,firstcol,lastcol) 
-
-double ****x;
-double ****y;
-double ****z;
-int psiindex;
-int pid;
-int firstrow;
-int lastrow;
-int firstcol;
-int lastcol;
-
+void jacobcalc2(double ****x, double ****y, double ****z, long psiindex, long pid, long firstrow, long lastrow, long firstcol, long lastcol)
 {
    double f1;
    double f2;
@@ -45,14 +34,14 @@
    double f6;
    double f7;
    double f8;
-   int iindex;
-   int indexp1;
-   int indexm1;
-   int im1;
-   int ip1;
-   int i;
-   int j;
-   int jj;
+   long iindex;
+   long indexp1;
+   long indexm1;
+   long im1;
+   long ip1;
+   long i;
+   long j;
+   long jj;
    double **t2a;
    double **t2b;
    double **t2c;
@@ -67,16 +56,16 @@
    t2a = z[pid][psiindex];
    if ((gp[pid].neighbors[UP] == -1) && (gp[pid].neighbors[LEFT] == -1)) {
      t2a[0][0]=0.0;
-   }  
+   }
    if ((gp[pid].neighbors[DOWN] == -1) && (gp[pid].neighbors[LEFT] == -1)) {
      t2a[im-1][0]=0.0;
    }
    if ((gp[pid].neighbors[UP] == -1) && (gp[pid].neighbors[RIGHT] == -1)) {
      t2a[0][jm-1]=0.0;
-   }  
+   }
    if ((gp[pid].neighbors[DOWN] == -1) && (gp[pid].neighbors[RIGHT] == -1)) {
      t2a[im-1][jm-1]=0.0;
-   }  
+   }
 
    t2a = x[pid][psiindex];
    jj = gp[pid].neighbors[UPLEFT];
diff -Naur splash2/codes/apps/ocean/contiguous_partitions/jacobcalc.C splash2-modified/codes/apps/ocean/contiguous_partitions/jacobcalc.C
--- splash2/codes/apps/ocean/contiguous_partitions/jacobcalc.C	1994-10-15 00:06:22.000000000 -0400
+++ splash2-modified/codes/apps/ocean/contiguous_partitions/jacobcalc.C	2007-03-12 20:21:31.000000000 -0400
@@ -14,7 +14,7 @@
 /*                                                                       */
 /*************************************************************************/
 
-/* Does the arakawa jacobian calculation (of the x and y matrices, 
+/* Does the arakawa jacobian calculation (of the x and y matrices,
    putting the results in the z matrix) for a subblock.  */
 
 EXTERN_ENV
@@ -24,17 +24,7 @@
 #include <time.h>
 #include "decs.h"
 
-void jacobcalc(x,y,z,pid,firstrow,lastrow,firstcol,lastcol) 
-
-double ***x;
-double ***y;
-double ***z;
-int pid;
-int firstrow;
-int lastrow;
-int firstcol;
-int lastcol;
-
+void jacobcalc(double ***x, double ***y, double ***z, long pid, long firstrow, long lastrow, long firstcol, long lastcol)
 {
    double f1;
    double f2;
@@ -44,14 +34,14 @@
    double f6;
    double f7;
    double f8;
-   int iindex;
-   int indexp1;
-   int indexm1;
-   int im1;
-   int ip1;
-   int i;
-   int j;
-   int jj;
+   long iindex;
+   long indexp1;
+   long indexm1;
+   long im1;
+   long ip1;
+   long i;
+   long j;
+   long jj;
    double **t2a;
    double **t2b;
    double **t2c;
@@ -66,16 +56,16 @@
    t2a = (double **) z[pid];
    if ((gp[pid].neighbors[UP] == -1) && (gp[pid].neighbors[LEFT] == -1)) {
      t2a[0][0]=0.0;
-   }  
+   }
    if ((gp[pid].neighbors[DOWN] == -1) && (gp[pid].neighbors[LEFT] == -1)) {
      t2a[im-1][0]=0.0;
    }
    if ((gp[pid].neighbors[UP] == -1) && (gp[pid].neighbors[RIGHT] == -1)) {
      t2a[0][jm-1]=0.0;
-   }  
+   }
    if ((gp[pid].neighbors[DOWN] == -1) && (gp[pid].neighbors[RIGHT] == -1)) {
      t2a[im-1][jm-1]=0.0;
-   }  
+   }
 
    t2a = (double **) x[pid];
    jj = gp[pid].neighbors[UPLEFT];
diff -Naur splash2/codes/apps/ocean/contiguous_partitions/laplacalc.C splash2-modified/codes/apps/ocean/contiguous_partitions/laplacalc.C
--- splash2/codes/apps/ocean/contiguous_partitions/laplacalc.C	1994-10-15 00:06:22.000000000 -0400
+++ splash2-modified/codes/apps/ocean/contiguous_partitions/laplacalc.C	2007-03-12 20:20:34.000000000 -0400
@@ -23,25 +23,15 @@
 #include <time.h>
 #include "decs.h"
 
-void laplacalc(procid,x,z,psiindex,firstrow,lastrow,firstcol,lastcol)
-
-int procid;
-double ****x;
-double ****z;
-int psiindex;
-int firstrow;
-int lastrow;
-int firstcol;
-int lastcol;
-
+void laplacalc(long procid, double ****x, double ****z, long psiindex, long firstrow, long lastrow, long firstcol, long lastcol)
 {
-   int iindex;
-   int indexp1;
-   int indexm1;
-   int ip1;
-   int im1;
-   int i;
-   int j;
+   long iindex;
+   long indexp1;
+   long indexm1;
+   long ip1;
+   long im1;
+   long i;
+   long j;
    double **t2a;
    double **t2b;
    double *t1a;
@@ -120,6 +110,6 @@
      for (j=firstrow;j<=lastrow;j++) {
        t2b[j][jm-1] = 0.0;
      }
-   }  
+   }
 
 }
diff -Naur splash2/codes/apps/ocean/contiguous_partitions/linkup.C splash2-modified/codes/apps/ocean/contiguous_partitions/linkup.C
--- splash2/codes/apps/ocean/contiguous_partitions/linkup.C	1994-11-19 02:28:18.000000000 -0500
+++ splash2-modified/codes/apps/ocean/contiguous_partitions/linkup.C	2007-03-12 20:22:44.000000000 -0400
@@ -14,21 +14,17 @@
 /*                                                                       */
 /*************************************************************************/
 
-/* Set all the pointers to the proper locations for the q_multi and 
+/* Set all the pointers to the proper locations for the q_multi and
    rhs_multi data structures */
 
 EXTERN_ENV
 
 #include "decs.h"
 
-void linkup();
-void link_multi();
-
 void link_all()
-
 {
-  int i;
-  int j;
+  long i;
+  long j;
 
   for (j=0;j<nprocs;j++) {
     linkup(psium[j]);
@@ -55,18 +51,14 @@
   link_multi();
 }
 
-void linkup(row_ptr)
-
-double **row_ptr;
-
+void linkup(double **row_ptr)
 {
-  int i;
-  int j;
+  long i;
   double *a;
   double **row;
   double **y;
-  int x_part;
-  int y_part;
+  long x_part;
+  long y_part;
 
   x_part = (jm-2)/xprocs + 2;
   y_part = (im-2)/yprocs + 2;
@@ -74,28 +66,27 @@
   y = row + y_part;
   a = (double *) y;
   for (i=0;i<y_part;i++) {
-    *row = (double *) a;  
+    *row = (double *) a;
     row++;
     a += x_part;
   }
 }
 
 void link_multi()
-
 {
-  int i;
-  int j;
-  int l;
+  long i;
+  long j;
+  long l;
   double *a;
   double **row;
   double **y;
-  unsigned int z;
-  unsigned int zz;
-  int x_part;
-  int y_part;
-  unsigned int d_size;
+  unsigned long z;
+  unsigned long zz;
+  long x_part;
+  long y_part;
+  unsigned long d_size;
 
-  z = ((unsigned int) q_multi + nprocs*sizeof(double ***));
+  z = ((unsigned long) q_multi + nprocs*sizeof(double ***));
 
   if (nprocs%2 == 1) {         /* To make sure that the actual data
                                   starts double word aligned, add an extra
@@ -118,7 +109,7 @@
     z += d_size;
   }
   for (j=0;j<nprocs;j++) {
-    zz = (unsigned int) q_multi[j];
+    zz = (unsigned long) q_multi[j];
     zz += numlev*sizeof(double **);
     if (numlev%2 == 1) {       /* To make sure that the actual data
                                   starts double word aligned, add an extra
@@ -148,7 +139,7 @@
     }
   }
 
-  z = ((unsigned int) rhs_multi + nprocs*sizeof(double ***));
+  z = ((unsigned long) rhs_multi + nprocs*sizeof(double ***));
   if (nprocs%2 == 1) {         /* To make sure that the actual data
                                   starts double word aligned, add an extra
                                   pointer */
@@ -170,7 +161,7 @@
     z += d_size;
   }
   for (j=0;j<nprocs;j++) {
-    zz = (unsigned int) rhs_multi[j];
+    zz = (unsigned long) rhs_multi[j];
     zz += numlev*sizeof(double **);
     if (numlev%2 == 1) {       /* To make sure that the actual data
                                   starts double word aligned, add an extra
diff -Naur splash2/codes/apps/ocean/contiguous_partitions/main.C splash2-modified/codes/apps/ocean/contiguous_partitions/main.C
--- splash2/codes/apps/ocean/contiguous_partitions/main.C	1994-11-19 02:28:11.000000000 -0500
+++ splash2-modified/codes/apps/ocean/contiguous_partitions/main.C	2007-03-19 23:48:53.000000000 -0400
@@ -59,18 +59,13 @@
 #include <stdio.h>
 #include <math.h>
 #include <time.h>
+#include <stdlib.h>
+#include "decs.h"
 
-struct multi_struct {
-   double err_multi;
-} *multi;
-
-struct global_struct {
-   int id;
-   int starttime;
-   int trackstart;
-   double psiai;
-   double psibi;
-} *global;
+struct multi_struct *multi;
+struct global_struct *global;
+struct locks_struct *locks;
+struct bars_struct *bars;
 
 double ****psi;
 double ****psim;
@@ -94,44 +89,7 @@
 double ****q_multi;
 double ****rhs_multi;
 
-struct locks_struct {
-   LOCKDEC(idlock)
-   LOCKDEC(psiailock)
-   LOCKDEC(psibilock)
-   LOCKDEC(donelock)
-   LOCKDEC(error_lock)
-   LOCKDEC(bar_lock)
-} *locks;
-
-struct bars_struct {
-   BARDEC(iteration)
-   BARDEC(gsudn)
-   BARDEC(p_setup) 
-   BARDEC(p_redph) 
-   BARDEC(p_soln) 
-   BARDEC(p_subph) 
-   BARDEC(sl_prini)
-   BARDEC(sl_psini)
-   BARDEC(sl_onetime)
-   BARDEC(sl_phase_1)
-   BARDEC(sl_phase_2)
-   BARDEC(sl_phase_3)
-   BARDEC(sl_phase_4)
-   BARDEC(sl_phase_5)
-   BARDEC(sl_phase_6)
-   BARDEC(sl_phase_7)
-   BARDEC(sl_phase_8)
-   BARDEC(sl_phase_9)
-   BARDEC(sl_phase_10)
-   BARDEC(error_barrier)
-} *bars;
-
-void subblock();
-void slave();
-int log_2(int);
-void printerr(char *);
-
-int nprocs = DEFAULT_P;
+long nprocs = DEFAULT_P;
 double h1 = 1000.0;
 double h3 = 4000.0;
 double h = 5000.0;
@@ -141,12 +99,12 @@
 double f0 = 8.3e-5;
 double beta = 2.0e-11;
 double gpr = 0.02;
-int im = DEFAULT_N;
-int jm;
+long im = DEFAULT_N;
+long jm;
 double tolerance = DEFAULT_E;
 double eig2;
 double ysca;
-int jmm1;
+long jmm1;
 double pi;
 double t0 = 0.5e-4 ;
 double outday0 = 1.0;
@@ -155,63 +113,37 @@
 double outday3 = 2.0;
 double factjacob;
 double factlap;
-int numlev;
-int *imx;
-int *jmx;
+long numlev;
+long *imx;
+long *jmx;
 double *lev_res;
 double *lev_tol;
 double maxwork = 10000.0;
 
-struct Global_Private {
-  char pad[PAGE_SIZE];
-  int *rel_num_x;
-  int *rel_num_y;
-  int *eist;     
-  int *ejst;     
-  int *oist;     
-  int *ojst;     
-  int *rlist;    
-  int *rljst;    
-  int *rlien;    
-  int *rljen;    
-  int rownum;
-  int colnum;
-  int neighbors[8];
-  double multi_time;
-  double total_time;
-} *gp;
+struct Global_Private *gp;
 
 double *i_int_coeff;
 double *j_int_coeff;
-int xprocs;
-int yprocs;
-int *xpts_per_proc;
-int *ypts_per_proc;
-int minlevel;
-int do_stats = 0;
-int do_output = 0;
-
-void main(argc, argv)
-
-int argc;
-char *argv[];
+long xprocs;
+long yprocs;
+long *xpts_per_proc;
+long *ypts_per_proc;
+long minlevel;
+long do_stats = 0;
+long do_output = 0;
 
+int main(int argc, char *argv[])
 {
-   int i;
-   int j;
-   int k;
-   double work_multi;
-   int my_num;
-   int x_part;
-   int y_part;
-   int d_size;
-   int itemp;
-   int jtemp;
+   long i;
+   long j;
+   long k;
+   long x_part;
+   long y_part;
+   long d_size;
+   long itemp;
+   long jtemp;
    double procsqrt;
-   FILE *fileptr;
-   int iindex;
-   int temp = 0;
-   char c;
+   long temp = 0;
    double min_total;
    double max_total;
    double avg_total;
@@ -221,10 +153,10 @@
    double min_frac;
    double max_frac;
    double avg_frac;
-   int ch;
+   long ch;
    extern char *optarg;
-   unsigned int computeend;
-   unsigned int start;
+   unsigned long computeend;
+   unsigned long start;
 
    CLOCK(start)
 
@@ -268,13 +200,13 @@
      }
    }
 
-   MAIN_INITENV(,60000000) 
+   MAIN_INITENV(,60000000)
 
    jm = im;
    printf("\n");
    printf("Ocean simulation with W-cycle multigrid solver\n");
-   printf("    Processors                         : %1d\n",nprocs);
-   printf("    Grid size                          : %1d x %1d\n",im,jm);
+   printf("    Processors                         : %1ld\n",nprocs);
+   printf("    Grid size                          : %1ld x %1ld\n",im,jm);
    printf("    Grid resolution (meters)           : %0.2f\n",res);
    printf("    Time between relaxations (seconds) : %0.0f\n",dtau);
    printf("    Error tolerance                    : %0.7g\n",tolerance);
@@ -283,7 +215,7 @@
    xprocs = 0;
    yprocs = 0;
    procsqrt = sqrt((double) nprocs);
-   j = (int) procsqrt;
+   j = (long) procsqrt;
    while ((xprocs == 0) && (j > 0)) {
      k = nprocs / j;
      if (k * j == nprocs) {
@@ -300,7 +232,7 @@
    if (xprocs == 0) {
      printerr("Could not find factors for subblocking\n");
      exit(-1);
-   }  
+   }
 
    minlevel = 0;
    itemp = 1;
@@ -313,21 +245,21 @@
      if ((itemp/yprocs > 1) && (jtemp/xprocs > 1)) {
        numlev++;
      }
-   }  
-   
+   }
+
    if (numlev == 0) {
      printerr("Must have at least 2 grid points per processor in each dimension\n");
      exit(-1);
    }
 
-   imx = (int *) G_MALLOC(numlev*sizeof(int));
-   jmx = (int *) G_MALLOC(numlev*sizeof(int));
+   imx = (long *) G_MALLOC(numlev*sizeof(long));
+   jmx = (long *) G_MALLOC(numlev*sizeof(long));
    lev_res = (double *) G_MALLOC(numlev*sizeof(double));
    lev_tol = (double *) G_MALLOC(numlev*sizeof(double));
    i_int_coeff = (double *) G_MALLOC(numlev*sizeof(double));
    j_int_coeff = (double *) G_MALLOC(numlev*sizeof(double));
-   xpts_per_proc = (int *) G_MALLOC(numlev*sizeof(int));
-   ypts_per_proc = (int *) G_MALLOC(numlev*sizeof(int));
+   xpts_per_proc = (long *) G_MALLOC(numlev*sizeof(long));
+   ypts_per_proc = (long *) G_MALLOC(numlev*sizeof(long));
 
    imx[numlev-1] = im;
    jmx[numlev-1] = jm;
@@ -343,14 +275,14 @@
    for (i=0;i<numlev;i++) {
      xpts_per_proc[i] = (jmx[i]-2) / xprocs;
      ypts_per_proc[i] = (imx[i]-2) / yprocs;
-   }  
+   }
    for (i=numlev-1;i>=0;i--) {
      if ((xpts_per_proc[i] < 2) || (ypts_per_proc[i] < 2)) {
        minlevel = i+1;
        break;
      }
-   }    
- 
+   }
+
    for (i=0;i<numlev;i++) {
      temp += imx[i];
    }
@@ -398,16 +330,16 @@
 
    gp = (struct Global_Private *) G_MALLOC((nprocs+1)*sizeof(struct Global_Private));
    for (i=0;i<nprocs;i++) {
-     gp[i].rel_num_x = (int *) G_MALLOC(numlev*sizeof(int));
-     gp[i].rel_num_y = (int *) G_MALLOC(numlev*sizeof(int));
-     gp[i].eist = (int *) G_MALLOC(numlev*sizeof(int));
-     gp[i].ejst = (int *) G_MALLOC(numlev*sizeof(int));
-     gp[i].oist = (int *) G_MALLOC(numlev*sizeof(int));
-     gp[i].ojst = (int *) G_MALLOC(numlev*sizeof(int));
-     gp[i].rlist = (int *) G_MALLOC(numlev*sizeof(int));
-     gp[i].rljst = (int *) G_MALLOC(numlev*sizeof(int));
-     gp[i].rlien = (int *) G_MALLOC(numlev*sizeof(int));
-     gp[i].rljen = (int *) G_MALLOC(numlev*sizeof(int));
+     gp[i].rel_num_x = (long *) G_MALLOC(numlev*sizeof(long));
+     gp[i].rel_num_y = (long *) G_MALLOC(numlev*sizeof(long));
+     gp[i].eist = (long *) G_MALLOC(numlev*sizeof(long));
+     gp[i].ejst = (long *) G_MALLOC(numlev*sizeof(long));
+     gp[i].oist = (long *) G_MALLOC(numlev*sizeof(long));
+     gp[i].ojst = (long *) G_MALLOC(numlev*sizeof(long));
+     gp[i].rlist = (long *) G_MALLOC(numlev*sizeof(long));
+     gp[i].rljst = (long *) G_MALLOC(numlev*sizeof(long));
+     gp[i].rlien = (long *) G_MALLOC(numlev*sizeof(long));
+     gp[i].rljen = (long *) G_MALLOC(numlev*sizeof(long));
      gp[i].multi_time = 0;
      gp[i].total_time = 0;
    }
@@ -419,7 +351,7 @@
 
    d_size = x_part*y_part*sizeof(double) + y_part*sizeof(double *);
 
-   global = (struct global_struct *) G_MALLOC(sizeof(struct global_struct));  
+   global = (struct global_struct *) G_MALLOC(sizeof(struct global_struct));
    for (i=0;i<nprocs;i++) {
      psi[i][0] = (double **) G_MALLOC(d_size);
      psi[i][1] = (double **) G_MALLOC(d_size);
@@ -452,7 +384,7 @@
    multi = (struct multi_struct *) G_MALLOC(sizeof(struct multi_struct));
 
    d_size = numlev*sizeof(double **);
-   if (numlev%2 == 1) {         /* To make sure that the actual data 
+   if (numlev%2 == 1) {         /* To make sure that the actual data
                                    starts double word aligned, add an extra
                                    pointer */
      d_size += sizeof(double **);
@@ -464,7 +396,7 @@
 
    d_size *= nprocs;
 
-   if (nprocs%2 == 1) {         /* To make sure that the actual data 
+   if (nprocs%2 == 1) {         /* To make sure that the actual data
                                    starts double word aligned, add an extra
                                    pointer */
      d_size += sizeof(double ***);
@@ -484,26 +416,30 @@
    LOCKINIT(locks->error_lock)
    LOCKINIT(locks->bar_lock)
 
-   BARINIT(bars->iteration)
-   BARINIT(bars->gsudn)
-   BARINIT(bars->p_setup) 
-   BARINIT(bars->p_redph) 
-   BARINIT(bars->p_soln) 
-   BARINIT(bars->p_subph) 
-   BARINIT(bars->sl_prini)
-   BARINIT(bars->sl_psini)
-   BARINIT(bars->sl_onetime)
-   BARINIT(bars->sl_phase_1)
-   BARINIT(bars->sl_phase_2)
-   BARINIT(bars->sl_phase_3)
-   BARINIT(bars->sl_phase_4)
-   BARINIT(bars->sl_phase_5)
-   BARINIT(bars->sl_phase_6)
-   BARINIT(bars->sl_phase_7)
-   BARINIT(bars->sl_phase_8)
-   BARINIT(bars->sl_phase_9)
-   BARINIT(bars->sl_phase_10)
-   BARINIT(bars->error_barrier)
+#if defined(MULTIPLE_BARRIERS)
+   BARINIT(bars->iteration, nprocs)
+   BARINIT(bars->gsudn, nprocs)
+   BARINIT(bars->p_setup, nprocs)
+   BARINIT(bars->p_redph, nprocs)
+   BARINIT(bars->p_soln, nprocs)
+   BARINIT(bars->p_subph, nprocs)
+   BARINIT(bars->sl_prini, nprocs)
+   BARINIT(bars->sl_psini, nprocs)
+   BARINIT(bars->sl_onetime, nprocs)
+   BARINIT(bars->sl_phase_1, nprocs)
+   BARINIT(bars->sl_phase_2, nprocs)
+   BARINIT(bars->sl_phase_3, nprocs)
+   BARINIT(bars->sl_phase_4, nprocs)
+   BARINIT(bars->sl_phase_5, nprocs)
+   BARINIT(bars->sl_phase_6, nprocs)
+   BARINIT(bars->sl_phase_7, nprocs)
+   BARINIT(bars->sl_phase_8, nprocs)
+   BARINIT(bars->sl_phase_9, nprocs)
+   BARINIT(bars->sl_phase_10, nprocs)
+   BARINIT(bars->error_barrier, nprocs)
+#else
+   BARINIT(bars->barrier, nprocs)
+#endif
 
    link_all();
 
@@ -535,25 +471,19 @@
    im = (imx[numlev-1]-2)/yprocs + 2;
    jm = (jmx[numlev-1]-2)/xprocs + 2;
 
-   for (i=1;i<nprocs;i++) {
-     CREATE(slave)  
-   }
-
    if (do_output) {
      printf("                       MULTIGRID OUTPUTS\n");
    }
 
-   slave();
-   WAIT_FOR_END(nprocs-1)
+   CREATE(slave, nprocs);
+   WAIT_FOR_END(nprocs);
    CLOCK(computeend)
 
    printf("\n");
    printf("                       PROCESS STATISTICS\n");
    printf("                  Total          Multigrid         Multigrid\n");
    printf(" Proc             Time             Time            Fraction\n");
-   printf("    0   %15.0f    %15.0f        %10.3f\n",
-          gp[0].total_time,gp[0].multi_time,
-          gp[0].multi_time/gp[0].total_time);
+   printf("    0   %15.0f    %15.0f        %10.3f\n", gp[0].total_time,gp[0].multi_time, gp[0].multi_time/gp[0].total_time);
 
    if (do_stats) {
      min_total = max_total = avg_total = gp[0].total_time;
@@ -586,45 +516,32 @@
      avg_multi = avg_multi / nprocs;
      avg_frac = avg_frac / nprocs;
      for (i=1;i<nprocs;i++) {
-       printf("  %3d   %15.0f    %15.0f        %10.3f\n",
-	      i,gp[i].total_time,gp[i].multi_time,
-	      gp[i].multi_time/gp[i].total_time);
+       printf("  %3ld   %15.0f    %15.0f        %10.3f\n", i,gp[i].total_time,gp[i].multi_time, gp[i].multi_time/gp[i].total_time);
      }
-     printf("  Avg   %15.0f    %15.0f        %10.3f\n",
-            avg_total,avg_multi,avg_frac);
-     printf("  Min   %15.0f    %15.0f        %10.3f\n",
-            min_total,min_multi,min_frac);
-     printf("  Max   %15.0f    %15.0f        %10.3f\n",
-            max_total,max_multi,max_frac);
+     printf("  Avg   %15.0f    %15.0f        %10.3f\n", avg_total,avg_multi,avg_frac);
+     printf("  Min   %15.0f    %15.0f        %10.3f\n", min_total,min_multi,min_frac);
+     printf("  Max   %15.0f    %15.0f        %10.3f\n", max_total,max_multi,max_frac);
    }
    printf("\n");
 
    global->starttime = start;
    printf("                       TIMING INFORMATION\n");
-   printf("Start time                        : %16d\n",
-           global->starttime);
-   printf("Initialization finish time        : %16d\n",
-           global->trackstart);
-   printf("Overall finish time               : %16d\n",
-           computeend);
-   printf("Total time with initialization    : %16d\n",
-           computeend-global->starttime);
-   printf("Total time without initialization : %16d\n",
-           computeend-global->trackstart);
+   printf("Start time                        : %16lu\n", global->starttime);
+   printf("Initialization finish time        : %16lu\n", global->trackstart);
+   printf("Overall finish time               : %16lu\n", computeend);
+   printf("Total time with initialization    : %16lu\n", computeend-global->starttime);
+   printf("Total time without initialization : %16lu\n", computeend-global->trackstart);
    printf("    (excludes first timestep)\n");
    printf("\n");
 
    MAIN_END
 }
 
-int log_2(number)
-
-int number;
-
+long log_2(long number)
 {
-  int cumulative = 1;
-  int out = 0;
-  int done = 0;
+  long cumulative = 1;
+  long out = 0;
+  long done = 0;
 
   while ((cumulative < number) && (!done) && (out < 50)) {
     if (cumulative == number) {
@@ -642,10 +559,7 @@
   }
 }
 
-void printerr(s)
-
-char *s;
-
+void printerr(char *s)
 {
   fprintf(stderr,"ERROR: %s\n",s);
 }
diff -Naur splash2/codes/apps/ocean/contiguous_partitions/makefile splash2-modified/codes/apps/ocean/contiguous_partitions/makefile
--- splash2/codes/apps/ocean/contiguous_partitions/makefile	1994-10-12 00:31:26.000000000 -0400
+++ splash2-modified/codes/apps/ocean/contiguous_partitions/makefile	1969-12-31 19:00:00.000000000 -0500
@@ -1,39 +0,0 @@
-TARGET = OCEAN
-OBJS = main.o jacobcalc.o jacobcalc2.o laplacalc.o \
-	slave1.o slave2.o multi.o linkup.o subblock.o 
-CFLAGS = -O2 -Olimit 2000 -w 
-LDFLAGS = -lmpc -lm
-MACROS = ../../../null_macros/c.m4.null
-
-x = *
-
-$(TARGET): $(OBJS)
-	cc $(OBJS) -o $(TARGET) $(LDFLAGS)
-
-.SUFFIXES:
-.SUFFIXES:	.o .c .C .h .H
-
-.H.h: 
-	m4 ${MACROS} $*.H > $*.h
-
-.C.c: 
-	m4 $(MACROS) $*.C > $*.c
-
-.c.o: 
-	cc -c $(CFLAGS) $*.c
-
-.C.o: 
-	m4 $(MACROS) $*.C > $*.c
-	cc -c $(CFLAGS) $*.c
-
-decs.h: decs.H
-jacobcalc.c: decs.h
-linkup.c: decs.h
-slave1.c: decs.h
-jacobcalc2.c: decs.h
-main.c: decs.h
-slave2.c: decs.h
-laplacalc.c: decs.h
-multi.c: decs.h
-subblock.c: decs.h
-
diff -Naur splash2/codes/apps/ocean/contiguous_partitions/Makefile splash2-modified/codes/apps/ocean/contiguous_partitions/Makefile
--- splash2/codes/apps/ocean/contiguous_partitions/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ splash2-modified/codes/apps/ocean/contiguous_partitions/Makefile	2007-03-12 19:53:10.000000000 -0400
@@ -0,0 +1,16 @@
+TARGET = OCEAN
+OBJS = jacobcalc.o jacobcalc2.o laplacalc.o linkup.o main.o multi.o slave1.o slave2.o subblock.o
+
+include ../../../Makefile.config
+
+decs.h: decs.H
+jacobcalc.c: decs.h
+linkup.c: decs.h
+slave1.c: decs.h
+jacobcalc2.c: decs.h
+main.c: decs.h
+slave2.c: decs.h
+laplacalc.c: decs.h
+multi.c: decs.h
+subblock.c: decs.h
+
diff -Naur splash2/codes/apps/ocean/contiguous_partitions/multi.C splash2-modified/codes/apps/ocean/contiguous_partitions/multi.C
--- splash2/codes/apps/ocean/contiguous_partitions/multi.C	1994-10-15 00:06:23.000000000 -0400
+++ splash2-modified/codes/apps/ocean/contiguous_partitions/multi.C	2007-03-19 23:52:51.000000000 -0400
@@ -14,7 +14,7 @@
 /*                                                                       */
 /*************************************************************************/
 
-/* Shared memory implementation of the multigrid method 
+/* Shared memory implementation of the multigrid method
    Implementation uses red-black gauss-seidel relaxation
    iterations, w cycles, and the method of half-injection for
    residual computation. */
@@ -24,41 +24,25 @@
 #include <stdio.h>
 #include <math.h>
 #include <time.h>
+#include <stdlib.h>
 #include "decs.h"
 
-void multig(int);
-void relax(int,double *,int,int);
-void rescal(int,int);
-void intadd(int,int);
-void putz(int,int);
-void copy_borders(int,int);
-void copy_rhs_borders(int,int);
-void copy_red(int,int);
-void copy_black(int,int);
-void printerr(char *);
-
-void multig(my_id)
-
 /* perform multigrid (w cycles)                                     */
-
-int my_id;
-
+void multig(long my_id)
 {
-   int iter;
-   double wu; 
+   long iter;
+   double wu;
    double errp;
-   int m;
-   int flag1;
-   int flag2;
-   int k;
-   int my_num;
+   long m;
+   long flag1;
+   long flag2;
+   long k;
+   long my_num;
    double wmax;
    double local_err;
    double red_local_err;
    double black_local_err;
    double g_error;
-   int i;
-   int j;
 
    flag1 = 0;
    flag2 = 0;
@@ -79,15 +63,21 @@
 
 /* barrier to make sure all procs have finished intadd or rescal   */
 /* before proceeding with relaxation                               */
-
-     BARRIER(bars->error_barrier,nprocs)  
+#if defined(MULTIPLE_BARRIERS)
+     BARRIER(bars->error_barrier,nprocs)
+#else
+     BARRIER(bars->barrier,nprocs)
+#endif
      copy_black(k,my_num);
 
      relax(k,&red_local_err,RED_ITER,my_num);
 
 /* barrier to make sure all red computations have been performed   */
-
-     BARRIER(bars->error_barrier,nprocs)  
+#if defined(MULTIPLE_BARRIERS)
+     BARRIER(bars->error_barrier,nprocs)
+#else
+     BARRIER(bars->barrier,nprocs)
+#endif
      copy_red(k,my_num);
 
      relax(k,&black_local_err,BLACK_ITER,my_num);
@@ -114,15 +104,20 @@
      wu+=pow((double)4.0,(double)k-m);
 
 /* barrier to make sure all processors have checked local error    */
-
-     BARRIER(bars->error_barrier,nprocs)  
-
+#if defined(MULTIPLE_BARRIERS)
+     BARRIER(bars->error_barrier,nprocs)
+#else
+     BARRIER(bars->barrier,nprocs)
+#endif
      g_error = multi->err_multi;
 
 /* barrier to make sure master does not cycle back to top of loop  */
 /* and reset global->err before we read it and decide what to do   */
-
-     BARRIER(bars->error_barrier,nprocs)  
+#if defined(MULTIPLE_BARRIERS)
+     BARRIER(bars->error_barrier,nprocs)
+#else
+     BARRIER(bars->barrier,nprocs)
+#endif
 
      if (g_error >= lev_tol[k]) {
        if (wu > wmax) {
@@ -133,7 +128,7 @@
        } else {
 /* if we have not converged                                        */
          if ((k != 0) && (g_error/errp >= 0.6) &&
-	     (k > minlevel)) {  
+	     (k > minlevel)) {
 /* if need to go to coarser grid                                   */
 
            copy_borders(k,my_num);
@@ -144,7 +139,11 @@
    border points have been written before we try computing the new
    rescal values                                                   */
 
-           BARRIER(bars->error_barrier,nprocs)    
+#if defined(MULTIPLE_BARRIERS)
+	   BARRIER(bars->error_barrier,nprocs)
+#else
+	   BARRIER(bars->barrier,nprocs)
+#endif
 
            rescal(k,my_num);
 
@@ -176,30 +175,22 @@
    }
    if (do_output) {
      if (my_num == MASTER) {
-       printf("iter %d, level %d, residual norm %12.8e, work = %7.3f\n",
-               iter,k,multi->err_multi,wu);
+       printf("iter %ld, level %ld, residual norm %12.8e, work = %7.3f\n", iter,k,multi->err_multi,wu);
      }
    }
-}  
-
-void relax(k,err,color,my_num) 
-
-int k;
-double *err;
-int color;
-int my_num;
+}
 
 /* perform red or black iteration (not both)                    */
-
+void relax(long k, double *err, long color, long my_num)
 {
-   int i;
-   int j;
-   int iend;
-   int jend;
-   int oddistart;
-   int oddjstart;
-   int evenistart;
-   int evenjstart;
+   long i;
+   long j;
+   long iend;
+   long jend;
+   long oddistart;
+   long oddjstart;
+   long evenistart;
+   long evenjstart;
    double a;
    double h;
    double factor;
@@ -242,8 +233,8 @@
        t1c = (double *) t2a[i-1];
        t1d = (double *) t2a[i+1];
        for (j=evenjstart;j<jend;j+=2) {
-         a = t1a[j+1] + t1a[j-1] + 
-	     t1c[j] + t1d[j] - 
+         a = t1a[j+1] + t1a[j-1] +
+	     t1c[j] + t1d[j] -
 	     t1b[j] ;
          oldval = t1a[j];
          newval = a / factor;
@@ -260,8 +251,8 @@
        t1c = (double *) t2a[i-1];
        t1d = (double *) t2a[i+1];
        for (j=oddjstart;j<jend;j+=2) {
-         a = t1a[j+1] + t1a[j-1] + 
-	     t1c[j] + t1d[j] - 
+         a = t1a[j+1] + t1a[j-1] +
+	     t1c[j] + t1d[j] -
 	     t1b[j] ;
          oldval = t1a[j];
          newval = a / factor;
@@ -279,8 +270,8 @@
        t1c = (double *) t2a[i-1];
        t1d = (double *) t2a[i+1];
        for (j=oddjstart;j<jend;j+=2) {
-         a = t1a[j+1] + t1a[j-1] + 
-	     t1c[j] + t1d[j] - 
+         a = t1a[j+1] + t1a[j-1] +
+	     t1c[j] + t1d[j] -
 	     t1b[j] ;
          oldval = t1a[j];
          newval = a / factor;
@@ -297,8 +288,8 @@
        t1c = (double *) t2a[i-1];
        t1d = (double *) t2a[i+1];
        for (j=evenjstart;j<jend;j+=2) {
-         a = t1a[j+1] + t1a[j-1] + 
-	     t1c[j] + t1d[j] - 
+         a = t1a[j+1] + t1a[j-1] +
+	     t1c[j] + t1d[j] -
 	     t1b[j] ;
          oldval = t1a[j];
          newval = a / factor;
@@ -313,23 +304,18 @@
    *err = maxerr;
 }
 
-void rescal(kf,my_num)
-
 /* perform half-injection to next coarsest level                */
-
-int kf;
-int my_num;
-
+void rescal(long kf, long my_num)
 {
-   int ic;
-   int if17;
-   int jf;
-   int jc;
-   int krc;
-   int istart;
-   int iend;
-   int jstart;
-   int jend;
+   long ic;
+   long if17;
+   long jf;
+   long jc;
+   long krc;
+   long istart;
+   long iend;
+   long jstart;
+   long jend;
    double hf;
    double hc;
    double s;
@@ -338,18 +324,17 @@
    double s3;
    double s4;
    double factor;
-   double h;
    double int1;
    double int2;
    double i_int_factor;
    double j_int_factor;
    double int_val;
-   int i_off;
-   int j_off;
-   int up_proc;
-   int left_proc;
-   int im;
-   int jm;
+   long i_off;
+   long j_off;
+   long up_proc;
+   long left_proc;
+   long im;
+   long jm;
    double temp;
    double temp2;
    double **t2a;
@@ -384,7 +369,7 @@
    t2a = (double **) q_multi[my_num][kf];
    t2b = (double **) rhs_multi[my_num][kf];
    t2c = (double **) rhs_multi[my_num][krc];
-   if17=2*(istart-1);  
+   if17=2*(istart-1);
    for(ic=istart;ic<=iend;ic++) {
      if17+=2;
      i_int_factor = (ic+i_off) * i_int_coeff[krc] * 0.5;
@@ -405,8 +390,8 @@
 
 /* do bilinear interpolation */
        s = t1a[jf+1] + t1a[jf-1] + t1d[jf] + t1e[jf];
-       s1 = 2.0 * (t1b[jf] - s + factor * t1a[jf]); 
-       if (((if17 == 2) && (gp[my_num].neighbors[UP] == -1)) || 
+       s1 = 2.0 * (t1b[jf] - s + factor * t1a[jf]);
+       if (((if17 == 2) && (gp[my_num].neighbors[UP] == -1)) ||
 	   ((jf == 2) && (gp[my_num].neighbors[LEFT] == -1))) {
           s2 = 0;
           s3 = 0;
@@ -417,15 +402,15 @@
           } else {
             temp = t1a[jf-3];
           }
-          s = t1a[jf-1] + temp + t1d[jf-2] + t1e[jf-2];   
-          s2 = 2.0 * (t1b[jf-2] - s + factor * t1a[jf-2]);  
+          s = t1a[jf-1] + temp + t1d[jf-2] + t1e[jf-2];
+          s2 = 2.0 * (t1b[jf-2] - s + factor * t1a[jf-2]);
 	  if (if17 == 2) {
 	    temp = q_multi[up_proc][kf][im-1][jf];
           } else {
             temp = t1g[jf];
           }
           s = t1f[jf+1]+ t1f[jf-1]+ temp + t1d[jf];
-          s3 = 2.0 * (t1h[jf] - s + factor * t1f[jf]);   
+          s3 = 2.0 * (t1h[jf] - s + factor * t1f[jf]);
 	  if (jf == 2) {
 	    temp = q_multi[left_proc][kf][if17-2][jm-1];
           } else {
@@ -436,44 +421,36 @@
           } else {
             temp2 = t1g[jf-2];
           }
-          s = t1f[jf-1]+ temp + temp2 + t1d[jf-2];  
-          s4 = 2.0 * (t1h[jf-2] - s + factor * t1f[jf-2]); 
+          s = t1f[jf-1]+ temp + temp2 + t1d[jf-2];
+          s4 = 2.0 * (t1h[jf-2] - s + factor * t1f[jf-2]);
        } else {
-          s = t1a[jf-1] + t1a[jf-3] + t1d[jf-2] + t1e[jf-2];  
-          s2 = 2.0 * (t1b[jf-2] - s + factor * t1a[jf-2]);  
+          s = t1a[jf-1] + t1a[jf-3] + t1d[jf-2] + t1e[jf-2];
+          s2 = 2.0 * (t1b[jf-2] - s + factor * t1a[jf-2]);
           s = t1f[jf+1]+ t1f[jf-1]+ t1g[jf] +   t1d[jf];
-          s3 = 2.0 * (t1h[jf] - s + factor * t1f[jf]);   
-          s = t1f[jf-1]+ t1f[jf-3]+ t1g[jf-2]+ t1d[jf-2];  
-          s4 = 2.0 * (t1h[jf-2] - s + factor * t1f[jf-2]); 
+          s3 = 2.0 * (t1h[jf] - s + factor * t1f[jf]);
+          s = t1f[jf-1]+ t1f[jf-3]+ t1g[jf-2]+ t1d[jf-2];
+          s4 = 2.0 * (t1h[jf-2] - s + factor * t1f[jf-2]);
        }
        int1 = j_int_factor*s4 + (1.0-j_int_factor)*s3;
        int2 = j_int_factor*s2 + (1.0-j_int_factor)*s1;
        int_val = i_int_factor*int1+(1.0-i_int_factor)*int2;
-       t1c[jc] = i_int_factor*int1+(1.0-i_int_factor)*int2;  
+       t1c[jc] = i_int_factor*int1+(1.0-i_int_factor)*int2;
      }
    }
 }
 
-void intadd(kc,my_num)
-
 /* perform interpolation and addition to next finest grid       */
-
-int kc;
-int my_num;
-
+void intadd(long kc, long my_num)
 {
-   int ic;
-   int if17;
-   int jf;
-   int jc;
-   int i;
-   int kf;
-   int istart;
-   int jstart;
-   int iend;
-   int jend;
-   double a;
-   double am;
+   long ic;
+   long if17;
+   long jf;
+   long jc;
+   long kf;
+   long istart;
+   long jstart;
+   long iend;
+   long jend;
    double hc;
    double hf;
    double int1;
@@ -482,9 +459,8 @@
    double j_int_factor1;
    double i_int_factor2;
    double j_int_factor2;
-   double int_val;
-   int i_off;
-   int j_off;
+   long i_off;
+   long j_off;
    double **t2a;
    double **t2b;
    double *t1a;
@@ -506,12 +482,12 @@
 
    t2a = (double **) q_multi[my_num][kc];
    t2b = (double **) q_multi[my_num][kf];
-   if17 = 2*(istart-1);  
+   if17 = 2*(istart-1);
    for(ic=istart;ic<=iend;ic++) {
      if17+=2;
      i_int_factor1= ((imx[kc]-2)-(ic+i_off-1)) * (i_int_coeff[kf]);
      i_int_factor2= (ic+i_off) * i_int_coeff[kf];
-     jf = 2*(jstart-1); 
+     jf = 2*(jstart-1);
 
      t1a = (double *) t2a[ic];
      t1b = (double *) t2a[ic-1];
@@ -537,25 +513,20 @@
    }
 }
 
-void putz(k,my_num)
-
 /* initialize a grid to zero in parallel                        */
-
-int k;
-int my_num;
-
+void putz(long k, long my_num)
 {
-   int i;
-   int j;
-   int istart;
-   int jstart;
-   int iend;
-   int jend;
+   long i;
+   long j;
+   long istart;
+   long jstart;
+   long iend;
+   long jend;
    double **t2a;
    double *t1a;
 
    istart = gp[my_num].rlist[k];
-   jstart = gp[my_num].rljst[k];  
+   jstart = gp[my_num].rljst[k];
    iend = gp[my_num].rlien[k];
    jend = gp[my_num].rljen[k];
 
@@ -568,19 +539,15 @@
    }
 }
 
-void copy_borders(k,pid)
-
-int k;
-int pid;
-
+void copy_borders(long k, long pid)
 {
-  int i;
-  int j;
-  int jj;
-  int im;
-  int jm;
-  int lastrow;
-  int lastcol;
+  long i;
+  long j;
+  long jj;
+  long im;
+  long jm;
+  long lastrow;
+  long lastcol;
   double **t2a;
   double **t2b;
   double *t1a;
@@ -700,18 +667,14 @@
 
 }
 
-void copy_rhs_borders(k,procid)
-
-int k;
-int procid;
-
+void copy_rhs_borders(long k, long procid)
 {
-   int i;
-   int j;
-   int im;
-   int jm;
-   int lastrow;
-   int lastcol;
+   long i;
+   long j;
+   long im;
+   long jm;
+   long lastrow;
+   long lastcol;
    double **t2a;
    double **t2b;
    double *t1a;
@@ -721,7 +684,7 @@
    jm = (jmx[k]-2)/xprocs+2;
    lastrow = (imx[k]-2)/yprocs;
    lastcol = (jmx[k]-2)/xprocs;
-  
+
    t2a = (double **) rhs_multi[procid][k];
    if (gp[procid].neighbors[UPLEFT] != -1) {
      j = gp[procid].neighbors[UPLEFT];
@@ -749,18 +712,14 @@
    }
 }
 
-void copy_red(k,procid)
-
-int k;
-int procid;
-
+void copy_red(long k, long procid)
 {
-   int i;
-   int j;
-   int im;
-   int jm;
-   int lastrow;
-   int lastcol;
+   long i;
+   long j;
+   long im;
+   long jm;
+   long lastrow;
+   long lastcol;
    double **t2a;
    double **t2b;
    double *t1a;
@@ -804,18 +763,14 @@
    }
 }
 
-void copy_black(k,procid)
-
-int k;
-int procid;
-
+void copy_black(long k, long procid)
 {
-   int i;
-   int j;
-   int im;
-   int jm;
-   int lastrow;
-   int lastcol;
+   long i;
+   long j;
+   long im;
+   long jm;
+   long lastrow;
+   long lastcol;
    double **t2a;
    double **t2b;
    double *t1a;
diff -Naur splash2/codes/apps/ocean/contiguous_partitions/slave1.C splash2-modified/codes/apps/ocean/contiguous_partitions/slave1.C
--- splash2/codes/apps/ocean/contiguous_partitions/slave1.C	1994-10-15 00:06:23.000000000 -0400
+++ splash2-modified/codes/apps/ocean/contiguous_partitions/slave1.C	2007-03-19 23:58:52.000000000 -0400
@@ -17,56 +17,55 @@
 /*    ****************
       subroutine slave
       ****************  */
-     
+
 EXTERN_ENV
 
 #include <stdio.h>
 #include <math.h>
 #include <time.h>
+#include <stdlib.h>
 #include "decs.h"
 
-void slave() 
-
+void slave()
 {
-   int i;
-   int j;
-   int nstep;
-   int iindex;
-   int iday;
+   long i;
+   long j;
+   long nstep;
+   long iindex;
+   long iday;
    double ysca1;
    double y;
    double factor;
    double sintemp;
    double curlt;
    double ressqr;
-   int istart; 
-   int iend; 
-   int jstart; 
-   int jend;
-   int ist; 
-   int ien; 
-   int jst; 
-   int jen;
+   long istart;
+   long iend;
+   long jstart;
+   long jend;
+   long ist;
+   long ien;
+   long jst;
+   long jen;
    double fac;
-   int dayflag=0;
-   int dhourflag=0;
-   int endflag=0;
-   int firstrow;
-   int lastrow;
-   int numrows;
-   int firstcol;
-   int lastcol;
-   int numcols;
-   int psiindex;
+   long dayflag=0;
+   long dhourflag=0;
+   long endflag=0;
+   long firstrow;
+   long lastrow;
+   long numrows;
+   long firstcol;
+   long lastcol;
+   long numcols;
+   long psiindex;
    double psibipriv;
    double ttime;
    double dhour;
    double day;
-   int procid;
-   int psinum;
-   int i_off = 0;
-   int j_off = 0;
-   unsigned int t1;
+   long procid;
+   long psinum;
+   long j_off = 0;
+   unsigned long t1;
    double **t2a;
    double **t2b;
    double *t1a;
@@ -79,24 +78,27 @@
    LOCK(locks->idlock)
      procid = global->id;
      global->id = global->id+1;
-   UNLOCK(locks->idlock)     
+   UNLOCK(locks->idlock)
 
+#if defined(MULTIPLE_BARRIERS)
    BARRIER(bars->sl_prini,nprocs)
-
+#else
+   BARRIER(bars->barrier,nprocs)
+#endif
 /* POSSIBLE ENHANCEMENT:  Here is where one might pin processes to
    processors to avoid migration. */
 
-/* POSSIBLE ENHANCEMENT:  Here is where one might distribute 
+/* POSSIBLE ENHANCEMENT:  Here is where one might distribute
    data structures across physically distributed memories as
    desired.
-   
+
    One way to do this is as follows.  The function allocate(START,SIZE,I)
-   is assumed to place all addresses x such that 
+   is assumed to place all addresses x such that
    (START <= x < START+SIZE) on node I.
 
-   int d_size;
-   unsigned int g_size;
-   unsigned int mg_size;
+   long d_size;
+   unsigned long g_size;
+   unsigned long mg_size;
 
    if (procid == MASTER) {
      g_size = ((jmx[numlev-1]-2)/xprocs+2)*((imx[numlev-1]-2)/yprocs+2)*siz
@@ -110,53 +112,53 @@
      }
      for (i= 0;i<nprocs;i++) {
        d_size = 2*sizeof(double **);
-       allocate((unsigned int) psi[i],d_size,i);
-       allocate((unsigned int) psim[i],d_size,i);
-       allocate((unsigned int) work1[i],d_size,i);
-       allocate((unsigned int) work4[i],d_size,i);
-       allocate((unsigned int) work5[i],d_size,i);
-       allocate((unsigned int) work7[i],d_size,i);
-       allocate((unsigned int) temparray[i],d_size,i);
-       allocate((unsigned int) psi[i][0],g_size,i);
-       allocate((unsigned int) psi[i][1],g_size,i);
-       allocate((unsigned int) psim[i][0],g_size,i);
-       allocate((unsigned int) psim[i][1],g_size,i);
-       allocate((unsigned int) psium[i],g_size,i);
-       allocate((unsigned int) psilm[i],g_size,i);
-       allocate((unsigned int) psib[i],g_size,i);
-       allocate((unsigned int) ga[i],g_size,i);
-       allocate((unsigned int) gb[i],g_size,i);
-       allocate((unsigned int) work1[i][0],g_size,i);
-       allocate((unsigned int) work1[i][1],g_size,i);
-       allocate((unsigned int) work2[i],g_size,i);
-       allocate((unsigned int) work3[i],g_size,i);
-       allocate((unsigned int) work4[i][0],g_size,i);
-       allocate((unsigned int) work4[i][1],g_size,i);
-       allocate((unsigned int) work5[i][0],g_size,i);
-       allocate((unsigned int) work5[i][1],g_size,i);
-       allocate((unsigned int) work6[i],g_size,i);
-       allocate((unsigned int) work7[i][0],g_size,i);
-       allocate((unsigned int) work7[i][1],g_size,i);
-       allocate((unsigned int) temparray[i][0],g_size,i);
-       allocate((unsigned int) temparray[i][1],g_size,i);
-       allocate((unsigned int) tauz[i],g_size,i);
-       allocate((unsigned int) oldga[i],g_size,i);
-       allocate((unsigned int) oldgb[i],g_size,i);
-       d_size = numlev * sizeof(int);
-       allocate((unsigned int) gp[i].rel_num_x,d_size,i);
-       allocate((unsigned int) gp[i].rel_num_y,d_size,i);
-       allocate((unsigned int) gp[i].eist,d_size,i);
-       allocate((unsigned int) gp[i].ejst,d_size,i);
-       allocate((unsigned int) gp[i].oist,d_size,i);
-       allocate((unsigned int) gp[i].ojst,d_size,i);
-       allocate((unsigned int) gp[i].rlist,d_size,i);
-       allocate((unsigned int) gp[i].rljst,d_size,i);
-       allocate((unsigned int) gp[i].rlien,d_size,i);
-       allocate((unsigned int) gp[i].rljen,d_size,i);
-
-       allocate((unsigned int) q_multi[i],mg_size,i);
-       allocate((unsigned int) rhs_multi[i],mg_size,i);
-       allocate((unsigned int) &(gp[i]),sizeof(struct Global_Private),i);
+       allocate((unsigned long) psi[i],d_size,i);
+       allocate((unsigned long) psim[i],d_size,i);
+       allocate((unsigned long) work1[i],d_size,i);
+       allocate((unsigned long) work4[i],d_size,i);
+       allocate((unsigned long) work5[i],d_size,i);
+       allocate((unsigned long) work7[i],d_size,i);
+       allocate((unsigned long) temparray[i],d_size,i);
+       allocate((unsigned long) psi[i][0],g_size,i);
+       allocate((unsigned long) psi[i][1],g_size,i);
+       allocate((unsigned long) psim[i][0],g_size,i);
+       allocate((unsigned long) psim[i][1],g_size,i);
+       allocate((unsigned long) psium[i],g_size,i);
+       allocate((unsigned long) psilm[i],g_size,i);
+       allocate((unsigned long) psib[i],g_size,i);
+       allocate((unsigned long) ga[i],g_size,i);
+       allocate((unsigned long) gb[i],g_size,i);
+       allocate((unsigned long) work1[i][0],g_size,i);
+       allocate((unsigned long) work1[i][1],g_size,i);
+       allocate((unsigned long) work2[i],g_size,i);
+       allocate((unsigned long) work3[i],g_size,i);
+       allocate((unsigned long) work4[i][0],g_size,i);
+       allocate((unsigned long) work4[i][1],g_size,i);
+       allocate((unsigned long) work5[i][0],g_size,i);
+       allocate((unsigned long) work5[i][1],g_size,i);
+       allocate((unsigned long) work6[i],g_size,i);
+       allocate((unsigned long) work7[i][0],g_size,i);
+       allocate((unsigned long) work7[i][1],g_size,i);
+       allocate((unsigned long) temparray[i][0],g_size,i);
+       allocate((unsigned long) temparray[i][1],g_size,i);
+       allocate((unsigned long) tauz[i],g_size,i);
+       allocate((unsigned long) oldga[i],g_size,i);
+       allocate((unsigned long) oldgb[i],g_size,i);
+       d_size = numlev * sizeof(long);
+       allocate((unsigned long) gp[i].rel_num_x,d_size,i);
+       allocate((unsigned long) gp[i].rel_num_y,d_size,i);
+       allocate((unsigned long) gp[i].eist,d_size,i);
+       allocate((unsigned long) gp[i].ejst,d_size,i);
+       allocate((unsigned long) gp[i].oist,d_size,i);
+       allocate((unsigned long) gp[i].ojst,d_size,i);
+       allocate((unsigned long) gp[i].rlist,d_size,i);
+       allocate((unsigned long) gp[i].rljst,d_size,i);
+       allocate((unsigned long) gp[i].rlien,d_size,i);
+       allocate((unsigned long) gp[i].rljen,d_size,i);
+
+       allocate((unsigned long) q_multi[i],mg_size,i);
+       allocate((unsigned long) rhs_multi[i],mg_size,i);
+       allocate((unsigned long) &(gp[i]),sizeof(struct Global_Private),i);
      }
    }
 
@@ -176,7 +178,7 @@
    firstcol = 1;
    lastcol = firstcol + gp[procid].rel_num_x[numlev-1] - 1;
    firstrow = 1;
-   lastrow = firstrow + gp[procid].rel_num_y[numlev-1] - 1;  
+   lastrow = firstrow + gp[procid].rel_num_y[numlev-1] - 1;
    numcols = gp[procid].rel_num_x[numlev-1];
    numrows = gp[procid].rel_num_y[numlev-1];
    j_off = gp[procid].colnum*numcols;
@@ -206,16 +208,16 @@
    }
 
    t2a = (double **) psium[procid];
-   if ((gp[procid].neighbors[UP] == -1) && (gp[procid].neighbors[LEFT] == -1)) {  
+   if ((gp[procid].neighbors[UP] == -1) && (gp[procid].neighbors[LEFT] == -1)) {
      t2a[0][0]=0.0;
-   }  
-   if ((gp[procid].neighbors[DOWN] == -1) && (gp[procid].neighbors[LEFT] == -1)) {  
+   }
+   if ((gp[procid].neighbors[DOWN] == -1) && (gp[procid].neighbors[LEFT] == -1)) {
      t2a[im-1][0]=0.0;
    }
-   if ((gp[procid].neighbors[UP] == -1) && (gp[procid].neighbors[RIGHT] == -1)) {  
+   if ((gp[procid].neighbors[UP] == -1) && (gp[procid].neighbors[RIGHT] == -1)) {
      t2a[0][jm-1]=0.0;
    }
-   if ((gp[procid].neighbors[DOWN] == -1) && (gp[procid].neighbors[RIGHT] == -1)) {  
+   if ((gp[procid].neighbors[DOWN] == -1) && (gp[procid].neighbors[RIGHT] == -1)) {
      t2a[im-1][jm-1]=0.0;
    }
    if (gp[procid].neighbors[UP] == -1) {
@@ -240,7 +242,7 @@
        t2a[j][jm-1] = 0.0;
      }
    }
-   
+
    for(i=firstrow;i<=lastrow;i++) {
      t1a = (double *) t2a[i];
      for(iindex=firstcol;iindex<=lastcol;iindex++) {
@@ -248,16 +250,16 @@
      }
    }
    t2a = (double **) psilm[procid];
-   if ((gp[procid].neighbors[UP] == -1) && (gp[procid].neighbors[LEFT] == -1)) {  
+   if ((gp[procid].neighbors[UP] == -1) && (gp[procid].neighbors[LEFT] == -1)) {
      t2a[0][0]=0.0;
    }
-   if ((gp[procid].neighbors[DOWN] == -1) && (gp[procid].neighbors[LEFT] == -1)) {  
+   if ((gp[procid].neighbors[DOWN] == -1) && (gp[procid].neighbors[LEFT] == -1)) {
      t2a[im-1][0]=0.0;
    }
-   if ((gp[procid].neighbors[UP] == -1) && (gp[procid].neighbors[RIGHT] == -1)) {  
+   if ((gp[procid].neighbors[UP] == -1) && (gp[procid].neighbors[RIGHT] == -1)) {
      t2a[0][jm-1]=0.0;
    }
-   if ((gp[procid].neighbors[DOWN] == -1) && (gp[procid].neighbors[RIGHT] == -1)) {  
+   if ((gp[procid].neighbors[DOWN] == -1) && (gp[procid].neighbors[RIGHT] == -1)) {
      t2a[im-1][jm-1]=0.0;
    }
    if (gp[procid].neighbors[UP] == -1) {
@@ -290,16 +292,16 @@
    }
 
    t2a = (double **) psib[procid];
-   if ((gp[procid].neighbors[UP] == -1) && (gp[procid].neighbors[LEFT] == -1)) {  
+   if ((gp[procid].neighbors[UP] == -1) && (gp[procid].neighbors[LEFT] == -1)) {
      t2a[0][0]=1.0;
    }
-   if ((gp[procid].neighbors[UP] == -1) && (gp[procid].neighbors[RIGHT] == -1)) {  
+   if ((gp[procid].neighbors[UP] == -1) && (gp[procid].neighbors[RIGHT] == -1)) {
      t2a[0][jm-1]=1.0;
    }
-   if ((gp[procid].neighbors[DOWN] == -1) && (gp[procid].neighbors[LEFT] == -1)) {  
+   if ((gp[procid].neighbors[DOWN] == -1) && (gp[procid].neighbors[LEFT] == -1)) {
      t2a[im-1][0]=1.0;
    }
-   if ((gp[procid].neighbors[DOWN] == -1) && (gp[procid].neighbors[RIGHT] == -1)) {  
+   if ((gp[procid].neighbors[DOWN] == -1) && (gp[procid].neighbors[RIGHT] == -1)) {
      t2a[im-1][jm-1]=1.0;
    }
    if (gp[procid].neighbors[UP] == -1) {
@@ -332,20 +334,22 @@
    }
 
 /* wait until all processes have completed the above initialization  */
-
+#if defined(MULTIPLE_BARRIERS)
    BARRIER(bars->sl_prini,nprocs)
- 
+#else
+   BARRIER(bars->barrier,nprocs)
+#endif
 /* compute psib array (one-time computation) and integrate into psibi */
- 
+
    istart = 1;
    iend = istart + gp[procid].rel_num_y[numlev-1] - 1;
    jstart = 1;
-   jend = jstart + gp[procid].rel_num_x[numlev-1] - 1;    
+   jend = jstart + gp[procid].rel_num_x[numlev-1] - 1;
    ist = istart;
    ien = iend;
    jst = jstart;
-   jen = jend;  
-   
+   jen = jend;
+
    if (gp[procid].neighbors[UP] == -1) {
      istart = 0;
    }
@@ -353,10 +357,10 @@
      jstart = 0;
    }
    if (gp[procid].neighbors[DOWN] == -1) {
-     iend = im-1;   
+     iend = im-1;
    }
    if (gp[procid].neighbors[RIGHT] == -1) {
-     jend = jm-1;    
+     jend = jm-1;
    }
 
    t2a = (double **) rhs_multi[procid][numlev-1];
@@ -367,7 +371,7 @@
      for(j=jstart;j<=jend;j++) {
        t1a[j] = t1b[j] * ressqr;
      }
-   }  
+   }
    t2a = (double **) q_multi[procid][numlev-1];
    if (gp[procid].neighbors[UP] == -1) {
      t1a = (double *) t2a[0];
@@ -393,9 +397,11 @@
        t2a[i][jm-1] = t2b[i][jm-1];
      }
    }
-   
-   BARRIER(bars->sl_psini,nprocs) 
-
+#if defined(MULTIPLE_BARRIERS)
+   BARRIER(bars->sl_psini,nprocs)
+#else
+   BARRIER(bars->barrier,nprocs)
+#endif
    t2a = (double **) psib[procid];
    j = gp[procid].neighbors[UP];
    if (j != -1) {
@@ -426,7 +432,7 @@
      for (i=1;i<im-1;i++) {
        t2a[i][jm-1] = t2b[i][1];
      }
-   }  
+   }
 
    t2a = (double **) q_multi[procid][numlev-1];
    t2b = (double **) psib[procid];
@@ -437,11 +443,11 @@
      t1c = (double *) t2b[i-1];
      t1d = (double *) t2b[i+1];
      for(j=jst;j<=jen;j++) {
-       t1a[j] = fac * (t1d[j]+t1c[j]+t1b[j+1]+t1b[j-1] - 
+       t1a[j] = fac * (t1d[j]+t1c[j]+t1b[j+1]+t1b[j-1] -
                    ressqr*t1b[j]);
      }
    }
-   
+
    multig(procid);
 
    for(i=istart;i<=iend;i++) {
@@ -451,24 +457,26 @@
        t1b[j] = t1a[j];
      }
    }
-
+#if defined(MULTIPLE_BARRIERS)
    BARRIER(bars->sl_prini,nprocs)
-
+#else
+   BARRIER(bars->barrier,nprocs)
+#endif
 /* update the local running sum psibipriv by summing all the resulting
    values in that process's share of the psib matrix   */
 
    t2a = (double **) psib[procid];
    psibipriv=0.0;
-   if ((gp[procid].neighbors[UP] == -1) && (gp[procid].neighbors[LEFT] == -1)) {  
+   if ((gp[procid].neighbors[UP] == -1) && (gp[procid].neighbors[LEFT] == -1)) {
      psibipriv = psibipriv + 0.25*(t2a[0][0]);
    }
-   if ((gp[procid].neighbors[UP] == -1) && (gp[procid].neighbors[RIGHT] == -1)) {  
+   if ((gp[procid].neighbors[UP] == -1) && (gp[procid].neighbors[RIGHT] == -1)) {
      psibipriv = psibipriv + 0.25*(t2a[0][jm-1]);
    }
-   if ((gp[procid].neighbors[DOWN] == -1) && (gp[procid].neighbors[LEFT] == -1)) {  
+   if ((gp[procid].neighbors[DOWN] == -1) && (gp[procid].neighbors[LEFT] == -1)) {
      psibipriv=psibipriv+0.25*(t2a[im-1][0]);
    }
-   if ((gp[procid].neighbors[DOWN] == -1) && (gp[procid].neighbors[RIGHT] == -1)) {  
+   if ((gp[procid].neighbors[DOWN] == -1) && (gp[procid].neighbors[RIGHT] == -1)) {
      psibipriv=psibipriv+0.25*(t2a[im-1][jm-1]);
    }
    if (gp[procid].neighbors[UP] == -1) {
@@ -498,11 +506,11 @@
      for(iindex=firstcol;iindex<=lastcol;iindex++) {
        psibipriv = psibipriv + t1a[iindex];
      }
-   } 
+   }
 
 /* update the shared variable psibi by summing all the psibiprivs
    of the individual processes into it.  note that this combined
-   private and shared sum method avoids accessing the shared 
+   private and shared sum method avoids accessing the shared
    variable psibi once for every element of the matrix.  */
 
    LOCK(locks->psibilock)
@@ -510,20 +518,20 @@
    UNLOCK(locks->psibilock)
 
 /* initialize psim matrices
-   
+
    if there is more than one process, then split the processes
    between the two psim matrices; otherwise, let the single process
    work on one first and then the other   */
 
    for(psiindex=0;psiindex<=1;psiindex++) {
      t2a = (double **) psim[procid][psiindex];
-     if ((gp[procid].neighbors[UP] == -1) && (gp[procid].neighbors[LEFT] == -1)) {  
+     if ((gp[procid].neighbors[UP] == -1) && (gp[procid].neighbors[LEFT] == -1)) {
        t2a[0][0] = 0.0;
      }
-     if ((gp[procid].neighbors[DOWN] == -1) && (gp[procid].neighbors[LEFT] == -1)) {  
+     if ((gp[procid].neighbors[DOWN] == -1) && (gp[procid].neighbors[LEFT] == -1)) {
        t2a[im-1][0] = 0.0;
      }
-     if ((gp[procid].neighbors[UP] == -1) && (gp[procid].neighbors[RIGHT] == -1)) {  
+     if ((gp[procid].neighbors[UP] == -1) && (gp[procid].neighbors[RIGHT] == -1)) {
        t2a[0][jm-1] = 0.0;
      }
      if ((gp[procid].neighbors[DOWN] == -1) && (gp[procid].neighbors[RIGHT] == -1)) {
@@ -558,18 +566,18 @@
        }
      }
    }
- 
+
 /* initialize psi matrices the same way  */
 
    for(psiindex=0;psiindex<=1;psiindex++) {
      t2a = (double **) psi[procid][psiindex];
-     if ((gp[procid].neighbors[UP] == -1) && (gp[procid].neighbors[LEFT] == -1)) {  
+     if ((gp[procid].neighbors[UP] == -1) && (gp[procid].neighbors[LEFT] == -1)) {
        t2a[0][0] = 0.0;
      }
-     if ((gp[procid].neighbors[UP] == -1) && (gp[procid].neighbors[RIGHT] == -1)) {  
+     if ((gp[procid].neighbors[UP] == -1) && (gp[procid].neighbors[RIGHT] == -1)) {
        t2a[0][jm-1] = 0.0;
      }
-     if ((gp[procid].neighbors[DOWN] == -1) && (gp[procid].neighbors[LEFT] == -1)) {  
+     if ((gp[procid].neighbors[DOWN] == -1) && (gp[procid].neighbors[LEFT] == -1)) {
        t2a[im-1][0] = 0.0;
      }
      if ((gp[procid].neighbors[DOWN] == -1) && (gp[procid].neighbors[RIGHT] == -1)) {
@@ -610,18 +618,18 @@
    t2a = (double **) tauz[procid];
    ysca1 = .5*ysca;
    factor= -t0*pi/ysca1;
-   if ((gp[procid].neighbors[UP] == -1) && (gp[procid].neighbors[LEFT] == -1)) {  
+   if ((gp[procid].neighbors[UP] == -1) && (gp[procid].neighbors[LEFT] == -1)) {
      t2a[0][0] = 0.0;
    }
-   if ((gp[procid].neighbors[DOWN] == -1) && (gp[procid].neighbors[LEFT] == -1)) {  
+   if ((gp[procid].neighbors[DOWN] == -1) && (gp[procid].neighbors[LEFT] == -1)) {
      t2a[im-1][0] = 0.0;
    }
-   if ((gp[procid].neighbors[UP] == -1) && (gp[procid].neighbors[RIGHT] == -1)) {  
+   if ((gp[procid].neighbors[UP] == -1) && (gp[procid].neighbors[RIGHT] == -1)) {
      sintemp = pi*((double) jm-1+j_off)*res/ysca1;
      sintemp = sin(sintemp);
      t2a[0][jm-1] = factor*sintemp;
    }
-   if ((gp[procid].neighbors[DOWN] == -1) && (gp[procid].neighbors[RIGHT] == -1)) {  
+   if ((gp[procid].neighbors[DOWN] == -1) && (gp[procid].neighbors[RIGHT] == -1)) {
      sintemp = pi*((double) jm-1+j_off)*res/ysca1;
      sintemp = sin(sintemp);
      t2a[im-1][jm-1] = factor*sintemp;
@@ -665,11 +673,13 @@
        curlt = factor*sintemp;
        t1a[iindex] = curlt;
      }
-   }  
-   
+   }
+#if defined(MULTIPLE_BARRIERS)
    BARRIER(bars->sl_onetime,nprocs)
-   
-   
+#else
+   BARRIER(bars->barrier,nprocs)
+#endif
+
 /***************************************************************
  one-time stuff over at this point
  ***************************************************************/
@@ -700,10 +710,10 @@
        ttime = ttime + dtau;
        nstep = nstep + 1;
        day = ttime/86400.0;
- 
+
        if (day > ((double) outday0)) {
          dayflag = 1;
-         iday = (int) day;
+         iday = (long) day;
          dhour = dhour+dtau;
          if (dhour >= 86400.0) {
 	   dhourflag = 1;
@@ -714,13 +724,13 @@
 
      t2a = (double **) psium[procid];
      t2b = (double **) psim[procid][0];
-     if ((gp[procid].neighbors[UP] == -1) && (gp[procid].neighbors[LEFT] == -1)) {  
+     if ((gp[procid].neighbors[UP] == -1) && (gp[procid].neighbors[LEFT] == -1)) {
        t2a[0][0] = t2a[0][0]+t2b[0][0];
      }
-     if ((gp[procid].neighbors[DOWN] == -1) && (gp[procid].neighbors[LEFT] == -1)) {  
+     if ((gp[procid].neighbors[DOWN] == -1) && (gp[procid].neighbors[LEFT] == -1)) {
        t2a[im-1][0] = t2a[im-1][0]+t2b[im-1][0];
      }
-     if ((gp[procid].neighbors[UP] == -1) && (gp[procid].neighbors[RIGHT] == -1)) {  
+     if ((gp[procid].neighbors[UP] == -1) && (gp[procid].neighbors[RIGHT] == -1)) {
        t2a[0][jm-1] = t2a[0][jm-1]+t2b[0][jm-1];
      }
      if ((gp[procid].neighbors[DOWN] == -1) && (gp[procid].neighbors[RIGHT] == -1)) {
@@ -759,18 +769,18 @@
          t1a[iindex] = t1a[iindex] + t1b[iindex];
        }
      }
-     
+
 /* update values of psilm array to psilm + psim[2]  */
-     
+
      t2a = (double **) psilm[procid];
      t2b = (double **) psim[procid][1];
-     if ((gp[procid].neighbors[UP] == -1) && (gp[procid].neighbors[LEFT] == -1)) {  
+     if ((gp[procid].neighbors[UP] == -1) && (gp[procid].neighbors[LEFT] == -1)) {
        t2a[0][0] = t2a[0][0]+t2b[0][0];
      }
-     if ((gp[procid].neighbors[DOWN] == -1) && (gp[procid].neighbors[LEFT] == -1)) {  
+     if ((gp[procid].neighbors[DOWN] == -1) && (gp[procid].neighbors[LEFT] == -1)) {
        t2a[im-1][0] = t2a[im-1][0]+t2b[im-1][0];
      }
-     if ((gp[procid].neighbors[UP] == -1) && (gp[procid].neighbors[RIGHT] == -1)) {  
+     if ((gp[procid].neighbors[UP] == -1) && (gp[procid].neighbors[RIGHT] == -1)) {
        t2a[0][jm-1] = t2a[0][jm-1]+t2b[0][jm-1];
      }
      if ((gp[procid].neighbors[DOWN] == -1) && (gp[procid].neighbors[RIGHT] == -1)) {
@@ -808,7 +818,7 @@
          t1a[iindex] = t1a[iindex] + t1b[iindex];
        }
      }
-     if (iday >= (int) outday3) {
+     if (iday >= (long) outday3) {
        endflag = 1;
      }
   }
diff -Naur splash2/codes/apps/ocean/contiguous_partitions/slave2.C splash2-modified/codes/apps/ocean/contiguous_partitions/slave2.C
--- splash2/codes/apps/ocean/contiguous_partitions/slave2.C	1994-10-21 18:40:17.000000000 -0400
+++ splash2-modified/codes/apps/ocean/contiguous_partitions/slave2.C	2007-03-19 23:59:23.000000000 -0400
@@ -23,51 +23,36 @@
 #include <stdio.h>
 #include <math.h>
 #include <time.h>
-#include "decs.h" 
-
-void slave2(procid,firstrow,lastrow,numrows,firstcol,lastcol,numcols)
-
-int procid;
-int firstrow;
-int lastrow;
-int numrows;
-int firstcol;
-int lastcol;
-int numcols;
+#include <stdlib.h>
+#include "decs.h"
 
+void slave2(long procid, long firstrow, long lastrow, long numrows, long firstcol, long lastcol, long numcols)
 {
-   int i;
-   int j;
-   int nstep;
-   int iindex;
-   int iday;
-   double ysca1;
-   double y;
-   double factor;
-   double sintemp;
-   double curlt;
+   long i;
+   long j;
+   long iindex;
    double hh1;
    double hh3;
    double hinv;
    double h1inv;
-   int istart; 
-   int iend; 
-   int jstart; 
-   int jend;
-   int ist; 
-   int ien; 
-   int jst; 
-   int jen;
+   long istart;
+   long iend;
+   long jstart;
+   long jend;
+   long ist;
+   long ien;
+   long jst;
+   long jen;
    double fac;
    double ressqr;
    double psiaipriv;
    double f4;
    double timst;
-   int psiindex;
-   int i_off;
-   int j_off;
-   int multi_start;
-   int multi_end;
+   long psiindex;
+   long i_off;
+   long j_off;
+   long multi_start;
+   long multi_end;
    double **t2a;
    double **t2b;
    double **t2c;
@@ -179,7 +164,7 @@
      }
    }
 
-/* put the laplacian of psi{1,3} in work1{1,2} 
+/* put the laplacian of psi{1,3} in work1{1,2}
    note that psi(i,j,2) represents the psi3 array in
    the original equations  */
 
@@ -200,7 +185,7 @@
      laplacalc(procid,psi,work1,psiindex,
 	       firstrow,lastrow,firstcol,lastcol);
    }
- 
+
 /* set values of work2 array to psi1 - psi3   */
 
    t2a = (double **) work2[procid];
@@ -253,7 +238,7 @@
          t1a[iindex] = t1b[iindex] - t1c[iindex];
      }
    }
- 
+
 /* set values of work3 array to h3/h * psi1 + h1/h * psi3  */
 
    t2a = (double **) work3[procid];
@@ -350,9 +335,11 @@
        }
      }
    }
-
+#if defined(MULTIPLE_BARRIERS)
    BARRIER(bars->sl_phase_1,nprocs)
-
+#else
+   BARRIER(bars->barrier,nprocs)
+#endif
 /*     *******************************************************
 
               s e c o n d   p h a s e
@@ -406,7 +393,7 @@
      }
    }
 
-/* put the laplacian of the psim array 
+/* put the laplacian of the psim array
    into the work7 array; first part of a three-laplacian
    calculation to compute the friction terms  */
 
@@ -430,7 +417,7 @@
 
 /* to the values of the work1{1,2} arrays obtained from the
    laplacians of psi{1,2} in the previous phase, add to the
-   elements of every column the corresponding value in the 
+   elements of every column the corresponding value in the
    one-dimenional f array  */
 
    for(psiindex=0;psiindex<=1;psiindex++) {
@@ -474,18 +461,20 @@
        }
      }
    }
-
+#if defined(MULTIPLE_BARRIERS)
    BARRIER(bars->sl_phase_2,nprocs)
-
+#else
+   BARRIER(bars->barrier,nprocs)
+#endif
 /* 	*******************************************************
 
                  t h i r d   p h a s e
- 
+
  	*******************************************************
 
    put the jacobian of the work1{1,2} and psi{1,3} arrays
    (the latter currently in temparray) in the work5{1,2} arrays  */
-     
+
    for(psiindex=0;psiindex<=1;psiindex++) {
      jacobcalc2(work1,temparray,work5,psiindex,procid,firstrow,lastrow,
 	       firstcol,lastcol);
@@ -548,9 +537,11 @@
      laplacalc(procid,work7,work4,psiindex,
 	       firstrow,lastrow,firstcol,lastcol);
    }
-
+#if defined(MULTIPLE_BARRIERS)
    BARRIER(bars->sl_phase_3,nprocs)
-
+#else
+   BARRIER(bars->barrier,nprocs)
+#endif
 /*     *******************************************************
 
                 f o u r t h   p h a s e
@@ -568,10 +559,12 @@
    for(psiindex=0;psiindex<=1;psiindex++) {
      laplacalc(procid,work4,work7,psiindex,
 	       firstrow,lastrow,firstcol,lastcol);
-   } 
-
+   }
+#if defined(MULTIPLE_BARRIERS)
    BARRIER(bars->sl_phase_4,nprocs)
-
+#else
+   BARRIER(bars->barrier,nprocs)
+#endif
 /*     *******************************************************
 
                 f i f t h   p h a s e
@@ -581,7 +574,7 @@
    use the values of the work5, work6 and work7 arrays
    computed in the previous time-steps to compute the
    ga and gb arrays   */
-   
+
    hinv = 1.0/h;
    h1inv = 1.0/h1;
 
@@ -618,7 +611,7 @@
 	   lf*hh1*t2e[0][jm-1]+lf*hh3*t2f[0][jm-1];
    }
    if ((gp[procid].neighbors[DOWN] == -1) && (gp[procid].neighbors[RIGHT] == -1)) {
-     t2a[im-1][jm-1] = t2c[im-1][jm-1] - 
+     t2a[im-1][jm-1] = t2c[im-1][jm-1] -
 	   t2d[im-1][jm-1]+eig2*t2g[im-1][jm-1] +
 	   h1inv*t2h[im-1][jm-1]+lf*t2e[im-1][jm-1] -
 	   lf*t2f[im-1][jm-1];
@@ -667,7 +660,7 @@
    if (gp[procid].neighbors[LEFT] == -1) {
      for(j=firstrow;j<=lastrow;j++) {
        t2a[j][0] = t2c[j][0]-t2d[j][0] +
-	   eig2*t2g[j][0]+h1inv*t2h[j][0] + 
+	   eig2*t2g[j][0]+h1inv*t2h[j][0] +
 	   lf*t2e[j][0]-lf*t2f[j][0];
        t2b[j][0] = hh1*t2c[j][0] +
 	   hh3*t2d[j][0]+hinv*t2h[j][0] +
@@ -706,9 +699,11 @@
 	   lf*hh3*t1f[iindex];
      }
    }
-   
+#if defined(MULTIPLE_BARRIERS)
    BARRIER(bars->sl_phase_5,nprocs)
-
+#else
+   BARRIER(bars->barrier,nprocs)
+#endif
 /*     *******************************************************
 
                s i x t h   p h a s e
@@ -793,9 +788,9 @@
      gp[procid].multi_time += (multi_end - multi_start);
    }
 
-/* the shared sum variable psiai is initialized to 0 at 
+/* the shared sum variable psiai is initialized to 0 at
    every time-step  */
-     
+
    if (procid == MASTER) {
      global->psiai=0.0;
    }
@@ -811,9 +806,11 @@
        t1c[j] = t1d[j];
      }
    }
-
+#if defined(MULTIPLE_BARRIERS)
    BARRIER(bars->sl_phase_6,nprocs)
-
+#else
+   BARRIER(bars->barrier,nprocs)
+#endif
 /*     *******************************************************
 
                 s e v e n t h   p h a s e
@@ -822,7 +819,7 @@
 
    every process computes the running sum for its assigned portion
    in a private variable psiaipriv   */
-    
+
    psiaipriv=0.0;
    t2a = (double **) ga[procid];
    if ((gp[procid].neighbors[UP] == -1) && (gp[procid].neighbors[LEFT] == -1)) {
@@ -868,13 +865,15 @@
 
 /* after computing its private sum, every process adds that to the
    shared running sum psiai  */
-   
+
    LOCK(locks->psiailock)
    global->psiai = global->psiai + psiaipriv;
    UNLOCK(locks->psiailock)
-
+#if defined(MULTIPLE_BARRIERS)
    BARRIER(bars->sl_phase_7,nprocs)
-
+#else
+   BARRIER(bars->barrier,nprocs)
+#endif
 /*      *******************************************************
 
                 e i g h t h   p h a s e
@@ -997,9 +996,11 @@
        t1c[j] = t1d[j];
      }
    }
-
+#if defined(MULTIPLE_BARRIERS)
    BARRIER(bars->sl_phase_8,nprocs)
-
+#else
+   BARRIER(bars->barrier,nprocs)
+#endif
 /*      *******************************************************
 
                 n i n t h   p h a s e
@@ -1010,7 +1011,7 @@
    note that here (as in most cases) the constant multipliers are made
    private variables; the specific order in which things are done is
    chosen in order to hopefully reuse things brought into the cache
-   
+
    note that here again we choose to have all processes share the work
    on both matrices despite the fact that the work done per element
    is the same, because the operand matrices are the same in both cases */
@@ -1080,9 +1081,11 @@
        t1c[iindex] = t1b[iindex] - hh1*t1a[iindex];
      }
    }
-
+#if defined(MULTIPLE_BARRIERS)
    BARRIER(bars->sl_phase_9,nprocs)
-
+#else
+   BARRIER(bars->barrier,nprocs)
+#endif
 /*      *******************************************************
 
                 t e n t h    p h a s e
@@ -1100,15 +1103,15 @@
      t2a[0][0] = t2a[0][0] + timst*t2b[0][0];
    }
    if ((gp[procid].neighbors[DOWN] == -1) && (gp[procid].neighbors[LEFT] == -1)) {
-     t2a[im-1][0] = t2a[im-1][0] + 
+     t2a[im-1][0] = t2a[im-1][0] +
 			       timst*t2b[im-1][0];
    }
    if ((gp[procid].neighbors[UP] == -1) && (gp[procid].neighbors[RIGHT] == -1)) {
-     t2a[0][jm-1] = t2a[0][jm-1] + 
+     t2a[0][jm-1] = t2a[0][jm-1] +
 			       timst*t2b[0][jm-1];
    }
    if ((gp[procid].neighbors[DOWN] == -1) && (gp[procid].neighbors[RIGHT] == -1)) {
-     t2a[im-1][jm-1] = t2a[im-1][jm-1] + 
+     t2a[im-1][jm-1] = t2a[im-1][jm-1] +
 				  timst*t2b[im-1][jm-1];
    }
    if (gp[procid].neighbors[UP] == -1) {
@@ -1132,7 +1135,7 @@
    }
    if (gp[procid].neighbors[RIGHT] == -1) {
      for(j=firstrow;j<=lastrow;j++) {
-       t2a[j][jm-1] = t2a[j][jm-1] + 
+       t2a[j][jm-1] = t2a[j][jm-1] +
 				 timst*t2b[j][jm-1];
      }
    }
@@ -1150,15 +1153,15 @@
      t2a[0][0] = t2a[0][0] + timst*t2b[0][0];
    }
    if ((gp[procid].neighbors[DOWN] == -1) && (gp[procid].neighbors[LEFT] == -1)) {
-     t2a[im-1][0] = t2a[im-1][0] + 
+     t2a[im-1][0] = t2a[im-1][0] +
 			       timst*t2b[im-1][0];
    }
    if ((gp[procid].neighbors[UP] == -1) && (gp[procid].neighbors[RIGHT] == -1)) {
-     t2a[0][jm-1] = t2a[0][jm-1] + 
+     t2a[0][jm-1] = t2a[0][jm-1] +
 			       timst*t2b[0][jm-1];
    }
    if ((gp[procid].neighbors[DOWN] == -1) && (gp[procid].neighbors[RIGHT] == -1)) {
-     t2a[im-1][jm-1] = t2a[im-1][jm-1] + 
+     t2a[im-1][jm-1] = t2a[im-1][jm-1] +
 				  timst*t2b[im-1][jm-1];
    }
    if (gp[procid].neighbors[UP] == -1) {
@@ -1182,7 +1185,7 @@
    }
    if (gp[procid].neighbors[RIGHT] == -1) {
      for(j=firstrow;j<=lastrow;j++) {
-       t2a[j][jm-1] = t2a[j][jm-1] + 
+       t2a[j][jm-1] = t2a[j][jm-1] +
 				 timst*t2b[j][jm-1];
      }
    }
@@ -1194,6 +1197,9 @@
          t1a[iindex] = t1a[iindex] + timst*t1b[iindex];
      }
    }
-
-   BARRIER(bars->sl_phase_10,nprocs)   
+#if defined(MULTIPLE_BARRIERS)
+   BARRIER(bars->sl_phase_10,nprocs)
+#else
+   BARRIER(bars->barrier,nprocs)
+#endif
 }
diff -Naur splash2/codes/apps/ocean/contiguous_partitions/subblock.C splash2-modified/codes/apps/ocean/contiguous_partitions/subblock.C
--- splash2/codes/apps/ocean/contiguous_partitions/subblock.C	1994-10-15 00:06:23.000000000 -0400
+++ splash2-modified/codes/apps/ocean/contiguous_partitions/subblock.C	2007-03-12 19:58:56.000000000 -0400
@@ -23,16 +23,14 @@
 void subblock()
 
 {
-   double procsqrt;
-   int i;
-   int j;
-   int k;
-   int xportion;
-   int xextra;
-   int yportion;
-   int yextra;
-   int lower;
-   int my_num;
+   long i;
+   long j;
+   long k;
+   long xportion;
+   long xextra;
+   long yportion;
+   long yextra;
+   long my_num;
 
 /* Determine starting coord and number of points to process in     */
 /* each direction                                                  */
diff -Naur splash2/codes/apps/ocean/non_contiguous_partitions/.C..e splash2-modified/codes/apps/ocean/non_contiguous_partitions/.C..e
--- splash2/codes/apps/ocean/non_contiguous_partitions/.C..e	1994-10-12 00:07:02.000000000 -0400
+++ splash2-modified/codes/apps/ocean/non_contiguous_partitions/.C..e	1969-12-31 19:00:00.000000000 -0500
@@ -1,5 +0,0 @@
-ld:
-The shared object /usr/lib/libC.so did not resolve any symbols.
-	You may want to remove it from your link line.
-Unresolved:
-main
diff -Naur splash2/codes/apps/ocean/non_contiguous_partitions/decs.h splash2-modified/codes/apps/ocean/non_contiguous_partitions/decs.h
--- splash2/codes/apps/ocean/non_contiguous_partitions/decs.h	1994-10-15 00:16:40.000000000 -0400
+++ splash2-modified/codes/apps/ocean/non_contiguous_partitions/decs.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,207 +0,0 @@
-
-/*************************************************************************/
-/*                                                                       */
-/*  Copyright (c) 1994 Stanford University                               */
-/*                                                                       */
-/*  All rights reserved.                                                 */
-/*                                                                       */
-/*  Permission is given to use, copy, and modify this software for any   */
-/*  non-commercial purpose as long as this copyright notice is not       */
-/*  removed.  All other uses, including redistribution in whole or in    */
-/*  part, are forbidden without prior written permission.                */
-/*                                                                       */
-/*  This software is provided with absolutely no warranty and no         */
-/*  support.                                                             */
-/*                                                                       */
-/*************************************************************************/
-
-#define INPROCS        16
-#define IMAX          258 
-#define JMAX          258 
-#define MAX_LEVELS      9
-#define MASTER          0
-#define RED_ITER        0
-#define BLACK_ITER      1
-#define PAGE_SIZE    4096
-
- 
-
-extern struct global_struct {
-   int id;
-   int starttime;
-   int trackstart;
-   double psiai;
-   double psibi;
-} *global;
-
-extern struct fields_struct {
-   double psi[2][IMAX][JMAX];
-   double psim[2][IMAX][JMAX];
-} *fields;
-  
-extern struct fields2_struct {
-   double psium[IMAX][JMAX];
-   double psilm[IMAX][JMAX];
-} *fields2;
-
-extern struct wrk1_struct {
-   double psib[IMAX][JMAX];
-   double ga[IMAX][JMAX];
-   double gb[IMAX][JMAX];
-} *wrk1;
-
-extern struct wrk3_struct {
-   double work1[2][IMAX][JMAX];
-   double work2[IMAX][JMAX];
-} *wrk3;
-
-extern struct wrk2_struct {
-   double work3[IMAX][JMAX];
-   double f[IMAX];
-} *wrk2;
-
-extern struct wrk4_struct {
-   double work4[2][IMAX][JMAX];
-   double work5[2][IMAX][JMAX];
-} *wrk4;
-
-extern struct wrk6_struct {
-   double work6[IMAX][JMAX];
-} *wrk6;
-
-extern struct wrk5_struct {
-   double work7[2][IMAX][JMAX];
-   double temparray[2][IMAX][JMAX];
-} *wrk5;
-
-extern struct frcng_struct {
-   double tauz[IMAX][JMAX];
-} *frcng;
-
-extern struct iter_struct {
-   int notdone;
-   double work8[IMAX][JMAX];
-   double work9[IMAX][JMAX];
-} *iter;
-
-extern struct guess_struct {
-   double oldga[IMAX][JMAX];
-   double oldgb[IMAX][JMAX];
-} *guess;
-
-extern struct multi_struct {
-   double q_multi[MAX_LEVELS][IMAX][JMAX];
-   double rhs_multi[MAX_LEVELS][IMAX][JMAX];
-   double err_multi;
-   int numspin;
-   int spinflag[INPROCS];
-} *multi;
-
-extern struct locks_struct {
-   int (idlock);
-   int (psiailock);
-   int (psibilock);
-   int (donelock);
-   int (error_lock);
-   int (bar_lock);
-} *locks;
- 
-extern struct bars_struct {
-   int (iteration);
-   int (gsudn);
-   int (p_setup);
-   int (p_redph);
-   int (p_soln);
-   int (p_subph);
-   int (sl_prini);
-   int (sl_psini);
-   int (sl_onetime);
-   int (sl_phase_1);
-   int (sl_phase_2);
-   int (sl_phase_3);
-   int (sl_phase_4);
-   int (sl_phase_5);
-   int (sl_phase_6);
-   int (sl_phase_7);
-   int (sl_phase_8);
-   int (sl_phase_9);
-   int (sl_phase_10);
-   int (error_barrier);
-} *bars;
-
-extern double eig2;
-extern double ysca;
-extern int jmm1;
-extern double pi;
-extern double t0;
-
-extern int *procmap;
-extern int xprocs;
-extern int yprocs;
-
-extern int numlev;
-extern int imx[MAX_LEVELS];
-extern int jmx[MAX_LEVELS];
-extern double lev_res[MAX_LEVELS];
-extern double lev_tol[MAX_LEVELS];
-extern double maxwork;
-extern int minlevel;
-extern double outday0;
-extern double outday1;
-extern double outday2;
-extern double outday3;
-
-extern int nprocs;
-
-extern double h1;
-extern double h3;
-extern double h;
-extern double lf;
-extern double res;
-extern double dtau;
-extern double f0;
-extern double beta;
-extern double gpr;
-extern int im;
-extern int jm;
-extern int do_stats;
-extern int do_output;
-extern int *multi_times;
-extern int *total_times;
-extern double factjacob;
-extern double factlap;
-
-extern struct Global_Private {
-  char pad[PAGE_SIZE];
-  double multi_time;
-  double total_time;
-  int rel_start_x[MAX_LEVELS];
-  int rel_start_y[MAX_LEVELS];
-  int rel_num_x[MAX_LEVELS];
-  int rel_num_y[MAX_LEVELS];
-  int eist[MAX_LEVELS];
-  int ejst[MAX_LEVELS];
-  int oist[MAX_LEVELS];
-  int ojst[MAX_LEVELS];
-  int eiest[MAX_LEVELS];
-  int ejest[MAX_LEVELS];
-  int oiest[MAX_LEVELS];
-  int ojest[MAX_LEVELS];
-  int rlist[MAX_LEVELS];
-  int rljst[MAX_LEVELS];
-  int rlien[MAX_LEVELS];
-  int rljen[MAX_LEVELS];
-  int iist[MAX_LEVELS];
-  int ijst[MAX_LEVELS];
-  int iien[MAX_LEVELS];
-  int ijen[MAX_LEVELS];
-  int pist[MAX_LEVELS];
-  int pjst[MAX_LEVELS];
-  int pien[MAX_LEVELS];
-  int pjen[MAX_LEVELS];
-} *gp;
-
-extern double i_int_coeff[MAX_LEVELS];
-extern double j_int_coeff[MAX_LEVELS];
-extern int minlev;
-
diff -Naur splash2/codes/apps/ocean/non_contiguous_partitions/decs.H splash2-modified/codes/apps/ocean/non_contiguous_partitions/decs.H
--- splash2/codes/apps/ocean/non_contiguous_partitions/decs.H	1994-10-15 00:06:43.000000000 -0400
+++ splash2-modified/codes/apps/ocean/non_contiguous_partitions/decs.H	2007-03-19 23:50:10.000000000 -0400
@@ -15,8 +15,8 @@
 /*************************************************************************/
 
 #define INPROCS        16
-#define IMAX          258 
-#define JMAX          258 
+#define IMAX          258
+#define JMAX          258
 #define MAX_LEVELS      9
 #define MASTER          0
 #define RED_ITER        0
@@ -25,87 +25,88 @@
 
 EXTERN_ENV
 
-extern struct global_struct {
-   int id;
-   int starttime;
-   int trackstart;
+struct global_struct {
+   long id;
+   long starttime;
+   long trackstart;
    double psiai;
    double psibi;
-} *global;
+};
 
-extern struct fields_struct {
+struct fields_struct {
    double psi[2][IMAX][JMAX];
    double psim[2][IMAX][JMAX];
-} *fields;
-  
-extern struct fields2_struct {
+};
+
+struct fields2_struct {
    double psium[IMAX][JMAX];
    double psilm[IMAX][JMAX];
-} *fields2;
+};
 
-extern struct wrk1_struct {
+struct wrk1_struct {
    double psib[IMAX][JMAX];
    double ga[IMAX][JMAX];
    double gb[IMAX][JMAX];
-} *wrk1;
+};
 
-extern struct wrk3_struct {
+struct wrk3_struct {
    double work1[2][IMAX][JMAX];
    double work2[IMAX][JMAX];
-} *wrk3;
+};
 
-extern struct wrk2_struct {
+struct wrk2_struct {
    double work3[IMAX][JMAX];
    double f[IMAX];
-} *wrk2;
+};
 
-extern struct wrk4_struct {
+struct wrk4_struct {
    double work4[2][IMAX][JMAX];
    double work5[2][IMAX][JMAX];
-} *wrk4;
+};
 
-extern struct wrk6_struct {
+struct wrk6_struct {
    double work6[IMAX][JMAX];
-} *wrk6;
+};
 
-extern struct wrk5_struct {
+struct wrk5_struct {
    double work7[2][IMAX][JMAX];
    double temparray[2][IMAX][JMAX];
-} *wrk5;
+};
 
-extern struct frcng_struct {
+struct frcng_struct {
    double tauz[IMAX][JMAX];
-} *frcng;
+};
 
-extern struct iter_struct {
-   int notdone;
+struct iter_struct {
+   long notdone;
    double work8[IMAX][JMAX];
    double work9[IMAX][JMAX];
-} *iter;
+};
 
-extern struct guess_struct {
+struct guess_struct {
    double oldga[IMAX][JMAX];
    double oldgb[IMAX][JMAX];
-} *guess;
+};
 
-extern struct multi_struct {
+struct multi_struct {
    double q_multi[MAX_LEVELS][IMAX][JMAX];
    double rhs_multi[MAX_LEVELS][IMAX][JMAX];
    double err_multi;
-   int numspin;
-   int spinflag[INPROCS];
-} *multi;
+   long numspin;
+   long spinflag[INPROCS];
+};
 
-extern struct locks_struct {
+struct locks_struct {
    LOCKDEC(idlock)
    LOCKDEC(psiailock)
    LOCKDEC(psibilock)
    LOCKDEC(donelock)
    LOCKDEC(error_lock)
    LOCKDEC(bar_lock)
-} *locks;
- 
-extern struct bars_struct {
+};
+
+struct bars_struct {
+#if defined(MULTIPLE_BARRIERS)
    BARDEC(iteration)
    BARDEC(gsudn)
    BARDEC(p_setup)
@@ -126,31 +127,50 @@
    BARDEC(sl_phase_9)
    BARDEC(sl_phase_10)
    BARDEC(error_barrier)
-} *bars;
+#else
+   BARDEC(barrier)
+#endif
+};
+
+extern struct global_struct *global;
+extern struct fields_struct *fields;
+extern struct fields2_struct *fields2;
+extern struct wrk1_struct *wrk1;
+extern struct wrk3_struct *wrk3;
+extern struct wrk2_struct *wrk2;
+extern struct wrk4_struct *wrk4;
+extern struct wrk6_struct *wrk6;
+extern struct wrk5_struct *wrk5;
+extern struct frcng_struct *frcng;
+extern struct iter_struct *iter;
+extern struct guess_struct *guess;
+extern struct multi_struct *multi;
+extern struct locks_struct *locks;
+extern struct bars_struct *bars;
 
 extern double eig2;
 extern double ysca;
-extern int jmm1;
+extern long jmm1;
 extern double pi;
 extern double t0;
 
-extern int *procmap;
-extern int xprocs;
-extern int yprocs;
-
-extern int numlev;
-extern int imx[MAX_LEVELS];
-extern int jmx[MAX_LEVELS];
+extern long *procmap;
+extern long xprocs;
+extern long yprocs;
+
+extern long numlev;
+extern long imx[MAX_LEVELS];
+extern long jmx[MAX_LEVELS];
 extern double lev_res[MAX_LEVELS];
 extern double lev_tol[MAX_LEVELS];
 extern double maxwork;
-extern int minlevel;
+extern long minlevel;
 extern double outday0;
 extern double outday1;
 extern double outday2;
 extern double outday3;
 
-extern int nprocs;
+extern long nprocs;
 
 extern double h1;
 extern double h3;
@@ -161,46 +181,82 @@
 extern double f0;
 extern double beta;
 extern double gpr;
-extern int im;
-extern int jm;
-extern int do_stats;
-extern int do_output;
-extern int *multi_times;
-extern int *total_times;
+extern long im;
+extern long jm;
+extern long do_stats;
+extern long do_output;
+extern long *multi_times;
+extern long *total_times;
 extern double factjacob;
 extern double factlap;
 
-extern struct Global_Private {
+struct Global_Private {
   char pad[PAGE_SIZE];
   double multi_time;
   double total_time;
-  int rel_start_x[MAX_LEVELS];
-  int rel_start_y[MAX_LEVELS];
-  int rel_num_x[MAX_LEVELS];
-  int rel_num_y[MAX_LEVELS];
-  int eist[MAX_LEVELS];
-  int ejst[MAX_LEVELS];
-  int oist[MAX_LEVELS];
-  int ojst[MAX_LEVELS];
-  int eiest[MAX_LEVELS];
-  int ejest[MAX_LEVELS];
-  int oiest[MAX_LEVELS];
-  int ojest[MAX_LEVELS];
-  int rlist[MAX_LEVELS];
-  int rljst[MAX_LEVELS];
-  int rlien[MAX_LEVELS];
-  int rljen[MAX_LEVELS];
-  int iist[MAX_LEVELS];
-  int ijst[MAX_LEVELS];
-  int iien[MAX_LEVELS];
-  int ijen[MAX_LEVELS];
-  int pist[MAX_LEVELS];
-  int pjst[MAX_LEVELS];
-  int pien[MAX_LEVELS];
-  int pjen[MAX_LEVELS];
-} *gp;
+  long rel_start_x[MAX_LEVELS];
+  long rel_start_y[MAX_LEVELS];
+  long rel_num_x[MAX_LEVELS];
+  long rel_num_y[MAX_LEVELS];
+  long eist[MAX_LEVELS];
+  long ejst[MAX_LEVELS];
+  long oist[MAX_LEVELS];
+  long ojst[MAX_LEVELS];
+  long eiest[MAX_LEVELS];
+  long ejest[MAX_LEVELS];
+  long oiest[MAX_LEVELS];
+  long ojest[MAX_LEVELS];
+  long rlist[MAX_LEVELS];
+  long rljst[MAX_LEVELS];
+  long rlien[MAX_LEVELS];
+  long rljen[MAX_LEVELS];
+  long iist[MAX_LEVELS];
+  long ijst[MAX_LEVELS];
+  long iien[MAX_LEVELS];
+  long ijen[MAX_LEVELS];
+  long pist[MAX_LEVELS];
+  long pjst[MAX_LEVELS];
+  long pien[MAX_LEVELS];
+  long pjen[MAX_LEVELS];
+};
+
+extern struct Global_Private *gp;
 
 extern double i_int_coeff[MAX_LEVELS];
 extern double j_int_coeff[MAX_LEVELS];
-extern int minlev;
+extern long minlev;
 
+/*
+ * jacobcalc.C
+ */
+void jacobcalc(double x[IMAX][JMAX], double y[IMAX][JMAX], double z[IMAX][JMAX], long pid, long firstrow, long lastrow, long firstcol, long lastcol, long numrows, long numcols);
+
+/*
+ * laplacalc.C
+ */
+void laplacalc(double x[IMAX][JMAX], double z[IMAX][JMAX], long firstrow, long lastrow, long firstcol, long lastcol, long numrows, long numcols);
+
+/*
+ * main.C
+ */
+long log_2(long number);
+void printerr(char *s);
+
+/*
+ * multi.C
+ */
+void multig(long my_id);
+void relax(long k, double *err, long color, long my_num);
+void rescal(long kf, long my_num);
+void intadd(long kc, long my_num);
+void putz(long k, long my_num);
+
+/*
+ * slave1.C
+ */
+void slave(void);
+
+/*
+ * slave2.C
+ */
+void slave2(long procid, long firstrow, long lastrow, long numrows, long firstcol, long lastcol, long numcols);
diff -Naur splash2/codes/apps/ocean/non_contiguous_partitions/jacobcalc.c splash2-modified/codes/apps/ocean/non_contiguous_partitions/jacobcalc.c
--- splash2/codes/apps/ocean/non_contiguous_partitions/jacobcalc.c	1994-10-15 00:16:47.000000000 -0400
+++ splash2-modified/codes/apps/ocean/non_contiguous_partitions/jacobcalc.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,106 +0,0 @@
-
-/*************************************************************************/
-/*                                                                       */
-/*  Copyright (c) 1994 Stanford University                               */
-/*                                                                       */
-/*  All rights reserved.                                                 */
-/*                                                                       */
-/*  Permission is given to use, copy, and modify this software for any   */
-/*  non-commercial purpose as long as this copyright notice is not       */
-/*  removed.  All other uses, including redistribution in whole or in    */
-/*  part, are forbidden without prior written permission.                */
-/*                                                                       */
-/*  This software is provided with absolutely no warranty and no         */
-/*  support.                                                             */
-/*                                                                       */
-/*************************************************************************/
-
-/* does the arakawa jacobian calculation (of the x and y matrices, 
-   putting the results in the z matrix) for a subblock. */
-
-#include <stdio.h>
-#include <math.h>
-#include <time.h>
-#include "decs.h"
-
-void jacobcalc(x,y,z,pid,firstrow,lastrow,firstcol,lastcol,numrows,numcols) 
-
-double x[IMAX][JMAX];
-double y[IMAX][JMAX];
-double z[IMAX][JMAX];
-int pid;
-int firstrow,lastrow,firstcol,lastcol,numrows,numcols;
-
-{
-   double f1;
-   double f2;
-   double f3;
-   double f4;
-   double f5;
-   double f6;
-   double f7;
-   double f8;
-   int iindex;
-   int indexp1;
-   int indexm1;
-   int im1;
-   int ip1;
-   int i;
-   int j;
-
-   if (pid == MASTER) {
-     z[0][0]=0.0;
-   }
-   if (pid == nprocs-xprocs) {
-     z[im-1][0]=0.0;
-   }
-   if (pid == xprocs-1) {
-     z[0][jm-1]=0.0;
-   }
-   if (pid == nprocs-1) {
-     z[im-1][jm-1]=0.0;
-   }
-   for (iindex=firstcol;iindex<=lastcol;iindex++) {
-     indexp1 = iindex+1;
-     indexm1 = iindex-1;
-     for (i=firstrow;i<=lastrow;i++) {
-       ip1 = i+1;
-       im1 = i-1;
-       f1 = (y[i][indexm1]+y[ip1][indexm1]-y[i][indexp1]-y[ip1][indexp1])*
-            (x[ip1][iindex]-x[i][iindex]);
-       f2 = (y[im1][indexm1]+y[i][indexm1]-y[im1][indexp1]-y[i][indexp1])*
-            (x[i][iindex]-x[im1][iindex]);
-       f3 = (y[ip1][iindex]+y[ip1][indexp1]-y[im1][iindex]-y[im1][indexp1])*
-            (x[i][indexp1]-x[i][iindex]);
-       f4 = (y[ip1][indexm1]+y[ip1][iindex]-y[im1][indexm1]-y[im1][iindex])*
-            (x[i][iindex]-x[i][indexm1]);
-       f5 = (y[ip1][iindex]-y[i][indexp1])*(x[ip1][indexp1]-x[i][iindex]);
-       f6 = (y[i][indexm1]-y[im1][iindex])*(x[i][iindex]-x[im1][indexm1]);
-       f7 = (y[i][indexp1]-y[im1][iindex])*(x[im1][indexp1]-x[i][iindex]);
-       f8 = (y[ip1][iindex]-y[i][indexm1])*(x[i][iindex]-x[ip1][indexm1]);
- 
-       z[i][iindex] = factjacob*(f1+f2+f3+f4+f5+f6+f7+f8);
-     }
-   }
-   if (firstrow == 1) {
-     for (j=firstcol;j<=lastcol;j++) {
-       z[0][j] = 0.0;
-     }
-   }
-   if ((firstrow+numrows) == im-1) {
-     for (j=firstcol;j<=lastcol;j++) {
-       z[im-1][j] = 0.0;
-     }
-   }
-   if (firstcol == 1) {
-     for (j=firstrow;j<=lastrow;j++) {
-       z[j][0] = 0.0;
-     }
-   }
-   if ((firstcol+numcols) == jm-1) {
-     for (j=firstrow;j<=lastrow;j++) {
-       z[j][jm-1] = 0.0;
-     }
-   }
-}
-
diff -Naur splash2/codes/apps/ocean/non_contiguous_partitions/jacobcalc.C splash2-modified/codes/apps/ocean/non_contiguous_partitions/jacobcalc.C
--- splash2/codes/apps/ocean/non_contiguous_partitions/jacobcalc.C	1994-10-15 00:06:43.000000000 -0400
+++ splash2-modified/codes/apps/ocean/non_contiguous_partitions/jacobcalc.C	2007-03-12 20:39:09.000000000 -0400
@@ -14,7 +14,7 @@
 /*                                                                       */
 /*************************************************************************/
 
-/* does the arakawa jacobian calculation (of the x and y matrices, 
+/* does the arakawa jacobian calculation (of the x and y matrices,
    putting the results in the z matrix) for a subblock. */
 
 #include <stdio.h>
@@ -22,14 +22,7 @@
 #include <time.h>
 #include "decs.h"
 
-void jacobcalc(x,y,z,pid,firstrow,lastrow,firstcol,lastcol,numrows,numcols) 
-
-double x[IMAX][JMAX];
-double y[IMAX][JMAX];
-double z[IMAX][JMAX];
-int pid;
-int firstrow,lastrow,firstcol,lastcol,numrows,numcols;
-
+void jacobcalc(double x[IMAX][JMAX], double y[IMAX][JMAX], double z[IMAX][JMAX], long pid, long firstrow, long lastrow, long firstcol, long lastcol, long numrows, long numcols)
 {
    double f1;
    double f2;
@@ -39,13 +32,13 @@
    double f6;
    double f7;
    double f8;
-   int iindex;
-   int indexp1;
-   int indexm1;
-   int im1;
-   int ip1;
-   int i;
-   int j;
+   long iindex;
+   long indexp1;
+   long indexm1;
+   long im1;
+   long ip1;
+   long i;
+   long j;
 
    if (pid == MASTER) {
      z[0][0]=0.0;
@@ -77,7 +70,7 @@
        f6 = (y[i][indexm1]-y[im1][iindex])*(x[i][iindex]-x[im1][indexm1]);
        f7 = (y[i][indexp1]-y[im1][iindex])*(x[im1][indexp1]-x[i][iindex]);
        f8 = (y[ip1][iindex]-y[i][indexm1])*(x[i][iindex]-x[ip1][indexm1]);
- 
+
        z[i][iindex] = factjacob*(f1+f2+f3+f4+f5+f6+f7+f8);
      }
    }
diff -Naur splash2/codes/apps/ocean/non_contiguous_partitions/jacobcalc.o splash2-modified/codes/apps/ocean/non_contiguous_partitions/jacobcalc.o
--- splash2/codes/apps/ocean/non_contiguous_partitions/jacobcalc.o	1994-10-15 00:16:51.000000000 -0400
+++ splash2-modified/codes/apps/ocean/non_contiguous_partitions/jacobcalc.o	1969-12-31 19:00:00.000000000 -0500
@@ -1,10 +0,0 @@
-ELF                            4     ( 	                                                                                 "             %             /            .symtab .shstrtab .strtab .text .options .reginfo .rel.text .mdebug  .text jacobcalc nprocs xprocs im jm factjacob _gp_disp                <  '  !' \ X T P L H D @ < 8 0 4 ( ,   $      @ DDh D`          c  Dh D` x#         Y       qp! q  !c        $  	          y       p !    $  XN  y   !   x! p!X\ @%'*  %
- %9 PT  *    @%!  x!$ dD !  `  l x!p!TH0! yx! y ! ` d d  qp! q  `.p! d d ` 
-8! `  qp! q .p! $  y@!  dx! y  hp! h!% yx! y /(! !  l `  P! ! !H! tX!' !!h!!7`!   ]  \ {  z wF8 vF:UF6TF<sF6F> rUTF2Y  F:X F4  F2    /  F0 . F4  F. q  p F<c  F.cF8  M  L F*q  F4Rp F,  F*bF<    F('  F2& F.  F:7  F2F<c6 $& F&$BF4$F:fF4$$c%F4EF>%)%J$F>7F*r%k%%F2T F4 F:&F>&1F6&R&s&Dh D`  \XHPT         @@%*6%J PT$  '*   @%'`#% 1   
-X! x P!% M  L h%J %.    P!% %8 M L M L M L %J  ML`O   !'8  >'*  < @%'`#% 1  X! PY  %  yx! y  !
-p!h%J %9 ( ( PO  %  !   p!!-,O       !   p!!-,O       !   p!!- ,O       !   p!!%/ -,%J   # *  ! @% P#%J 1X   H! qp! q  !% M  L ($B$ (  yx! y  !% $ MLM L$M0L4$B @MLdn   x!%  4 *  2 @% P#%J 1Y   %8! yx! y  !n  %   X!-,$B$   qp! q  !x  %   Yx!n        X!-,o       p N!y  $  x Op!(,$B @ \         $ ( , 0 4 8 < @ D H L P T X '@                                                                   	     	     	     	     	     	    	    	  |  	    	p	       
-X     h          H      	         $     4  4     h      	       "## "'88! $   ( ! $  0   !P 0                4@4H                 @     "   i           ,                                     ,                                  	       !   
-                                           	       !   
-                 jacobcalc.c jacobcalc  ./decs.h    jacobcalc nprocs xprocs im jm factjacob _gp_disp                                                                               
-                                                                     
-                                                   (                                                                                                                         4                  	                 E                              	   8                             P                   !p            	`                     *p           	                    3   	          	   `               =p            	                
\ No newline at end of file
diff -Naur splash2/codes/apps/ocean/non_contiguous_partitions/laplacalc.c splash2-modified/codes/apps/ocean/non_contiguous_partitions/laplacalc.c
--- splash2/codes/apps/ocean/non_contiguous_partitions/laplacalc.c	1994-10-15 00:16:51.000000000 -0400
+++ splash2-modified/codes/apps/ocean/non_contiguous_partitions/laplacalc.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,74 +0,0 @@
-
-/*************************************************************************/
-/*                                                                       */
-/*  Copyright (c) 1994 Stanford University                               */
-/*                                                                       */
-/*  All rights reserved.                                                 */
-/*                                                                       */
-/*  Permission is given to use, copy, and modify this software for any   */
-/*  non-commercial purpose as long as this copyright notice is not       */
-/*  removed.  All other uses, including redistribution in whole or in    */
-/*  part, are forbidden without prior written permission.                */
-/*                                                                       */
-/*  This software is provided with absolutely no warranty and no         */
-/*  support.                                                             */
-/*                                                                       */
-/*************************************************************************/
-
-/*      **************************************************************
-                       end of subroutine jacobcalc
-        **************************************************************  
-
-   performs the laplacian calculation for a subblock. */
-
-#include <stdio.h>
-#include <math.h>
-#include <time.h>
-#include "decs.h"
-
-void laplacalc(x,z,firstrow,lastrow,firstcol,lastcol,numrows,numcols)
-
-double x[IMAX][JMAX];
-double z[IMAX][JMAX];
-int firstrow,lastrow,firstcol,lastcol,numrows,numcols;
-
-{
-   int iindex;
-   int indexp1;
-   int indexm1;
-   int ip1;
-   int im1;
-   int i;
-   int j;
-
-   for (iindex=firstcol;iindex<=lastcol;iindex++) {
-     indexp1 = iindex+1;
-     indexm1 = iindex-1;
-     for (i=firstrow;i<=lastrow;i++) {
-       ip1 = i+1;
-       im1 = i-1;
-       z[i][iindex] = factlap*(x[ip1][iindex]+x[im1][iindex]+x[i][indexp1]+
-                              x[i][indexm1]-4.*x[i][iindex]);
-     }
-   }
-   if (firstrow == 1) {
-     for (j=firstcol;j<=lastcol;j++) {
-       z[0][j] = 0.0;
-     }
-   }
-   if ((firstrow+numrows) == im-1) {
-     for (j=firstcol;j<=lastcol;j++) {
-       z[im-1][j] = 0.0;
-     }
-   }
-   if (firstcol == 1) {
-     for (j=firstrow;j<=lastrow;j++) {
-       z[j][0] = 0.0;
-     }
-   }
-   if ((firstcol+numcols) == jm-1) {
-     for (j=firstrow;j<=lastrow;j++) {
-       z[j][jm-1] = 0.0;
-     }
-   }
-}
diff -Naur splash2/codes/apps/ocean/non_contiguous_partitions/laplacalc.C splash2-modified/codes/apps/ocean/non_contiguous_partitions/laplacalc.C
--- splash2/codes/apps/ocean/non_contiguous_partitions/laplacalc.C	1994-10-15 00:06:43.000000000 -0400
+++ splash2-modified/codes/apps/ocean/non_contiguous_partitions/laplacalc.C	2007-03-12 20:38:20.000000000 -0400
@@ -16,7 +16,7 @@
 
 /*      **************************************************************
                        end of subroutine jacobcalc
-        **************************************************************  
+        **************************************************************
 
    performs the laplacian calculation for a subblock. */
 
@@ -25,20 +25,15 @@
 #include <time.h>
 #include "decs.h"
 
-void laplacalc(x,z,firstrow,lastrow,firstcol,lastcol,numrows,numcols)
-
-double x[IMAX][JMAX];
-double z[IMAX][JMAX];
-int firstrow,lastrow,firstcol,lastcol,numrows,numcols;
-
+void laplacalc(double x[IMAX][JMAX], double z[IMAX][JMAX], long firstrow, long lastrow, long firstcol, long lastcol, long numrows, long numcols)
 {
-   int iindex;
-   int indexp1;
-   int indexm1;
-   int ip1;
-   int im1;
-   int i;
-   int j;
+   long iindex;
+   long indexp1;
+   long indexm1;
+   long ip1;
+   long im1;
+   long i;
+   long j;
 
    for (iindex=firstcol;iindex<=lastcol;iindex++) {
      indexp1 = iindex+1;
diff -Naur splash2/codes/apps/ocean/non_contiguous_partitions/laplacalc.o splash2-modified/codes/apps/ocean/non_contiguous_partitions/laplacalc.o
--- splash2/codes/apps/ocean/non_contiguous_partitions/laplacalc.o	1994-10-15 00:16:54.000000000 -0400
+++ splash2-modified/codes/apps/ocean/non_contiguous_partitions/laplacalc.o	1969-12-31 19:00:00.000000000 -0500
@@ -1,10 +0,0 @@
-ELF                        p    4     ( 	                                                                                             .symtab .shstrtab .strtab .text .options .reginfo .rel.text .mdebug  .text laplacalc factlap im jm _gp_disp                <  '  !'  4 0 * %       %<@D D    % &  *   @% #$B 0O  & H E  qp! q  !.P!   !)!IX!R!T!h!gfml% o  n s  r  F,4 F F.     F(R  F,C% F&a$c%k&s&gfgfmlo  F,4 n s  r     F F.     F(R  F,C$cF&a%k&s&fg$  i qp! q  !.P!   !)!IX!R!T!gfedk  F$2 j d e  F*D   F " % $ $c @F2 F(2  %k @F0T&s @& @rsdefgjF&" kfgF*D F 2    F2  F("      F0TrsfgdejF$2 kdeF*D F "    F2 F(2      F0Trsfgd e  jF&" kfgF*D F 2    F2  F("      F0Trs %F$ $	  &     0    *  ! %@#% 1   8 ! pD D   !$c A  @ $B &   D D   !$c & A @ A @ A @ $B  A@   8N   !D D  '8  B 0 0    *  <%@#% 1   / ! N  $c  !   !"x!$B &  ( X  $c  8!   x!p!X       8!   x!p!X       8!   x!p! X       8!   x!p!& $B   0 *) #      ! % #$B 0O  @! qp! q   !$c    $$   #!    !$c $  $04$ @   0 <.  x!%  4 *  2 % #$B 0Y   &@! yx! y   !.  $c   !! $$   qp! q   !8  $c   x!.        !! /       p ! 9  $  x p!(,$ @        '                                                                     P  	    	    	p	     \     
-             	0      @      	x   $  	   $  
-     
-@      @     
- 	 	 	8 8301 
-BB@EH                                 #   J           ,                                     ,                                  	       !   
-                                           	       !   
-                 laplacalc.c laplacalc  ./decs.h    laplacalc factlap im jm _gp_disp                                                                  Z             
-                                                                     
-                                                                                                                                                  4   p               	                 E                                  (                                                 !p                                 *p                                3   	             (               =p            @  0              
\ No newline at end of file
diff -Naur splash2/codes/apps/ocean/non_contiguous_partitions/main.c splash2-modified/codes/apps/ocean/non_contiguous_partitions/main.c
--- splash2/codes/apps/ocean/non_contiguous_partitions/main.c	1994-10-15 00:16:40.000000000 -0400
+++ splash2-modified/codes/apps/ocean/non_contiguous_partitions/main.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,678 +0,0 @@
-
-/*************************************************************************/
-/*                                                                       */
-/*  SPLASH Ocean Code                                                    */
-/*                                                                       */
-/*  This application studies the role of eddy and boundary currents in   */
-/*  influencing large-scale ocean movements.  This implementation uses   */
-/*  statically allocated two-dimensional arrays for grid data storage.   */
-/*                                                                       */
-/*  Command line options:                                                */
-/*                                                                       */
-/*     -nN : Simulate NxN ocean.  N must be (power of 2)+2.              */
-/*     -pP : P = number of processors.  P must be power of 2.            */
-/*     -eE : E = error tolerance for iterative relaxation.               */
-/*     -rR : R = distance between grid points in meters.                 */
-/*     -tT : T = timestep in seconds.                                    */
-/*     -s  : Print timing statistics.                                    */
-/*     -o  : Print out relaxation residual values.                       */
-/*     -h  : Print out command line options.                             */
-/*                                                                       */
-/*  Default: OCEAN -n130 -p1 -e1e-7 -r20000.0 -t28800.0                  */
-/*                                                                       */
-/*  NOTE: This code works under both the FORK and SPROC models.          */
-/*                                                                       */
-/*************************************************************************/
-
- 
-
-#include <stdio.h>
-#include <math.h>
-#include <time.h>
-#define DEFAULT_N      258
-#define DEFAULT_P        1
-#define DEFAULT_E        1e-7
-#define DEFAULT_T    28800.0
-#define DEFAULT_R    20000.0
-#define INPROCS         16         /* Maximum number of processors */
-#define IMAX           258
-#define JMAX           258
-#define MAX_LEVELS       9
-#define PAGE_SIZE     4096
-
-struct global_struct {
-   int id;
-   int starttime;
-   int trackstart;
-   double psiai;
-   double psibi;
-} *global;
-
-struct fields_struct {
-   double psi[2][IMAX][JMAX];
-   double psim[2][IMAX][JMAX];
-} *fields;
-  
-struct fields2_struct {
-   double psium[IMAX][JMAX];
-   double psilm[IMAX][JMAX];
-} *fields2;
-
-struct wrk1_struct {
-   double psib[IMAX][JMAX];
-   double ga[IMAX][JMAX];
-   double gb[IMAX][JMAX];
-} *wrk1;
-
-struct wrk3_struct {
-   double work1[2][IMAX][JMAX];
-   double work2[IMAX][JMAX];
-} *wrk3;
-
-struct wrk2_struct {
-   double work3[IMAX][JMAX];
-   double f[IMAX];
-} *wrk2;
-
-struct wrk4_struct {
-   double work4[2][IMAX][JMAX];
-   double work5[2][IMAX][JMAX];
-} *wrk4;
-
-struct wrk6_struct {
-   double work6[IMAX][JMAX];
-} *wrk6;
-
-struct wrk5_struct {
-   double work7[2][IMAX][JMAX];
-   double temparray[2][IMAX][JMAX];
-} *wrk5;
-
-struct frcng_struct {
-   double tauz[IMAX][JMAX];
-} *frcng;
-
-struct iter_struct {
-   int notdone;
-   double work8[IMAX][JMAX];
-   double work9[IMAX][JMAX];
-} *iter;
-
-struct guess_struct {
-   double oldga[IMAX][JMAX];
-   double oldgb[IMAX][JMAX];
-} *guess;
-
-struct multi_struct {
-   double q_multi[MAX_LEVELS][IMAX][JMAX];
-   double rhs_multi[MAX_LEVELS][IMAX][JMAX];
-   double err_multi;
-   int numspin;
-   int spinflag[INPROCS];
-} *multi;
-
-struct locks_struct {
-   int (idlock);
-   int (psiailock);
-   int (psibilock);
-   int (donelock);
-   int (error_lock);
-   int (bar_lock);
-} *locks;
-
-struct bars_struct {
-   int (iteration);
-   int (gsudn);
-   int (p_setup); 
-   int (p_redph); 
-   int (p_soln); 
-   int (p_subph); 
-   int (sl_prini);
-   int (sl_psini);
-   int (sl_onetime);
-   int (sl_phase_1);
-   int (sl_phase_2);
-   int (sl_phase_3);
-   int (sl_phase_4);
-   int (sl_phase_5);
-   int (sl_phase_6);
-   int (sl_phase_7);
-   int (sl_phase_8);
-   int (sl_phase_9);
-   int (sl_phase_10);
-   int (error_barrier);
-} *bars;
-
-void subblock();
-void slave();
-int log_2(int);
-void printerr(char *);
-
-int startcol[2][INPROCS];
-int nprocs = DEFAULT_P;
-int startrow[2][INPROCS];
-double h1 = 1000.0;
-double h3 = 4000.0;
-double h = 5000.0;
-double lf = -5.12e11;
-double eps = 0;
-double res = DEFAULT_R;
-double dtau = DEFAULT_T;
-double f0 = 8.3e-5;
-double beta = 2.0e-11;
-double gpr = 0.02;
-int im = DEFAULT_N;
-int jm;
-double tolerance = DEFAULT_E;
-double eig2;
-double ysca;
-int jmm1;
-double pi;
-double t0 = 0.5e-4 ;
-double outday0 = 1.0;
-double outday1 = 2.0;
-double outday2 = 2.0;
-double outday3 = 2.0;
-double factjacob;
-double factlap;
-int numlev;
-int minlev;
-int imx[MAX_LEVELS];
-int jmx[MAX_LEVELS];
-double lev_res[MAX_LEVELS];
-double lev_tol[MAX_LEVELS];
-double maxwork = 10000.0;
-
-struct Global_Private {
-  char pad[PAGE_SIZE];
-  double multi_time;
-  double total_time;
-  int rel_start_x[MAX_LEVELS];
-  int rel_start_y[MAX_LEVELS];
-  int rel_num_x[MAX_LEVELS];
-  int rel_num_y[MAX_LEVELS];
-  int eist[MAX_LEVELS];
-  int ejst[MAX_LEVELS];
-  int oist[MAX_LEVELS];
-  int ojst[MAX_LEVELS];
-  int eiest[MAX_LEVELS];
-  int ejest[MAX_LEVELS];
-  int oiest[MAX_LEVELS];
-  int ojest[MAX_LEVELS];
-  int rlist[MAX_LEVELS];
-  int rljst[MAX_LEVELS];
-  int rlien[MAX_LEVELS];
-  int rljen[MAX_LEVELS];
-  int iist[MAX_LEVELS];
-  int ijst[MAX_LEVELS];
-  int iien[MAX_LEVELS];
-  int ijen[MAX_LEVELS];
-  int pist[MAX_LEVELS];
-  int pjst[MAX_LEVELS];
-  int pien[MAX_LEVELS];
-  int pjen[MAX_LEVELS];
-} *gp;
-
-double i_int_coeff[MAX_LEVELS];
-double j_int_coeff[MAX_LEVELS];
-int xprocs;
-int yprocs;
-int do_stats = 0;
-int do_output = 0;
-
-void main(argc, argv)
-
-int argc;
-char *argv[];
-
-{
-   double s;
-   double st2;
-   int i;
-   int j;
-   int xextra;
-   int xportion;
-   int yextra;
-   int yportion;
-   int lower;
-   double procsqrt;
-   int k;
-   int logtest;
-   double work_multi;
-   int my_num;
-   unsigned int computeend;
-   double min_total;
-   double max_total;
-   double avg_total;
-   double min_multi;
-   double max_multi;
-   double avg_multi;
-   double min_frac;
-   double max_frac;
-   double avg_frac;
-   extern char *optarg;
-   int ch;
-   unsigned int start;
-
-   {long time(); (start) = time(0);}
-
-   while ((ch = getopt(argc, argv, "n:p:e:r:t:soh")) != -1) {
-     switch(ch) {
-     case 'n': im = atoi(optarg);
-               if (im > IMAX) {
-                 printerr("Max grid size exceeded\n");
-                 exit(-1);
-               }
-               if (log_2(im-2) == -1) {
-                 printerr("Grid must be ((power of 2)+2) in each dimension\n");
-                 exit(-1);
-               }
-               break;
-     case 'p': nprocs = atoi(optarg);
-               if (nprocs < 1) {
-                 printerr("P must be >= 1\n");
-                 exit(-1);
-               }
-               if (log_2(nprocs) == -1) {
-                 printerr("P must be a power of 2\n");
-                 exit(-1);
-               }
-               break;
-     case 'e': tolerance = atof(optarg); break;
-     case 'r': res = atof(optarg); break;
-     case 't': dtau = atof(optarg); break;
-     case 's': do_stats = !do_stats; break;
-     case 'o': do_output = !do_output; break;
-     case 'h': printf("Usage: OCEAN <options>\n\n");
-               printf("options:\n");
-               printf("  -nN : Simulate NxN ocean.  N must be (power of 2)+2.\n");
-               printf("  -pP : P = number of processors.  P must be power of 2.\n");
-               printf("  -eE : E = error tolerance for iterative relaxation.\n");
-               printf("  -rR : R = distance between grid points in meters.\n");
-               printf("  -tT : T = timestep in seconds.\n");
-               printf("  -s  : Print timing statistics.\n");
-               printf("  -o  : Print out relaxation residual values.\n");
-               printf("  -h  : Print out command line options.\n\n");
-               printf("Default: OCEAN -n%1d -p%1d -e%1g -r%1g -t%1g\n",
-                       DEFAULT_N,DEFAULT_P,DEFAULT_E,DEFAULT_R,DEFAULT_T);
-               exit(0);
-               break;
-     }
-   }
-
-   {;}
-
-   logtest = im-2;
-   numlev = 1;
-   while (logtest != 1) {
-     if (logtest%2 != 0) {
-       printerr("Cannot determine number of multigrid levels\n");
-       exit(-1);
-     }
-     logtest = logtest / 2;
-     numlev++;
-   }
-
-   if (numlev > MAX_LEVELS) {
-     printerr("Max grid levels exceeded for multigrid\n");
-     exit(-1);
-   }
-
-   jm = im;
-   printf("\n");
-   printf("Ocean simulation with W-cycle multigrid solver\n");
-   printf("    Processors                         : %1d\n",nprocs);
-   printf("    Grid size                          : %1d x %1d\n",im,jm);
-   printf("    Grid resolution (meters)           : %0.2f\n",res);
-   printf("    Time between relaxations (seconds) : %0.0f\n",dtau);
-   printf("    Error tolerance                    : %0.7g\n",tolerance);
-   printf("\n");
-
-   gp = (struct Global_Private *) malloc((nprocs+1)*sizeof(struct Global_Private));;
-   for (i=0;i<nprocs;i++) {
-     gp[i].multi_time = 0;
-     gp[i].total_time = 0;
-   }
-   global = (struct global_struct *) malloc(sizeof(struct global_struct));;
-   fields = (struct fields_struct *) malloc(sizeof(struct fields_struct));;
-   fields2 = (struct fields2_struct *) malloc(sizeof(struct fields2_struct));;
-   wrk1 = (struct wrk1_struct *) malloc(sizeof(struct wrk1_struct));;
-   wrk3 = (struct wrk3_struct *) malloc(sizeof(struct wrk3_struct));;
-   wrk2 = (struct wrk2_struct *) malloc(sizeof(struct wrk2_struct));;
-   wrk4 = (struct wrk4_struct *) malloc(sizeof(struct wrk4_struct));;
-   wrk6 = (struct wrk6_struct *) malloc(sizeof(struct wrk6_struct));;
-   wrk5 = (struct wrk5_struct *) malloc(sizeof(struct wrk5_struct));;
-   frcng = (struct frcng_struct *) malloc(sizeof(struct frcng_struct));;
-   iter = (struct iter_struct *) malloc(sizeof(struct iter_struct));;
-   guess = (struct guess_struct *) malloc(sizeof(struct guess_struct));;
-   multi = (struct multi_struct *) malloc(sizeof(struct multi_struct));;
-   locks = (struct locks_struct *) malloc(sizeof(struct locks_struct));;
-   bars = (struct bars_struct *) malloc(sizeof(struct bars_struct));;
-
-   {;}
-   {;}
-   {;}
-   {;}
-   {;}
-   {;}
-
-   {;}
-   {;}
-   {;} 
-   {;} 
-   {;} 
-   {;} 
-   {;}
-   {;}
-   {;}
-   {;}
-   {;}
-   {;}
-   {;}
-   {;}
-   {;}
-   {;}
-   {;}
-   {;}
-   {;}
-   {;}
-
-   imx[numlev-1] = im;
-   jmx[numlev-1] = jm;
-   lev_res[numlev-1] = res;
-   lev_tol[numlev-1] = tolerance;
-   multi->err_multi = 0.0;
-   multi->numspin = 0;
-   for (i=0;i<nprocs;i++) {
-     multi->spinflag[i] = 0;
-   }
-
-   for (i=numlev-2;i>=0;i--) {
-     imx[i] = ((imx[i+1] - 2) / 2) + 2;
-     jmx[i] = ((jmx[i+1] - 2) / 2) + 2;
-     lev_res[i] = lev_res[i+1] * 2;
-   }
-
-   xprocs = 0;
-   yprocs = 0;
-   procsqrt = sqrt((double) nprocs);
-   j = (int) procsqrt;
-   while ((xprocs == 0) && (j > 0)) {
-     k = nprocs / j;
-     if (k * j == nprocs) {
-       if (k > j) {
-         xprocs = j;
-         yprocs = k;
-       } else {
-         xprocs = k;
-         yprocs = j;
-       }
-     }
-     j--;
-   }
-   if (xprocs == 0) {
-     printerr("Could not find factors for subblocking\n");
-     exit(-1);
-   }
-
-/* Determine starting coord and number of points to process in     */
-/* each direction                                                  */
-
-   for (i=0;i<numlev;i++) {
-     xportion = (jmx[i] - 2) / xprocs;
-     xextra = (jmx[i] - 2) % xprocs;
-     for (j=0;j<xprocs;j++) {
-       if (xextra == 0) {
-         for (k=0;k<yprocs;k++) {
-           gp[k*xprocs+j].rel_start_x[i] = j * xportion + 1;
-           gp[k*xprocs+j].rel_num_x[i] = xportion;
-         }
-       } else {
-         if (j + 1 > xextra) {
-           for (k=0;k<yprocs;k++) {
-             lower = xextra * (xportion + 1);
-             gp[k*xprocs+j].rel_start_x[i] = lower + (j - xextra) * xportion + 1;
-             gp[k*xprocs+j].rel_num_x[i] = xportion;
-           }
-         } else {
-           for (k=0;k<yprocs;k++) {
-             gp[k*xprocs+j].rel_start_x[i] = j * (xportion + 1) + 1;
-             gp[k*xprocs+j].rel_num_x[i] = xportion + 1;
-           }
-         }
-       }
-     }
-     yportion = (imx[i] - 2) / yprocs;
-     yextra = (imx[i] - 2) % yprocs;
-     for (j=0;j<yprocs;j++) {
-       if (yextra == 0) {
-         for (k=0;k<xprocs;k++) {
-           gp[j*xprocs+k].rel_start_y[i] = j * yportion + 1;
-           gp[j*xprocs+k].rel_num_y[i] = yportion;
-         }
-       } else {
-         if (j + 1 > yextra) {
-           for (k=0;k<xprocs;k++) {
-             lower = yextra * (yportion + 1);
-             gp[j*xprocs+k].rel_start_y[i] = lower + (j - yextra) * yportion + 1;
-             gp[j*xprocs+k].rel_num_y[i] = yportion;
-           }
-         } else {
-           for (k=0;k<xprocs;k++) {
-             gp[j*xprocs+k].rel_start_y[i] = j * (yportion + 1) + 1;
-             gp[j*xprocs+k].rel_num_y[i] = yportion + 1;
-           }
-         }
-       }
-     }
-   }
-
-   i_int_coeff[0] = 0.0;
-   j_int_coeff[0] = 0.0;
-   for (i=0;i<numlev;i++) {
-     i_int_coeff[i] = 1.0/(imx[i]-1);
-     j_int_coeff[i] = 1.0/(jmx[i]-1);
-   }
-
-   for (my_num=0;my_num<nprocs;my_num++) {
-     for (i=0;i<numlev;i++) {
-       gp[my_num].rlist[i] = gp[my_num].rel_start_y[i];
-       gp[my_num].rljst[i] = gp[my_num].rel_start_x[i];
-       gp[my_num].rlien[i] = gp[my_num].rlist[i] + gp[my_num].rel_num_y[i] - 1;
-       gp[my_num].rljen[i] = gp[my_num].rljst[i] + gp[my_num].rel_num_x[i] - 1;
-       gp[my_num].iist[i] = gp[my_num].rel_start_y[i];
-       gp[my_num].ijst[i] = gp[my_num].rel_start_x[i];
-       gp[my_num].iien[i] = gp[my_num].iist[i] + gp[my_num].rel_num_y[i] - 1;
-       gp[my_num].ijen[i] = gp[my_num].ijst[i] + gp[my_num].rel_num_x[i] - 1;
-       gp[my_num].pist[i] = gp[my_num].rel_start_y[i];
-       gp[my_num].pjst[i] = gp[my_num].rel_start_x[i];
-       gp[my_num].pien[i] = gp[my_num].pist[i] + gp[my_num].rel_num_y[i] - 1;
-       gp[my_num].pjen[i] = gp[my_num].pjst[i] + gp[my_num].rel_num_x[i] - 1;
-  
-       if (gp[my_num].pist[i] == 1) {
-         gp[my_num].pist[i] = 0;
-       }
-       if (gp[my_num].pjst[i] == 1) {
-         gp[my_num].pjst[i] = 0;
-       }
-       if (gp[my_num].pien[i] == imx[i] - 2) {
-         gp[my_num].pien[i] = imx[i]-1;
-       }
-       if (gp[my_num].pjen[i] == jmx[i] - 2) {
-         gp[my_num].pjen[i] = jmx[i]-1;
-       }
-
-       if (gp[my_num].rlist[i] % 2 == 0) {
-         gp[my_num].eist[i] = gp[my_num].rlist[i];
-         gp[my_num].oist[i] = gp[my_num].rlist[i] + 1;
-       } else {
-         gp[my_num].eist[i] = gp[my_num].rlist[i] + 1;
-         gp[my_num].oist[i] = gp[my_num].rlist[i];
-       }
-       if (gp[my_num].rljst[i] % 2 == 0) {
-         gp[my_num].ejst[i] = gp[my_num].rljst[i];
-         gp[my_num].ojst[i] = gp[my_num].rljst[i] + 1;
-       } else {
-         gp[my_num].ejst[i] = gp[my_num].rljst[i] + 1;
-         gp[my_num].ojst[i] = gp[my_num].rljst[i];
-       }
-       if (gp[my_num].rlien[i] == imx[i]-2) {
-         gp[my_num].rlien[i] = gp[my_num].rlien[i] - 1;
-         if (gp[my_num].rlien[i] % 2 == 0) {
-           gp[my_num].ojest[i] = gp[my_num].ojst[i];
-           gp[my_num].ejest[i] = gp[my_num].ejst[i];
-         } else {
-           gp[my_num].ojest[i] = gp[my_num].ejst[i];
-           gp[my_num].ejest[i] = gp[my_num].ojst[i];
-         }
-       }
-       if (gp[my_num].rljen[i] == jmx[i]-2) {
-         gp[my_num].rljen[i] = gp[my_num].rljen[i] - 1;
-         if (gp[my_num].rljen[i] % 2 == 0) {
-           gp[my_num].oiest[i] = gp[my_num].oist[i];
-           gp[my_num].eiest[i] = gp[my_num].eist[i];
-         } else {
-           gp[my_num].oiest[i] = gp[my_num].eist[i];
-           gp[my_num].eiest[i] = gp[my_num].oist[i];
-         }
-       }
-     }
-   }
-
-/* initialize constants and variables
-
-   id is a global shared variable that has fetch-and-add operations
-   performed on it by processes to obtain their pids.   */
-
-   global->id = 0;
-   global->psibi = 0.0;
-   pi = atan(1.0);
-   pi = 4.*pi;
-
-   factjacob = -1./(12.*res*res);
-   factlap = 1./(res*res);
-   eig2 = -h*f0*f0/(h1*h3*gpr);
-   jmm1 = jm-1 ;
-   ysca = ((double) jmm1)*res ;
-   for (i=0;i<im;i++) {
-     for (j=0;j<jm;j++) {
-       guess->oldga[i][j] = 0.0;
-       guess->oldgb[i][j] = 0.0;
-     }
-   }
-
-   for (i=1;i<nprocs;i++) {
-     {fprintf(stderr, "No more processors -- this is a uniprocessor version!\n"); exit(-1);}
-   }
-
-   if (do_output) {
-     printf("                       MULTIGRID OUTPUTS\n");
-   }
-
-   slave();
-   {;}
-   {long time(); (computeend) = time(0);}
-
-   printf("\n");
-   printf("                       PROCESS STATISTICS\n");
-   printf("                  Total          Multigrid         Multigrid\n");
-   printf(" Proc             Time             Time            Fraction\n");
-   printf("    0   %15.0f    %15.0f        %10.3f\n",
-          gp[0].total_time,gp[0].multi_time,
-          gp[0].multi_time/gp[0].total_time);
-
-   if (do_stats) {
-     min_total = max_total = avg_total = gp[0].total_time;
-     min_multi = max_multi = avg_multi = gp[0].multi_time;
-     min_frac = max_frac = avg_frac = gp[0].multi_time/gp[0].total_time;
-     for (i=1;i<nprocs;i++) {
-       if (gp[i].total_time > max_total) {
-         max_total = gp[i].total_time;
-       }
-       if (gp[i].total_time < min_total) {
-         min_total = gp[i].total_time;
-       }
-       if (gp[i].multi_time > max_multi) {
-         max_multi = gp[i].multi_time;
-       }
-       if (gp[i].multi_time < min_multi) {
-         min_multi = gp[i].multi_time;
-       }
-       if (gp[i].multi_time/gp[i].total_time > max_frac) {
-         max_frac = gp[i].multi_time/gp[i].total_time;
-       }
-       if (gp[i].multi_time/gp[i].total_time < min_frac) {
-         min_frac = gp[i].multi_time/gp[i].total_time;
-       }
-       avg_total += gp[i].total_time;
-       avg_multi += gp[i].multi_time;
-       avg_frac += gp[i].multi_time/gp[i].total_time;
-     }
-     avg_total = avg_total / nprocs;
-     avg_multi = avg_multi / nprocs;
-     avg_frac = avg_frac / nprocs;
-     for (i=1;i<nprocs;i++) {
-       printf("  %3d   %15.0f    %15.0f        %10.3f\n",
-              i,gp[i].total_time,gp[i].multi_time,
-              gp[i].multi_time/gp[i].total_time);
-     }
-     printf("  Avg   %15.0f    %15.0f        %10.3f\n",
-            avg_total,avg_multi,avg_frac);
-     printf("  Min   %15.0f    %15.0f        %10.3f\n",
-            min_total,min_multi,min_frac);
-     printf("  Max   %15.0f    %15.0f        %10.3f\n",
-            max_total,max_multi,max_frac);
-   }
-   printf("\n");
-
-   global->starttime = start;
-   printf("                       TIMING INFORMATION\n");
-   printf("Start time                        : %16d\n",
-           global->starttime);
-   printf("Initialization finish time        : %16d\n",
-           global->trackstart);
-   printf("Overall finish time               : %16d\n",
-           computeend);
-   printf("Total time with initialization    : %16d\n",
-           computeend-global->starttime);
-   printf("Total time without initialization : %16d\n",
-           computeend-global->trackstart);
-   printf("    (excludes first timestep)\n");
-   printf("\n");
-
-   {exit(0);}
-}
-
-int log_2(number)
-
-int number;
-
-{
-  int cumulative = 1;
-  int out = 0;
-  int done = 0;
-
-  while ((cumulative < number) && (!done) && (out < 50)) {
-    if (cumulative == number) {
-      done = 1;
-    } else {
-      cumulative = cumulative * 2;
-      out ++;
-    }
-  }
-
-  if (cumulative == number) {
-    return(out);
-  } else {
-    return(-1);
-  }
-}
-
-void printerr(s)
-
-char *s;
-
-{
-  fprintf(stderr,"ERROR: %s\n",s);
-}
-
diff -Naur splash2/codes/apps/ocean/non_contiguous_partitions/main.C splash2-modified/codes/apps/ocean/non_contiguous_partitions/main.C
--- splash2/codes/apps/ocean/non_contiguous_partitions/main.C	1994-10-15 00:06:43.000000000 -0400
+++ splash2-modified/codes/apps/ocean/non_contiguous_partitions/main.C	2007-03-19 23:50:53.000000000 -0400
@@ -23,11 +23,14 @@
 /*                                                                       */
 /*************************************************************************/
 
-MAIN_ENV
-
 #include <stdio.h>
 #include <math.h>
 #include <time.h>
+#include <stdlib.h>
+#include "decs.h"
+
+MAIN_ENV
+
 #define DEFAULT_N      258
 #define DEFAULT_P        1
 #define DEFAULT_E        1e-7
@@ -39,117 +42,25 @@
 #define MAX_LEVELS       9
 #define PAGE_SIZE     4096
 
-struct global_struct {
-   int id;
-   int starttime;
-   int trackstart;
-   double psiai;
-   double psibi;
-} *global;
-
-struct fields_struct {
-   double psi[2][IMAX][JMAX];
-   double psim[2][IMAX][JMAX];
-} *fields;
-  
-struct fields2_struct {
-   double psium[IMAX][JMAX];
-   double psilm[IMAX][JMAX];
-} *fields2;
-
-struct wrk1_struct {
-   double psib[IMAX][JMAX];
-   double ga[IMAX][JMAX];
-   double gb[IMAX][JMAX];
-} *wrk1;
-
-struct wrk3_struct {
-   double work1[2][IMAX][JMAX];
-   double work2[IMAX][JMAX];
-} *wrk3;
-
-struct wrk2_struct {
-   double work3[IMAX][JMAX];
-   double f[IMAX];
-} *wrk2;
-
-struct wrk4_struct {
-   double work4[2][IMAX][JMAX];
-   double work5[2][IMAX][JMAX];
-} *wrk4;
-
-struct wrk6_struct {
-   double work6[IMAX][JMAX];
-} *wrk6;
-
-struct wrk5_struct {
-   double work7[2][IMAX][JMAX];
-   double temparray[2][IMAX][JMAX];
-} *wrk5;
-
-struct frcng_struct {
-   double tauz[IMAX][JMAX];
-} *frcng;
-
-struct iter_struct {
-   int notdone;
-   double work8[IMAX][JMAX];
-   double work9[IMAX][JMAX];
-} *iter;
-
-struct guess_struct {
-   double oldga[IMAX][JMAX];
-   double oldgb[IMAX][JMAX];
-} *guess;
-
-struct multi_struct {
-   double q_multi[MAX_LEVELS][IMAX][JMAX];
-   double rhs_multi[MAX_LEVELS][IMAX][JMAX];
-   double err_multi;
-   int numspin;
-   int spinflag[INPROCS];
-} *multi;
-
-struct locks_struct {
-   LOCKDEC(idlock)
-   LOCKDEC(psiailock)
-   LOCKDEC(psibilock)
-   LOCKDEC(donelock)
-   LOCKDEC(error_lock)
-   LOCKDEC(bar_lock)
-} *locks;
-
-struct bars_struct {
-   BARDEC(iteration)
-   BARDEC(gsudn)
-   BARDEC(p_setup) 
-   BARDEC(p_redph) 
-   BARDEC(p_soln) 
-   BARDEC(p_subph) 
-   BARDEC(sl_prini)
-   BARDEC(sl_psini)
-   BARDEC(sl_onetime)
-   BARDEC(sl_phase_1)
-   BARDEC(sl_phase_2)
-   BARDEC(sl_phase_3)
-   BARDEC(sl_phase_4)
-   BARDEC(sl_phase_5)
-   BARDEC(sl_phase_6)
-   BARDEC(sl_phase_7)
-   BARDEC(sl_phase_8)
-   BARDEC(sl_phase_9)
-   BARDEC(sl_phase_10)
-   BARDEC(error_barrier)
-} *bars;
-
-void subblock();
-void slave();
-int log_2(int);
-void printerr(char *);
-
-int startcol[2][INPROCS];
-int nprocs = DEFAULT_P;
-int startrow[2][INPROCS];
+struct global_struct *global;
+struct fields_struct *fields;
+struct fields2_struct *fields2;
+struct wrk1_struct *wrk1;
+struct wrk3_struct *wrk3;
+struct wrk2_struct *wrk2;
+struct wrk4_struct *wrk4;
+struct wrk6_struct *wrk6;
+struct wrk5_struct *wrk5;
+struct frcng_struct *frcng;
+struct iter_struct *iter;
+struct guess_struct *guess;
+struct multi_struct *multi;
+struct locks_struct *locks;
+struct bars_struct *bars;
+
+long startcol[2][INPROCS];
+long nprocs = DEFAULT_P;
+long startrow[2][INPROCS];
 double h1 = 1000.0;
 double h3 = 4000.0;
 double h = 5000.0;
@@ -160,12 +71,12 @@
 double f0 = 8.3e-5;
 double beta = 2.0e-11;
 double gpr = 0.02;
-int im = DEFAULT_N;
-int jm;
+long im = DEFAULT_N;
+long jm;
 double tolerance = DEFAULT_E;
 double eig2;
 double ysca;
-int jmm1;
+long jmm1;
 double pi;
 double t0 = 0.5e-4 ;
 double outday0 = 1.0;
@@ -174,72 +85,37 @@
 double outday3 = 2.0;
 double factjacob;
 double factlap;
-int numlev;
-int minlev;
-int imx[MAX_LEVELS];
-int jmx[MAX_LEVELS];
+long numlev;
+long minlev;
+long imx[MAX_LEVELS];
+long jmx[MAX_LEVELS];
 double lev_res[MAX_LEVELS];
 double lev_tol[MAX_LEVELS];
 double maxwork = 10000.0;
 
-struct Global_Private {
-  char pad[PAGE_SIZE];
-  double multi_time;
-  double total_time;
-  int rel_start_x[MAX_LEVELS];
-  int rel_start_y[MAX_LEVELS];
-  int rel_num_x[MAX_LEVELS];
-  int rel_num_y[MAX_LEVELS];
-  int eist[MAX_LEVELS];
-  int ejst[MAX_LEVELS];
-  int oist[MAX_LEVELS];
-  int ojst[MAX_LEVELS];
-  int eiest[MAX_LEVELS];
-  int ejest[MAX_LEVELS];
-  int oiest[MAX_LEVELS];
-  int ojest[MAX_LEVELS];
-  int rlist[MAX_LEVELS];
-  int rljst[MAX_LEVELS];
-  int rlien[MAX_LEVELS];
-  int rljen[MAX_LEVELS];
-  int iist[MAX_LEVELS];
-  int ijst[MAX_LEVELS];
-  int iien[MAX_LEVELS];
-  int ijen[MAX_LEVELS];
-  int pist[MAX_LEVELS];
-  int pjst[MAX_LEVELS];
-  int pien[MAX_LEVELS];
-  int pjen[MAX_LEVELS];
-} *gp;
+struct Global_Private *gp;
 
 double i_int_coeff[MAX_LEVELS];
 double j_int_coeff[MAX_LEVELS];
-int xprocs;
-int yprocs;
-int do_stats = 0;
-int do_output = 0;
-
-void main(argc, argv)
-
-int argc;
-char *argv[];
+long xprocs;
+long yprocs;
+long do_stats = 0;
+long do_output = 0;
 
+int main(int argc, char *argv[])
 {
-   double s;
-   double st2;
-   int i;
-   int j;
-   int xextra;
-   int xportion;
-   int yextra;
-   int yportion;
-   int lower;
+   long i;
+   long j;
+   long xextra;
+   long xportion;
+   long yextra;
+   long yportion;
+   long lower;
    double procsqrt;
-   int k;
-   int logtest;
-   double work_multi;
-   int my_num;
-   unsigned int computeend;
+   long k;
+   long logtest;
+   long my_num;
+   unsigned long computeend;
    double min_total;
    double max_total;
    double avg_total;
@@ -250,8 +126,8 @@
    double max_frac;
    double avg_frac;
    extern char *optarg;
-   int ch;
-   unsigned int start;
+   long ch;
+   unsigned long start;
 
    CLOCK(start)
 
@@ -320,8 +196,8 @@
    jm = im;
    printf("\n");
    printf("Ocean simulation with W-cycle multigrid solver\n");
-   printf("    Processors                         : %1d\n",nprocs);
-   printf("    Grid size                          : %1d x %1d\n",im,jm);
+   printf("    Processors                         : %1ld\n",nprocs);
+   printf("    Grid size                          : %1ld x %1ld\n",im,jm);
    printf("    Grid resolution (meters)           : %0.2f\n",res);
    printf("    Time between relaxations (seconds) : %0.0f\n",dtau);
    printf("    Error tolerance                    : %0.7g\n",tolerance);
@@ -355,26 +231,30 @@
    LOCKINIT(locks->error_lock)
    LOCKINIT(locks->bar_lock)
 
-   BARINIT(bars->iteration)
-   BARINIT(bars->gsudn)
-   BARINIT(bars->p_setup) 
-   BARINIT(bars->p_redph) 
-   BARINIT(bars->p_soln) 
-   BARINIT(bars->p_subph) 
-   BARINIT(bars->sl_prini)
-   BARINIT(bars->sl_psini)
-   BARINIT(bars->sl_onetime)
-   BARINIT(bars->sl_phase_1)
-   BARINIT(bars->sl_phase_2)
-   BARINIT(bars->sl_phase_3)
-   BARINIT(bars->sl_phase_4)
-   BARINIT(bars->sl_phase_5)
-   BARINIT(bars->sl_phase_6)
-   BARINIT(bars->sl_phase_7)
-   BARINIT(bars->sl_phase_8)
-   BARINIT(bars->sl_phase_9)
-   BARINIT(bars->sl_phase_10)
-   BARINIT(bars->error_barrier)
+#if defined(MULTIPLE_BARRIERS)
+   BARINIT(bars->iteration, nprocs)
+   BARINIT(bars->gsudn, nprocs)
+   BARINIT(bars->p_setup, nprocs)
+   BARINIT(bars->p_redph, nprocs)
+   BARINIT(bars->p_soln, nprocs)
+   BARINIT(bars->p_subph, nprocs)
+   BARINIT(bars->sl_prini, nprocs)
+   BARINIT(bars->sl_psini, nprocs)
+   BARINIT(bars->sl_onetime, nprocs)
+   BARINIT(bars->sl_phase_1, nprocs)
+   BARINIT(bars->sl_phase_2, nprocs)
+   BARINIT(bars->sl_phase_3, nprocs)
+   BARINIT(bars->sl_phase_4, nprocs)
+   BARINIT(bars->sl_phase_5, nprocs)
+   BARINIT(bars->sl_phase_6, nprocs)
+   BARINIT(bars->sl_phase_7, nprocs)
+   BARINIT(bars->sl_phase_8, nprocs)
+   BARINIT(bars->sl_phase_9, nprocs)
+   BARINIT(bars->sl_phase_10, nprocs)
+   BARINIT(bars->error_barrier, nprocs)
+#else
+   BARINIT(bars->barrier, nprocs)
+#endif
 
    imx[numlev-1] = im;
    jmx[numlev-1] = jm;
@@ -395,7 +275,7 @@
    xprocs = 0;
    yprocs = 0;
    procsqrt = sqrt((double) nprocs);
-   j = (int) procsqrt;
+   j = (long) procsqrt;
    while ((xprocs == 0) && (j > 0)) {
      k = nprocs / j;
      if (k * j == nprocs) {
@@ -487,7 +367,7 @@
        gp[my_num].pjst[i] = gp[my_num].rel_start_x[i];
        gp[my_num].pien[i] = gp[my_num].pist[i] + gp[my_num].rel_num_y[i] - 1;
        gp[my_num].pjen[i] = gp[my_num].pjst[i] + gp[my_num].rel_num_x[i] - 1;
-  
+
        if (gp[my_num].pist[i] == 1) {
          gp[my_num].pist[i] = 0;
        }
@@ -560,25 +440,19 @@
      }
    }
 
-   for (i=1;i<nprocs;i++) {
-     CREATE(slave)
-   }
-
    if (do_output) {
      printf("                       MULTIGRID OUTPUTS\n");
    }
 
-   slave();
-   WAIT_FOR_END(nprocs-1)
+   CREATE(slave, nprocs);
+   WAIT_FOR_END(nprocs);
    CLOCK(computeend)
 
    printf("\n");
    printf("                       PROCESS STATISTICS\n");
    printf("                  Total          Multigrid         Multigrid\n");
    printf(" Proc             Time             Time            Fraction\n");
-   printf("    0   %15.0f    %15.0f        %10.3f\n",
-          gp[0].total_time,gp[0].multi_time,
-          gp[0].multi_time/gp[0].total_time);
+   printf("    0   %15.0f    %15.0f        %10.3f\n", gp[0].total_time,gp[0].multi_time, gp[0].multi_time/gp[0].total_time);
 
    if (do_stats) {
      min_total = max_total = avg_total = gp[0].total_time;
@@ -611,45 +485,32 @@
      avg_multi = avg_multi / nprocs;
      avg_frac = avg_frac / nprocs;
      for (i=1;i<nprocs;i++) {
-       printf("  %3d   %15.0f    %15.0f        %10.3f\n",
-              i,gp[i].total_time,gp[i].multi_time,
-              gp[i].multi_time/gp[i].total_time);
+       printf("  %3ld   %15.0f    %15.0f        %10.3f\n", i, gp[i].total_time, gp[i].multi_time, gp[i].multi_time/gp[i].total_time);
      }
-     printf("  Avg   %15.0f    %15.0f        %10.3f\n",
-            avg_total,avg_multi,avg_frac);
-     printf("  Min   %15.0f    %15.0f        %10.3f\n",
-            min_total,min_multi,min_frac);
-     printf("  Max   %15.0f    %15.0f        %10.3f\n",
-            max_total,max_multi,max_frac);
+     printf("  Avg   %15.0f    %15.0f        %10.3f\n", avg_total,avg_multi,avg_frac);
+     printf("  Min   %15.0f    %15.0f        %10.3f\n", min_total,min_multi,min_frac);
+     printf("  Max   %15.0f    %15.0f        %10.3f\n", max_total,max_multi,max_frac);
    }
    printf("\n");
 
    global->starttime = start;
    printf("                       TIMING INFORMATION\n");
-   printf("Start time                        : %16d\n",
-           global->starttime);
-   printf("Initialization finish time        : %16d\n",
-           global->trackstart);
-   printf("Overall finish time               : %16d\n",
-           computeend);
-   printf("Total time with initialization    : %16d\n",
-           computeend-global->starttime);
-   printf("Total time without initialization : %16d\n",
-           computeend-global->trackstart);
+   printf("Start time                        : %16lu\n", global->starttime);
+   printf("Initialization finish time        : %16lu\n", global->trackstart);
+   printf("Overall finish time               : %16lu\n", computeend);
+   printf("Total time with initialization    : %16lu\n", computeend-global->starttime);
+   printf("Total time without initialization : %16lu\n", computeend-global->trackstart);
    printf("    (excludes first timestep)\n");
    printf("\n");
 
    MAIN_END
 }
 
-int log_2(number)
-
-int number;
-
+long log_2(long number)
 {
-  int cumulative = 1;
-  int out = 0;
-  int done = 0;
+  long cumulative = 1;
+  long out = 0;
+  long done = 0;
 
   while ((cumulative < number) && (!done) && (out < 50)) {
     if (cumulative == number) {
@@ -667,11 +528,7 @@
   }
 }
 
-void printerr(s)
-
-char *s;
-
+void printerr(char *s)
 {
   fprintf(stderr,"ERROR: %s\n",s);
 }
-
diff -Naur splash2/codes/apps/ocean/non_contiguous_partitions/main.o splash2-modified/codes/apps/ocean/non_contiguous_partitions/main.o
--- splash2/codes/apps/ocean/non_contiguous_partitions/main.o	1994-10-15 00:16:46.000000000 -0400
+++ splash2-modified/codes/apps/ocean/non_contiguous_partitions/main.o	1969-12-31 19:00:00.000000000 -0500
@@ -1,66 +0,0 @@
-ELF                        M`    4     (                           "                                                    !           (           0           5           :           ?           D           I            N   $        T   (        Y   ,        _   0        e   4        k   8        p   @        y                                                                           (            0            8            @            H            P            X          @           `           H          P          X          `           h            p            x                                   h          p         x         |            $         $         H    "     H    *           2  `       5  h   H    A     H    M         T         [          d          n      "D    s             x                                        "   D                   "D   d                                                                                        @                              .symtab .shstrtab .strtab .text .rodata .data .bss .options .reginfo .rel.text .rel.rodata .gptab.data .gptab.bss .mdebug  .text .rodata .data .bss global fields fields2 wrk1 wrk3 wrk2 wrk4 wrk6 wrk5 frcng iter guess multi locks bars startcol nprocs startrow h1 h3 h lf eps res dtau f0 beta gpr im jm tolerance eig2 ysca jmm1 pi t0 outday0 outday1 outday2 outday3 factjacob factlap numlev minlev imx jmx lev_res lev_tol maxwork gp i_int_coeff j_int_coeff xprocs yprocs do_stats do_output main time getopt atoi optarg printerr exit log_2 atof printf malloc sqrt atan fprintf __iob slave _gp_disp         <  '  !'    < % T @ % P L H D 8 4 0 	   % P `    &  0%` % 	(% P$Q          & $N-          p .!.(    p!          	     P        "        (         % 	     P  %       	     P                  $ 	     PQ         $ ( 	     P  %       	     P           	     P  @  @%    $ \ 	     P  %       	     P        @ % 	     PQ         $ l 	     P  %       	     P           	     P          !           	     P          !    |       	     P          !    q      B      ,O   j/      B      ,X   c8      $  	     P        $  	     P        $  	     P        $  	     P        $  	     P        $X 	     P        $ 	     P        $ 	     P        $ 	     P        $ 	     P$    %h$l    'p&t  $ )x(|$4       	 $ P   %       	     P      ` %(% 	0% PQ$N      $   &         &1d2           % 	     P$       	     P        pC&  pC% %        +! 
-          $ 	     P$       	     P              $ 	   P        $ 	     P      $ 	     P           	$  P                	$T P                	$ P                	$ P        $ 	       P xx! xx# x  x# y  	%p P      %    D D    %  &1 #p!       !   $cp9*       %  $   	     P<      6R@ % 	"   P<     4@@ 	"   P<     6s``` % 	"   P` %    "   	     P<     4(0 	"   P@ %    "   	     P<     6s  ` % 	"   P@ %    "   	     P` %    "   	     P<     4@H 	"   P<     4@@ 	"   P<     4B 	b   P$     b   	     P$ P    "   	     PDx     "           !     p!    * +   ( x!    $ %   p!  x  < Dp  8!/B@.BDo  <  /! BH      @    %< y  &1 $p!! BL  $ 2*       D0 &1  )           h! !   p(!<@ Dh     D`     $F,A  xC$A  xC$$%  @0%F  %' a  C$a  C +''           F3!   	@  DN  P5 8! D   F $  D@ Dx Dp D    # @%@ !          C `       $a < A                  C   X 
-     b*   @0%  B     `0%  C   $c`             $ 	     P$       	     PDx Dp             %           G     %  &1 $B F '        $ < A         %  H  `      =  % 9     i   0$          Y   p ! # # pp! pp# pp#   q !.x!!     N $B   x ! # # xx! xx# xx#   y 8p!!$!	XG       G*             $k $k *  B     |f* lp# %9   x        ,   0!$      Y   x ! # # xx! xx# xx#   y !/p!!     O $B   p ! # # pp! pp# pp#   q 8x!!$!	XG       G*         =f* ;f*%&     @%          N    ! # # #! ## ##    p!x!!     Y $B   x ! # # xx! xx# xx#   y !/p!!XG       G*           f* @`%  %      $B G        $ < A         H  `      ;  % 7     i   8$      f     x pp! pp# pp# xx! xx# xx# q  y .!!$p!4     o    pp! pp# pp# "! "# "# q   x!!p!|  $B  F*     G        }$k $k *  @     xg* lx# %8              p.8!$  f      8! 8# 8# ! # #    p!x!!'4     x   x /! /# /# xx! xx# xx#   y !p!!)|  $B  F*     G    ;g* 9g*%'     @%      f     x pp! pp# pp# xx! xx# xx# q  y !/!p!4     o    pp! pp# pp# ! # # q   .x!!$p!|  $B  F*     G      g* F`%  $ (* [%   %      /  .       /  .     6<?  <? Dh       D`  !    '.D@ 'FB!D0 $B  D+F(d  F4!    F0b  '.D@ 'FB!D0 $B F4! D+s  r % ' $c F(dK J    F0b% ' $c srJK  %<?Dh D` @  %            % pp! pp# p  p# q .! p!p!O4 pp# pO  p# q .! p!p!O pp# pO  p# q .!!O|Y&1 p! #! %##X   ##  p!!XXO    ! xx! x'.x#N, x  x# y ! x$!x!N4 xx# xNP  x# y ! x$!x!N xx# xNt  x# y !$!N|XP    x! ! %#Y   #  x!!YXNt    .! pp! p'p#O p  p# q .! p!p!O4 pp# pO  p# q .! p!p!O pp# pO  p# q .!!O|Y    p! #! %##X(   ##  p!!XXO    ! xx! x'.x#NL x  x# y !$!N x 
-x! xx# x@  x# y !$!N x 
-x! xx# x@  x# y !$!N(  %  $ pp! pp# pO(  p# q .!!OL  % % $ xx! xx# xNL  x# y !$!E    0  $  xx! xx#E x  x# y !$!N    %   X pp! pp#O p  p# q .!!O    O pp! pp# p  p# q .!!E    0  $  pp! pp#E p  p# q .!!O    %   Y xx! xx#N x  x# y !$!N    N xx! xx# x  x# y !$!E  $  B%  pp! p$p#O p  p# q .!!O    1    x xx!N xx# xN  x# y ! xx!$!N xx# xNT  x# y !  $!x!N xx# xN  x# y ! xx!$!N xx# xNT  x# y !$!E,  $  .$ pp! pp#O, p  p# q .!!O,    1    xx!N xx# xNx  x# y !$!N  N0 #!X ## Xx  ##  p!!X    X0  $ (* >'     %$c  r* 3          O        Y      / .        	     P<@  D8 A  @ D0 H I    F(2D0 D      J K  " #  <D( <@(D8   F"2Dx Dp F"BD@ F*!F"& '  <?DH   F$B* +        -  ,       '  &       )  (   F(1+  *   F*!)  (   F AF,"F,R    F&A$ %      $DP x  FR!  F"A&  #'  <    %  % o  1!  p!!    o  1!  p!!x!   $  $c  d* $B             &1 &*       $ +!           &s&R    @ % 	`(% P$       	      &1  P.*                           $H 	     P           	     P   %       	     P @%    $t 	     P        $x 	     P        $ 	     P        $ 	       Pa`c b  F   D D    $$  	  P                         on    pq *A F.$ $bp     t | p  A xML  &1 F,P<2*E              F(`<    E        C B  F,F"0<    E              F$<    E         p t    F P<    E       p t x |    F( <    E       x |F,s$BpF"  F $ D0 *A F0!    F s    F   )F   $p&RL  @ %#!MLC B  F,Dh D`  l h     X (%    	    X&1  P     h l.* $cp    Dx Dp      	$t P   x |           	$ P   p t           	$ P        $ 	     P `        $ 	  P        9  $%        	     P              	$H P`(%    $t 	     P             $ 	o(# P        9  $.   n(# 	     P        $ 	     P        $ 	     P   %       	     T P 0 4 8 < @ D H L ' ( $   %    (%D  p@  $ %$c  D*       (a 2     D $  `%$     <  '  ! 0%      '  $   	$   '      n:p:e:r:t:soh   Max grid size exceeded
- Grid must be ((power of 2)+2) in each dimension
-    P must be >= 1
- P must be a power of 2
- Usage: OCEAN <options>
-
-    options:
-     -nN : Simulate NxN ocean.  N must be (power of 2)+2.
-   -pP : P = number of processors.  P must be power of 2.
-     -eE : E = error tolerance for iterative relaxation.
-    -rR : R = distance between grid points in meters.
-      -tT : T = timestep in seconds.
-     -s  : Print timing statistics.
-     -o  : Print out relaxation residual values.
-    -h  : Print out command line options.
-
-   Default: OCEAN -n%1d -p%1d -e%1g -r%1g -t%1g
-   Cannot determine number of multigrid levels
-    Max grid levels exceeded for multigrid
- 
-   Ocean simulation with W-cycle multigrid solver
-     Processors                         : %1d
-       Grid size                          : %1d x %1d
-     Grid resolution (meters)           : %0.2f
-     Time between relaxations (seconds) : %0.0f
-     Error tolerance                    : %0.7g
- 
-   Could not find factors for subblocking
- No more processors -- this is a uniprocessor version!
-                         MULTIGRID OUTPUTS
-   
-                          PROCESS STATISTICS
-                    Total          Multigrid         Multigrid
-    Proc             Time             Time            Fraction
-        0   %15.0f    %15.0f        %10.3f
-   %3d   %15.0f    %15.0f        %10.3f
-   Avg   %15.0f    %15.0f        %10.3f
-   Min   %15.0f    %15.0f        %10.3f
-   Max   %15.0f    %15.0f        %10.3f
- 
-                          TIMING INFORMATION
-  Start time                        : %16d
-   Initialization finish time        : %16d
-   Overall finish time               : %16d
-   Total time with initialization    : %16d
-   Total time without initialization : %16d
-       (excludes first timestep)
-  
-   ERROR: %s
-    8  |  |    |  |  |  |  |         |  d    >zH@     @             @@     @@     @     ]e            @     @      ?	$k=yd?zG{      >zH?
-6C-?      @       @       @       @                                                            M     M     >   T  	   \     X  ?     	     	          A	     	          @     !	     !	     B    C  (  !	  8  D  T  	  \    X  B  p  C    @    	        B    C    D     	        B    C  8  E  P  #	  d  E  |  	    E    	    ;	    ;	    <	    <	    	        F    	        F  ,  	  4    0  F  H  	  P    L  F  d  	  l    h  F    	        F    	        F    	        F    	        F    	        F    	  <      	            	  $    (    ,  	  4    8       F  d  C  |  ?    /	    	    !	    	        B    C  <  	  D    @  B  X  C  t  "	  p  !	  x  	      |  F    	        F    	        F    	        !	    F    	        	    	    F     	  4      	    	  $  F  H  	  \    @  #	  D  #	  L  F  h  	  p    l  F    G    6	    G  (  	  ,  G  H  	  L  G  d  	  h  G    	    G    		    G    
-	    G    	    G    	    G    	    G  0  	  4  G  L  	  P  G  h  	  l  G    	    G    	    G  	$  	    	    !	    1	    2	    	    3	  	  #	  	  4	  	  1	  	  2	  	  3	  
-H  9	  
-L  :	  
-P  H  
-x  9	  
-  :	  0  	  8    4  B  L  C  h  9	  l  :	    1	    2	  4  7	  D  8	  p  1	  t  2	  x  7	  `  8	  L  1	  P  2	  |  	    I    '	    &	    	    -	  <  .	  L  	  \  	  l  	  |   	    	    $	    %	    !	  P  !	    	        K	    J    C    <	    	        F    L     >  8  	  @    <  F  T  	  \    X  F  p  	  x    t  F    	        F    	        F    ;	    	        F   $  	   H     (  F   `  	        d  F     	          F     	          F     	     	          F  !  	  !    !  	  !   F  !<  	  !P    !8  	  !D  F  !\  	  !d    !`  F  !|  	  !    !x  	  !  F  !  	  !    !  	  !  F  !  	  !    !  F  !  	  !    !  F  "  C  "  M  "  M  "  K	  "  	  "    "  J  (    ,    0    4    8    <    @    D    H    L    P    T    X    \    `    d                                                    `         $      H         p	      <     I@     ?     @p      <   3  A    H  A    B     C      <   I  D   (&!&!&``` 040A    (F   ! "@   !0    P 3!h ( S(8 f(  S(f 1" "Q0   " &   ##3@3(@3( + P03 !1 F ! '0 x E4&%F0 #&#`&&&    0 X((5!(&( (&$ P000 A"                T                        "D                                   "                                   ,                "D        "D        d        "        D                     ,                    ,                                  	       !   
-                                                       	       !   
-                                     	       !   
-                 main.c main log_2 printerr  /usr/include/math.h  /usr/include/stdio.h  global fields fields2 wrk1 wrk3 wrk2 wrk4 wrk6 wrk5 frcng iter guess multi locks bars startcol nprocs startrow h1 h3 h lf eps res dtau f0 beta gpr im jm tolerance eig2 ysca jmm1 pi t0 outday0 outday1 outday2 outday3 factjacob factlap numlev minlev imx jmx lev_res lev_tol maxwork gp i_int_coeff j_int_coeff xprocs yprocs do_stats do_output main time getopt atoi optarg printerr exit log_2 atof printf malloc sqrt atan fprintf __iob slave   _gp_disp                                                                                                                                         1      
-                         $                                 o          o          o          o          o           o       %   o       *   o       /    o       4   $o       :   (o       ?   ,o       E   0o       K   4o       Q   8o       V   @o       _    O       f   o       o   O       r   O       u   O       w    O       z   (O       ~   0O          8O          @O          HO          PO          XO         @o          `O         Ho         Po         Xo         `o          hO          pO          xO          O          O         ho         po         xo         |o         o         o         o        o         O        `o        ho      '  o      3  o      :  o      A   O      J   O      T            Y          ^          e          j          q  "        z            "D                                                                                                                                             	   
-                                                                      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /   0   1   2   3   4   5   6   7   8   9   :        ;   <   =        >   ?                         @          A                                                                                       B   C       D   E   F           G                                                                                                                       H                                                            4                 	                {                                                             p  "                 !            *`                   )            1                    /            2                    4p            2                     =p           2                    F   	          2  	               P   	          ;                  \p            <@                    hp            <`   8                sp            <                
\ No newline at end of file
diff -Naur splash2/codes/apps/ocean/non_contiguous_partitions/makefile splash2-modified/codes/apps/ocean/non_contiguous_partitions/makefile
--- splash2/codes/apps/ocean/non_contiguous_partitions/makefile	1994-10-12 00:54:18.000000000 -0400
+++ splash2-modified/codes/apps/ocean/non_contiguous_partitions/makefile	1969-12-31 19:00:00.000000000 -0500
@@ -1,36 +0,0 @@
-TARGET = OCEAN
-OBJS = main.o jacobcalc.o laplacalc.o \
-	slave1.o slave2.o multi.o
-CFLAGS = -O2 -Olimit 2000 -w 
-LDFLAGS = -lmpc -lm
-MACROS = ../../../null_macros/c.m4.null
-
-x = *
-
-$(TARGET): $(OBJS)
-	cc $(OBJS) -o $(TARGET) $(LDFLAGS)
-
-.SUFFIXES:
-.SUFFIXES:	.o .c .C .h .H
-
-.H.h: 
-	m4 ${MACROS} $*.H > $*.h
-
-.C.c: 
-	m4 $(MACROS) $*.C > $*.c
-
-.c.o: 
-	cc -c $(CFLAGS) $*.c
-
-.C.o: 
-	m4 $(MACROS) $*.C > $*.c
-	cc -c $(CFLAGS) $*.c
-
-decs.h: decs.H
-jacobcalc.c: decs.h
-main.c: decs.h
-slave1.c: decs.h
-laplacalc.c: decs.h
-multi.c : decs.h
-slave2.c: decs.h
-
diff -Naur splash2/codes/apps/ocean/non_contiguous_partitions/Makefile splash2-modified/codes/apps/ocean/non_contiguous_partitions/Makefile
--- splash2/codes/apps/ocean/non_contiguous_partitions/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ splash2-modified/codes/apps/ocean/non_contiguous_partitions/Makefile	2007-03-12 20:25:58.000000000 -0400
@@ -0,0 +1,13 @@
+TARGET = OCEAN
+OBJS = jacobcalc.o laplacalc.o main.o multi.o slave1.o slave2.o
+
+include ../../../Makefile.config
+
+decs.h: decs.H
+jacobcalc.c: decs.h
+main.c: decs.h
+slave1.c: decs.h
+laplacalc.c: decs.h
+multi.c : decs.h
+slave2.c: decs.h
+
diff -Naur splash2/codes/apps/ocean/non_contiguous_partitions/multi.c splash2-modified/codes/apps/ocean/non_contiguous_partitions/multi.c
--- splash2/codes/apps/ocean/non_contiguous_partitions/multi.c	1994-10-15 00:18:37.000000000 -0400
+++ splash2-modified/codes/apps/ocean/non_contiguous_partitions/multi.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,492 +0,0 @@
-
-/*************************************************************************/
-/*                                                                       */
-/*  Copyright (c) 1994 Stanford University                               */
-/*                                                                       */
-/*  All rights reserved.                                                 */
-/*                                                                       */
-/*  Permission is given to use, copy, and modify this software for any   */
-/*  non-commercial purpose as long as this copyright notice is not       */
-/*  removed.  All other uses, including redistribution in whole or in    */
-/*  part, are forbidden without prior written permission.                */
-/*                                                                       */
-/*  This software is provided with absolutely no warranty and no         */
-/*  support.                                                             */
-/*                                                                       */
-/*************************************************************************/
-
-/* shared memory implementation of the multigrid method
-   implementation uses red-black gauss-seidel relaxation
-   iterations, w cycles, and the method of half-injection for
-   residual computation */ 
-
-#include <stdio.h>
-#include <math.h>
-#include <time.h>
-#include "decs.h"
-
-void multig(int);
-void relax(int,double *,int,int);
-void rescal(int,int);
-void intadd(int,int);
-void putz(int,int);
-
-void multig(my_id)
-
-/* perform multigrid (w cycles)                                     */
-
-int my_id;
-
-{
-   int iter;
-   double wu; 
-   double errp;
-   int m;
-   int minlevel;
-   int flag1;
-   int flag2;
-   int k;
-   int my_num;
-   double wmax;
-   double local_err;
-   double red_local_err;
-   double black_local_err;
-   double g_error;
-   int i;
-   int j;
-
-   flag1 = 0;
-   flag2 = 0;
-   iter = 0;
-   m = numlev-1;
-   wmax = maxwork;
-   minlevel = minlev;
-   my_num = my_id;
-   wu = 0.0;
-   
-   k = m;
-   g_error = 1.0e30;
-   while ((!flag1) && (!flag2)) {
-     errp = g_error;
-     iter++;
-     if (my_num == MASTER) {
-       multi->err_multi = 0.0;
-     }
-
-/* barrier to make sure all procs have finished intadd or rescal   */
-/* before proceeding with relaxation                               */
-
-     {;}  
-
-     relax(k,&red_local_err,RED_ITER,my_num);
-
-/* barrier to make sure all red computations have been performed   */
-
-     {;}  
-
-     relax(k,&black_local_err,BLACK_ITER,my_num);
-
-/* compute max local error from red_local_err and black_local_err  */
-
-     if (red_local_err > black_local_err) {
-       local_err = red_local_err;
-     } else {
-       local_err = black_local_err;
-     }
-
-/* update the global error if necessary                            */
-
-     {;}
-     if (local_err > multi->err_multi) {
-       multi->err_multi = local_err;
-     }
-     {;}
-
-/* a single relaxation sweep at the finest level is one unit of    */
-/* work                                                            */
-
-     wu+=pow((double)4.0,(double)k-m);
-
-/* barrier to make sure all processors have checked local error    */
-
-     {;}  
-
-     g_error = multi->err_multi;
-
-/* barrier to make sure master does not cycle back to top of loop  */
-/* and reset global->err before we read it and decide what to do   */
-
-     {;}  
-
-     if (g_error >= lev_tol[k]) {
-       if (wu > wmax) {
-/* max work exceeded                                               */
-         flag1 = 1;
-         fprintf(stderr,"ERROR: Maximum work limit %0.5f exceeded\n",wmax);
-         exit(-1);
-       } else {
-/* if we have not converged                                        */
-         if ((k != 1) && (g_error/errp >= 0.6) && (k > minlevel)) {  
-/* if need to go to coarser grid                                   */
-           rescal(k,my_num);
-/* transfer residual to rhs of coarser grid                        */
-           lev_tol[k-1] = 0.3 * g_error;
-           k = k-1;
-           putz(k,my_num);
-/* make initial guess on coarser grid zero                         */
-           g_error = 1.0e30;
-         }
-       }
-     } else {
-/* if we have converged at this level                              */
-       if (k == m) {
-/* if finest grid, we are done                                     */
-         flag2 = 1;
-       } else {
-/* else go to next finest grid                                     */
-         intadd(k,my_num);
-         k++;
-         g_error = 1.0e30;
-       }
-     }
-   }
-   if (do_output) {
-     if (my_num == MASTER) {
-       printf("iter %d, level %d, residual norm %12.8e, work = %7.3f\n",
-               iter,k,multi->err_multi,wu);
-     }
-   }
-}
-
-void relax(k,err,color,my_num) 
-
-int k;
-double *err;
-int color;
-int my_num;
-
-/* perform red or black iteration (not both)                    */
-
-{
-   int i;
-   int j;
-   int istart;
-   int jstart;
-   int iend;
-   int jend;
-   int oddistart;
-   int oddjstart;
-   int evenistart;
-   int evenjstart;
-   int oddiendst;
-   int eveniendst;
-   int oddjendst;
-   int evenjendst;
-   int tiend;
-   int tjend;
-   double a;
-   double h;
-   double factor;
-   double maxerr;
-   double newerr;
-   double oldval;
-   double newval;
-   double f1;
-   double f2;
-   double f3;
-   double f4;
-   double ressqr;
-
-   i = 0;
-   j = 0;
-
-   *err = 0.0;
-   h = lev_res[k];
-
-/* points whose sum of row and col -1 is even do a red iteration, */
-/* others do a black				                     */
-
-   evenistart = gp[my_num].eist[k];
-   evenjstart = gp[my_num].ejst[k];
-   oddistart = gp[my_num].oist[k];
-   oddjstart = gp[my_num].ojst[k];
-   eveniendst = gp[my_num].eiest[k];
-   evenjendst = gp[my_num].ejest[k];
-   oddiendst = gp[my_num].oiest[k];
-   oddjendst = gp[my_num].ojest[k];
-
-   iend = gp[my_num].rel_start_y[k] + gp[my_num].rel_num_y[k];
-   jend = gp[my_num].rel_start_x[k] + gp[my_num].rel_num_x[k];
-
-   factor = 4.0 - eig2 * h * h ;
-   maxerr = 0.0;
-   if (color == RED_ITER) {
-     for (i=evenistart;i<iend;i+=2) {
-       for (j=evenjstart;j<jend;j+=2) {
-         a = multi->q_multi[k][i][j+1] + multi->q_multi[k][i][j-1] + 
-	     multi->q_multi[k][i-1][j] + multi->q_multi[k][i+1][j] - 
-	     multi->rhs_multi[k][i][j] ;
-         oldval = multi->q_multi[k][i][j];
-         newval = a / factor;
-         newerr = oldval - newval;
-         multi->q_multi[k][i][j] = newval;
-         if (fabs(newerr) > maxerr) {
-           maxerr = fabs(newerr);
-         }
-       }
-     }
-     for (i=oddistart;i<iend;i+=2) {
-       for (j=oddjstart;j<jend;j+=2) {
-         a = multi->q_multi[k][i][j+1] + multi->q_multi[k][i][j-1] + 
-	     multi->q_multi[k][i-1][j] + multi->q_multi[k][i+1][j] - 
-	     multi->rhs_multi[k][i][j] ;
-         oldval = multi->q_multi[k][i][j];
-         newval = a / factor;
-         newerr = oldval - newval;
-         multi->q_multi[k][i][j] = newval;
-         if (fabs(newerr) > maxerr) {
-           maxerr = fabs(newerr);
-         }
-       }
-     }
-   } else if (color == BLACK_ITER) {
-     for (i=evenistart;i<iend;i+=2) {
-       for (j=oddjstart;j<jend;j+=2) {
-         a = multi->q_multi[k][i][j+1] + multi->q_multi[k][i][j-1] + 
-	     multi->q_multi[k][i-1][j] + multi->q_multi[k][i+1][j] - 
-	     multi->rhs_multi[k][i][j] ;
-         oldval = multi->q_multi[k][i][j];
-         newval = a / factor;
-         newerr = oldval - newval;
-         multi->q_multi[k][i][j] = newval;
-         if (fabs(newerr) > maxerr) {
-           maxerr = fabs(newerr);
-         }
-       }
-     }
-     for (i=oddistart;i<iend;i+=2) {
-       for (j=evenjstart;j<jend;j+=2) {
-         a = multi->q_multi[k][i][j+1] + multi->q_multi[k][i][j-1] + 
-	     multi->q_multi[k][i-1][j] + multi->q_multi[k][i+1][j] - 
-	     multi->rhs_multi[k][i][j] ;
-         oldval = multi->q_multi[k][i][j];
-         newval = a / factor;
-         newerr = oldval - newval;
-         multi->q_multi[k][i][j] = newval;
-         if (fabs(newerr) > maxerr) {
-           maxerr = fabs(newerr);
-         }
-       }
-     }
-   } 
-   *err = maxerr;
-}
-
-void rescal(kf,my_num)
-
-/* perform half-injection to next coarsest level                */
-
-int kf;
-int my_num;
-
-{
-   int ic;
-   int if17;
-   int jf;
-   int jc;
-   int krc;
-   int istart;
-   int iend;
-   int jstart;
-   int jend;
-   int oddiendst;
-   int eveniendst;
-   int oddjendst;
-   int evenjendst;
-   double hf;
-   double hc;
-   double s;
-   double s1;
-   double s2;
-   double s3;
-   double s4;
-   double factor;
-   double h;
-   double int1;
-   double int2;
-   double i_int_factor;
-   double j_int_factor;
-   double int_val;
-
-   krc = kf - 1;
-   hc = lev_res[krc];
-   hf = lev_res[kf];
-
-   istart = gp[my_num].rlist[krc];
-   jstart = gp[my_num].rljst[krc];
-   iend = gp[my_num].rlien[krc];
-   jend = gp[my_num].rljen[krc];
-   iend = gp[my_num].rel_start_y[krc] + gp[my_num].rel_num_y[krc] - 1;
-   jend = gp[my_num].rel_start_x[krc] + gp[my_num].rel_num_x[krc] - 1;
-
-   factor = 4.0 - eig2 * hf * hf;
-
-   if17=2*(istart-1);  
-   for(ic=istart;ic<=iend;ic++) {
-     if17+=2;
-     i_int_factor = ic * i_int_coeff[krc] * 0.5;
-     jf = 2 * (jstart - 1);
-     for(jc=jstart;jc<=jend;jc++) {
-       jf+=2;
-       j_int_factor = jc*j_int_coeff[krc] * 0.5;
-/* method of half-injection uses 2.0 instead of 4.0 */
-       s = multi->q_multi[kf][if17][jf+1] + multi->q_multi[kf][if17][jf-1] + 
-           multi->q_multi[kf][if17-1][jf] + multi->q_multi[kf][if17+1][jf];
-       s1 = 2.0 * (multi->rhs_multi[kf][if17][jf] - s +
-		   factor * multi->q_multi[kf][if17][jf]); 
-       if ((if17 == 2) || (jf ==2)) {
-         s2 = 0;
-       } else {
-         s = multi->q_multi[kf][if17][jf-1] + multi->q_multi[kf][if17][jf-3] + 
-             multi->q_multi[kf][if17-1][jf-2] + multi->q_multi[kf][if17+1][jf-2];
-         s2 = 2.0 * (multi->rhs_multi[kf][if17][jf-2] - s +
-	  	   factor * multi->q_multi[kf][if17][jf-2]); 
-       }
-       if ((if17 == 2) || (jf ==2)) {
-         s3 = 0;
-       } else {
-         s = multi->q_multi[kf][if17-2][jf+1] + multi->q_multi[kf][if17-2][jf-1] + 
-             multi->q_multi[kf][if17-3][jf] + multi->q_multi[kf][if17-1][jf];
-         s3 = 2.0 * (multi->rhs_multi[kf][if17-2][jf] - s +
-		     factor * multi->q_multi[kf][if17-2][jf]); 
-       }
-       if ((if17 == 2) || (jf ==2)) {
-         s4 = 0;
-       } else {
-         s = multi->q_multi[kf][if17-2][jf-1] + multi->q_multi[kf][if17-2][jf-3] + 
-         multi->q_multi[kf][if17-3][jf-2] + multi->q_multi[kf][if17-1][jf-2];
-         s4 = 2.0 * (multi->rhs_multi[kf][if17-2][jf-2] - s +
-		   factor * multi->q_multi[kf][if17-2][jf-2]); 
-       }
-       int1 = j_int_factor*s4 + (1.0-j_int_factor)*s3;
-       int2 = j_int_factor*s2 + (1.0-j_int_factor)*s1;
-       int_val = i_int_factor*int1+(1.0-i_int_factor)*int2;
-       multi->rhs_multi[krc][ic][jc] = i_int_factor*int1+(1.0-i_int_factor)*int2;  
-     }
-   }
-}
-
-void intadd(kc,my_num)
-
-/* perform interpolation and addition to next finest grid       */
-
-int kc;
-int my_num;
-
-{
-   int ic;
-   int if17;
-   int jf;
-   int jc;
-   int i;
-   int kf;
-   int istart;
-   int jstart;
-   int iend;
-   int jend;
-   double a;
-   double am;
-   double hc;
-   double hf;
-   int ifine1;
-   int ifine2;
-   int jfine1;
-   int jfine2;
-   double int1;
-   double int2;
-   double i_int_factor1;
-   double j_int_factor1;
-   double i_int_factor2;
-   double j_int_factor2;
-   double int_val;
-
-   kf = kc + 1;
-   hc = lev_res[kc];
-   hf = lev_res[kf];
-
-   istart = gp[my_num].iist[kc];
-   jstart = gp[my_num].ijst[kc];
-   iend = gp[my_num].iien[kc];
-   jend = gp[my_num].ijen[kc];
-
-   istart = gp[my_num].rel_start_y[kc];
-   jstart = gp[my_num].rel_start_x[kc];
-   iend = gp[my_num].rel_start_y[kc] + gp[my_num].rel_num_y[kc] - 1;
-   jend = gp[my_num].rel_start_x[kc] + gp[my_num].rel_num_x[kc] - 1;
-   if17 = 2*(istart-1);  
-   for(ic=istart;ic<=iend;ic++) {
-
-     if17+=2;
-     ifine1 = if17-1;
-     ifine2 = if17;
-     i_int_factor1= ((imx[kc]-2)-(ic-1)) * (i_int_coeff[kf]);
-     i_int_factor2= ic * i_int_coeff[kf];
-
-     jf = 2*(jstart-1); 
-
-     for(jc=jstart;jc<=jend;jc++) {
-       jf+=2;
-       jfine1 = jf-1;
-       jfine2 = jf;
-       j_int_factor1= ((jmx[kc]-2)-(jc-1)) * (j_int_coeff[kf]);
-       j_int_factor2= jc * j_int_coeff[kf];
-
-       int1 = j_int_factor1*multi->q_multi[kc][ic][jc-1] + 
-	      (1.0-j_int_factor1)*multi->q_multi[kc][ic][jc];
-       int2 = j_int_factor1*multi->q_multi[kc][ic-1][jc-1] + 
-	      (1.0-j_int_factor1)*multi->q_multi[kc][ic-1][jc];
-       multi->q_multi[kf][if17-1][jf-1] += i_int_factor1*int2 + 
-	      (1.0-i_int_factor1)*int1;
-       int2 = j_int_factor1*multi->q_multi[kc][ic+1][jc-1] + 
-	      (1.0-j_int_factor1)*multi->q_multi[kc][ic+1][jc];
-       multi->q_multi[kf][if17][jf-1] += i_int_factor2*int2 + 
-	      (1.0-i_int_factor2)*int1;
-       int1 = j_int_factor2*multi->q_multi[kc][ic][jc+1] + 
-	      (1.0-j_int_factor2)*multi->q_multi[kc][ic][jc];
-       int2 = j_int_factor2*multi->q_multi[kc][ic-1][jc+1] + 
-	      (1.0-j_int_factor2)*multi->q_multi[kc][ic-1][jc];
-       multi->q_multi[kf][if17-1][jf] += i_int_factor1*int2 + 
-	      (1.0-i_int_factor1)*int1;
-       int2 = j_int_factor2*multi->q_multi[kc][ic+1][jc+1] + 
-	      (1.0-j_int_factor2)*multi->q_multi[kc][ic+1][jc];
-       multi->q_multi[kf][if17][jf] += i_int_factor2*int2 + 
-	      (1.0-i_int_factor2)*int1;
-     }
-   }
-}
-
-void putz(k,my_num)
-
-/* initialize a grid to zero in parallel                        */
-
-int k;
-int my_num;
-
-{
-   int i;
-   int j;
-   int istart;
-   int jstart;
-   int iend;
-   int jend;
-
-   istart = gp[my_num].pist[k];
-   jstart = gp[my_num].pjst[k];
-   iend = gp[my_num].pien[k];
-   jend = gp[my_num].pjen[k];
-   for (i=istart;i<=iend;i++) {
-     for (j=jstart;j<=jend;j++) {
-       multi->q_multi[k][i][j] = 0.0;
-     }
-   }
-}
diff -Naur splash2/codes/apps/ocean/non_contiguous_partitions/multi.C splash2-modified/codes/apps/ocean/non_contiguous_partitions/multi.C
--- splash2/codes/apps/ocean/non_contiguous_partitions/multi.C	1994-10-15 00:06:43.000000000 -0400
+++ splash2-modified/codes/apps/ocean/non_contiguous_partitions/multi.C	2007-03-19 23:53:53.000000000 -0400
@@ -17,42 +17,31 @@
 /* shared memory implementation of the multigrid method
    implementation uses red-black gauss-seidel relaxation
    iterations, w cycles, and the method of half-injection for
-   residual computation */ 
+   residual computation */
 
 #include <stdio.h>
 #include <math.h>
 #include <time.h>
+#include <stdlib.h>
 #include "decs.h"
 
-void multig(int);
-void relax(int,double *,int,int);
-void rescal(int,int);
-void intadd(int,int);
-void putz(int,int);
-
-void multig(my_id)
-
 /* perform multigrid (w cycles)                                     */
-
-int my_id;
-
+void multig(long my_id)
 {
-   int iter;
-   double wu; 
+   long iter;
+   double wu;
    double errp;
-   int m;
-   int minlevel;
-   int flag1;
-   int flag2;
-   int k;
-   int my_num;
+   long m;
+   long minlevel;
+   long flag1;
+   long flag2;
+   long k;
+   long my_num;
    double wmax;
    double local_err;
    double red_local_err;
    double black_local_err;
    double g_error;
-   int i;
-   int j;
 
    flag1 = 0;
    flag2 = 0;
@@ -62,7 +51,7 @@
    minlevel = minlev;
    my_num = my_id;
    wu = 0.0;
-   
+
    k = m;
    g_error = 1.0e30;
    while ((!flag1) && (!flag2)) {
@@ -75,14 +64,20 @@
 /* barrier to make sure all procs have finished intadd or rescal   */
 /* before proceeding with relaxation                               */
 
-     BARRIER(bars->error_barrier,nprocs)  
-
+#if defined(MULTIPLE_BARRIERS)
+     BARRIER(bars->error_barrier,nprocs)
+#else
+     BARRIER(bars->barrier,nprocs)
+#endif
      relax(k,&red_local_err,RED_ITER,my_num);
 
 /* barrier to make sure all red computations have been performed   */
 
-     BARRIER(bars->error_barrier,nprocs)  
-
+#if defined(MULTIPLE_BARRIERS)
+     BARRIER(bars->error_barrier,nprocs)
+#else
+     BARRIER(bars->barrier,nprocs)
+#endif
      relax(k,&black_local_err,BLACK_ITER,my_num);
 
 /* compute max local error from red_local_err and black_local_err  */
@@ -108,15 +103,21 @@
 
 /* barrier to make sure all processors have checked local error    */
 
-     BARRIER(bars->error_barrier,nprocs)  
-
+#if defined(MULTIPLE_BARRIERS)
+     BARRIER(bars->error_barrier,nprocs)
+#else
+     BARRIER(bars->barrier,nprocs)
+#endif
      g_error = multi->err_multi;
 
 /* barrier to make sure master does not cycle back to top of loop  */
 /* and reset global->err before we read it and decide what to do   */
 
-     BARRIER(bars->error_barrier,nprocs)  
-
+#if defined(MULTIPLE_BARRIERS)
+     BARRIER(bars->error_barrier,nprocs)
+#else
+     BARRIER(bars->barrier,nprocs)
+#endif
      if (g_error >= lev_tol[k]) {
        if (wu > wmax) {
 /* max work exceeded                                               */
@@ -125,7 +126,7 @@
          exit(-1);
        } else {
 /* if we have not converged                                        */
-         if ((k != 1) && (g_error/errp >= 0.6) && (k > minlevel)) {  
+         if ((k != 1) && (g_error/errp >= 0.6) && (k > minlevel)) {
 /* if need to go to coarser grid                                   */
            rescal(k,my_num);
 /* transfer residual to rhs of coarser grid                        */
@@ -151,38 +152,26 @@
    }
    if (do_output) {
      if (my_num == MASTER) {
-       printf("iter %d, level %d, residual norm %12.8e, work = %7.3f\n",
-               iter,k,multi->err_multi,wu);
+       printf("iter %ld, level %ld, residual norm %12.8e, work = %7.3f\n", iter,k,multi->err_multi,wu);
      }
    }
 }
 
-void relax(k,err,color,my_num) 
-
-int k;
-double *err;
-int color;
-int my_num;
-
 /* perform red or black iteration (not both)                    */
-
+void relax(long k, double *err, long color, long my_num)
 {
-   int i;
-   int j;
-   int istart;
-   int jstart;
-   int iend;
-   int jend;
-   int oddistart;
-   int oddjstart;
-   int evenistart;
-   int evenjstart;
-   int oddiendst;
-   int eveniendst;
-   int oddjendst;
-   int evenjendst;
-   int tiend;
-   int tjend;
+   long i;
+   long j;
+   long iend;
+   long jend;
+   long oddistart;
+   long oddjstart;
+   long evenistart;
+   long evenjstart;
+   long oddiendst;
+   long eveniendst;
+   long oddjendst;
+   long evenjendst;
    double a;
    double h;
    double factor;
@@ -190,11 +179,6 @@
    double newerr;
    double oldval;
    double newval;
-   double f1;
-   double f2;
-   double f3;
-   double f4;
-   double ressqr;
 
    i = 0;
    j = 0;
@@ -222,8 +206,8 @@
    if (color == RED_ITER) {
      for (i=evenistart;i<iend;i+=2) {
        for (j=evenjstart;j<jend;j+=2) {
-         a = multi->q_multi[k][i][j+1] + multi->q_multi[k][i][j-1] + 
-	     multi->q_multi[k][i-1][j] + multi->q_multi[k][i+1][j] - 
+         a = multi->q_multi[k][i][j+1] + multi->q_multi[k][i][j-1] +
+	     multi->q_multi[k][i-1][j] + multi->q_multi[k][i+1][j] -
 	     multi->rhs_multi[k][i][j] ;
          oldval = multi->q_multi[k][i][j];
          newval = a / factor;
@@ -236,8 +220,8 @@
      }
      for (i=oddistart;i<iend;i+=2) {
        for (j=oddjstart;j<jend;j+=2) {
-         a = multi->q_multi[k][i][j+1] + multi->q_multi[k][i][j-1] + 
-	     multi->q_multi[k][i-1][j] + multi->q_multi[k][i+1][j] - 
+         a = multi->q_multi[k][i][j+1] + multi->q_multi[k][i][j-1] +
+	     multi->q_multi[k][i-1][j] + multi->q_multi[k][i+1][j] -
 	     multi->rhs_multi[k][i][j] ;
          oldval = multi->q_multi[k][i][j];
          newval = a / factor;
@@ -251,8 +235,8 @@
    } else if (color == BLACK_ITER) {
      for (i=evenistart;i<iend;i+=2) {
        for (j=oddjstart;j<jend;j+=2) {
-         a = multi->q_multi[k][i][j+1] + multi->q_multi[k][i][j-1] + 
-	     multi->q_multi[k][i-1][j] + multi->q_multi[k][i+1][j] - 
+         a = multi->q_multi[k][i][j+1] + multi->q_multi[k][i][j-1] +
+	     multi->q_multi[k][i-1][j] + multi->q_multi[k][i+1][j] -
 	     multi->rhs_multi[k][i][j] ;
          oldval = multi->q_multi[k][i][j];
          newval = a / factor;
@@ -265,8 +249,8 @@
      }
      for (i=oddistart;i<iend;i+=2) {
        for (j=evenjstart;j<jend;j+=2) {
-         a = multi->q_multi[k][i][j+1] + multi->q_multi[k][i][j-1] + 
-	     multi->q_multi[k][i-1][j] + multi->q_multi[k][i+1][j] - 
+         a = multi->q_multi[k][i][j+1] + multi->q_multi[k][i][j-1] +
+	     multi->q_multi[k][i-1][j] + multi->q_multi[k][i+1][j] -
 	     multi->rhs_multi[k][i][j] ;
          oldval = multi->q_multi[k][i][j];
          newval = a / factor;
@@ -277,31 +261,22 @@
          }
        }
      }
-   } 
+   }
    *err = maxerr;
 }
 
-void rescal(kf,my_num)
-
 /* perform half-injection to next coarsest level                */
-
-int kf;
-int my_num;
-
+void rescal(long kf, long my_num)
 {
-   int ic;
-   int if17;
-   int jf;
-   int jc;
-   int krc;
-   int istart;
-   int iend;
-   int jstart;
-   int jend;
-   int oddiendst;
-   int eveniendst;
-   int oddjendst;
-   int evenjendst;
+   long ic;
+   long if17;
+   long jf;
+   long jc;
+   long krc;
+   long istart;
+   long iend;
+   long jstart;
+   long jend;
    double hf;
    double hc;
    double s;
@@ -310,7 +285,6 @@
    double s3;
    double s4;
    double factor;
-   double h;
    double int1;
    double int2;
    double i_int_factor;
@@ -330,7 +304,7 @@
 
    factor = 4.0 - eig2 * hf * hf;
 
-   if17=2*(istart-1);  
+   if17=2*(istart-1);
    for(ic=istart;ic<=iend;ic++) {
      if17+=2;
      i_int_factor = ic * i_int_coeff[krc] * 0.5;
@@ -339,75 +313,66 @@
        jf+=2;
        j_int_factor = jc*j_int_coeff[krc] * 0.5;
 /* method of half-injection uses 2.0 instead of 4.0 */
-       s = multi->q_multi[kf][if17][jf+1] + multi->q_multi[kf][if17][jf-1] + 
+       s = multi->q_multi[kf][if17][jf+1] + multi->q_multi[kf][if17][jf-1] +
            multi->q_multi[kf][if17-1][jf] + multi->q_multi[kf][if17+1][jf];
        s1 = 2.0 * (multi->rhs_multi[kf][if17][jf] - s +
-		   factor * multi->q_multi[kf][if17][jf]); 
+		   factor * multi->q_multi[kf][if17][jf]);
        if ((if17 == 2) || (jf ==2)) {
          s2 = 0;
        } else {
-         s = multi->q_multi[kf][if17][jf-1] + multi->q_multi[kf][if17][jf-3] + 
+         s = multi->q_multi[kf][if17][jf-1] + multi->q_multi[kf][if17][jf-3] +
              multi->q_multi[kf][if17-1][jf-2] + multi->q_multi[kf][if17+1][jf-2];
          s2 = 2.0 * (multi->rhs_multi[kf][if17][jf-2] - s +
-	  	   factor * multi->q_multi[kf][if17][jf-2]); 
+	  	   factor * multi->q_multi[kf][if17][jf-2]);
        }
        if ((if17 == 2) || (jf ==2)) {
          s3 = 0;
        } else {
-         s = multi->q_multi[kf][if17-2][jf+1] + multi->q_multi[kf][if17-2][jf-1] + 
+         s = multi->q_multi[kf][if17-2][jf+1] + multi->q_multi[kf][if17-2][jf-1] +
              multi->q_multi[kf][if17-3][jf] + multi->q_multi[kf][if17-1][jf];
          s3 = 2.0 * (multi->rhs_multi[kf][if17-2][jf] - s +
-		     factor * multi->q_multi[kf][if17-2][jf]); 
+		     factor * multi->q_multi[kf][if17-2][jf]);
        }
        if ((if17 == 2) || (jf ==2)) {
          s4 = 0;
        } else {
-         s = multi->q_multi[kf][if17-2][jf-1] + multi->q_multi[kf][if17-2][jf-3] + 
+         s = multi->q_multi[kf][if17-2][jf-1] + multi->q_multi[kf][if17-2][jf-3] +
          multi->q_multi[kf][if17-3][jf-2] + multi->q_multi[kf][if17-1][jf-2];
          s4 = 2.0 * (multi->rhs_multi[kf][if17-2][jf-2] - s +
-		   factor * multi->q_multi[kf][if17-2][jf-2]); 
+		   factor * multi->q_multi[kf][if17-2][jf-2]);
        }
        int1 = j_int_factor*s4 + (1.0-j_int_factor)*s3;
        int2 = j_int_factor*s2 + (1.0-j_int_factor)*s1;
        int_val = i_int_factor*int1+(1.0-i_int_factor)*int2;
-       multi->rhs_multi[krc][ic][jc] = i_int_factor*int1+(1.0-i_int_factor)*int2;  
+       multi->rhs_multi[krc][ic][jc] = i_int_factor*int1+(1.0-i_int_factor)*int2;
      }
    }
 }
 
-void intadd(kc,my_num)
-
 /* perform interpolation and addition to next finest grid       */
-
-int kc;
-int my_num;
-
+void intadd(long kc, long my_num)
 {
-   int ic;
-   int if17;
-   int jf;
-   int jc;
-   int i;
-   int kf;
-   int istart;
-   int jstart;
-   int iend;
-   int jend;
-   double a;
-   double am;
+   long ic;
+   long if17;
+   long jf;
+   long jc;
+   long kf;
+   long istart;
+   long jstart;
+   long iend;
+   long jend;
    double hc;
    double hf;
-   int ifine1;
-   int ifine2;
-   int jfine1;
-   int jfine2;
+   long ifine1;
+   long ifine2;
+   long jfine1;
+   long jfine2;
    double int1;
    double int2;
    double i_int_factor1;
    double j_int_factor1;
    double i_int_factor2;
    double j_int_factor2;
-   double int_val;
 
    kf = kc + 1;
    hc = lev_res[kc];
@@ -422,7 +387,7 @@
    jstart = gp[my_num].rel_start_x[kc];
    iend = gp[my_num].rel_start_y[kc] + gp[my_num].rel_num_y[kc] - 1;
    jend = gp[my_num].rel_start_x[kc] + gp[my_num].rel_num_x[kc] - 1;
-   if17 = 2*(istart-1);  
+   if17 = 2*(istart-1);
    for(ic=istart;ic<=iend;ic++) {
 
      if17+=2;
@@ -431,7 +396,7 @@
      i_int_factor1= ((imx[kc]-2)-(ic-1)) * (i_int_coeff[kf]);
      i_int_factor2= ic * i_int_coeff[kf];
 
-     jf = 2*(jstart-1); 
+     jf = 2*(jstart-1);
 
      for(jc=jstart;jc<=jend;jc++) {
        jf+=2;
@@ -440,44 +405,39 @@
        j_int_factor1= ((jmx[kc]-2)-(jc-1)) * (j_int_coeff[kf]);
        j_int_factor2= jc * j_int_coeff[kf];
 
-       int1 = j_int_factor1*multi->q_multi[kc][ic][jc-1] + 
+       int1 = j_int_factor1*multi->q_multi[kc][ic][jc-1] +
 	      (1.0-j_int_factor1)*multi->q_multi[kc][ic][jc];
-       int2 = j_int_factor1*multi->q_multi[kc][ic-1][jc-1] + 
+       int2 = j_int_factor1*multi->q_multi[kc][ic-1][jc-1] +
 	      (1.0-j_int_factor1)*multi->q_multi[kc][ic-1][jc];
-       multi->q_multi[kf][if17-1][jf-1] += i_int_factor1*int2 + 
+       multi->q_multi[kf][if17-1][jf-1] += i_int_factor1*int2 +
 	      (1.0-i_int_factor1)*int1;
-       int2 = j_int_factor1*multi->q_multi[kc][ic+1][jc-1] + 
+       int2 = j_int_factor1*multi->q_multi[kc][ic+1][jc-1] +
 	      (1.0-j_int_factor1)*multi->q_multi[kc][ic+1][jc];
-       multi->q_multi[kf][if17][jf-1] += i_int_factor2*int2 + 
+       multi->q_multi[kf][if17][jf-1] += i_int_factor2*int2 +
 	      (1.0-i_int_factor2)*int1;
-       int1 = j_int_factor2*multi->q_multi[kc][ic][jc+1] + 
+       int1 = j_int_factor2*multi->q_multi[kc][ic][jc+1] +
 	      (1.0-j_int_factor2)*multi->q_multi[kc][ic][jc];
-       int2 = j_int_factor2*multi->q_multi[kc][ic-1][jc+1] + 
+       int2 = j_int_factor2*multi->q_multi[kc][ic-1][jc+1] +
 	      (1.0-j_int_factor2)*multi->q_multi[kc][ic-1][jc];
-       multi->q_multi[kf][if17-1][jf] += i_int_factor1*int2 + 
+       multi->q_multi[kf][if17-1][jf] += i_int_factor1*int2 +
 	      (1.0-i_int_factor1)*int1;
-       int2 = j_int_factor2*multi->q_multi[kc][ic+1][jc+1] + 
+       int2 = j_int_factor2*multi->q_multi[kc][ic+1][jc+1] +
 	      (1.0-j_int_factor2)*multi->q_multi[kc][ic+1][jc];
-       multi->q_multi[kf][if17][jf] += i_int_factor2*int2 + 
+       multi->q_multi[kf][if17][jf] += i_int_factor2*int2 +
 	      (1.0-i_int_factor2)*int1;
      }
    }
 }
 
-void putz(k,my_num)
-
 /* initialize a grid to zero in parallel                        */
-
-int k;
-int my_num;
-
+void putz(long k, long my_num)
 {
-   int i;
-   int j;
-   int istart;
-   int jstart;
-   int iend;
-   int jend;
+   long i;
+   long j;
+   long istart;
+   long jstart;
+   long iend;
+   long jend;
 
    istart = gp[my_num].pist[k];
    jstart = gp[my_num].pjst[k];
diff -Naur splash2/codes/apps/ocean/non_contiguous_partitions/multi.o splash2-modified/codes/apps/ocean/non_contiguous_partitions/multi.o
--- splash2/codes/apps/ocean/non_contiguous_partitions/multi.o	1994-10-15 00:18:40.000000000 -0400
+++ splash2-modified/codes/apps/ocean/non_contiguous_partitions/multi.o	1969-12-31 19:00:00.000000000 -0500
@@ -1,17 +0,0 @@
-ELF                        #    4     ( 
-                                                                                 %             ,             2    l     8              <       H      D              L      @      R              W  8  `     ^  8       c         j             t              {       H                                                     H             H             $             $                  .symtab .shstrtab .strtab .text .rodata .options .reginfo .rel.text .mdebug  .text .rodata multig numlev maxwork minlev multi relax pow lev_tol fprintf __iob exit rescal putz intadd do_output printf lev_res gp eig2 fabs i_int_coeff j_int_coeff imx jmx _gp_disp       <  '  !' x       H'D   L> l? hF!         ` @ D 8 < p l h d \ X T   $ xD D   < =   % | t 0 4 ( ,  %  %  %%<   F ! D@  FB D D  F & @ F0Uy  <  9!!B@ BD    %'   0% 	@8% t  %  ' $  	@8%     tF,<< E        F `F b  D`  V@!B@BD "!F <    E      !B@ BD  <@Dh  	F i  %  6P!UB@TBD$  tF4 >F E  9    F:<$ E            D D $ $   	$   t$       	     t  /     -    F8   ) p( tp*F&@>    E  #      !        % 	@(% t&    + x* |&1F4T  %@(%0  	1   t  F        	$     % 	@(% t& &1 F      u          <   |@ (%m    p!B@BD     0%$ ,  	  t     |   $ ( , 0 4 8 < @ D H L T X \ ` d h l p x '<  '  !'   pDh D`     ! pp!<@   D(  p    p# p    9  p#'  &  q  .x!F 2X!y|n4oXF BxD  jbic.@!`! sF* H*  6@0%  < I L*  - @8% P X qp! r   p! ! q@  .x!!*8!  F(1 F*! p!! !$F(1   F*# F"t%J K*F2 F F4`<  E      F   q$  *  L*  (*< I   0% l*  - `8% P  !    ! qp! @ q !.x!8!  F(1 F*! !! 
-!$F(1   F*# F"t%J B*F2 F F4`<  E      F   $  *  l*  t  $  pH*  6@0%  < I l*  - `8% P X qp! r   p! ! q@  .x!!*8!  F(1 F*! p!! !$F(1   F*# F"t%J K*F2 F F4`<  E      F   q$  *  l*  (*< I  4 0% L*  - @8% P  !    ! qp! @ q !.x!8!  F(1 F*! !! 
-!$F(1   F*# F"t%J C*F2 F F4`<  E      F   $  *  L*        ' <  '  !'   p! p<@D( p!   p   \ X T P L H D @ < 8 0 4 ( ,   $      p# p    '  & 9  p# q F 2 .x!!yxn0F BkoTx.!D  'v 0@*! %$&$  F*%    x@%p!D D    h d$ $ $ <
- I$	  hD@ '  FA!& <?F$2DH D@  d*$ (%  F(W<?D8   D0   @& `!F<7 yx! z DP   x! &! y@FR!   !   $c p!!F(!<?DX DP H I MLF*4ONDEF,AH F.2I  F*   J !F6A! !$<?F "F*0 F"q       F IHGFF(a HF&"I DEF*@ !F6!!    F BF*0F"      r       F EDIHKJF(!HF*1 IF$p F6A     F QF$0F"      s       F IHKJEDF*AJF$2 KFGF(P F61    F RF( F" D8 D0 F,F20 yx! z F0x! +! y@F$R  !F(  p!x!$ F4!% F:F$R F(F*1 !$p! %k * T     \         $ ( , 0 4 8 < @ D H L P T X '<  '  !' xx! x  x# x  x# H y  ! T P L D @ < 8 4 0 ( ,   $      !f4gy|nX&H!%) `%h! 8@&* %$ %  $    <?  @Dh D`   &%5 /!!y  O  &p#%D  N F!D@ *F&pFB$ % %  F*p      F f% F"g8H!P!N  9  8 D   Fx#%F6D $c  0!F!  0!F4 @p! yx!F4f y !!   F8F0 (!  F8sF0 (! @p!F* yx! y !F0F*r!F* 0!  0!F0F2T @ yx!F2t y   F6dp!!!F8v (!  F*(! @p! yF*x!F* y !!F0T  F0 0!    0! @p! yx! y !!    F2 F8 (!  F2RF8 (! @p!F4 yx! y !F8F4U !F4 0!  0!F0  @F8F0T  y  x!p! y !!F2 (!  F*(! y @x!F*p!F* y !!  F8V  $ F8 $B   dJ $ .     T         $ ( , 0 4 8 < @ D H L P ' X<  '  ! xx! x  x# x  x# y  !!ig(fhL *  b    D D        *  W %P#%J 1L  (!  qp! r m  p! 		! q@  x!!#`!$B    $c %  =  yx! z n  x! 	)! y@  !`! yh!x! z    n  x! 	)! y@  !`!h! yx! z   n  x! 	)! y@  !`!h! yx! z   n  x! 	)! y@  !`!h!% $B   $c  %)  * *         ERROR: Maximum work limit %0.5f exceeded
-   iter %d, level %d, residual norm %12.8e, work = %7.3f
-      F)>Y9?333333?333333                                                       	   4     0       	   <  	   @  	   D  
-	     	      <      	     	    	           ,    T  	  \    `          	                    	    	  4  	  T    D              	    	    	    	  l  	  h  	  <  	  8    <    H  	  l  	  d  	  	H  	  	d  	  	  	            	  d  	  h  	    	    	    	  8    <    P  	    	p	    l      )  "@                   F  h   `                             `   p" 	 h@ 
- ` t`pp  p48$0 !  !Q!4@@AH " "Q   Q   	  `@4000   000  000   000    qp ! 	pA0Q0   	@8(1(B$!1#$  #  !'!&3&  &3( !&h # # # * $ $  $    V@`!HB a18" "B$## "  @"#'  (" "B$##   ("#'    '   Q               t  @       (                   0                 8       D        $  y  :       &  ?     X          8   	  N                            P       ,     	         	                 l        8       `                     $  8     $     	                  ,                    ,                    ,                                  	       !   
-                                     	                              	       !   
-                                     	       !   
-                                     	       !   
-                 multi.c multig relax rescal intadd putz  ./decs.h  /usr/include/math.h  /usr/include/stdio.h   multig numlev maxwork minlev multi relax pow lev_tol fprintf __iob exit rescal putz intadd do_output printf lev_res gp eig2 fabs i_int_coeff j_int_coeff imx jmx    _gp_disp                  )                                               j          )   
-                                                           3                               (                               H                               7                                                                                  #          )          -          5          =           C           H  8         O  8  	       T          [          e          l          t          w          |                                                                                                                                   	       
-                                                                              
-                                                               4                 	                M                              A                                                     !                                 )p                                 2p                               ;   	                           Ep              
-              
\ No newline at end of file
diff -Naur splash2/codes/apps/ocean/non_contiguous_partitions/OCEAN splash2-modified/codes/apps/ocean/non_contiguous_partitions/OCEAN
--- splash2/codes/apps/ocean/non_contiguous_partitions/OCEAN	1994-10-15 00:18:43.000000000 -0400
+++ splash2-modified/codes/apps/ocean/non_contiguous_partitions/OCEAN	1969-12-31 19:00:00.000000000 -0500
@@ -1,250 +0,0 @@
-ELF               @   4 <    4    (        4 @ 4 @ 4                    @  @             p     @ @@ @@                  @ @          p                                     @   @                                               /usr/lib/libc.so.1                                                                   p   8p      p         @    @p    @   
-  %          p     rp   @  p  
-   
-p     p     	p     p  	 @@                          p    p     	                   -f   	       -fn#                libm.so sgi1.0 libc.so.1 sgi1.0 .text .init .fini .data .rdata .sdata .sbss .bss __dso_displacement _DYNAMIC_LINK __elf_header __program_header_table _ftext __start fabs _mcount etext _etext _fdata eps outday1 outday2 edata _edata _fbss startcol startrow __rld_obj_head end _end optarg __iob _environ printf malloc sin sqrt atan fprintf getopt pow exit __readenv_sigfpe atof atoi time main log_2 printerr jacobcalc laplacalc slave slave2 multig relax rescal intadd putz __istart nprocs h1 h3 h lf res dtau f0 beta gpr im tolerance t0 outday0 outday3 maxwork do_stats do_output global fields fields2 wrk1 wrk3 wrk2 wrk4 wrk6 wrk5 frcng iter guess multi locks bars jm eig2 ysca jmm1 pi factjacob factlap numlev minlev imx jmx lev_res lev_tol gp i_int_coeff j_int_coeff xprocs yprocs __Argc __Argv _gp_disp                               ! @         ' A          - A          3            9           @          G 
-0         M 
-0         R           e           s @          @ 4        @         @         @           @         A          A                      (          x                   
-0         
-0         
-0         
-p         
-         8        @                                          %             . @         5 @         < @         @ @         E @         J @          R @         Y @          ] @0         b @@         s @P         x @`         } @p          @        @4        @5H        @5        @=        @D`        @@        Az        A~        A        Ax        A        A                                                        0         8         @         H         P         X       
-  `         h         p                '         /         8         B 
-0       I 
-4       P 
-8       X 
-<       ] 
-@       b 
-D       g 
-H       l 
-L       q 
-P       v 
-T       | 
-X        
-\        
-`        
-d        
-h        p        x                                                                                         H                                 (        ,        0        4                   r       `      L   *             7                   ]   !       C   _          %       k                                              0      	   +   "           Z           i               I         >      .                   :                               X   A      4   '      f                                           #           ,           -       
-                   c   Q   1   R   T   V   U   )   ?   a                           H       E         G       6               K      F   $                                           9       5   B         \                    =          D   3   8   W   (      ;               @   2   &   M   /   d                                   ^   S   o   <       P           N               Y       J                                       q       O                   h                       p               [       m           b                   j   e       g                   l       n                             x! 	4 x! 	4 "x! 	4 #x! 	4 $x! 	4 %x! 	4 &x! 	4 'x! 	4 (x! 	4 )x! 	4 *x! 	4 +x! 	4 ,x! 	4 -x! 	4 .@%     <'w! %  <  '  <!!@$   0!&  <   <!!x<  $  <   <!!|<!9'    % 	%   <  <!9h     	     <  <  <  <    ! (! 0!x|@<!9x       	     <  <!9d @ % 	        ''    %        <'v !' t < % T @ % P L H D 8 4 0 	   % P `\& 0%` % 	(% P$Q    8& $N-        p .!.    p!     p   	     P    "        (       % 	     P  %d     	     P              |$ 	     PQ     $  	     P  %d     	     P      p   	     P  @  @%$  	     P  %d     	     P      |@ % 	     PQ     $ 	     P  %d     	     P      l   	     P        !      l   	     P        !    |  l   	     P        !    q  B      ,O   j/  B      ,X   c8  D$$ 	     P    D$@ 	     P    D$L 	     P    D$ 	     P    D$ 	     P    D$ 	     P    D$0 	     P    D$T 	     P    D$x 	     P    D$ 	     P$%$D'&$ )($       	 $ P   %d     	     P    \` %(% 	0% PQ$NL  $ &       &12         % 	     P$d     	     P        pC&  pC% %        +! 
-      $4 	     P$d     	     P    0D  $\ 	   P    D$` 	     P  D$ 	     P  D   	$ P    D    	$ P    D    	$$ P    D    	$T P    D$ 	       P xx! xx# xHx# y  	%p P  d  %    D D    %  &1 #p!       !   $cp9*       %H$   	     P<  H6R@ % 	"   P< H4@@ 	"   P< H6s``` % 	"   P` % H"   	     P< H4(0 	"   P@ %H"   	     P< H6s  ` % 	"   P@ %H"   	     P` %H"   	     P< H4@H 	"   P< H4@@ 	"   P<  H4B 	b   P$ $Hb   	     P$ P(H"   	     PDx ,"    T     !X   p!\* +   ( x!`$ %   p!$x  < Dp  8!/B@.BDo  <  /! BH      @    %< y  &1 $p!! BL  $ 2*       D0 &1  )    TX   h! !\ p(!<@ Dh     D`     $F,A  xC$A  xC$$%  @0%F  %' a  C$a  C +''     ptPF3!   	@  DN  P5 8! D pF $  D@ Dx Dp D t # @%@ !          C `       $a < A                  C   X 
-     b*   @0%  B     `0%  C   $c`         $ 	     P$d     	     PDx Dp pt        %     TX  G     %  &1 $B F '        $ < A         %  H  `      =  % 9     i   0$          Y   p ! # # pp! pp# pp#   q !.x!!     N $B   x ! # # xx! xx# xx#   y 8p!!$!	XG       G*             $k $k *  B     |f* lp# %9   x        ,   0!$      Y   x ! # # xx! xx# xx#   y !/p!!     O $B   p ! # # pp! pp# pp#   q 8x!!$!	XG       G*         =f* ;f*%&     @%          N    ! # # #! ## ##    p!x!!     Y $B   x ! # # xx! xx# xx#   y !/p!!XG       G*           f* @`%  %      $B G        $ < A         H  `      ;  % 7     i   8$      f     x pp! pp# pp# xx! xx# xx# q  y .!!$p!4     o    pp! pp# pp# "! "# "# q   x!!p!|  $B  F*     G        }$k $k *  @     xg* lx# %8              p.8!$  f      8! 8# 8# ! # #    p!x!!'4     x   x /! /# /# xx! xx# xx#   y !p!!)|  $B  F*     G    ;g* 9g*%'     @%      f     x pp! pp# pp# xx! xx# xx# q  y !/!p!4     o    pp! pp# pp# ! # # q   .x!!$p!|  $B  F*     G      g* F`%  $ (* [%   %h    /  . l    /  .     6<?l<? Dh TXhD`  !    '.D@ 'FB!D0 $B  D+F(d  F4!    F0b  '.D@ 'FB!D0 $B F4! D+s  r % ' $c F(dK J    F0b% ' $c srJK  %<?Dh D` @  %     TX   % pp! pp# p  p# q .! p!p!O4 pp# pO  p# q .! p!p!O pp# pO  p# q .!!O|Y&1 p! #! %##X   ##  p!!XXO    ! xx! x'.x#N, x  x# y ! x$!x!N4 xx# xNP  x# y ! x$!x!N xx# xNt  x# y !$!N|XP    x! ! %#Y   #  x!!YXNt    .! pp! p'p#O p  p# q .! p!p!O4 pp# pO  p# q .! p!p!O pp# pO  p# q .!!O|Y    p! #! %##X(   ##  p!!XXO    ! xx! x'.x#NL x  x# y !$!N x 
-x! xx# x@  x# y !$!N x 
-x! xx# x@  x# y !$!N(  %  $ pp! pp# pO(  p# q .!!OL  % % $ xx! xx# xNL  x# y !$!E    0  $  xx! xx#E x  x# y !$!N    %   X pp! pp#O p  p# q .!!O    O pp! pp# p  p# q .!!E    0  $  pp! pp#E p  p# q .!!O    %   Y xx! xx#N x  x# y !$!N    N xx! xx# x  x# y !$!E  $  B%  pp! p$p#O p  p# q .!!O    1    x xx!N xx# xN  x# y ! xx!$!N xx# xNT  x# y !  $!x!N xx# xN  x# y ! xx!$!N xx# xNT  x# y !$!E,  $  .$ pp! pp#O, p  p# q .!!O,    1    xx!N xx# xNx  x# y !$!N  N0 #!X ## Xx  ##  p!!X    X0  $ (* >'     %$c  r* 3        O        Y      / . T     	     P<@@D8 A  @ D0 H I  F(2D0 D  <J K  " #  <D( <@(D8 DF"2Dx Dp F"BD@ F*!F"& '  <?DH HF$B* +      -  ,     '  &     )  ( F(1+  * F*!)  ( 4F AF,"F,R    F&A$ %    8$DP x  FR!  F"A&  #'  <    %  % o  1!  p!!    o  1!  p!!x!   $  $c  d* $B           &1 &*       $ +!       <&s&R  X@ % 	`(% P$d     	      &1  P.*                     D$ 	     P         	     P   %t     	     P @%D$ 	     P    D$ 	     P    D$D 	     P    D$ 	       Pa`c bF DD D    $  	  P                       on    pq *A F.$ $bp     t | p  A xML  &1 F,P<2*E              F(`<    E        C B  F,F"0<    E              F$<    E         p t    F P<    E       p t x |    F( <    E       x |F,s$BpF"  F $ D0 *A F0!    F s    F   )F $p&R  @ %#!MLC BDF,Dh D`  l h     X (%    	    X&1  P     h l.* $cpDDx Dp      	$ P   x |D       	$< P   p tD       	$d P    D$ 	     P `D  $ 	  P    9  $% D     	     P      D  	$ P`(%D$ 	     P      D $@ 	o(# P    9  $l. Dn(# 	     P    D$ 	     P    D$ 	     P   %d     	     T P 0 4 8 < @ D H L ' ( $   %    (%D  p@  $ %$c  D*       (a 2     D $  `%$     <'SX! 0%<X'  $   	$   '      <'S!' \ X T P L H D @ < 8 0 4 ( ,   $      @ DDh D`    p  c  Dh D` x#     pY       qp! q  !c      $  	    0    y       p !  0$  XN  y   !   x! p!X\ @%'*  %
- %9 PT  *    @%!  x!$ dD !  `  l x!p!TH0! yx! y ! ` d d  qp! q  `.p! d d ` 
-8! `  qp! q .p! $  y@!  dx! y  hp! h!% yx! y /(! !  l `  P! ! !H! tX!' !!h!!7`!   ]  \ {  z wF8 vF:UF6TF<sF6F> rUTF2Y  F:X F4  F2    /  F0 . F4  F. q  p F<c  F.cF8  M  L F*q  F4Rp F,  F*bF<    F('  F2& F.DF:7  F2F<c6 $& F&$BF4$F:fF4$$c%F4EF>%)%J$F>7F*r%k%%F2T F4 F:&F>&1F6&R&s&Dh D`  \XHPT0     @@%*6%J PT$  '*   @%'`#% 1   
-X! x P!% M  L h%J %.    P!% %8 M L M L M L %J  ML`O   !'8  >'*  < @%'`#% 1  X! PY  %  yx! y  !
-p!h%J %9 ( ( PO  %  !   p!!-,O       !   p!!-,O       !   p!!- ,O       !   p!!%/ -,%J   # *  ! @% P#%J 1X   H! qp! q  !% M  L ($B$ (  yx! y  !% $ MLM L$M0L4$B @MLdn   x!%  4 *  2 @% P#%J 1Y   %8! yx! y  !n  %   X!-,$B$   qp! q  !x  %   Yx!n        X!-,o       p N!y  $  x Op!(,$B @ \         $ ( , 0 4 8 < @ D H L P T X '@            <'K !'  4 0 * %       %<@D D  H% &  *   @% #$B 0O  & H E  qp! q  !.P!   !)!IX!R!T!h!gfml% o  n s  r  F,4 F F.     F(R  F,C% F&a$c%k&s&gfgfmlo  F,4 n s  r     F F.     F(R  F,C$cF&a%k&s&fg$  i qp! q  !.P!   !)!IX!R!T!gfedk  F$2 j d e  F*D   F " % $ $c @F2 F(2  %k @F0T&s @& @rsdefgjF&" kfgF*D F 2    F2  F("      F0TrsfgdejF$2 kdeF*D F "    F2 F(2      F0Trsfgd e  jF&" kfgF*D F 2    F2  F("      F0Trs %F$ $	  &     0    *  ! %@#% 1   8 ! pD D   !$c A  @ $B &   D D   !$c & A @ A @ A @ $B  A@ 8N   !D D  '8  B 0 0    *  <%@#% 1   / ! N  $c  !   !"x!$B &  ( X  $c  8!   x!p!X       8!   x!p!X       8!   x!p! X       8!   x!p!& $B   0 *) #      ! % #$B 0O  @! qp! q   !$c    $$   #!    !$c $  $04$ @0 0 <.  x!%  4 *  2 % #$B 0Y   &@! yx! y   !.  $c   !! $$   qp! q   !8  $c   x!.        !! /       p ! 9  $  x p!(,$ @        '              <'D@!'L  \c   t p l h d ` \ X T P L @ D 8 < 0 4 ( ,   $ xd  !! X$ n  Xd 8! 8# 8#      p! x!Y0IET<?D Fx8D D  p!F  D X%  $ % @!%p|F F   $F$0  %X    %  X< D0   F2!   F*@    N  F8x!F2!& $c F&" ( $)  X      *     X0 <              p  9  X%#X       o  p /!  !      $O      Y     x!$Y       . o     /!O    p! !54$ a +	*  ) %	(#$ 0  !   &s !   S& % 3    &s p!         !5 4       p!    % !5 4 &      |y   n!' . C |	*  @ %	(#$ 0   	! y     qp! q !!&s 54S& %  ) x     8!  x!!y     yx! y !!54o     !  !0x! x     8!  x!!% &s &      $ ! 4p#*  . `%/0#$ 0   !  s!    &s !5  4 S$c    $X    s!    &s p!         #!      p! $  $O #!04$c @pX  .!'.  I x %*  C0#$ 0   ! y  x!Y   y ! px!&s S    $Y 3 /     q  p!Y   q x! p! y  x!N   y /! x!   !O    ! p.!   3!X    p! x!$X &s 5(4,    *  A% 	*  9 %	(#$ 0  !    !  8p!x!&    T$c % 4 %  q  p! q x!! q5  4   p! q x!!5 4  q  p! q x!!5 4  q  p! q x!!% & 5 4 $c  &R 	*    X %           !5  4 $pN    Xx# Xn     !  8x!p!p      X    '8  	XN     !p!  XX  % 8 o     /!O    ! p!>x!$  .	*  , %	(#$ 0  !   &s 0x!!   $S& %     &s 0x!!   $      !>x! ( ,      p!!5 04 4  % !p! 8 <3&   |o  '  E	*  C %	(#$ 0   )! o     qp! q !0x!!&s S& %  - o     !  8p!x!!54n     yx! y !0p!!y     qp! q !!>x! $x     8!  x!!p!% &s (,3&  $ ! 9 x%*  20#$ 0  !  o!    &s #!p!   $S$c    % 3   s!    &s p!x!   $      #!p!(0(4      !>!0@0D  $X x!!58P48T$c @ xN  %  O %*  H0#$ 0  ! y  x!X   y /p! x!!&s  S     % 3 3       !Y    p! x!! y5 4   x!Y   y ! px!!5((4(, q  p!Y   q x! p!!50840<   !Y    p! x!!$N &s 58H48L    *  F% 	*  >	(#$ 0   )!    !  x!!>p!&    $T$c %  )    2!  p!!x! q   $  p! q .!x!!5 (4 ,   !  x!!>p! 0 4 y  x! y !#p!!% &  8 <$c   %&R 	*    X           <?  Dh D`    pX  <?Dh  D` '  
-    N     8x!p      XB       E# Xo     qp! q !-,B      X    %  y     yx!Y   y ! px!$ ! )	*  ' %	(#$ 0   	!   &s x!   S& % 3    &s p!         !- ,       p!    % !- , &   |n  %  @	*  > %	(#$ 0   	! n     .!  !p!&s S& %  ) x     qp! q .x!!n     yx! y /!p!o     !  8p!x! x     qp! q .x!!% &s 3&  $ ! 4 x%*  -0#$ 0   !  n!    &s #x!   S$c    '    s!    &s #x!         p!      #x! $  $Y p!043$c @ xO  '  J %*  C0#$ 0  !   !Y    x! p!&s S    '/  /       !O    ! p.!   3!X    p! x!-, q  p!Y   q x! p! y  x!N   y /! x!$N &s (,    *  ?' 	*  9	(#$ 0  !    2!  !x!&    T$c %  %    !  8x!p!      !  8x!p!     !  8x!p!     !  8x!p!% &   4$c   %&R 	*Xd pp! pp# pp#     q ! 8!LC0NxOTh!(!%$P  d  $  0%%a $  '8   `% $ $ &    2*      $'- < A *  %  #$ 0    !  y  x! y !  0! /!    
- /!.   yF"Tx! @ y !p!!"!&s  s& $  i    2!  !  x! !     !.   F"2! @  x!p!!x! q   p! q .!  x! !    !9   qF"2p! @ q 8x!!0!x!   2!  !  x! !    !.   F"T2! @  x!p!!x! q  p! q .!  x! !  !  9   qp! @F" q 8x!!0!x!$ &s &  &R o *$  g *  e%  #$ 0   !<6      p! yx! z 9  x!    y@/p!!!&s & '_S&_$  G<6      ! qp! r 9  p!	    q@.!x!!)_(_    ! qp! r /  p! 
-  q@!!5x!__    ! qp! r 9  p!   q@.!x!!1_0_    ! qp! r /  p!   q@!!5x!$ &s &  __o  <' / 6  *  %  #$ 0   ! d     $!  x!  p! yx! z x!8    y@$!  p!!x!p!&s & WSW$ 3 i d     yx! y p!  ! qp! r p!8   y'& q@x! y !/!p!!'W&Wd     !  p!  ! qp! r p!/   )( q@!  !8x!p!!)W(Wd     yx! y p!  ! qp! r p!8   y+ * q@x! y !/!p!!+W*Wd     !  p!  ! qp! r p!/   10 q@!  !8x!p!!$ &s &  1W0W m    %*  g #$ 0   /!  O!      p! !  9  !    @8p!x!!&R $B3_r2_    '  H  R!      ! yx! z 8  x!%  $  y@!"p!!__    ! yx! z .  x!'& y@!"!p!gg    ! yx! z 8  x!) ($ y@!"p!!	p p    ! yx! z .  x!+0*4 y@!"!p!$o &R $B @xxX  $ 8 <@%*   #$ 0   #.! C    2!   p!   %! qp! r p!/   2! q@  !x!p!!&R _R_    '/  s<@     C    2!   px!  %p! yx! z x!8   2! y@  p!!x!p!__ y  C  x! y p!    %! qp! r p!8   y%$x! q@ y !/!p!!%g$g q  C  p! q ! x  %/x! .!  .!8   qp! @ q x!!!5x!oo   C  2!  x! p  %p! yx! z x!8   (,2! y@  p!!x!p!$Y &R x2x<@DX 4DP 1  0 F0    *F2Q  F$`%  *  % #$B 0N  -!    !  8x!!GFIHK F(4 J H I  F*  F"DED !F$  F02!.   F T2! @  x!p!!x!&s __s& $ 3     !  x!!EDIHQ F(!P H I  F02  F"ASR !F2Q   F&$!9   qF p! @ q 8x!!0!x! __  2!  !!SRIHG F( F H I F&$   F"AK  J  .!F*  F$.!/   qF 4p! @ q !x!!5!__ y  x! y !0!K J$I HE F(TD H I F$  F"DQ P  yx!F02 z F2Qx!8   qF !p! y@ q !.!x!!'_&_   !  x!!Q(P,IHS  F(R $H I   F2Q G F"BF  !  F&$ !F*9   qp! @F  q 8x!!0!x!$ &s __e&  &R . *Xtx 	 ltxL02*  '-  *  %  #$ 0   !   /   .!  .! qp! @ q !x!!5! y  x! y __!0!&s &   S $  e   /   !  ! 2! @  p!x!!p! y  x! y __/!p!     9   !  ! yx! @ y 8p!!0!p!   2!  __!p!    /   !  ! 2! @  p!x!!p! y  x! y __/!p!    9   !  ! yx! @ y 8p!!0!p!   2!  __!p!$ &s &    &R t *XX  
-F   <?D D        F"!F40 p<?  D D %  
-    X     p.x!    F"DF  XB  P   E# Xo     !  !+*    F"TF  Xd  %     $!   px!!    F"!F 0 $ ! 3	*  1 % 	(#$ 0    ! p !&s Y  s     X &s F6Y $B sF  X $B F6F  %    !K  J E F6TD I H J F6!K F  &s % F6DF 0 $B  F6TF  F   |    %  7	*  5 %  y	(#9  $ x! y 0  /0!  !!&s Ys     X&s F6Y$B sF  X$B F6F  % 3  x !IHKF6DJE DHF6TIF  &s % F6!F  $B  F6DF 0 F  $ ! > x %8*  780# $ 0    ! qp! q  !&s Y  s     X &s F6Y$BsF  X $BF6F      '/   !   !E  D IF6!HK J$D4F6DE0F 0 &s $n F6TF  $B @F6!F  F 0  x    '/  B	* %*  ;0# $ 0       yx! y  p!!8 !&s Y     X&s F6Y$BF  X$BF6F      '8   yx! y  p!!    KJEF6TDIHJ,F6!K(F  &s $y F6DF 0 $B @F6TF  3F  	*  9< %  %*  .0# $ 0      8!   x!! !E  D &R $BF       %   2!   x!!    G  F IHF 0 Q P$F @ K0J4F  &R $n $B @F P &  %< c  s r 4  F     %d e X        9    x/p!!@@@Dp    Xp#.  yx! z 8  x!n   y@! !  8x!p!p8084      X q'8  p! r /  p!X   q@! x/p!!@8@<X  '/   $!  8  $!n   @x! !N    ! x/!p!8(8,$ ! J	*  H %	(#$ 0  !  qp! r 8  p! q@!0x!!&s @@@DS& %  1  yx! z 9  x! y@/!p! !!  5@@4@D/  ! @p!!6x! qp! r @H@L8  p! q@!0x!! $!  @P@T.  $! @x!!p!% &s @X@\3&   |o  '  c	*  a %	(#$ 0   )!  yx! z 8  x!y   y@p! !  x!!6p!&s 8084S& %  E  $!  /  $!x   @p! yx! y !0! p!$!  8084/  $!n   @! yx! y !0p!! $!  888</  $!x   @p! yx! y !0!p! $!  8@8D/  $!n   @! yx! y !0p!!% &s 8H8L&  $ ! U x %*  N0#$ 0   !  y!   qp! r /  p! q@!!6x!&s @@@DS$c    %  4  s!   yx! z 9  x! y@/p!! q!p! r 5@@4@D/  p! q@!!6x! !  HPHT.  ! @!#x!p! $!  P`Pd8  $! @x!p!!$Y &s XpXt3$c @ xO  %  m %*  f0#$ 0  ! qp! r 8  p! q@ 3!x!N    ! x!6p!&s @8S@<    '  K     qp! r 9  p! q@ yx!.!N   y ! 8x! p!!  @8@<9  ! @ qp!8x!X   q ! x/p!! yx! z HHHL9  x! y@ !/p!O    ! p.!x! qp! r PXP\9  p! q@ yx!.!N   y ! 8x!p!$Y &s Xh3Xl' *  a	*  \	(#$ 0  !  yx! z 9  x! qp! y@ q /!!#x!!& @@@DT$c %  A  yx! z 9  x! qp! y@ q /!!#x!! $!@@@D  .  $! ! @  x!p!!6x! qp!@H@L r 8  p! yx! q@ y !/!p!! !5@P4@T  /  ! 2! @  p!x!!p!% & @X@\4$c   %&R 	*$ (  X   %X       8    p!5  4 pX  %   $!  .  $!X   @x! p!p54      XB    Ex# $!  .  $!o   @! qp! q !54B      X %  $!  .  $!x   @x! qp!X   q ! x/p!$  E	*  C %	(#$ 0   )!  qp! r /  p! q@!!&s 5  4 S& %  -  !  .  ! @! 0x!!     .  ! @!0x! !    .  ! @!0x! !    .  ! @!0x!% &s   &   |x  '/  ^	*  \ %	(#$ 0  !  !  9  !n   @8x! .!  !p!&s S& %  A  !  9  !o   @8p! /!  ! x!$!  .  $!o   @! qp! q !0x! qp! r 8  p!o   q@! !  8p!x! !   9  !o   @8p! /!  !x!% &s &  $ ! P x %*  I0#$ 0  !  y!   !  .  ! @x!!&s 5  4 S$c    %  0  s!   $!  /  $! @p! !$!     /  $! @p!! $!  /  $! @p!! $!   $/  $! @p!!$O &s 04$c @ xY  % 8 h%*  a0#$ 0   /! qp! r 8  p! q@ yx!!N   y /! x!&s S    %  G     yx! z 9  x! y@ !/p!O    ! p.! $!  /  $! @ !p!Y    x! p! yx! z 9  x! y@ !/p!O    ! p.! $!  /  $! @ !p!Y    x! p!$Y &s (3,% *  \	*  W	(#$ 0   	!  qp! r 9  p! ! q@  .x!!#p!&    T$c %  =  $!  8  $! yx! @ y p!!! yx!5  4  z .  x! 2! y@  !p!x! $!    8  $! yx! @ y p!!! yx!5 4  z .  x! 2! y@  !p!x!% &   $c   %&R 	*$ (  X<?D8 8D0 )  ( F(61  0 @X3  2 F F2Q  F8%             p    X# Xx     yx! y !p54      X    '      <@O  1  D0 0 F2!LF0B3  2 txF2Q 	F8# lF 0  X  t px.x!X  <' . &O  @D@ +  FD!* F*%  $ LtF$x 	F83 l  0C  n    X! yx! y  %)( O!tx!)($  #	*  ! % % D @F3  2 F2Q'  & L F&"tx 	F8CF  l   tx!&s 0&     |y  % / (	*  & % % DP @FT%  $ F$)  ( L F(4tx 	F8 lF   n    .!  x!txp!&s 0& $ ! 4 x %8*  -80#$ 0  !  x!    &s !5  4 S$c    %    s!    &s !5  4       !      !5 4$  $N !04$c @ xY  % 8 a	*N  @D '  F!& F&"1  0 LF0Btx % 	F8S ltx0*  E0#$ 0   #!F  q  p!Y   q x! p!&s S    '/  /	*F  q  p!O   q ! 8p!   3!N    ! x!#"   !Y    x! p! y  x!X   y /p! x!$X &s (,	*  _    % D @F!'  & F&"1  0 L %F0B tx 	F8S l tx0*  ?     0#$ 0  !F  q  p! q x!!&R #  R"     $X  'F  y  x! y !#! y     x! y !#! y  x! y !#! $ y  x! y !#!$N &R 04    &     D D 5 4$<        {X$  :X   % Xtt 	x ltx       XX     %            ! pp! pp#t pp#  t 	x lD txdA F!<AD8 D0     F&! o      !%$x      p! pX|  tx 	  lt!    F  )  F4( x0'8 F"@<    E  DO $ 5 8! D F $$ D F F:>    E           D D     X         9    6!@@
-@DS  R     F2QF G  p    X# Xb     !.    !!6!8084ihpF($ pq      X    %      C    /   !p!!+@8*@<SR    F2QFGX  '  d  C   y  x! y  p!! % 9  !  8x!p!!%8($8,IH    F($ PQ$  Q	*  O %	(#$ 0  ! 9    0!x!!S  R @@@D&s F2Q& F sG  %  7 8    x!p!0!I  H @@@D&s F($ P Q  8    x!p!0!S R @H@L    F2QF G 8    x!p!0!I H @P@T    F($ P Q 8    x!p!0!S R @X@\% F2Q&  F 3G  |x  %  ~	*  | %	(#$ 0   )! d     !  p! y9  x! y !/!p!!%80$84IH&s F($ & PsQ%  [ d     qp! q ! /  !  0!p!!6x!8084SR&s F2QFGd     qp! q ! /  !  0!p!!6x!888<IH    F($ PQd     qp! q ! /  !  0!p!!6x!8@8DS R    F2QFG d     qp! q ! /  !  0!p!!6x!8H8LIH% F($ &  PQ$ ! \ x%.*  U.0#$ 0   !  n!  9    #x!p!!S  R @@@D&s F2Q$cF G      ' 3 :  s!  .    !!!I  H %@@$@D&s F($ P Q  .    !!!SR+HP*HT    F2QFG.    !!!I H$%P`$Pd    F($ P$Q .    !!!S0R4+Xp*Xt$ F2Q$c @F4G0 xX  '/  %%.*  .0#$ 0   : !$ C     ! x  8p!%!/   YX3!  !p!x!@8@<&s F8  YXC    !  8p! x%! /  3!  !p!x!@8@<YX$ F8 &s XY    '8  c     C    3!   p!! y%.  x! y !#!p!@8@<SR F2Q!FG  C    8p! x%! /  3!  !p!x!HHHLIH qF($ p!PQ  C   q x!  %! 9  !  8p!x!!+PX*P\SR yF2Qx!FG  C   y !  %8! q8  p! q x!!6!XhXlI(H,$ F($ &s P,Q(        *  }% 	*  u %	(#$ 0   ) !  q  p! q x! 9  !  !8p!x!!+@@*@DS  R & F2Q$c F G  %  U  y  x! y ! q8  p! q #!x!!6!@@@DI  H  yF($ x!P Q     y ! q8  p! q #!x!!6!@H
-@LS R  yF2Qx!F G    y ! q8  p! q #!x!!6!@P@TI H  yF($ x!P Q    y ! q8  p! q #!x!!6!@X
-@\S R % F2Q& F G $c  &R 	*    X            .  !x!```dI  H $    F($ P $Q  p    Xp#. Xb     yx! y .  !x!!>!srXP
-XTpF2Qfg      X    '.      C     x.  !x!!>!I H `X`\    F($ P Q X  '.  d     qp!C   q .x!  % q9  !p! q !.x!!!+XH*XLSR    F2QFG$  V	*  T %	(#$ 0  !   .  !x!!>!I  H $```d&s F($ & P $sQ  % 3 ;   8  x!!5p!!S  R $```d&s F2QF $G    9  !0p!x!!I (H ,`h`l    F($ P ,Q (  .  !x!!>!S 0R 4`p
-`t    F2QF 4G 0  /  0p!!!!I 8H <%`x$`|% F($ &  P <Q 8 |o  '  	*   %	(#$ 0  ! d     yx! y ! y8  0p!x! y !!0p!!XP
-XTSR&s F2Q& FsG%  _ d     qp! q .! q9  x!p! q !.!x!!%XP$XTIH&s F($ PQd     !  x! .  !!  >!x!!5p!XXX\SR    F2QFGd     yx! y ! y8  0p!x! y !!0p!!X`XdI H$    F($ P$Q d     $!  p! /  !$!  !p!!x!XhXlS(R,% F2Q&  F,3G($ ! a x%*  Z0#$ 0   !  n!    /  #!p!!!I  H $%``$`d&s F($ $cP $Q      '  >  s!    8  !x!p!>!S  R $```d&s F2QF $G    /  #!p!!!I(0H(4%hp$ht    F($ P(4Q(0  .  x!!5!!S0@R0Dp
-p    F2QF0DG0@  9  p!#!x!!I8PH8Txx$ F($ $c @P8TQ8P xX  %   % %*  0#$ 0   < !$  C    !   p!/  %.p! !!  Y X !#p!x!`X`\&s F8  Y X   !C    ! p% /  !.p!  !!#p!x!`X`\Y X $ F8 &s X Y     ' 3 g       !C    ! p% /  !.p!  !!#p!x!`X`\I H  qF($ p!P Q   C   q .x!  % q9  p!! q !.x!!!+hh*hlS((R(, F2Q!F(,G((  C    ! p% /  !.p!  !!#p!x!pxp|I08H0< qF($ p!P0<Q08  C   q .x!  % q9  p!! q !.x!!!+x*xS8HR8L$ F2Q&s F8LG8H        *  % 	*  z %	(#$ 0   	 !  q  p! q .x! q9  p!! q !.x!!!%``$`dI  H $& F($ $c P $Q  %  Y    !  ! /  !#p!  !!#p!x!```dS  R $ F2Q2!F $G      p! 8  2!x!  !p!x!!`h`lI (H , qF($ p!P ,Q (   q .x! q9  p!! q !.x!!!+`p*`tS 0R 4 yF2Qx!F 4G 0   y ! y.  x!! y >!!!5p!`x`|I 8H <% F($ & P <Q 8$c  &R 	*DY +  * 7! 8! D F T$ D D *       X   %@              ! #t # 	   lD0 dF1!  A !<ADH D@     F(! qp    F0"jk t   $ ( , 0 4 8 < @ D L P T X \ ` d h p '     <'`!'xL\   t x p l h d ` \ X T P L @ D 8 < 0 4 ( ,!!  	F  < O  D D !   $p     D D x#/ < X  .  p .!  x!p!      ' % 
-    0O         !6p!  9  0%  /  N   !    ! p.!x!$ ! 2`0%K*  +K8#$ 0   ! X  $ x!!9  8 $$c %N   X  $ x!!9  8 $N      !x! ( ,Y      #p!! 0 4O  %X !6p! 8 <$c  8  p!%  F K*  C`0%K8#$ 0   + ! 8  N   yx! y !#!p!$ $c %O  - 8  Y   qp! q .x!!!98/  N   !  !#x!p!9  X   yx! y p!!6! $.  O   .!  !p!x!%Y $ (,&$c  $ a 9 0%*  28#$ 0  ! !  ! ! Y  $ $p!x!   $f$    $x   !  ! ! Y  $ $p!x!   $X      !6p!(0(4O      !!90@80DN  $y x!!8P8T&$ @  nx!%  Q |0%/*  K/8#$ 0   ! N  &!    ! p!6x!$  f     $x  3     N  &!    x! p!6! q  O  p!   q ! x/p!!(((, yY  x!   y /p! x!!080< N  &!    x! p!6!$o $ 8H8L    D 0*  Q  %'( K*  H`%     8#$ 0   !   q  p! q !#!x!&R    $R$c $  ,     !  8x!p!! y9  8 $  x! y p!!6! ( , q  p! q !#!x! 0 4   0!  !x!p!$ &R  8 <2$c       & K*    D   `% < O      p!@@@Dp    x#/ < N    p 8!  x!!8084      % % 
-$ 0O         p!4!@8@<9  0%    X   qp!   q ! 8p!x!8(8,$ ! 2 0%L*  +L8#$ 0    ! N  $ x!!9@@8@D$c %X   N  $ x!!9@@8@DX      p!x!@H@LY      #!p!@P@TO  %N !4!@X@\$c     '8  EL*  C0%L8#$ 0   !   Y   !  8p!x!!$ 980884$c %X  -   N   /!  !x!p!8084  Y   yx! y /p!!!98888<  O   !  !#p!x!8@8D  X   qp! q x!!4!%N $ 8H8L$c  $  ; |0%o*  4o8#$ 0   /! !  !  ! X  $ p!!9@@8@Df$%o   !  ! ! X  $ p!!9@@8@DO      !p!HPHTY      $x!!P`PdN  %x !4x!XpXt$ @0     |  '/  M    x*  G 0%x8#$ 0   8! yN  x!   y ! p.x!!$ @8f@<%y & / yN  x!   y ! px!! q9@88@<X  p!   q x! p!!9HH8HL O  !    p! x!!9PX8P\ yN  x!   y ! px!!%x $ 9Xh8Xl        n*  O%i L*  G         8#$ 0  !     !  8p!x!!&R 9@@8@DR$c $  ,   y  x! y !#!p! @@@D  0!  !p!x!@H@L   !  8p!x!!9@P8@T q  p! q x!!4!$ &R @X@\$c   %& 0L*      @%               3!   pO    #  yx! z   x!9   y@p! !  x!p       y'.  x!0 z   x!   y@! 8x!X  % 8  qp! r   p!   q@! yx!0 y   /p! x!        !(! 	  l< 4!  D D % a!               Vp!   $E  D 4x!F&"@D@@p    #   B     yx! y ! v!kj/x!F0Tp!p8084          ' %     0       x! V!  ED/x!F&"p!@8@<  ' / 0       %!   px!! % Vp!   %!KJ  x!F0Tp!!8(8,$  ]     @0%"*  W"8#$ 0   !     ! V!   $E  D #x!F&"p!$ @@@D$c     ' & <     ! Vp!   $K  J !F0T4x!@@@D    ! V! ( ,E D #x!F&"p!@H@L    ! V!1 00 4K J p!F0T!@P@T    #! Vx! 8 <E D !F&"!$ $ )@X(@\$c         '  $  @0%*  8#$ 0   !@!      %!  x!! V!   %!KJ  x!F0T!p!$ 8084$c     $ & a      !  p!! V!   !'&ED  p!F&"!4x!8084     qp! q !#! Vx! q  p!KJ q !F0T#x!!888<     %!  x!! V!   %! $E D  x!F&"!p!8@8D     yx! y /!! y   Vp!x! y (,KJ/!F0Tp!!$ $ 38H28L$c      $ A ^     0%*  Y8#$ 0  ! !  ! !     $! Vx!   $E  D p!F&"!$ )@@(@Df$    %  < !  ! !     ! V!1  0 $K  J !F0Tp!@@@D    $! Vx!(0(4EDp!F&"!)HP(HT    ! V!0@0DK J$!F0T4x!P`Pd    ! Vp!8P8TE0D4$x!F&"!$n $ 	XpXt$ @0 |9  % 8  0%*  8#$ 0  "    0(!d   q  p! q  x!!  % V! q  p!1 0 KJ q x!F0T!4!$ @8@<    $  h0    d     !   x8p!! % Vx!   !  ED  8p!F&"x!!)@8(@<d   y  x! y  !8!  % V! y  x!(((,KJ y !F0T$!p!HHHLd     !   x8p!! % Vx!   !080<ED  8p!F&"x!!)PX(P\ y  d  x! y ! 8!  % y  x! V! y 8H8LK(J,!F0T$!p!$ $ XhXl        %*      '%     *  8#$ 0   !    0!  !! Vp!   0!   $E  D   !F&"p!x!&R @@@D$c     '8  \  y  x! y !#! V! y  x!   $K  J  y !F0T#!p! @@@D  0!  !! Vp!   0! ( ,E D   !F&"p!x!@H@L   !  8p!! Vx!   ! 0 4K J   8p!F0Tx!!3@P2@T q  p! q x!! q  p! V! q ' 8& <E D x!F&"!4!$ &R 	@X@\$c       @%& {    !        +  * F U1  0   F    V!   $G  F6F   F&F("   p  9  %#   B     qp! q .! vx!gF6fp!pF&F$           '/      0       ! V!+ * GF6TF!F&F2   % / 0       %!   x!!  % V!	GF6BF   %!F&  x!!F0T$  q     0%*  k8#$ 0   ) !   $  !S  R  Vx!F2   $  $ F6!$c F23  2   !S  R  Vx!F2   $  F6!$c F22 3      $  ?         ! V!   $G  F6F #p!$ F&F("       ! V! ( ,G F6F #p!F&F$       ! V! 0
- 4G F6TF #p!F&F2       ! V!	 8 <G F6BF #p!$ $c  F&F0T   9  % /  % 0%*  8#$ 0   "8@!      qp! q !#! V!GF6"F q  p!F& q !#!$ F*D $c     $  e      %!  !! Vx!GF6F   %!F&  !x!$ F("     %!  !! Vx!GF6F   %!F&  !x!F$      %!  !! Vx! $G F6TF   %!F&  !x!F2       %!  !! Vx!(,GF6BF   %!F&  !x!$ F0T$c      $ a t     0%*  n8#$ 0  *! !  ! !   $ f !S  R  V!F2   $  $ F6!$F23  2   f!S  R  V!F2   $  F6!$F22 3      $n  @ !  ! !     ! Vx!   $G  F6F $p!$ F&F("       ! Vx!(0(4GF6F$p!F&F$     ! Vx!0@0DG F6TF$$p!F&F2 $     ! Vx!8P8TG0F6BF4$p!$x $ @F&F0T400 |  '.    @% @0%*  8#$ 0   $0"(!d     x !   %!/!SR Vx!F2     F6!  !$x!F2$     %  l0    d   q  p! q  !!  % V!3 2 GF6F q  p!F& q !! F("!*+d       x!/! % Vx!(((,GF6F   !F&  !$x! F$ &!d       px!! % Vp!080<GF6TF   &!F&  x!p! yF2 x!d     y  /p!!  % V!	8H8LG(F6BF, y  x!F& y /p!!$ F0T$ ,&(    < *      %     *  8#$ 0     !  y  x! y /p!! V!   $G  F6"F  y  x!F& y /p!!&R F*D $c        '/  `    !  !#! Vx!   $G  F6F    !F&  !#x! F("!       !#! Vx! ( ,G F6F    !F&  !#x! F$ !      !#! Vx! 0 4G F6TF    !F&  !#x! F2 !      !#! Vx! 8 <G F6BF    !F&  !#x!$ F0T&R   $c       @%& v    7              9    !3x!   p!@@@Dp  9  %x#  !    B  ! @8x! q p!  !  p!9  ! @8x!p!!p)80(84          '   !0    !   @8x!  p %!  p!9  ! @8x!p!!'@8&@<  '  %0   y  x!   % z   x!  y@%!  p!!x! (!  .  (! y @x! y !p!!4!8(
-8,$      0% *  } 8#$ 0   .!  yx! z   x! y@! yx! z #p!8  x! y@   !#p!!$ $c @@F@D    $O  [      qp! r   p! q@.! qp! r x!9  p! q@   .!x! !!  3@@2@D  ! @x! !  !.  ! @% $ x!!4p! yx! z @H@L  x! y@! yx! z #p!8  x! y@  !#p!! (!  	@P@T  (! @p! (!  /  (!! @p!  !x!$Y $ $c  @X&@\   %      *  0%8#$ 0   )!  q  p! r   p! y q@x! y .!!#p! yx! z 8  x! q y@p! q !.!x!!$ $c +80F*84    %        E  (!    (!  @!  p!x!! !10  .  !  @%!  x!p!!x! q8084E  p! r   p! y q@x! y .!!#p! yx! z 8  x! q y@p! q !.!x!! 38828<E  !    !  @%!  x!p!! (!   /  (!  @!  p!x!!4p! y8@8DE  x! z   x! q y@p! q !.!x! qp! r 9  p! y q@x! y .!!#p!!$ $ $c  	8H8L$ !     0% *   8#$ 0    ! !  ! !  (!    (! @! (!  p!/  (! @   !p!x!$ $@@F@D    $Y & \ !  ! !  qp! r   p! q@x! qp! r !8  p! q@+  * x!! y4!x! z @@
-@D  x! y@! yx! z $!.  x! y@!$!p! (!  HPHT  (! @! (!  p!/  (! @ $!p!x! !  P`Pd  ! @8p! !  9  !x! @8p!04x!!$X $ $ @%Xp$Xt0 |  %   `0%*  8#$ 0  *!0    d   ! p %    ! qp! @ q 8x!!$! qp!	 r /  p! ! q@  !8x!p!!$ )@8F(@<    '  0    D   ! p %    ! qp! @ q 8x!!$! qp! r /  p! ! q@  !8x!p!!'@8&@<D   qp!   % r   p! ! q@  !8x!p! !  9  ! qp! @ q 8x!!$!x!HHHLD   ! p %    ! qp! @ q 8x!!$! qp! r /  p! ! q@  !8x!p!!1PX0P\D   qp!   % r   p! ! q@  !8x!p! !(,  9  ! qp! @ q 8x!!$!x!$n $ Xh~Xl    #*  '8   *   8#$ 0  * ! (!    (! yx! @ y !p!! yx!%  $  z 8  x! 0! y@  p!!x!p!&R $c @@R@D    $Y 2 |  yx! z   x! 0! y@  p!!x! (!     .  (! yx! @ y !p!!4! qp!	@@@D r   p! ! q@  !8x!p! !    9  ! qp! @ q 8x!!#!x! (!@H@L    (! yx! @ y !p!! yx!+ *  z 8  x! 0! y@  p!!x!p! !@P@T    ! qp! @ q 8x!!#! qp!   r /  p! ! q@  !8x!p!!$X &R $c  1@X0@\ `% & R *    % )  D  @%      
-         x! Tp!@@@DS  R p  '8   qp!0 r   p!   q@! x/! Tp!@8@<pED      c   q e# p! r   p!9   q@! yx! y ! Tp!8084IHc       q'8  p! r   p!   q@! yx!0 y   /p! ! Tx!8(8,GF$  [    0% n*  U n8#$ 0   . !  !    ! @!#! Tp!@@@D$ $c K  J     $  ;      (!    (! @p!! Tx!@@@D (!  Q  P   (! @p!! Tx!@H@L (!  S R   (! @p!! Tx!@P@T (!  E D   (! @p!! Tx!@X@\$ $ $c  I H  9  % / w 0%*  p8#$ 0   8 !  qp! r   p!   q@! yx! y /p!! T!8084$ $c GF    '/  Q  !    !   @! qp! q .!! Tx!8084 qp! r KJ  p!   q@.! /!  p!! Tx!888< (!  QP  (!   @p! !  !#! Tx!8@8D !  S R  !   @! qp! q .!! Tx!8H8L$ $ $c  E&D$  ^     0% *  X 8#$ 0  ! !  ! !  qp! r   p! q@.x!! T!	@@@D$ $I  fH     '.  < !  ! !  !    ! @!$! Tp!@@@D !  G  F   ! @!$! Tp!HPHT !  KJ  ! @!$! Tp!P`Pd !  Q P$  ! @!$! Tp!XpXt$o $ $ @S0R40 |  '.  z @0%*  s8#$ 0   0"! qp! r   p! q@ &!x!    ! x! T!%@8$@<$ EfD    %  T0     (!    (! @ !p!y    x! p! T!	@8@< yx! z IH  x! y@ !/p!o    ! p.! T!HHHL (!  GF  (! @ !p!y    x! p! T!PX
-P\ yx! z KJ  x! y@ !/p!o    ! p.! T!XhXl$ $ Q(P,    "*  z'.   b*  n b8#$ 0     ! (!    (! ! @  p!x!! T!3@@2@D&R $c S  R     $  L  yx! z   x! qp! y@ q !.!! Tx!@@@D qp! r E  D   p! yx! q@ y .!!#! Tp!@H@L yx! z I H   x! qp! y@ q !.!! Tx!@P@T qp! r G F   p! yx! q@ y .!!#! Tp!@X@\$ &R $c  K J  @% & 0 b*    % )  o  @%  %<  4!@@8      x!   p    #8  qp! r /  p!   q@! yx! y /p!p       q' % p!0 r /  p!9   q@! xp!  '8   (!  .  (!   @! qp!0 q   ! 8p!9    3(! !   !   	  l< 4!  a!% ) D D    @%                   6!   $  x!S  R     F2 D E  p    #  yx! z   x!9   y@p!   !  !!)  ( $GFpF&BJK          %   q0p!   r   p! q@ x.!! %  S!6p!  R    F2 DE9  '  0 y  x! p % z   x!   y@! !    8x!!6!!GF	      F&BJK$  t    0%.*  n.8#$ 0    !  (!    (! @  !x!!!S  R 1  0 $$ F2 $c D E      '  O      (!    (! @  !x!!!G  F )  ( $ qF&Bp! r J K    p! q@  x!#!p!!S R  ( , F2 (!  D E   (! @  !x!!!G F ) 0( 4 qF&Bp! r J K   p! q@  x!#!p!!S R  8 <$ F2 $ D E $c     %   % 0%*  8#$ 0   " !  qp! r   p!   q@! yx! y   p!#!x!!GF   $$ F&B$c JK    % & e  yx! z   x!   y@p! !    x!#p!!!SR   $ F2 (!  DE  (!   @p! yx! y   !p!x!#!GF ( , F&B!  JK  !   @8p! /!    !p!!!S R1 00 4 yF2 x! z DE   x!   y@p! !    x!#p!!!GF	 8 <$ F&B$ JK$c      $ A {     0%*  u8#$ 0   (! !  ! !   qp! r   p! q@  !#x!p!!S  R    $$ F2 $D E  $c     ' & R !  ! !   qp! r   p! q@  !#x!p!!G  F    $ F&B(!  J K    (! @  x!!!!SR1 (0 , qF2 p! r DE  p! q@  !#x!p!!G F$ 0 4 F&B(!  J$K   (! @  x!!!!S0R41 80 <$ F2 $ D4E0$ @$c  0 |  '  0%*  8#$ 0  # !0  !    ! @ yx!8p! y   !   p.!!!)  ( $GF$ F&B$c JK    %  i0  (!    (! @ yx!p! y   !   p!!6!   $SR yF2 x! z DE  x! y@ !!    8p!   !x!p! ( ,GF F&B!  JK  ! @ qp!8x! q   !   x/!!!1 00 4SR qF2 p! r DE  p! q@ &!!    x!   !#p!x! 8 <G(F,$ F&B$ J,K($c      "*  '.      *  8#$ 0    8 !  yx! z   x! y@ !!    8p!!6!!S  R    $&R F2 $c D E      $  _      (!    (! @ qp!! q   x!#!p!!G  F    $ F&B(!  J K    (! @ qp!! q   x!#!p!!S R  ( , F2 (!  D E   (! @ qp!! q   x!#!p!!G F  0 4 F&B(!  J K   (! @ qp!! q   x!#!p!!S R  8 <$ F2 &R D E $c       & 0u    % )  < 6@@  %.      < x!4B@@ !(!3!0!      $ 	  l< 4!  a!w*       @%           8      p!x!3!@@@Dp!@@@Dp  9  %#   yB  x! z 9  x! q y@p!  /!p! !  !  ! @'80&84p!!4x!p8084          '   0!    /  ! @   %p!! qp! r 4x!  p! q@@8@<!$x!!@8
-@<  % / &0     (!   %  .  (!  @!  x!p!!4x! qp!8(8, r   p! y q@x! y !/!p!!18(08,$       0%*  8#$ 0    8!  qp! r /  p! q@!#! (!  x!  (! @@@@D!x!p!$ $c @@F@D    '8  _      qp! r /  p! q@!#! (!  x!  (! @@@@D!x! p!!  @@@D9  ! @8x!p! yx! z !  x! y@)@H(@Lp!!4! qp! r 	@H@L/  p! q@!#! (!  x!  (! @@P@T!x!p! !  @P@T9  ! @8x!p! yx! z   x!! y@p!+@X*@\!4!$O $ $c  @X
-@\ 9  ' / 0%*  8#$ 0   *.!    !  /  ! q @p! q !.x!!! yx!180084 z   x!  y@%!  !p!x!!$ $c 80F84    '.    E  !  /  ! q @p! q !.x!!! yx!380284 z   x!  y@%!  !p!x!! q8084E  p! r 9  p!  q@!  .x!!#p!x! (!888<    (! y @x! y p!!!4p! 888<E  !  /  ! q @p! q !.x!!! yx!)8@(8D z   x!  y@%!  !p!x!! q	8@8DE  p! r 9  p!  q@!  .x!!#p!x! (!8H8L    (! y @x! y p!!!4p!$ $ $c  8H8L$       0%*  8#$ 0  !! !  ! !  qp! r 8  p! q@x!! yx! z 4!  x! y@@@
-@D!$!p!$ $@@F@D    % & ` !  ! !  qp! r 8  p! q@x!! yx! z 4!  x! y@@@@D!$! p!(!  @@@D/  (! @!p! !  x!  ! @HPHT8p!x!! qp! r 3HP2HT8  p! q@x!! yx! z 4!  x! y@P`Pd!$!p! (!  P`Pd/  (! @!p! !    !x! @8p!XpXtx!!$X $ $ @)Xp(Xt0 |  %   0%*  8#$ 0  ,0!d   qp!   % r /  p! &! q@  !x!p!! yx!@8@< z   x! ! y@  /p!!$x!p!$ @8F@<    ' & 0    D   ! x %  .  ! yx! @ y !/p!!! qp!+@8*@< r   p! &! q@  !x!p!!@8
-@<D   qp!   % r /  p! &! q@  !x!p!! yx!HHHL z   x! ! y@  /p!!$x!p!HHHLD   yx!   % z 9  x! ! y@  /p!!$x!p! (!PXP\    (! qp! @ q x!!!4x!PXP\D   (! p %  8  (! qp! @ q x!!!4x! !XhXl    ! yx! @ y !/p!!!$o $ %Xhz$Xl    *  %      /*  /8#$ 0  (!  (!  8  (! yx! @ y p!!!4p! !@@@D    ! qp! @ q !.x!!!&R $c )@@R(@D    $N        !  /  ! qp! @ q !.x!!! yx!'@@&@D z   x! 0! y@  !p!x!! qp!@@@D r 9  p! ! q@  .x!!#p!x! (!@H@L    (! yx! @ y p!!!4p! !@H@L  /  ! qp! @ q !.x!!! yx!1@P0@T z   x! 0! y@  !p!x!! qp!@P@T r 9  p! ! q@  .x!!#p!x! (!@X@\    (! yx! @ y p!!!4p!$O &R $c  @X@\     & M    % )  )< 6@@  %9    3 !(!    	  l< 4!  a!w*          < 4!@@     $    ! 	  l< 6@@  %  .  3 !(!    	  l< 4!  a!w    <?D D  %  $ )  ( F$ LF(  4  <  g! t!@@@D+``*`ds  r      F$F*4   F*tF("  !    Q  P F21  V!F0   $ F 4F("      6p!F2T $       tx!@@@D g!F$```d1  0 F&  !  "    F0aF*DJ K   Vp!F6F$ $  !F*DF4F04F("F2Q@D@@p    4x#/ [< $X     9  k  j !     p  !   tx!" ! g!!8084  32XPXTF2QF$!F&D F$r p!y  F*F("x!!F F& F*"	N     9    !    ! t!8084 gp!F2" !  XPXT"x!F0 !n  F(dF$2!F6F2T 4x!F$2F4F(F&F*$ 8480          '  X    0    8   !    %! Tp! G!!@8@<  
-3`X2`\e  d F2A!F*$32!    F2qF02 fg vx!F$B F&        F AF0Tp!!F$& '      x!8   T!+@8*@< %! Gx!F*`X`\    F(p!!  F&bF2 rs v!F6F*" * +   F2!p!F4F&A F0TF$ @<@8  '/  0E     y  x! y /! p %! .  %!  x!! T! y  x!8(8, y  Gp!/!XHXLp! y  x!e  d  y /!F2"F*4p!F(pF*qq!     v!F$4&F0'  o  F 1!F(  p!F$T!6x!E  .     %!  x!   %! q  p! q !$! Tx!8(8, G! F2  %!XHXL  x!F&!  F0d!  F*A jkF6F2! vp!F*D yy  x! y F4F01 /!p!!F(F$Q&8,'8($  V     *  P ($   9   3  2 q  p !#x!     F2T T!@@
-@D   Gp!```d#x!F(R     F*p!   #x!F0tF*B!F0T F2 F2   $.    3  2  !F6  #! Tx!@@F4@D G!	```dF*   !%  F($  x!   $F$aF(R       p!F&F$A !$c F2F&!F&'@@&@D   '   "*  z P%J     9   3  2  yx! y p!! !  8x!  q  p  ! Tp!8084 G!)XP(XT yF(Rx! y p!  !+*F* yx! y F&F*Bp!o  !)( !F(r qp!F2F(R  q !#!F&Ax!F24  .    3  2  F6%!  ! qF4p! ! q !  #! T!	8084 Gx!F(XPXT %!F*  !F04F*Bx!y  F(b p! F24F(R !  8x!F0D p!F0 !$c 180C084$       !*    ! ) (! ) $ !   9  !   T!$!@@@D Gx!!  $3  2 ```dk  j  Rx!F2QF( #  " F&!   a  F$q`    vp!  F F$1  $$!x!F"PF   F"    $.    #  " !F6  $! T!@@F4@Dg  f  Gx!F$```d!1  F20    v!  F0dF(! 
- $p!!F&F2! $F"PF&!F&'@@&@D  9  !   T!@@@D$!  k  j  Gx!```d!3  2 x!F2QF(#  " a  F&!   ` F$q vp!   $ F F$1   $$!F"PF   x!F"  $  " #    F6$! T!.  @@F4@D Gx!!  F$```d!1  F20 g  f  v!F0d  
- $  F&F(! p!!$F"PF2! F&!F&&@D'@@0 |  %      &*  '/  0     &!  x!   %! q8  p! q !$!  Tx!  &!@8@<   G!x!`X`\!   &!k  j   x!F0RF$4!F(rF$rs!     vp!F*4  F2   yY  F 2x!F(  y /!F*$p!!3 2  q8    p! q ! x %/!   !  p!! T!1@80@< Gx! qF0  p!`X`\ q !F&$x!  F2d!  F$BdeF6F0Q v!  F$D N  &!  F4F22x!!p!F($ F*!@<@8     &        *  %   8*  y ($   9   3  2  qp! q !! yx! y /p!   !q  p  T!@@
-@D G!)``(`d qF(Rp! q !  !+  *   F*  qp! q F&F*B!  !)  (  x!F(r   $ !F2F(R   !#x!F&Ap!F24    $8    3  2 0!F6  x! !F4 !  !  #! Tx!@@@D Gp!F(```d 0!F*     x!F04F*Bp!     F(b !   $ yF24F(R x! y /p!F0D !F0 !$c 1@@0@D     & d 8! 8# 8#L      x! p!C0YxKXT0# !H!$%)$      P%a `h%  %$ a $   X% %. $  *&	 `%$   $$ $ < A+*  `0%+ #$ 0   $+!L   y  x! y p!!  6! .!  	   $.!/   qF:Ap! @ q !x!!>!$  F$c %.  p    L   O  0!  !p!  x! qp! r    $p!9   F:4! q@  .x!!#p!x!  X  0!  p!x!  ! yx! z  (
- ,x!9   qF:Tp! y@ q /!!#x!! N  0!  x!!  p! !   0 4!9   yF:Ax! @ y 8p!!#!p! O  0!  !p!  x! qp! r p! 8 <9   ! q@F:4  .x!!#p!x!%8 $ $c  & e+*$$  q< A+*  n`0%+ #$ 0  (!<L 6s  O  .  !  ! !  !+  * $ @!#x!p!$ $c __%8  M<L 6s  Y  8  #x!  p! yx! z x!   $ y@p!!3!__O  8  p!  ! qp! r p!) (( , q@!#x!!	__N  8  !  6x! .!  .! 0 4 @x!p!!__Y  8  #x!  p! yx! z x! 8 < y@p!!3!%/ $ $c  __   <% 8 6s +*  `0%+ #$ 0  %@!L  E     %!  !x!  p! yx! z x!9    y@!  /p!!#x!p!$ $c WW%8  q    L  E     yx! y /p!!  ! !  !/   q+* @p! q !.x!!!+W*WE     yx! y !!  6p! 8!  8!/    @!  p!x!!3p!WWE     yx! y !#p!  ! qp! r p!/   	 $ q@%!  !x!p!!	WWE     yx! y /p!!  ! !  !/   q%($, @p! q !.x!!!%. $ $c  %W$W` v    $ %*  p#$c 0y   /(!  O!L   n  /  !  ! !  !'  & $ @!"p!x!& $B__     ' 0 N  P! L   n  9  x!  ! yx! z x!   $ y@/!p!!1_0_o  9  !  p! !  !(0(4 @8p!x!!+g*gx  9  p!  x! qp! r p!0@0D q@.x!!!3p 2pn  9  x!  ! yx! z x!	8P8T y@/!p!!$ & $B @)x(x0%8        $  %*  #$c 0x   ) L 00!D   o  !   p %!.p!  x! qp! r p!8     0! q@  x!!p!x!& __     '8  y     L 0    D   o  0!   p %!p!  x! qp! r p!9     ! q@  .x!!$p!x!__D   qy  p! q    %.x!!  ! !  !.   y1((0(,x! @ y !/p!!!1g0gD   n  !   x %!/x!  p! yx! z x!8   080<0! y@  p!!x!p!ooD   yx  x! y    %p!!  6! .!  .!/   q8H8Lp! @ q !x!!3!$ & xx    0*       '% M*  0%M #$ 0   !!L  y  x! y !  #! /!  /!.   y	   x! @ y !p!!3!$ $c 	_F_%O  g    L    0!  !Y  x! !  !.      0! @  x!p!!x! q__  p! q .!N  x! !  !9   q  p! @ q 8x!!#!x! __  0!  !Y  x! !  !.     0! @  x!p!!x! q__  p! q .!N  x! !  !9   q  p! @ q 8x!!#!x!%N $ $c  __& qM*                       t   % 	 l 	 l                "t   % 	 l xx! xx#d xx#9   N#D@  y /!FA!s rF$fg       $            $     * % +* `0%+ #$ 0   ;! L   9   qp! r p! yx! q@ y .!!#p!!   0!  __p!!x!   $  9   !  ! qp! @ q 8x!!#!x!   0!  __!x!$ $c   F %.       L X  9   yx! z x! ! y@  /p!!#x!p!   0!  __x!p!!	   $O  9   qp! r p! yx! q@ y .!!#p!!   0!  __p!!   Y  /   qp! r p! 0! q@  !x!p!! y  x! y __/p!!!% ($ ,N  /   !  ! qp! @ q !.x!!! y  x! y '_&_!!' & O  .   !  ! yx! @ y !/p!!! q  p! q 1_0_!!6x! 0 4X  .   8!  8! ! @  x!p!!3x! q  p! q __!#x!  N  8   .!  .! qp! @ q x!!!3x!   !  __!#x!p! 8 <Y  8   yx! z x! 0! y@  p!!x!p!   !  __8x!p!%9 $ $c   &9 & +*  F  <?  D p!D    $    F"!F80 p<?  D D '8      0      !p!      F"F P 0c     e#           yx! y !6p!    F"DF    '    q9  p! q  x.!!6p!    F"!F 0 $  B 0%/*  ;/8# $ 0    ! <?!D D 6 !$   F      $$ F" ($ FF   $$ F"F      %  <? !D D 6 !   $ (F"D , 0 4 <F"! 8F  $ $N F"F 0 $  F"DF P F   <?D D %  ? *  8 0% !    8#$ !0  !  xp! !$ F F"$ $ F  FF"$ F      % &   xp! !F" $,F"D(F P $ $O F"!F  $  F"F 0 F P $ ! @ | 0%*  98# $ 0    ! 8!  p!!$ y  F     x $$ F"y(0$cFF  x $$cF"F      %   &!  p!!e  d $q(0F"!p(4i0@h0Dd8TF"e8PF 0 $ $O F"DF P $c @F"!F  F 0  |    '  C0%*  <8# $ 0        .!  x!!!!$ y F     x $ F"y(($cFF  x $cF"F      % &  yx! y !p!!i h e((F"Dd(,q08p0<h8LF"!i8HF  $ $Y F"F 0 $c @F"DF P &F       O*  <$F     *  2 @% 8#$ 0       yx! y !.!!6 !   $& $PF       %   !  !#p! !   $(0(4F 0 0@0DF  8P8TF P & $O $ @F @     &R     B      S R     F  D E B  G F K J F 4  F*           	   !F"DE  D $    F$F $G  p    x#/       .!  !qp v!F"IHpF(TRS          %      0 9     x!ED V!F"!q p     F02j k   % 8       .!0    ! x!IH V!F"Ded    F$fg$ ! f    0%*  `8#$ 0  $@!    $  #!Y  X  V !F"   $$c $ F2   $  #!Y  X  V !F"   $$c F2 $      '  9        $ !E  D  V !F"!   $$ F02 $        #!I H  V !F"D ( ,    F$ , (      !Q P  V !F" 0 4    F(T 4 0      !E D  V !F"! 8 <$c  F02 < 8 9  ' / q0%*  j8#$ 0   .@!       8!  p!!IH V !F"D$ $c F$    '  L       !  8x!!QP V !F"$ F(T     !  x!!ED V !F"!    F02     !  8x!!I H V !F"D $    F$$      !  x!!QP V !F"(,% $c  F(T,&($  i     0%*  c8#$ 0   %8@! !  !  !   $  !Y  X  V!F"s  r $$$ F2s  r $  !Y  X  V!F"s  r $$F2r $s      % & : !  !  !   $ !I  H  V!F"De  d $$ F$f $g        !QP V!F"i(0h(4    F(Tr(4s(0      !E D$ V!F"!q0@p0D    F02j0Dk0@      $!I0H4 V!F"De8Pd8T$ @F$f8Tg8P0 |  %   0%*  8#$ 0  2 0@! y%x!    y   /p! !YX V!F"s r $  yF2x!s r    y   /p! !YX V!F"s r % $ F2r s     %  M 0       &!    x! p!ED V!F"!q p  !F02  j k     8x! !IH V!F"De((d(, qp!F$ q f(,g((    x! !QP V!F"i08h0< &!F(T  r0<s08    x! p!E(D, V!F"!q8Hp8L$ $ F02j8L&k8H    *  '  "*  w @%/8#$ 0   ,(!  &R     0!  !!Y  X  V !F"   $&R $c F2    $  0!  !!Y  X  V !F"   $$c F2 $      %  F     !  8x!!Q  P  V !F"   $ 0!F(T   $    &R !!E D  V !F"! ( , qp!F02 q  , (      !#!I H  V !F"D 0 4 yx!F$ y  4 0  $ p!!Q P  V !F" 8 <$c  F(T <2 8     & $     *  % +*  `0%+ #$ 0   $+!L   y  x! y p!!  4! .!  @@@D.!/   qF:!p! @ q !x!!>!$  F$c %.  p    L   O  0!  !p!  x! qp! r @@@Dp!9   F:! q@  .x!!#p!x!  X  0!  p!x!  ! yx! z 	@H@Lx!9   qF:Dp! y@ q /!!#x!! N  0!  x!!  p! !  @P@T!9   yF:!x! @ y 8p!!#!p! O  0!  !p!  x! qp! r p!@X@\9   ! q@F:  .x!!#p!x!%8 $ $c  & e+*$      m+*  k`0%+ #$ 0  (!L  O  .  !  ! !  !)@@(@D @!#x!p!$ $c __%8  L    L  Y  8  #x!  p! yx! z x!@@@D y@p!!3!__O  8  p!  ! qp! r p!%@H$@L q@!#x!!__N  8  !  4x! .!  .!@P@T @x!p!!__Y  8  #x!  p! yx! z x!@X@\ y@p!!3!%/ $ $c  __   % 8 +*  `0%+ #$ 0  %@!L  E     %!  !x!  p! yx! z x!9   8084 y@!  /p!!#x!p!$ $c WW%8  q    L  E     yx! y /p!!  ! !  !/   q)80(84 @p! q !.x!!!)W(WE     yx! y !!  4p! 8!  8!/   888< @!  p!x!!3p!WWE     yx! y !#p!  ! qp! r p!/   8@8D q@%!  !x!p!!WWE     yx! y /p!!  ! !  !/   q'8H&8L @p! q !.x!!!%. $ $c  'W&W` v    $ %*  p#$c 0y   /(!  O!L   n  /  !  ! !  !1@@0@D @!"p!x!& $B__     ' 0 N  P! L   n  9  x!  ! yx! z x!@@
-@D y@/!p!!+_*_o  9  !  p! !  !HPHT @8p!x!!)g(gx  9  p!  x! qp! r p!P`Pd q@.x!!!3p 2pn  9  x!  ! yx! z x!XpXt y@/!p!!$ & $B @%x$x0%8        $  %*  #$c 0x   ) L 00!D   o  !   p %!.p!  x! qp! r p!8   @8@<0! q@  x!!p!x!& __     '8  y     L 0    D   o  0!   p %!p!  x! qp! r p!9   @8@<! q@  .x!!$p!x!__D   qy  p! q    %.x!!  ! !  !.   y+HH*HLx! @ y !/p!!!+g*gD   n  !   x %!/x!  p! yx! z x!8   PXP\0! y@  p!!x!p!ooD   yx  x! y    %p!!  4! .!  .!/   qXhXlp! @ q !x!!3!$ & xx    0*  '% M*  0%M #$ 0   "!L  y  x! y !#!  p! !  !/      $0! @  p!x!!p!$ $c _F_%Y & k    L    !  p!!N  6x! .!  .!8   q   $p! @ q x!!!3x! __  !  !#x!Y  p! yx! z x!8    ( ,0! y@  p!!x!p! __  !  8x!p!O  ! qp! r p!8   y+ 0* 4x! q@ y !/!p!! +_*_  !  p!!N  6x! .!  .!8   q 8 <p! @ q x!!!3x!%N $ $c  __& lM*              9        
-    t   % 	 l 	 l             $t ! # #     % 	 ld Op#9  D  0!F!s rF& pq $      p* $g +* `0%+ #$ 0   <! L   9   qp! r p! yx! q@ y .!!#p!!   0!  _
-_p!!x!@@@D  9   !  ! qp! @ q 8x!!#!x!   0!  __!x!p!$ $c   F $%9 &      L O  8   qp! r p! yx! q@ y !/!p!!   !  %_$_p!!4x!@@@DN  8   .!  .! qp! @ q x!!!3x!   !  __!#x!p!   $Y  8   yx! z x! 0! y@  p!!x!p!   !  __8x!p!!'@H&@LO  8   qp! r p! yx! q@ y !/!p!!   !  1_0_p!!6x! ( ,N  8   .!  .! qp! @ q x!!!3x!   !  __!#x!p!@P@TY  8   yx! z x! 0! y@  p!!x!p!   !  __8x!p!!) 0( 4O  8   qp! r p! yx! q@ y !/!p!!   !  %_$_p!!4x!@X@\N  8   .!  .! qp! @ q x!!!   !3x!  !__#x!p!%8 $ $c   85 <& +*           p!   $x!F6@@@D!F*2(@D)@@    x!   $p!F4$@@@D    F0   p    p#. - B     !  ! vp! t!F6A+80*84  pF$Tx!!380284B     qp!  ! vx! t!F4)80(84  F(2!
-       % % '    0         p! V!3 2  Tx!F6 %  @8@<!F0!x!0@8@<     ! V!	   Tx!F4B@8@<  %  F2Q $p!9  '  ;0     y  x! y ! p.! V! %F62 Tp! 8(8,  %!  p!F(!x!8(8,0       !   x!!  % V!32 Tp!F4 y8(8,  x! y F&$ !$p!$ a     @0%**  *8#$ 0   F
-(!  
-    ! V!9  8 $ Tp!F4@@@D$  !F2x!       #! V!   $ Tp!F6@@@D!4p!F8$c @@@D    ! V!9  8 $ Tp!F4@@@D$ F2x!       #! V!   $ Tp!F6@@@D!4p!F8$c @D@@%8  {          ! V!3  2 $ Tp!F4@@@Dx!$ F0!       #! V!  
- $ Tp!F6T@@@D!4p!F2A@D@@    ! Vx! ( , T!F4+@H*@L!F*2  	     ! Vp! ( , T!F6$3@H2@Lx!!F0&@L'@H    ! V! 0
- 4 Tx!F4R@P@T#p!F$D      ! V!' 0& 4 Tx!F62@P@T!x!F*@T@P    #! Vp! 8 < T!F4$@X@\!F& 0 1     ! Vx! 8 < T!F6A@X
-@\#p!!F$T%/ @\@X$c   9  % 8	** @0%*8#$ 0  ;@!       %!  !! Vx! Tp!F44 8084  !  F(8x!p!     !  8x!! V!32 Tp!F6 y8084  x! y p!F&$!4!$ 8084$c     %         %!  !! Vx! Tp!F4B 8084  !  F2Q 8x!p!     !  8x!! V!10 Tp!F6 y8084  x! y p!F(2!4!80
-84     qp! q !#! V! Tx!F4 888<  %!  F0!!x!     %!  !! Vp! Tx!F6T 888<  !  8x!F2Ap!!%88$8<     yx! y p!! V!1 0$ T!F4 q8@
-8D  p! q F*2 !#!	      qp! q !#! Vx! $ T!F6$ 8@8D  %!  !F0x!p!8@8D     !  8x!! Vp!(, T!F4R y%8H$8L  x! y F$Dp!!32     yx! y p!! V!(, T!F62 q  p!18H08L q !F*#!x!% $ 8H8LA$c      $ A     `0%+*  +8#$ 0   I(! !  !  ! o    ! Vp!   $ T!F43@@2@D$  !F2x!   n    ! V!   $ T!F63@@2@Dp!!F8$9@@8@Do    ! Vp!   $ T!F43@@2@D$ F2x!   n    ! V!   $ T!F63@@2@Dp!!F8$8@D9@@    '  } !  !  ! n    ! V!'  & $ T!F44	@@@Dp!$ F(   y    $! Vx!   $ T!F6@@@D!4!F&$@D@@o    ! Vp!(0(4 T!F4B3HP2HTx!F2Q n    ! V!(0(4 T!F6'HP&HTp!!F(2*HT+HPx    ! Vx!0@0D Tp!F4P`Pd$!F0!$ o    ! V!+0@*0D Tp!F6TP`Pdx!p!F2APdP`y    $! V!8P8T Tx!F4XpXt!F*2 (4)0x    ! Vp!8P8T Tx!F6$XpXt$!x!F0$ XtXp$ @    0 |9  ' /`0%* 8#$ 0   ?     0@!d     !   x!/! % Vx!   Tp!F4R @8@<  &!  F$Dx!p! y  d  x! y /p! ! V!' &   %F62 T! q@8@<  p! q !F*!4x!$ @8@<    %  0     d   q  p! q  !!  % V!% $  Tx!F4$ @8@<  !  F& !$x!   d  &!  x! p! V!	   %F6A Tp! y@8@<  x! y /p!F$T!!3@82@<d     !   x!/! % Vx!(((, Tp!F44 HHHL  &!  F(x!p! y  d  x! y /p! ! V!3((2(,  %F6 T! qHHHL  p! q !F&$!4x!HHHLd     &!   px!! % Vp!080< T!F4B yPXP\  x! y F2Q /p!! q  d  p! q ! ! Vx!080<  %F6 T! 'PX&P\  !  !F(2$x!p!PXP\d   y  x! y  /p!!  % V!8H8L T!F4 q1Xh0Xl  p! q F0!!!'(&,   d  !  ! x/! Vp!8H8L %F6T Tx!   &!XhXl  x!F2Ap!!$ $ Xh&2Xl    * <@ %  *   % 8#$ 0   6 !   y  x! y /p!! V!   $ T!F4 q+@@*@D  p! q F*2 !!)  (  q  p! q !! Vx!   $ T!F6$ 3@@2@D  !  !F0#x!p!&R @@@D$c $         y  x! y /p!! V!  
- $ T!F4R q%@@$@D  p! q F$D!!3  2  q  p! q !! Vx!   $ T!F62 1@@0@D  !  !F*#x!p! @@@D  0!  x!! Vp! ( , T!F4$ y@H@L  x! y F& /p!!   y  x! y /p!! V!) (( , T!F6A q@H
-@L  p! q !F$T!4x!@H@L   !  !#! Vx! 0 4 Tp!F44 @P@T  0!  F(x!p!     0!  x!! V! 0 4 Tp!F6 y@P@T  x! y /p!F&$!!1@P0@T q  p! q !! V!) 8( < Tx!F4B @X@\  !  F2Q !#x!     !  !#! Vp! 8 < Tx!F6   0!@X@\  x!F(2p!!$ &R @X
-@\2I$c  & 0 *    <@ D D %  $  F$       I  F H     F(2J K  p    %x#   B     qp! q x!.!F qppF0!fg          % % 0       !)(!F BSR    F2Q DE  '  0     y  x! y p!   %!   !  8x!p!IF H    F(2JK$ a S     0% *  M 8#$ 0   ) ! 	    p!   !F Q  P $ $c F0!F G  $ & 6     p!   !F BS  R $ F2Q D E      x!  #!F I H     F(2J K     #!  !F Q P $ F0!F G     !) ( !F BS R $c  F2Q D E    %   *   0% 8#$ 0    	 !      yx! y ! q  p! q #!x!!10IF H$ $c F(2JK    '  _      !  8p!   %!  !!p!QF P$ F0!FG     %!  ! y  x! y !!#!	SF BR    F2Q DE     yx! y ! q  p! q #!x!!1 0I F H    F(2JK      qp! q x!   !  !8p!x!QF P$ $c  F0!F&G    $ ! Z    `0%K*  UK8#$ 0    !  ! ! !    $!	   !F BS  R $ $F2Q D fE  %N  8 !  ! !     $!   !F I  H $ F(2J K      !32!F QP    F0!FG    x! $!F BS R$%O F2Q D$E     p!04$!F I0H4$ @F(2J4K0    0 |9  ' . K*  `0%K8#$ 0  !    0(! qd    p! q  .x!!   %  &!  p!x!QF P$ F0!FG    $  d0     yd    x! y  !! q  %  p! q .x!!	SF BR yx! y F2Q DE  d  !   %! q  p! q .x!!IF H yx! y F(2JK  d  !   %! q  p! q .x!!QF P yx! y F0!FG  d  !   %! q  p! q .x!!	(,S(F BR,$ $ F2Q D,&E(    K*  %H  *   % 8#$ 0  2 ! &R       !  ! yx!#! y !!;  : Y  F X &R $c  F8 Y  X   !  ! y  x! y #!!!;  : Y  F X $c F8 X Y  $  U    !  ! y  x! y #!!!3  2 Q  F P  yx! y F0!&R F G      ! qp! q !.x!!	  S F BR  qp! q F2Q D E     .x! 0!  !p!x!  I F H  0!  F(2J K     p! !  !!#p!  Q F P $ $c  F0!F G & q *                  !	@@@D!F BS  R $    F2Q D $E  p    x#/   B     !  !!p!80846!F ihpF(2jk          '/  0       !!p!@8@<6!F Q P     F0!F G   '/  0     yx!   y /! p % y  p!x! y !/!p!!)8((8,SF BR    F2Q DE$ + o    @0% *  i 8#$ 0  & ! 
-    p!#x!!@@@D$  F !Y  X $$c F8 $ Y  X $    p!#x!!@@@DF !Y  X $$c F8 X $Y  $  ?     #x!p!!3@@2@D!F Q  P $$ F0!F $G      !!4x!@H@L!F BS (R ,    F2Q D ,E (    #x!p!!@P@T!F I 0H 4    F(2J 4K 0    !!p!@X@\6!F Q 8P <$ $c  F0!F <&G 8   '   *  @0% 8#$ 0   "*@!      yx! y p! y  !x! y 6!p!!4!	8084SF BR$ $c F2Q DE    %  g      yx! y p! y  !x! y 6!p!!4!8084IF H$ F(2JK     qp! q ! q  #!p! q !!#!x!888<QF P    F0!FG     %!  !   x!%!  !!x!p!8@8DS F BR$    F2Q D$E      !  8x!   p!!  !8x!p!!18H08LI(F H,$ $c  F(2J,K(    K v     0%	*  q	8#$ 0  ) !  ! ! !    $!p!!9@@8@D$ f F !Y  X $$F8 $ Y  X $    $!p!!9@@8@DfF !Y  X $$F8 X $Y  %  A !  ! !     p!$!x!@@@D!F BS  R $$ F2Q D $E      x!!p!HPHT6!F I(0H(4    F(2J(4K(0    p!$!!3P`2Pd!F Q0@P0D    F0!F0DG0@    !x!4!	XpXt!F BS8PR8T% $ @F2Q D8TE8P    0 |  '8  	*   0%	8#$ 0  >    0(!$  d    !     %x!  ! !6!  x!!4p!@8@<Y F X $  F8 Y X   !d    x!   %   !!  6!x!!4p!@8@<Y F X $ $ F8 X Y %  k0     q  p!d   q .! x % q  p!x! q !.!x!!3@82@<Q F P  yx! y F0!F G   d  ! p % y  x!.p! y !!$p!!	HHHLS((F BR(, qp! q F2Q D(,E((  d  .! x % q  p!x! q !.!x!!1PX0P\I08F H0< yx! y F(2J0<K08  d  ! p % y  x!.p! y !!$p!!XhXlQ8HF P8L% $ F0!F8LG8H    	*      %	  *   % 8#$ 0   6& ! &R     !  x!  ! !6!  x!!4p!@@@DY  F X $&R $c  F8 Y  X $  !  x!   !!  6!x!!4p!@@@DY  F X $$c F8 X $Y  $  `    0!  p!   0!!  !p!!x!@@@DI  F H $ qp! q F(2&R J $K        .! q  p!x! q !.!x!!3@H2@LQ (F P , !  F0!F ,G (      x!   !!  6!x!!4p!@P@TS 0F BR 4 yx! y F2Q D 4E 0      ! y  x!#p! y !!#p!!@X@\I 8F H <$ $c  F(2J <K 8& 0b * t ( , 0 4 8 < @ D L P T X \ ` d h p '        <'!' xL   H'D   L>?F!P`   ` @ D 8 < p l h d \ X T   $ xD D $< =   % | t 0 4 ( ,  %  %  %%<   F ! D@  FB D D  F & @ F0Uy  <  9!!B@ BD  %'   0% 	@8% t  %' $  	@8%     tF,<< E        F `F b  D`  V@!B@BD "!F <    E      !B@ BD`<@Dh  	F i  %  6P!UB@TBD$  tF4 >F E  9    F:<$ E      <XD D $ $   	$0 t$d     	     t  /     -    F8 )(p*F&@>    E  #      !      % 	@(% t&+*&1F4T  %@(%0  	1   t  F        	$   % 	@(% t& &1 F      u    $  <   |@ (%m  p!B@BDD   0%$\  	  t     |   $ ( , 0 4 8 < @ D H L T X \ ` d h l p x '<'	!'\ pDh D`     ! pp!<@   D(  pd4p# p    9  p#'  &  q  .x!F 2X!y|n4oXF BxD  jbic.@!`! sF* H*  6@0%$< I L*  - @8% P X qp! r   p! ! q@  .x!!*8!  F(1 F*! p!! !$F(1   F*# F"t%J K*F2 F F4`<  E      F   q$  *  L*$(*< I   0% l*  - `8% P  !    ! qp! @ q !.x!8!  F(1 F*! !! 
-!$F(1   F*# F"t%J B*F2 F F4`<  E      F   $  *  l*  t  $  pH*  6@0%$< I l*  - `8% P X qp! r   p! ! q@  .x!!*8!  F(1 F*! p!! !$F(1   F*# F"t%J K*F2 F F4`<  E      F   q$  *  l*$(*< I  4 0% L*  - @8% P  !    ! qp! @ q !.x!8!  F(1 F*! !! 
-!$F(1   F*# F"t%J C*F2 F F4`<  E      F   $  *  L*        ' <'!'\ p! p<@D( p!4 pd \ X T P L H D @ < 8 0 4 ( ,   $      p# p    '  & 9  p# q F 2 .x!!yxn0F BkoTx.!D  'v 0@*! %$&$  F*%h  x@%p!D D $ h d$ $ $ <
- I$	  hD@ '  FA!& <?F$2DH D@  d*$ (%  F(W<?D8 lD0   @& `!F<7 yx! z DP   x! &! y@FR!   !   $c p!!F(!<?DX DP H I MLF*4ONDEF,AH F.2I  F*   J !F6A! !$<?F "F*0 F"q       F IHGFF(a HF&"I DEF*@ !F6!!    F BF*0F"      r       F EDIHKJF(!HF*1 IF$p F6A     F QF$0F"      s       F IHKJEDF*AJF$2 KFGF(P F61    F RF( F" D8 D0 F,F20 yx! z F0x! +! y@F$R  !F(  p!x!$ F4!% F:F$R F(F*1 !$p! %k * T     \         $ ( , 0 4 8 < @ D H L P T X '<'(!' xx! xdx# x  x# H y  ! T P L D @ < 8 4 0 ( ,   $      !f4gy|nX&H!%) `%h! 8@&* %$ %  $hT<?  @Dh D` $&%5 /!!y  O  &p#%D  N F!D@ *F&pFB$ % %  F*plX  F f% F"g8H!P!N  9  8 D   Fx#%F6D $c  0!F!  0!F4 @p! yx!F4f y !!   F8F0 (!  F8sF0 (! @p!F* yx! y !F0F*r!F* 0!  0!F0F2T @ yx!F2t y   F6dp!!!F8v (!  F*(! @p! yF*x!F* y !!F0T  F0 0!    0! @p! yx! y !!    F2 F8 (!  F2RF8 (! @p!F4 yx! y !F8F4U !F4 0!  0!F0  @F8F0T  y  x!p! y !!F2 (!  F*(! y @x!F*p!F* y !!  F8V  $ F8 $B   dJ $ .     T         $ ( , 0 4 8 < @ D H L P ' X<'! xx! xdx# x  x# y  !!ig(fhL *  b    D D  $    *  W %P#%J 1L  (!  qp! r m  p! 		! q@  x!!#`!$B    $c %  =  yx! z n  x! 	)! y@  !`! yh!x! z    n  x! 	)! y@  !`!h! yx! z   n  x! 	)! y@  !`!h! yx! z   n  x! 	)! y@  !`!h!% $B   $c  %)  * *                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             @@     @@     @     ]e            @     @      ?	$k=yd?zG{      >zH?
-6C-?      @       @       @       @             n:p:e:r:t:soh   Max grid size exceeded
- Grid must be ((power of 2)+2) in each dimension
-    P must be >= 1
- P must be a power of 2
- Usage: OCEAN <options>
-
-    options:
-     -nN : Simulate NxN ocean.  N must be (power of 2)+2.
-   -pP : P = number of processors.  P must be power of 2.
-     -eE : E = error tolerance for iterative relaxation.
-    -rR : R = distance between grid points in meters.
-      -tT : T = timestep in seconds.
-     -s  : Print timing statistics.
-     -o  : Print out relaxation residual values.
-    -h  : Print out command line options.
-
-   Default: OCEAN -n%1d -p%1d -e%1g -r%1g -t%1g
-   Cannot determine number of multigrid levels
-    Max grid levels exceeded for multigrid
- 
-   Ocean simulation with W-cycle multigrid solver
-     Processors                         : %1d
-       Grid size                          : %1d x %1d
-     Grid resolution (meters)           : %0.2f
-     Time between relaxations (seconds) : %0.0f
-     Error tolerance                    : %0.7g
- 
-   Could not find factors for subblocking
- No more processors -- this is a uniprocessor version!
-                         MULTIGRID OUTPUTS
-   
-                          PROCESS STATISTICS
-                    Total          Multigrid         Multigrid
-    Proc             Time             Time            Fraction
-        0   %15.0f    %15.0f        %10.3f
-   %3d   %15.0f    %15.0f        %10.3f
-   Avg   %15.0f    %15.0f        %10.3f
-   Min   %15.0f    %15.0f        %10.3f
-   Max   %15.0f    %15.0f        %10.3f
- 
-                          TIMING INFORMATION
-  Start time                        : %16d
-   Initialization finish time        : %16d
-   Overall finish time               : %16d
-   Total time with initialization    : %16d
-   Total time without initialization : %16d
-       (excludes first timestep)
-  
-   ERROR: %s
-  ?8?|?|??|?|?|?|?|????|?d??>zH@     @      @             ERROR: Maximum work limit %0.5f exceeded
-   iter %d, level %d, residual norm %12.8e, work = %7.3f
-      F)>Y9?333333?333333                        EHjdX@p@!t @ @4 @5T @5 @= @Dl @L Az A~ A$ A A$ A              0  8  @  H  P  X  `  h  p         
-0 
-4 
-8 
-< 
-@ 
-D 
-H 
-L 
-P 
-T 
-X 
-\ 
-` 
-d 
-h p x            H    ( , 0 4                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             p	  _   4            `   A 8            D             G @   q \                                    Y               B                               +             T                        "D                                   "                                             @     "   i                                   #   J                 T?             j                                             t  @       (                   0                 8       D        $  y  :       &  ?     X          8   	  N                            P       ,                          "       ( @     0 @/   (        > @     >                        ,                    ,                    ,                    ,                    ,                    ,      @       "D       @4        d       @5H        D                     ,                    ,                    ,      @5                            ,                    ,      @=                            ,     
- @D`     
-  \                     ,     
- @@     
-                       ,     	 Az     	         A~       l       A       `       Ax             $ A     $     	                  ,                                   
-                         	       !   
-                                                       	       !   
-                                     	       !   
-                                     	       !   
-                                           	       !   
-                                     	       !   
-                                           	       !   
-                                           	       !   
-                                           	       !   
-                                     	          crt1text.s LOCALSZ FRAMESZ RAOFF GPOFF __start 10$0000000000 _mcount  /kona/sherwood/root/usr/include/regdef.h  /kona/sherwood/root/usr/include/sgidefs.h  /kona/sherwood/root/usr/include/sys/fpregdef.h  /kona/sherwood/root/usr/include/asm.h  crt1tinit.s  main.c main log_2 printerr  /usr/include/math.h  /usr/include/stdio.h  jacobcalc.c jacobcalc  ./decs.h  laplacalc.c laplacalc  slave1.c slave  slave2.c slave2  multi.c multig relax rescal intadd putz  crtninit.s .text .init .fini .data .sdata .rdata .sbss .bss _DYNAMIC_LINK __Argc __Argv __rld_obj_head exit __start _environ __istart __readenv_sigfpe main _mcount _gp_disp global fields fields2 wrk1 wrk3 wrk2 wrk4 wrk6 wrk5 frcng iter guess multi locks bars startcol nprocs startrow h1 h3 h lf eps res dtau f0 beta gpr im jm tolerance eig2 ysca jmm1 pi t0 outday0 outday1 outday2 outday3 factjacob factlap numlev minlev imx jmx lev_res lev_tol maxwork gp i_int_coeff j_int_coeff xprocs yprocs do_stats do_output time getopt atoi optarg printerr log_2 atof printf malloc sqrt atan fprintf __iob slave jacobcalc laplacalc multig sin slave2 relax pow rescal putz intadd fabs _etext _edata _end etext edata end _ftext _fdata __elf_header __program_header_table __dso_displacement _fbss  @          F              F                  
-       	         / @      F   *                            
-       	   	           @      p   +                            
-          	           @         0                            
-          	           @         '                            
-       $   	           @                                              -              @                  F               
-      .        /   @                                          1              @     0                               .      4              @5     F      !     	               =      7           @5     ]   
-   %                         N      9              @=     g      '                    ]      ;          Z @D`     ~      +       7             n      =          @@           /     #  6f                   @          Az        )   3     ZL           	          B         j A           ?                                  F                                                                                                                                                                                          	   
-   	   
-      
-      
-         
-      
-                @/      A       A O        O                  & 
-0     , 
-0o        O     1        @  O     @ 4O     @/       a @        @        @       A /     A /       O       (O     b  xO     j  O     
-0     
-0     
-0       
-po      
-o       M 8o     @o      o              B           i         " @     ) @     i @     0 @     5 @     : @       @     z @        \ @0         { @@      @P      @`      @p       @        @4        @5H     	  N @5       X @=       H @D`       m @@       b Az       t A~       ~ A        Ax        A  	      r A        O       O       O       O        O        0O     $  8O     )  @O     ,  HO     1  PO     5  XO     ;  `O     W  hO     Z  pO     r  O       O       O       O       
-0o       
-4o       
-8o       
-<o       
-@o       
-Do       
-Ho       
-Lo       
-Po       
-To       
-Xo       
-\o       
-`o       
-do       
-ho     8 po     E xo     J o     O o     T o     z o      o      o      o      o      o       o      Ho      o      o      o      (o      ,o       ? 0o       F 4o                         .text .init .fini .data .sdata .rdata .sbss .bss _DYNAMIC_LINK __Argc __Argv __rld_obj_head exit __start _environ __istart __readenv_sigfpe main _mcount _gp_disp global fields fields2 wrk1 wrk3 wrk2 wrk4 wrk6 wrk5 frcng iter guess multi locks bars startcol nprocs startrow h1 h3 h lf eps res dtau f0 beta gpr im jm tolerance eig2 ysca jmm1 pi t0 outday0 outday1 outday2 outday3 factjacob factlap numlev minlev imx jmx lev_res lev_tol maxwork gp i_int_coeff j_int_coeff xprocs yprocs do_stats do_output time getopt atoi optarg printerr log_2 atof printf malloc sqrt atan fprintf __iob slave jacobcalc laplacalc multig sin slave2 relax pow rescal putz intadd fabs _etext _edata _end etext edata end _ftext _fdata __elf_header __program_header_table __dso_displacement _fbss                                @           A        	                            
-                               '               - 
-0                  
-   2           @       
-   @ 4     
-   @         b @                       @         A          A                  
-    (      
-  c  x      
-  k        
-                                           
-p        	 
-         N 8        @                               C              j             #             *             j             1             6             ;                          {              ]              |                                                      @         @4         @5H        O @5        Y @=        I @D`        n @@        c Az        u A~         A         Ax         A         s A      	           
-          
-          
-          
-           
-  !  0      
-  %  8      
-  *  @      
-  -  H      
-  2  P      
-  6  X      
-  <  `      
-  X  h      
-  [  p      
-  s        
-          
-          
-          
-    
-0          
-4          
-8          
-<          
-@          
-D          
-H          
-L          
-P          
-T          
-X          
-\          
-`          
-d          
-h        9 p        F x        K         P         U         {                                                                 H                                    (         ,         @ 0        G 4               .interp .reginfo .dynamic .liblist .dynstr .dynsym .hash .text .init .data .rodata .got .bss .mdebug .strtab .symtab .compact_rel .shstrtab                                                      @                         	p      @@  @                           @           	          p       @@  @   0               $       @p  p  0       	          ,       @           	         4       @          	          :       @   }p                  @       A                         F                                L                             T                          Y       
-0 0                    ^p              |                  f            |                    n                     	                                          v            P                 &@PApa ` @"P@   (&!&!&``` 040A    (F   ! "@   !0    P 3!h ( S(8 f(  S(f 1" "Q0   " &   ##3@3(@3( + P03 !1 F ! '0 x E4&%F0 #&#`&&&    0 X((5!(&( (&$ P000 A"  "## "'88! $   ( ! $  0   !P 0                4@4H 	 	 	8 8301 
-BB@EH *0  00 
-  	      P "```##"%" EB F TS&$$# D C EEe""&$#DCE E  
-    R AP0 0!'PQAAXBDU 	 " 0   "&$#DCEA  0000C& $#CCEE  *$" #C CDE *$"%"" #0  !@@3 !#  @@2 D   ( D (   1   hpa02q# 0 ' $%#CC@BX D '$%# C  C @BX<<DX@(        $!  #""%CB BEA 0 0` *&  ! $""%AB BABD 
-% # (  '$% #BB B E F    $"$% $ ABXC BA  @   ' #%% BB E F W 3$ " %E EFW   -  & $ (  &#%$ ABXBF E  4 '#%$ BBD FE  +   `a   00(4110(5(7(4(30F8@@T (4(5F8B 	08@@ Q  R @0!0 0 0( PPh BAX B E g`g6 '3T 0   "'%$@CDE F 
-     8'$%$FDFG  S E A E eh 5 '3   ' "% $RRRUh! @@X&$$ $BBCBB Dc&$$# ABBABKKT x     `   p" 	 h@ 
- ` t`pp  p48$0 !  !Q!4@@AH " "Q   Q   	  `@4000   000  000   000    qp ! 	pA0Q0   	@8(1(B$!1#$  #  !'!&3&  &3( !&h # # # * $ $  $    V@`!HB a18" "B$## "  @"#'  (" "B$##   ("#'    '   Q                                                                                                                                                                                                                                                                               h          w @` Ev `SXp   @ Q   @Tp  @Sp  @Wh  @PX  @Uh  @Vh  @Pp  @U`  @`W`  @xRp  @,Tp  @W`  @Tp  @\Tp  @0  S @5`K `D@`8``6h` 	``(`(
\ No newline at end of file
diff -Naur splash2/codes/apps/ocean/non_contiguous_partitions/slave1.c splash2-modified/codes/apps/ocean/non_contiguous_partitions/slave1.c
--- splash2/codes/apps/ocean/non_contiguous_partitions/slave1.c	1994-10-15 00:16:54.000000000 -0400
+++ splash2-modified/codes/apps/ocean/non_contiguous_partitions/slave1.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,618 +0,0 @@
-
-/*************************************************************************/
-/*                                                                       */
-/*  Copyright (c) 1994 Stanford University                               */
-/*                                                                       */
-/*  All rights reserved.                                                 */
-/*                                                                       */
-/*  Permission is given to use, copy, and modify this software for any   */
-/*  non-commercial purpose as long as this copyright notice is not       */
-/*  removed.  All other uses, including redistribution in whole or in    */
-/*  part, are forbidden without prior written permission.                */
-/*                                                                       */
-/*  This software is provided with absolutely no warranty and no         */
-/*  support.                                                             */
-/*                                                                       */
-/*************************************************************************/
-
-/*    ****************
-      subroutine slave
-      ****************  */
-     
-#include <stdio.h>
-#include <math.h>
-#include <time.h>
-#include "decs.h"
-
-void slave() 
-
-{
-   int i;
-   int j;
-   int nstep;
-   int iindex;
-   int iday;
-   double ysca1;
-   double y;
-   double factor;
-   double sintemp;
-   double curlt;
-   double ressqr;
-   int istart; 
-   int iend; 
-   int jstart; 
-   int jend;
-   int ist; 
-   int ien; 
-   int jst; 
-   int jen;
-   double fac;
-   int dayflag=0;
-   int dhourflag=0;
-   int endflag=0;
-   double ttime;
-   double dhour;
-   double day;
-   int firstrow;
-   int lastrow;
-   int numrows;
-   int firstcol;
-   int lastcol;
-   int numcols;
-   int psiindex;
-   double psibipriv;
-   int psinum;
-   int procid;
-   unsigned int t1;
-
-   ressqr = lev_res[numlev-1] * lev_res[numlev-1];
-
-   {;}
-     procid = global->id;
-     global->id = global->id+1;
-   {;}
-
-/* POSSIBLE ENHANCEMENT:  Here is where one might pin processes to
-   processors to avoid migration. */
-
-/* POSSIBLE ENHANCEMENT:  Here is where one might distribute
-   data structures across physically distributed memories in
-   a round-robin fashion. */
-
-   firstcol = gp[procid].rel_start_x[numlev-1];
-   lastcol = firstcol + gp[procid].rel_num_x[numlev-1] - 1;
-   firstrow = gp[procid].rel_start_y[numlev-1];
-   lastrow = firstrow + gp[procid].rel_num_y[numlev-1] - 1;
-   numcols = gp[procid].rel_num_x[numlev-1];
-   numrows = gp[procid].rel_num_y[numlev-1];
-
-   if (procid > nprocs/2) {
-      psinum = 2;
-   } else {
-      psinum = 1;
-   }
-
-/* every process gets its own copy of the timing variables to avoid
-   contention at shared memory locations.  here, these variables
-   are initialized.  */
-
-   ttime = 0.0;
-   dhour = 0.0;
-   nstep = 0 ;
-   day = 0.0;
- 
-   ysca1 = 0.5*ysca;
-   if (procid == MASTER) {
-     for(iindex = 0;iindex<=jm-1;iindex++) {
-       y = ((double) iindex)*res;
-       wrk2->f[iindex] = f0+beta*(y-ysca1);
-     }
-   }
-
-   if (procid == MASTER) {
-     fields2->psium[0][0]=0.0;
-   }
-   if (procid == nprocs-xprocs) {
-     fields2->psium[im-1][0]=0.0;
-   }
-   if (procid == xprocs-1) {
-     fields2->psium[0][jm-1]=0.0;
-   }
-   if (procid == nprocs-1) {
-     fields2->psium[im-1][jm-1]=0.0;
-   }
-   if (firstrow == 1) {
-     for(j=firstcol;j<=lastcol;j++) {
-       fields2->psium[0][j] = 0.0;
-     }
-   }
-   if ((firstrow+numrows) == im-1) {
-     for(j=firstcol;j<=lastcol;j++) {
-       fields2->psium[im-1][j] = 0.0;
-     }
-   }
-   if (firstcol == 1) {
-     for(j=firstrow;j<=lastrow;j++) {
-       fields2->psium[j][0] = 0.0;
-     }
-   }
-   if ((firstcol+numcols) == jm-1) {
-     for(j=firstrow;j<=lastrow;j++) {
-       fields2->psium[j][jm-1] = 0.0;
-     }
-   }
-   
-   for(i=firstrow;i<=lastrow;i++) {
-     for(iindex=firstcol;iindex<=lastcol;iindex++) {
-       fields2->psium[i][iindex] = 0.0;
-     }
-   }
-   if (procid == MASTER) {
-     fields2->psilm[0][0]=0.0;
-   }
-   if (procid == nprocs-xprocs) {
-     fields2->psilm[im-1][0]=0.0;
-   }
-   if (procid == xprocs-1) {
-     fields2->psilm[0][jm-1]=0.0;
-   }
-   if (procid == nprocs-1) {
-     fields2->psilm[im-1][jm-1]=0.0;
-   }
-   if (firstrow == 1) {
-     for(j=firstcol;j<=lastcol;j++) {
-       fields2->psilm[0][j] = 0.0;
-     }
-   }
-   if ((firstrow+numrows) == im-1) {
-     for(j=firstcol;j<=lastcol;j++) {
-       fields2->psilm[im-1][j] = 0.0;
-     }
-   }
-   if (firstcol == 1) {
-     for(j=firstrow;j<=lastrow;j++) {
-       fields2->psilm[j][0] = 0.0;
-     }
-   }
-   if ((firstcol+numcols) == jm-1) {
-     for(j=firstrow;j<=lastrow;j++) {
-       fields2->psilm[j][jm-1] = 0.0;
-     }
-   }
-   for(i=firstrow;i<=lastrow;i++) {
-     for(iindex=firstcol;iindex<=lastcol;iindex++) {
-       fields2->psilm[i][iindex] = 0.0;
-     }
-   }
-
-   if (procid == MASTER) {
-     wrk1->psib[0][0]=1.0;
-   }
-   if (procid == xprocs-1) {
-     wrk1->psib[0][jm-1]=1.0;
-   }
-   if (procid == nprocs-xprocs) {
-     wrk1->psib[im-1][0]=1.0;
-   }
-   if (procid == nprocs-1) {
-     wrk1->psib[im-1][jm-1]=1.0;
-   }
-   if (firstrow == 1) {
-     for(j=firstcol;j<=lastcol;j++) {
-       wrk1->psib[0][j] = 1.0;
-     }
-   }
-   if ((firstrow+numrows) == im-1) {
-     for(j=firstcol;j<=lastcol;j++) {
-       wrk1->psib[im-1][j] = 1.0;
-     }
-   }
-   if (firstcol == 1) {
-     for(j=firstrow;j<=lastrow;j++) {
-       wrk1->psib[j][0] = 1.0;
-     }
-   }
-   if ((firstcol+numcols) == jm-1) {
-     for(j=firstrow;j<=lastrow;j++) {
-       wrk1->psib[j][jm-1] = 1.0;
-     }
-   }
-   for(i=firstrow;i<=lastrow;i++) {
-     for(iindex=firstcol;iindex<=lastcol;iindex++) {
-       wrk1->psib[i][iindex] = 0.0;
-     }
-   }
-
-/* wait until all processes have completed the above initialization  */
-
-{;}
-
-   istart = gp[procid].rel_start_y[numlev-1];
-   iend = istart + gp[procid].rel_num_y[numlev-1] - 1;
-   jstart = gp[procid].rel_start_x[numlev-1];
-   jend = jstart + gp[procid].rel_num_x[numlev-1] - 1;
-   ist = istart;
-   ien = iend;
-   jst = jstart;
-   jen = jend;
-   if (istart == 1) {
-     istart = 0;
-   }
-   if (jstart == 1) {
-     jstart = 0;
-   }
-   if (iend == im-2) {
-     iend = im-1;
-   }
-   if (jend == jm-2) {
-     jend = jm-1;
-   }
-   for(i=istart;i<=iend;i++) {
-     for(j=jstart;j<=jend;j++) {
-       multi->rhs_multi[numlev-1][i][j] = wrk1->psib[i][j] * ressqr;
-     }
-   }
-   if (istart == 0) {
-     for(j=jstart;j<=jend;j++) {
-       multi->q_multi[numlev-1][0][j] = wrk1->psib[0][j];
-     }
-   }
-   if (iend == im-1) {
-     for(j=jstart;j<=jend;j++) {
-       multi->q_multi[numlev-1][im-1][j] = wrk1->psib[im-1][j];
-     }
-   }
-   if (jstart == 0) {
-     for(i=istart;i<=iend;i++) {
-       multi->q_multi[numlev-1][i][0] = wrk1->psib[i][0];
-     }
-   }
-   if (jend == jm-1) {
-     for(i=istart;i<=iend;i++) {
-       multi->q_multi[numlev-1][i][jm-1] = wrk1->psib[i][jm-1];
-     }
-   }
-   
-   fac = 1.0 / (4.0 - ressqr*eig2);
-   for(i=ist;i<=ien;i++) {
-     for(j=jst;j<=jen;j++) {
-       multi->q_multi[numlev-1][i][j] = fac * (wrk1->psib[i+1][j] + 
-           wrk1->psib[i-1][j] + wrk1->psib[i][j+1] + wrk1->psib[i][j-1] - 
-           ressqr*wrk1->psib[i][j]);
-     }
-   }
-   {;}
-   
-   multig(procid);
-
-   for(i=istart;i<=iend;i++) {
-     for(j=jstart;j<=jend;j++) {
-       wrk1->psib[i][j] = multi->q_multi[numlev-1][i][j];
-     }
-   }
-
-   {;}
-
-/* update the local running sum psibipriv by summing all the resulting
-   values in that process's share of the psib matrix   */
-
-   psibipriv=0.0;
-   if (procid == MASTER) {
-     psibipriv = psibipriv + 0.25*(wrk1->psib[0][0]);
-   }
-   if (procid == xprocs-1){
-     psibipriv = psibipriv + 0.25*(wrk1->psib[0][jm-1]);
-   }
-   if (procid == nprocs - xprocs) {
-     psibipriv=psibipriv+0.25*(wrk1->psib[im-1][0]);
-   }
-   if (procid == nprocs-1) {
-     psibipriv=psibipriv+0.25*(wrk1->psib[im-1][jm-1]);
-   }
-   if (firstrow == 1) {
-     for(j=firstcol;j<=lastcol;j++) {
-       psibipriv = psibipriv + 0.5*wrk1->psib[0][j];
-     }
-   }
-   if ((firstrow+numrows) == im-1) {
-     for(j=firstcol;j<=lastcol;j++) {
-       psibipriv = psibipriv + 0.5*wrk1->psib[im-1][j];
-     }
-   }
-   if (firstcol == 1) {
-     for(j=firstrow;j<=lastrow;j++) {
-       psibipriv = psibipriv + 0.5*wrk1->psib[j][0];
-     }
-   }
-   if ((firstcol+numcols) == jm-1) {
-     for(j=firstrow;j<=lastrow;j++) {
-       psibipriv = psibipriv + 0.5*wrk1->psib[j][jm-1];
-     }
-   }
-     for(iindex=firstcol;iindex<=lastcol;iindex++) {
-   for(i=firstrow;i<=lastrow;i++) {
-       psibipriv = psibipriv + wrk1->psib[i][iindex];
-     }
-   } 
-
-/* update the shared variable psibi by summing all the psibiprivs
-   of the individual processes into it.  note that this combined
-   private and shared sum method avoids accessing the shared 
-   variable psibi once for every element of the matrix.  */
-
-   {;}
-   global->psibi = global->psibi + psibipriv;
-   {;}
-
-   for(psiindex=0;psiindex<=1;psiindex++) {
-     if (procid == MASTER) {
-       fields->psim[psiindex][0][0] = 0.0;
-     }
-     if (procid == nprocs-xprocs) {
-       fields->psim[psiindex][im-1][0] = 0.0;
-     }
-     if (procid == xprocs-1) {
-       fields->psim[psiindex][0][jm-1] = 0.0;
-     }
-     if (procid == nprocs-1) {
-       fields->psim[psiindex][im-1][jm-1] = 0.0;
-     }
-     if (firstrow == 1) {
-       for(j=firstcol;j<=lastcol;j++) {
-         fields->psim[psiindex][0][j] = 0.0;
-       }
-     }
-     if ((firstrow+numrows) == im-1) {
-       for(j=firstcol;j<=lastcol;j++) {
-         fields->psim[psiindex][im-1][j] = 0.0;
-       }
-     }
-     if (firstcol == 1) {
-       for(j=firstrow;j<=lastrow;j++) {
-         fields->psim[psiindex][j][0] = 0.0;
-       }
-     }
-     if ((firstcol+numcols) == jm-1) {
-       for(j=firstrow;j<=lastrow;j++) {
-         fields->psim[psiindex][j][jm-1] = 0.0;
-       }
-     }
-     for(i=firstrow;i<=lastrow;i++) {
-       for(iindex=firstcol;iindex<=lastcol;iindex++) {
-           fields->psim[psiindex][i][iindex] = 0.0;
-       }
-     }
-   }
- 
-/* initialize psi matrices the same way  */
-
-   for(psiindex=0;psiindex<=1;psiindex++) {
-     if (procid == MASTER) {
-       fields->psi[psiindex][0][0] = 0.0;
-     }
-     if (procid == xprocs-1) {
-       fields->psi[psiindex][0][jm-1] = 0.0;
-     }
-     if (procid == nprocs-xprocs) {
-       fields->psi[psiindex][im-1][0] = 0.0;
-     }
-     if (procid == nprocs-1) {
-       fields->psi[psiindex][im-1][jm-1] = 0.0;
-     }
-     if (firstrow == 1) {
-       for(j=firstcol;j<=lastcol;j++) {
-         fields->psi[psiindex][0][j] = 0.0;
-       }
-     }
-     if ((firstrow+numrows) == im-1) {
-       for(j=firstcol;j<=lastcol;j++) {
-         fields->psi[psiindex][im-1][j] = 0.0;
-       }
-     }
-     if (firstcol == 1) {
-       for(j=firstrow;j<=lastrow;j++) {
-         fields->psi[psiindex][j][0] = 0.0;
-       }
-     }
-     if ((firstcol+numcols) == jm-1) {
-       for(j=firstrow;j<=lastrow;j++) {
-         fields->psi[psiindex][j][jm-1] = 0.0;
-       }
-     }
-     for(i=firstrow;i<=lastrow;i++) {
-       for(iindex=firstcol;iindex<=lastcol;iindex++) {
-         fields->psi[psiindex][i][iindex] = 0.0;
-       }
-     }
-   }
-
-/* compute input curl of wind stress */
-
-   ysca1 = .5*ysca;
-   factor= -t0*pi/ysca1;
-   if (procid == MASTER) {
-     frcng->tauz[0][0] = 0.0;
-   }
-   if (procid == nprocs-xprocs) {
-     frcng->tauz[im-1][0] = 0.0;
-   }
-   if (procid == xprocs-1) {
-     sintemp = pi*((double) jmm1)*res/ysca1;
-     sintemp = sin(sintemp);
-     frcng->tauz[0][jm-1] = factor*sintemp;
-   }
-   if (procid == nprocs-1) {
-     sintemp = pi*((double) jmm1)*res/ysca1;
-     sintemp = sin(sintemp);
-     frcng->tauz[im-1][jm-1] = frcng->tauz[0][jm-1];
-   }
-   if (firstrow == 1) {
-     for(j=firstcol;j<=lastcol;j++) {
-       sintemp = pi*((double) j)*res/ysca1;
-       sintemp = sin(sintemp);
-       curlt = factor*sintemp;
-       frcng->tauz[0][j] = curlt;
-     }
-   }
-   if ((firstrow+numrows) == im-1) {
-     for(j=firstcol;j<=lastcol;j++) {
-       sintemp = pi*((double) j)*res/ysca1;
-       sintemp = sin(sintemp);
-       curlt = factor*sintemp;
-       frcng->tauz[im-1][j] = curlt;
-     }
-   }
-   if (firstcol == 1) {
-     for(j=firstrow;j<=lastrow;j++) {
-       frcng->tauz[j][0] = 0.0;
-     }
-   }
-   if ((firstcol+numcols) == jm-1) {
-     sintemp = pi*((double) jmm1)*res/ysca1;
-     sintemp = sin(sintemp);
-     curlt = factor*sintemp;
-     for(j=firstrow;j<=lastrow;j++) {
-       frcng->tauz[j][jm-1] = curlt;
-     }
-   }
-   for(iindex=firstcol;iindex<=lastcol;iindex++) {
-     sintemp = pi*((double) iindex)*res/ysca1;
-     sintemp = sin(sintemp);
-     curlt = factor*sintemp;
-     for(i=firstrow;i<=lastrow;i++) {
-       frcng->tauz[i][iindex] = curlt;
-     }
-   }
-   
-   {;}
-   
-   
-/***************************************************************
- one-time stuff over at this point
- ***************************************************************/
-
-   while (!endflag) {
-     while ((!dayflag) || (!dhourflag)) {
-       dayflag = 0;
-       dhourflag = 0;
-       if (nstep == 1) {
-         if (procid == MASTER) {
-            {long time(); (global->trackstart) = time(0);}
-         }
-         if ((procid == MASTER) || (do_stats)) {
-           {long time(); (t1) = time(0);};
-           gp[procid].total_time = t1;
-           gp[procid].multi_time = 0;
-         }
-/* POSSIBLE ENHANCEMENT:  Here is where one might reset the
-   statistics that one is measuring about the parallel execution */
-       }
-
-       slave2(procid,firstrow,lastrow,numrows,firstcol,lastcol,numcols);
-
-/* update time and step number
-   note that these time and step variables are private i.e. every
-   process has its own copy and keeps track of its own time  */
-
-       ttime = ttime + dtau;
-       nstep = nstep + 1;
-       day = ttime/86400.0;
-       if (day > ((double) outday0)) {
-         dayflag = 1;
-         iday = (int) day;
-         dhour = dhour+dtau;
-         if (dhour >= 86400.0) {
-	   dhourflag = 1;
-         }
-       }
-     }
-     dhour = 0.0;
-
-/* update values of psium array to psium + psim{1}  */
-
-     if (procid == MASTER) {
-       fields2->psium[0][0] = fields2->psium[0][0]+fields->psim[0][0][0];
-     }
-     if (procid == nprocs-xprocs) {
-       fields2->psium[im-1][0] = fields2->psium[im-1][0]+fields->psim[0][im-1][0];
-     }
-     if (procid == xprocs-1) {
-       fields2->psium[0][jm-1] = fields2->psium[0][jm-1]+fields->psim[0][0][jm-1];
-     }
-     if (procid == nprocs-1) {
-       fields2->psium[im-1][jm-1] = fields2->psium[im-1][jm-1]+fields->psim[0][im-1][jm-1];
-     }
-     if (firstrow == 1) {
-       for(j=firstcol;j<=lastcol;j++) {
-         fields2->psium[0][j] = fields2->psium[0][j]+fields->psim[0][0][j];
-       }
-     }
-     if ((firstrow+numrows) == im-1) {
-       for(j=firstcol;j<=lastcol;j++) {
-         fields2->psium[im-1][j] = fields2->psium[im-1][j]+fields->psim[0][im-1][j];
-       }
-     }
-     if (firstcol == 1) {
-       for(j=firstrow;j<=lastrow;j++) {
-         fields2->psium[j][0] = fields2->psium[j][0]+fields->psim[0][j][0];
-       }
-     }
-     if ((firstcol+numcols) == jm-1) {
-       for(j=firstrow;j<=lastrow;j++) {
-         fields2->psium[j][jm-1] = fields2->psium[j][jm-1]+fields->psim[0][j][jm-1];
-       }
-     }
-     for(i=firstrow;i<=lastrow;i++) {
-       for(iindex=firstcol;iindex<=lastcol;iindex++) {
-         fields2->psium[i][iindex] = fields2->psium[i][iindex]+fields->psim[0][i][iindex];
-       }
-     }
-     
-/* update values of psilm array to psilm + psim[2]  */
-     
-     if (procid == MASTER) {
-       fields2->psilm[0][0] = fields2->psilm[0][0]+fields->psim[1][0][0];
-     }
-     if (procid == nprocs-xprocs) {
-       fields2->psilm[im-1][0] = fields2->psilm[im-1][0]+fields->psim[1][im-1][0];
-     }
-     if (procid == xprocs-1) {
-       fields2->psilm[0][jm-1] = fields2->psilm[0][jm-1]+fields->psim[1][0][jm-1];
-     }
-     if (procid == nprocs-1) {
-       fields2->psilm[im-1][jm-1] = fields2->psilm[im-1][jm-1]+fields->psim[1][im-1][jm-1];
-     }
-     if (firstrow == 1) {
-       for(j=firstcol;j<=lastcol;j++) {
-         fields2->psilm[0][j] = fields2->psilm[0][j]+fields->psim[1][0][j];
-       }
-     }
-     if ((firstrow+numrows) == im-1) {
-       for(j=firstcol;j<=lastcol;j++) {
-         fields2->psilm[im-1][j] = fields2->psilm[im-1][j]+fields->psim[1][im-1][j];
-       }
-     }
-     if (firstcol == 1) {
-       for(j=firstrow;j<=lastrow;j++) {
-         fields2->psilm[j][0] = fields2->psilm[j][0]+fields->psim[1][j][0];
-       }
-     }
-     if ((firstcol+numcols) == jm-1) {
-       for(j=firstrow;j<=lastrow;j++) {
-         fields2->psilm[j][jm-1] = fields2->psilm[j][jm-1]+fields->psim[1][j][jm-1];
-       }
-     }
-     for(i=firstrow;i<=lastrow;i++) {
-       for(iindex=firstcol;iindex<=lastcol;iindex++) {
-         fields2->psilm[i][iindex] = fields2->psilm[i][iindex]+fields->psim[1][i][iindex];
-       }
-     }
-     if (iday >= (int) outday3) {
-       endflag = 1;
-     }
-  }
-  if ((procid == MASTER) || (do_stats)) {
-    {long time(); (t1) = time(0);};
-    gp[procid].total_time = t1-gp[procid].total_time;
-  }
-}
diff -Naur splash2/codes/apps/ocean/non_contiguous_partitions/slave1.C splash2-modified/codes/apps/ocean/non_contiguous_partitions/slave1.C
--- splash2/codes/apps/ocean/non_contiguous_partitions/slave1.C	1994-10-15 00:06:43.000000000 -0400
+++ splash2-modified/codes/apps/ocean/non_contiguous_partitions/slave1.C	2007-03-19 23:59:40.000000000 -0400
@@ -17,52 +17,53 @@
 /*    ****************
       subroutine slave
       ****************  */
-     
+
 #include <stdio.h>
 #include <math.h>
 #include <time.h>
-#include "decs.h"
+#include <stdlib.h>
 
-void slave() 
+#include "decs.h"
 
+void slave()
 {
-   int i;
-   int j;
-   int nstep;
-   int iindex;
-   int iday;
+   long i;
+   long j;
+   long nstep;
+   long iindex;
+   long iday;
    double ysca1;
    double y;
    double factor;
    double sintemp;
    double curlt;
    double ressqr;
-   int istart; 
-   int iend; 
-   int jstart; 
-   int jend;
-   int ist; 
-   int ien; 
-   int jst; 
-   int jen;
+   long istart;
+   long iend;
+   long jstart;
+   long jend;
+   long ist;
+   long ien;
+   long jst;
+   long jen;
    double fac;
-   int dayflag=0;
-   int dhourflag=0;
-   int endflag=0;
+   long dayflag=0;
+   long dhourflag=0;
+   long endflag=0;
    double ttime;
    double dhour;
    double day;
-   int firstrow;
-   int lastrow;
-   int numrows;
-   int firstcol;
-   int lastcol;
-   int numcols;
-   int psiindex;
+   long firstrow;
+   long lastrow;
+   long numrows;
+   long firstcol;
+   long lastcol;
+   long numcols;
+   long psiindex;
    double psibipriv;
-   int psinum;
-   int procid;
-   unsigned int t1;
+   long psinum;
+   long procid;
+   unsigned long t1;
 
    ressqr = lev_res[numlev-1] * lev_res[numlev-1];
 
@@ -99,7 +100,7 @@
    dhour = 0.0;
    nstep = 0 ;
    day = 0.0;
- 
+
    ysca1 = 0.5*ysca;
    if (procid == MASTER) {
      for(iindex = 0;iindex<=jm-1;iindex++) {
@@ -140,7 +141,7 @@
        fields2->psium[j][jm-1] = 0.0;
      }
    }
-   
+
    for(i=firstrow;i<=lastrow;i++) {
      for(iindex=firstcol;iindex<=lastcol;iindex++) {
        fields2->psium[i][iindex] = 0.0;
@@ -223,9 +224,11 @@
    }
 
 /* wait until all processes have completed the above initialization  */
-
+#if defined(MULTIPLE_BARRIERS)
 BARRIER(bars->sl_prini,nprocs)
-
+#else
+BARRIER(bars->barrier,nprocs)
+#endif
    istart = gp[procid].rel_start_y[numlev-1];
    iend = istart + gp[procid].rel_num_y[numlev-1] - 1;
    jstart = gp[procid].rel_start_x[numlev-1];
@@ -271,17 +274,20 @@
        multi->q_multi[numlev-1][i][jm-1] = wrk1->psib[i][jm-1];
      }
    }
-   
+
    fac = 1.0 / (4.0 - ressqr*eig2);
    for(i=ist;i<=ien;i++) {
      for(j=jst;j<=jen;j++) {
-       multi->q_multi[numlev-1][i][j] = fac * (wrk1->psib[i+1][j] + 
-           wrk1->psib[i-1][j] + wrk1->psib[i][j+1] + wrk1->psib[i][j-1] - 
+       multi->q_multi[numlev-1][i][j] = fac * (wrk1->psib[i+1][j] +
+           wrk1->psib[i-1][j] + wrk1->psib[i][j+1] + wrk1->psib[i][j-1] -
            ressqr*wrk1->psib[i][j]);
      }
    }
+#if defined(MULTIPLE_BARRIERS)
    BARRIER(bars->sl_prini,nprocs)
-   
+#else
+   BARRIER(bars->barrier,nprocs)
+#endif
    multig(procid);
 
    for(i=istart;i<=iend;i++) {
@@ -289,9 +295,11 @@
        wrk1->psib[i][j] = multi->q_multi[numlev-1][i][j];
      }
    }
-
+#if defined(MULTIPLE_BARRIERS)
    BARRIER(bars->sl_psini,nprocs)
-
+#else
+   BARRIER(bars->barrier,nprocs)
+#endif
 /* update the local running sum psibipriv by summing all the resulting
    values in that process's share of the psib matrix   */
 
@@ -332,11 +340,11 @@
    for(i=firstrow;i<=lastrow;i++) {
        psibipriv = psibipriv + wrk1->psib[i][iindex];
      }
-   } 
+   }
 
 /* update the shared variable psibi by summing all the psibiprivs
    of the individual processes into it.  note that this combined
-   private and shared sum method avoids accessing the shared 
+   private and shared sum method avoids accessing the shared
    variable psibi once for every element of the matrix.  */
 
    LOCK(locks->psibilock)
@@ -382,7 +390,7 @@
        }
      }
    }
- 
+
 /* initialize psi matrices the same way  */
 
    for(psiindex=0;psiindex<=1;psiindex++) {
@@ -482,10 +490,12 @@
        frcng->tauz[i][iindex] = curlt;
      }
    }
-   
+#if defined(MULTIPLE_BARRIERS)
    BARRIER(bars->sl_onetime,nprocs)
-   
-   
+#else
+   BARRIER(bars->barrier,nprocs)
+#endif
+
 /***************************************************************
  one-time stuff over at this point
  ***************************************************************/
@@ -518,7 +528,7 @@
        day = ttime/86400.0;
        if (day > ((double) outday0)) {
          dayflag = 1;
-         iday = (int) day;
+         iday = (long) day;
          dhour = dhour+dtau;
          if (dhour >= 86400.0) {
 	   dhourflag = 1;
@@ -566,9 +576,9 @@
          fields2->psium[i][iindex] = fields2->psium[i][iindex]+fields->psim[0][i][iindex];
        }
      }
-     
+
 /* update values of psilm array to psilm + psim[2]  */
-     
+
      if (procid == MASTER) {
        fields2->psilm[0][0] = fields2->psilm[0][0]+fields->psim[1][0][0];
      }
@@ -606,7 +616,7 @@
          fields2->psilm[i][iindex] = fields2->psilm[i][iindex]+fields->psim[1][i][iindex];
        }
      }
-     if (iday >= (int) outday3) {
+     if (iday >= (long) outday3) {
        endflag = 1;
      }
   }
diff -Naur splash2/codes/apps/ocean/non_contiguous_partitions/slave1.o splash2-modified/codes/apps/ocean/non_contiguous_partitions/slave1.o
--- splash2/codes/apps/ocean/non_contiguous_partitions/slave1.o	1994-10-15 00:17:21.000000000 -0400
+++ splash2-modified/codes/apps/ocean/non_contiguous_partitions/slave1.o	1969-12-31 19:00:00.000000000 -0500
@@ -1,33 +0,0 @@
-ELF                        o    4     ( 
-                          \                       \            H                   $             +             .             5             :             =             A             F             I             N             V             ]             `             e             k             p              w             ~                                                                                                                                                              .symtab .shstrtab .strtab .text .rodata .options .reginfo .rel.text .mdebug  .text .rodata slave lev_res numlev global gp nprocs ysca jm res wrk2 f0 beta fields2 xprocs im wrk1 multi eig2 multig fields t0 pi frcng jmm1 sin time do_stats slave2 dtau outday0 outday3 _gp_disp          <  '  !'        c   t p l h d ` \ X T P L @ D 8 < 0 4 ( ,   $ xd  !! X$ n  X   8! 8# 8#      p! x!Y0IET<?D Fx  D D  p!F  D X%  $ % @!%p|F F   $F$    %X    %  X        < D0   F2!   F*@    N  F8x!F2!& $c F&" ( $)  X      *     X   <                      9  X  %#X         o     /!  !        $O      Y     x!  $Y       . o     /!O    p! !54$ a +	*  ) %	(#$ 0  !   &s !   S& % 3    &s p!         !5 4       p!    % !5 4 &      |y   n!' . C |	*  @ %	(#$ 0   	! y     qp! q !!&s 54S& %  ) x     8!  x!!y     yx! y !!54o     !  !0x! x     8!  x!!% &s &      $ ! 4p#*  . `%/0#$ 0   !  s!    &s !5  4 S$c    $X    s!    &s p!         #!      p! $  $O #!04$c @pX  .!'.  I x %*  C0#$ 0   ! y  x!Y   y ! px!&s S    $Y 3 /     q  p!Y   q x! p! y  x!N   y /! x!   !O    ! p.!   3!X    p! x!$X &s 5(4,    *  A% 	*  9 %	(#$ 0  !    !  8p!x!&    T$c % 4 %  q  p! q x!! q5  4   p! q x!!5 4  q  p! q x!!5 4  q  p! q x!!% & 5 4 $c  &R 	*    X %           !5  4 $    N    Xx# Xn     !  8x!p!        X    '8  	XN     !p!  XX  % 8 o     /!O    ! p!>x!$  .	*  , %	(#$ 0  !   &s 0x!!   $S& %     &s 0x!!   $      !>x! ( ,      p!!5 04 4  % !p! 8 <3&   |o  '  E	*  C %	(#$ 0   )! o     qp! q !0x!!&s S& %  - o     !  8p!x!!54n     yx! y !0p!!y     qp! q !!>x! $x     8!  x!!p!% &s (,3&  $ ! 9 x%*  20#$ 0  !  o!    &s #!p!   $S$c    % 3   s!    &s p!x!   $      #!p!(0(4      !>!0@0D  $X x!!58P48T$c @ xN  %  O %*  H0#$ 0  ! y  x!X   y /p! x!!&s  S     % 3 3       !Y    p! x!! y5 4   x!Y   y ! px!!5((4(, q  p!Y   q x! p!!50840<   !Y    p! x!!$N &s 58H48L    *  F% 	*  >	(#$ 0   )!    !  x!!>p!&    $T$c %  )    2!  p!!x! q   $  p! q .!x!!5 (4 ,   !  x!!>p! 0 4 y  x! y !#p!!% &  8 <$c   %&R 	*    X            <?  Dh D`      X  <?Dh   D` '  
-    N     8x!          XB       E# Xo     qp! q !  -,B      X    %  y     yx!Y   y ! px!$ ! )	*  ' %	(#$ 0   	!   &s x!   S& % 3    &s p!         !- ,       p!    % !- , &   |n  %  @	*  > %	(#$ 0   	! n     .!  !p!&s S& %  ) x     qp! q .x!!n     yx! y /!p!o     !  8p!x! x     qp! q .x!!% &s 3&  $ ! 4 x%*  -0#$ 0   !  n!    &s #x!   S$c    '    s!    &s #x!         p!      #x! $  $Y p!043$c @ xO  '  J %*  C0#$ 0  !   !Y    x! p!&s S    '/  /       !O    ! p.!   3!X    p! x!-, q  p!Y   q x! p! y  x!N   y /! x!$N &s (,    *  ?' 	*  9	(#$ 0  !    2!  !x!&    T$c %  %    !  8x!p!      !  8x!p!     !  8x!p!     !  8x!p!% &   4$c   %&R 	*X   pp! pp# pp#     q ! 8!LC0NxOTh!(!%$P  d  $  0%%a $  '8   `% $ $ &    2*        '- < A *  %  #$ 0    !  y  x! y !  0! /!    
- /!.   yF"Tx! @ y !p!!"!&s  s& $  i    2!  !  x! !     !.   F"2! @  x!p!!x! q   p! q .!  x! !    !9   qF"2p! @ q 8x!!0!x!   2!  !  x! !    !.   F"T2! @  x!p!!x! q  p! q .!  x! !  !  9   qp! @F" q 8x!!0!x!$ &s &  &R o *    g *  e%  #$ 0   !<6      p! yx! z 9  x!    y@/p!!!&s & '_S&_$  G<6      ! qp! r 9  p!	    q@.!x!!)_(_    ! qp! r /  p! 
-  q@!!5x!__    ! qp! r 9  p!   q@.!x!!1_0_    ! qp! r /  p!   q@!!5x!$ &s &  __o  <' / 6  *  %  #$ 0   ! d     $!  x!  p! yx! z x!8    y@$!  p!!x!p!&s & WSW$ 3 i d     yx! y p!  ! qp! r p!8   y'& q@x! y !/!p!!'W&Wd     !  p!  ! qp! r p!/   )( q@!  !8x!p!!)W(Wd     yx! y p!  ! qp! r p!8   y+ * q@x! y !/!p!!+W*Wd     !  p!  ! qp! r p!/   10 q@!  !8x!p!!$ &s &  1W0W m    %*  g #$ 0   /!  O!      p! !  9  !    @8p!x!!&R $B3_r2_    '  H  R!      ! yx! z 8  x!%  $  y@!"p!!__    ! yx! z .  x!'& y@!"!p!gg    ! yx! z 8  x!) ($ y@!"p!!	p p    ! yx! z .  x!+0*4 y@!"!p!$o &R $B @xxX  $ 8 <@%*   #$ 0   #.! C    2!   p!   %! qp! r p!/   2! q@  !x!p!!&R _R_    '/  s<@     C    2!   px!  %p! yx! z x!8   2! y@  p!!x!p!__ y  C  x! y p!    %! qp! r p!8   y%$x! q@ y !/!p!!%g$g q  C  p! q ! x  %/x! .!  .!8   qp! @ q x!!!5x!oo   C  2!  x! p  %p! yx! z x!8   (,2! y@  p!!x!p!$Y &R x2x<@DX   DP 1  0 F0    *F2Q  F$`%  *  % #$B 0N  -!    !  8x!!GFIHK F(4 J H I  F*  F"DED !F$  F02!.   F T2! @  x!p!!x!&s __s& $ 3     !  x!!EDIHQ F(!P H I  F02  F"ASR !F2Q   F&$!9   qF p! @ q 8x!!0!x! __  2!  !!SRIHG F( F H I F&$   F"AK  J  .!F*  F$.!/   qF 4p! @ q !x!!5!__ y  x! y !0!K J$I HE F(TD H I F$  F"DQ P  yx!F02 z F2Qx!8   qF !p! y@ q !.!x!!'_&_   !  x!!Q(P,IHS  F(R $H I   F2Q G F"BF  !  F&$ !F*9   qp! @F  q 8x!!0!x!$ &s __e&  &R . *  Xtx 	 ltx      2*  '-  *  %  #$ 0   !   /   .!  .! qp! @ q !x!!5! y  x! y __!0!&s &   S $  e   /   !  ! 2! @  p!x!!p! y  x! y __/!p!     9   !  ! yx! @ y 8p!!0!p!   2!  __!p!    /   !  ! 2! @  p!x!!p! y  x! y __/!p!    9   !  ! yx! @ y 8p!!0!p!   2!  __!p!$ &s &    &R t *XX  
-F   <?D D        F"!F40   <?  D D %  
-    X     p.x!    F"DF    XB  P   E# Xo     !  !+*    F"TF  Xd  %     $!   px!!    F"!F 0 $ ! 3	*  1 %  	(#$ 0    ! p !&s Y  s     X &s F6Y $B sF  X $B F6F  %    !K  J E F6TD I H J F6!K F  &s % F6DF 0 $B  F6TF  F   |    %  7	*  5 %   y	(#9  $ x! y 0  /0!  !!&s Ys     X&s F6Y$B sF  X$B F6F  % 3  x !IHKF6DJE DHF6TIF  &s % F6!F  $B  F6DF 0 F  $ ! > x %8*  780#  $ 0    ! qp! q  !&s Y  s     X &s F6Y$BsF  X $BF6F      '/   !   !E  D IF6!HK J$D4F6DE0F 0 &s $n F6TF  $B @F6!F  F 0  x    '/  B	* %*  ;0#  $ 0       yx! y  p!!8 !&s Y     X&s F6Y$BF  X$BF6F      '8   yx! y  p!!    KJEF6TDIHJ,F6!K(F  &s $y F6DF 0 $B @F6TF  3F  	*  9< %  %*  .0#  $ 0      8!   x!! !E  D &R $BF       %   2!   x!!    G  F IHF 0 Q P$F @ K0J4F  &R $n $B @F P &  %  < c    s r 4  F     %d e X        9    x/p!!@@@D        Xp#.  yx! z 8  x!n   y@! !  8x!p!  8084      X q'8  p! r /  p!X   q@! x/p!!@8@<  X  '/   $!  8  $!n   @x! !N    ! x/!p!8(8,$ ! J	*  H %	(#$ 0  !  qp! r 8  p! q@!0x!!&s @@@DS& %  1  yx! z 9  x! y@/!p! !!  5@@4@D/  ! @p!!6x! qp! r @H@L8  p! q@!0x!! $!  @P@T.  $! @x!!p!% &s @X@\3&   |o  '  c	*  a %	(#$ 0   )!  yx! z 8  x!y   y@p! !  x!!6p!&s 8084S& %  E  $!  /  $!x   @p! yx! y !0! p!$!  8084/  $!n   @! yx! y !0p!! $!  888</  $!x   @p! yx! y !0!p! $!  8@8D/  $!n   @! yx! y !0p!!% &s 8H8L&  $ ! U x %*  N0#$ 0   !  y!   qp! r /  p! q@!!6x!&s @@@DS$c    %  4  s!   yx! z 9  x! y@/p!! q!p! r 5@@4@D/  p! q@!!6x! !  HPHT.  ! @!#x!p! $!  P`Pd8  $! @x!p!!$Y &s XpXt3$c @ xO  %  m %*  f0#$ 0  ! qp! r 8  p! q@ 3!x!N    ! x!6p!&s @8S@<    '  K     qp! r 9  p! q@ yx!.!N   y ! 8x! p!!  @8@<9  ! @ qp!8x!X   q ! x/p!! yx! z HHHL9  x! y@ !/p!O    ! p.!x! qp! r PXP\9  p! q@ yx!.!N   y ! 8x!p!$Y &s Xh3Xl' *  a	*  \	(#$ 0  !  yx! z 9  x! qp! y@ q /!!#x!!& @@@DT$c %  A  yx! z 9  x! qp! y@ q /!!#x!! $!@@@D  .  $! ! @  x!p!!6x! qp!@H@L r 8  p! yx! q@ y !/!p!! !5@P4@T  /  ! 2! @  p!x!!p!% & @X@\4$c   %&R 	*$ (  X   %X       8    p!5  4   X  %   $!  .  $!X   @x! p!  54        XB    Ex# $!  .  $!o   @! qp! q !  54B      X %  $!  .  $!x   @x! qp!X   q ! x/p!$  E	*  C %	(#$ 0   )!  qp! r /  p! q@!!&s 5  4 S& %  -  !  .  ! @! 0x!!     .  ! @!0x! !    .  ! @!0x! !    .  ! @!0x!% &s   &   |x  '/  ^	*  \ %	(#$ 0  !  !  9  !n   @8x! .!  !p!&s S& %  A  !  9  !o   @8p! /!  ! x!$!  .  $!o   @! qp! q !0x! qp! r 8  p!o   q@! !  8p!x! !   9  !o   @8p! /!  !x!% &s &  $ ! P x %*  I0#$ 0  !  y!   !  .  ! @x!!&s 5  4 S$c    %  0  s!   $!  /  $! @p! !$!     /  $! @p!! $!  /  $! @p!! $!   $/  $! @p!!$O &s 04$c @ xY  % 8 h%*  a0#$ 0   /! qp! r 8  p! q@ yx!!N   y /! x!&s S    %  G     yx! z 9  x! y@ !/p!O    ! p.! $!  /  $! @ !p!Y    x! p! yx! z 9  x! y@ !/p!O    ! p.! $!  /  $! @ !p!Y    x! p!$Y &s (3,% *  \	*  W	(#$ 0   	!  qp! r 9  p! ! q@  .x!!#p!&    T$c %  =  $!  8  $! yx! @ y p!!! yx!5  4  z .  x! 2! y@  !p!x! $!    8  $! yx! @ y p!!! yx!5 4  z .  x! 2! y@  !p!x!% &   $c   %&R 	*$ (  X<?D8   D0 )  (   F(61  0   X3  2 F F2Q  F8%                       X  # Xx     yx! y !  54      X    '          O  1  D0 0 F2!    F0B3  2 txF2Q 	F8# lF     X  t px.x!    X    ' . &O    D@ +  FD!*   F*%  $   tF$x 	F83 l      C  n    X! yx! y  %)( O!tx!)($  #	*  ! % % D   F3  2   F2Q'  &    F&"tx 	F8CF  l   tx!&s     &     |y  % / (	*  & % % DP   FT%  $   F$)  (    F(4tx 	F8 lF     n    .!  x!txp!&s   & $ ! 4 x %8*  -80#$ 0  !  x!    &s !5  4 S$c    %    s!    &s !5  4       !      !5 4$  $N !04$c @ xY  % 8 a	*N    D '  F!&   F&"1  0   F0Btx % 	F8S ltx    *  E0#$ 0   #!F  q  p!Y   q x! p!&s S    '/  /	*F  q  p!O   q ! 8p!   3!N    ! x!#"   !Y    x! p! y  x!X   y /p! x!$X &s (,	*  _    % D   F!'  &   F&"1  0    %F0B tx 	F8S l tx    *  ?     0#$ 0  !F  q  p! q x!!&R #  R"     $X  'F  y  x! y !#! y     x! y !#! y  x! y !#! $ y  x! y !#!$N &R 04    &       D D 5  4 <        {X$  :X   % X  t 	x lt  x       XX     %              ! pp! pp#   pp#  t 	x lD tx  A F!<AD8 D0     F&! o      !%$x      p! p  X|  tx 	  l  t!      F  )  F4( x    '8 F"@<    E  DO $ 5 8! D F $$ D F F:>    E           D D     X         9    6!@@
-@DS  R     F2QF G          X# Xb     !.    !!6!8084ih  F($ pq      X    %      C    /   !p!!+@8*@<SR    F2QFG  X  '  d  C   y  x! y  p!! % 9  !  8x!p!!%8($8,IH    F($ PQ$  Q	*  O %	(#$ 0  ! 9    0!x!!S  R @@@D&s F2Q& F sG  %  7 8    x!p!0!I  H @@@D&s F($ P Q  8    x!p!0!S R @H@L    F2QF G 8    x!p!0!I H @P@T    F($ P Q 8    x!p!0!S R @X@\% F2Q&  F 3G  |x  %  ~	*  | %	(#$ 0   )! d     !  p! y9  x! y !/!p!!%80$84IH&s F($ & PsQ%  [ d     qp! q ! /  !  0!p!!6x!8084SR&s F2QFGd     qp! q ! /  !  0!p!!6x!888<IH    F($ PQd     qp! q ! /  !  0!p!!6x!8@8DS R    F2QFG d     qp! q ! /  !  0!p!!6x!8H8LIH% F($ &  PQ$ ! \ x%.*  U.0#$ 0   !  n!  9    #x!p!!S  R @@@D&s F2Q$cF G      ' 3 :  s!  .    !!!I  H %@@$@D&s F($ P Q  .    !!!SR+HP*HT    F2QFG.    !!!I H$%P`$Pd    F($ P$Q .    !!!S0R4+Xp*Xt$ F2Q$c @F4G0 xX  '/  %%.*  .0#$ 0   : !$ C     ! x  8p!%!/   YX3!  !p!x!@8@<&s F8  YXC    !  8p! x%! /  3!  !p!x!@8@<YX$ F8 &s XY    '8  c     C    3!   p!! y%.  x! y !#!p!@8@<SR F2Q!FG  C    8p! x%! /  3!  !p!x!HHHLIH qF($ p!PQ  C   q x!  %! 9  !  8p!x!!+PX*P\SR yF2Qx!FG  C   y !  %8! q8  p! q x!!6!XhXlI(H,$ F($ &s P,Q(        *  }% 	*  u %	(#$ 0   ) !  q  p! q x! 9  !  !8p!x!!+@@*@DS  R & F2Q$c F G  %  U  y  x! y ! q8  p! q #!x!!6!@@@DI  H  yF($ x!P Q     y ! q8  p! q #!x!!6!@H
-@LS R  yF2Qx!F G    y ! q8  p! q #!x!!6!@P@TI H  yF($ x!P Q    y ! q8  p! q #!x!!6!@X
-@\S R % F2Q& F G $c  &R 	*    X            .  !x!```dI  H $    F($ P $Q          Xp#. Xb     yx! y .  !x!!>!srXP
-XT  F2Qfg      X    '.      C     x.  !x!!>!I H `X`\    F($ P Q   X  '.  d     qp!C   q .x!  % q9  !p! q !.x!!!+XH*XLSR    F2QFG$  V	*  T %	(#$ 0  !   .  !x!!>!I  H $```d&s F($ & P $sQ  % 3 ;   8  x!!5p!!S  R $```d&s F2QF $G    9  !0p!x!!I (H ,`h`l    F($ P ,Q (  .  !x!!>!S 0R 4`p
-`t    F2QF 4G 0  /  0p!!!!I 8H <%`x$`|% F($ &  P <Q 8 |o  '  	*   %	(#$ 0  ! d     yx! y ! y8  0p!x! y !!0p!!XP
-XTSR&s F2Q& FsG%  _ d     qp! q .! q9  x!p! q !.!x!!%XP$XTIH&s F($ PQd     !  x! .  !!  >!x!!5p!XXX\SR    F2QFGd     yx! y ! y8  0p!x! y !!0p!!X`XdI H$    F($ P$Q d     $!  p! /  !$!  !p!!x!XhXlS(R,% F2Q&  F,3G($ ! a x%*  Z0#$ 0   !  n!    /  #!p!!!I  H $%``$`d&s F($ $cP $Q      '  >  s!    8  !x!p!>!S  R $```d&s F2QF $G    /  #!p!!!I(0H(4%hp$ht    F($ P(4Q(0  .  x!!5!!S0@R0Dp
-p    F2QF0DG0@  9  p!#!x!!I8PH8Txx$ F($ $c @P8TQ8P xX  %   % %*  0#$ 0   < !$  C    !   p!/  %.p! !!  Y X !#p!x!`X`\&s F8  Y X   !C    ! p% /  !.p!  !!#p!x!`X`\Y X $ F8 &s X Y     ' 3 g       !C    ! p% /  !.p!  !!#p!x!`X`\I H  qF($ p!P Q   C   q .x!  % q9  p!! q !.x!!!+hh*hlS((R(, F2Q!F(,G((  C    ! p% /  !.p!  !!#p!x!pxp|I08H0< qF($ p!P0<Q08  C   q .x!  % q9  p!! q !.x!!!+x*xS8HR8L$ F2Q&s F8LG8H        *  % 	*  z %	(#$ 0   	 !  q  p! q .x! q9  p!! q !.x!!!%``$`dI  H $& F($ $c P $Q  %  Y    !  ! /  !#p!  !!#p!x!```dS  R $ F2Q2!F $G      p! 8  2!x!  !p!x!!`h`lI (H , qF($ p!P ,Q (   q .x! q9  p!! q !.x!!!+`p*`tS 0R 4 yF2Qx!F 4G 0   y ! y.  x!! y >!!!5p!`x`|I 8H <% F($ & P <Q 8$c  &R 	*  DY +  * 7! 8! D F T$ D D *       X   %@                ! #   # 	   lD0   F1!  A !<ADH D@     F(! qp    F0"jk t   $ ( , 0 4 8 < @ D L P T X \ ` d h p '     @                        ??                ??                  "     "     	     	     	     	     		  H  
-	  `  	  d  	  h  	  l  	    
-	    	    	    	     	     	  ,  	  P  	  x  	    	    	    	    	  $  	    	  H  	  \  	    	    	    	    	  $  	  "    "  	  "  
-	  "  	  %d  	  %  	  &H  	  '$  	  (  	  )  	  *,  	  *  	  *  	  +H  	  +L  	  +  	  +  	  4  	  4@  	  4T  	  4  	  <0  		  <@  	  <P  	  <p  	  <  	  <  	  <  	  <  	  <  	  <  	  =  	  =    =8  
-	  =T  	  =l  	  =`  	  =  	  =  	  =    =  
-	  =  	  >0  	  >@  	  >P    >  
-	  >  	  >  	  >  	  >    ?@  
-	  ?  	  @@  	  @T  	  @h    @  
-	  @  	  A  	  A  	  A    B$  
-	  B(  	  C<  	  CH    CL    C    C  	  C  	  C    D$  	  Dp    D  
-	  D  	  D  	  D   	  E  	  E  	  E  	  FP  	  P  	  P  	  P  	  QL  	  [  !	  \  	  \(    \D  	p	  7    d   '  n     il     i      dp   /  j    0  j     j     k      dp      l *0  00 
-  	      P "```##"%" EB F TS&$$# D C EEe""&$#DCE E  
-    R AP0 0!'PQAAXBDU 	 " 0   "&$#DCEA  0000C& $#CCEE  *$" #C CDE *$"%"" #0  !@@3 !#  @@2 D   ( D (   1   hpa02q# 0 ' $%#CC@BX D '$%# C  C @BX<<DX@(             T?             j           ,     
-         
-  \                     ,                    ,                                  	       !   
-                                           	       !   
-                                     	       !   
-                 slave1.c slave  ./decs.h  /usr/include/math.h  slave lev_res numlev global gp nprocs ysca jm res wrk2 f0 beta fields2 xprocs im wrk1 multi eig2 multig fields t0 pi frcng jmm1 sin time do_stats slave2 dtau outday0 outday3   _gp_disp                               7                                               
-                                                                                                                                                                                      &          +          .          2          7          :          ?          G          N          Q          V          \           a          h          o          r          u          {                                                                                                                                                     	   
-                                                                                                                                       4  0               	             d   M                                                                \                 !            ``                    )p            `p                     2p           `                    ;   	          `                 Ep            dp  H              
\ No newline at end of file
diff -Naur splash2/codes/apps/ocean/non_contiguous_partitions/slave2.c splash2-modified/codes/apps/ocean/non_contiguous_partitions/slave2.c
--- splash2/codes/apps/ocean/non_contiguous_partitions/slave2.c	1994-10-15 00:17:21.000000000 -0400
+++ splash2-modified/codes/apps/ocean/non_contiguous_partitions/slave2.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,992 +0,0 @@
-
-/*************************************************************************/
-/*                                                                       */
-/*  Copyright (c) 1994 Stanford University                               */
-/*                                                                       */
-/*  All rights reserved.                                                 */
-/*                                                                       */
-/*  Permission is given to use, copy, and modify this software for any   */
-/*  non-commercial purpose as long as this copyright notice is not       */
-/*  removed.  All other uses, including redistribution in whole or in    */
-/*  part, are forbidden without prior written permission.                */
-/*                                                                       */
-/*  This software is provided with absolutely no warranty and no         */
-/*  support.                                                             */
-/*                                                                       */
-/*************************************************************************/
-
-/*    ****************
-      subroutine slave2
-      ****************  */
-
-#include <stdio.h>
-#include <math.h>
-#include <time.h>
-#include "decs.h" 
-
-void slave2(procid,firstrow,lastrow,numrows,firstcol,lastcol,numcols)
-
-int procid,firstrow,lastrow,numrows,firstcol,lastcol,numcols;
-
-{
-   int i;
-   int j;
-   int nstep;
-   int iindex;
-   int iday;
-   double ysca1;
-   double y;
-   double factor;
-   double sintemp;
-   double curlt;
-   double hh1;
-   double hh3;
-   double hinv;
-   double h1inv;
-   int istart; 
-   int iend; 
-   int jstart; 
-   int jend;
-   int ist; 
-   int ien; 
-   int jst; 
-   int jen;
-   double fac;
-   double ressqr;
-   double timst;
-   double f4;
-   int psiindex;
-   double psiaipriv;
-   int multi_start;
-   int multi_end;
-
-   ressqr = lev_res[numlev-1] * lev_res[numlev-1];
-
-/*   ***************************************************************
-
-          f i r s t     p h a s e   (of timestep calculation)
-
-     ***************************************************************/
-
-   if (procid == MASTER) {
-     wrk1->ga[0][0]=0.0;
-   }
-   if (procid == nprocs-xprocs) {
-     wrk1->ga[im-1][0]=0.0;
-   }
-   if (procid == xprocs-1) {
-     wrk1->ga[0][jm-1]=0.0;
-   }
-   if (procid == nprocs-1) {
-     wrk1->ga[im-1][jm-1]=0.0;
-   }
-   if (firstrow == 1) {
-     for(j=firstcol;j<=lastcol;j++) {
-       wrk1->ga[0][j] = 0.0;
-     }
-   }
-   if ((firstrow+numrows) == im-1) {
-     for(j=firstcol;j<=lastcol;j++) {
-       wrk1->ga[im-1][j] = 0.0;
-     }
-   }
-   if (firstcol == 1) {
-     for(j=firstrow;j<=lastrow;j++) {
-       wrk1->ga[j][0] = 0.0;
-     }
-   }
-   if ((firstcol+numcols) == jm-1) {
-     for(j=firstrow;j<=lastrow;j++) {
-       wrk1->ga[j][jm-1] = 0.0;
-     }
-   }
-   for(i=firstrow;i<=lastrow;i++) {
-     for(iindex=firstcol;iindex<=lastcol;iindex++) {
-         wrk1->ga[i][iindex] = 0.0;
-     }
-   }
-
-   if (procid == MASTER) {
-     wrk1->gb[0][0]=0.0;
-   }
-   if (procid == nprocs-xprocs) {
-     wrk1->gb[im-1][0]=0.0;
-   }
-   if (procid == xprocs-1) {
-     wrk1->gb[0][jm-1]=0.0;
-   }
-   if (procid == nprocs-1) {
-     wrk1->gb[im-1][jm-1]=0.0;
-   }
-   if (firstrow == 1) {
-     for(j=firstcol;j<=lastcol;j++) {
-       wrk1->gb[0][j] = 0.0;
-     }
-   }
-   if ((firstrow+numrows) == im-1) {
-     for(j=firstcol;j<=lastcol;j++) {
-       wrk1->gb[im-1][j] = 0.0;
-     }
-   }
-   if (firstcol == 1) {
-     for(j=firstrow;j<=lastrow;j++) {
-       wrk1->gb[j][0] = 0.0;
-     }
-   }
-   if ((firstcol+numcols) == jm-1) {
-     for(j=firstrow;j<=lastrow;j++) {
-       wrk1->gb[j][jm-1] = 0.0;
-     }
-   }
-   for(i=firstrow;i<=lastrow;i++) {
-     for(iindex=firstcol;iindex<=lastcol;iindex++) {
-       wrk1->gb[i][iindex] = 0.0;
-     }
-   }
-
-/* put the laplacian of psi{1,3} in work1{1,2} 
-   note that psi(i,j,2) represents the psi3 array in
-   the original equations  */
-
-   for(psiindex=0;psiindex<=1;psiindex++) {
-     if (procid == MASTER) {
-       wrk3->work1[psiindex][0][0] = 0;
-     }
-     if (procid == nprocs-xprocs) {
-       wrk3->work1[psiindex][im-1][0] = 0;
-     }
-     if (procid == xprocs-1) {
-       wrk3->work1[psiindex][0][jm-1] = 0;
-     }
-     if (procid == nprocs-1) {
-       wrk3->work1[psiindex][im-1][jm-1] = 0;
-     }
-     laplacalc(&(fields->psi[psiindex][0][0]),
-	       &(wrk3->work1[psiindex][0][0]),
-	       firstrow,lastrow,firstcol,lastcol,numrows,numcols);
-   }
- 
- 
-   if (procid == MASTER) {	
-     wrk3->work2[0][0] = fields->psi[0][0][0]-fields->psi[1][0][0];
-   }
-   if (procid == nprocs-xprocs) {	
-     wrk3->work2[im-1][0] = fields->psi[0][im-1][0]-fields->psi[1][im-1][0];
-   }
-   if (procid == xprocs-1) {
-     wrk3->work2[0][jm-1] = fields->psi[0][0][jm-1]-fields->psi[1][0][jm-1];
-   }
-   if (procid == nprocs-1) {
-     wrk3->work2[im-1][jm-1] = fields->psi[0][im-1][jm-1]-fields->psi[1][im-1][jm-1];
-   }
-   if (firstrow == 1) {
-     for(j=firstcol;j<=lastcol;j++) {
-       wrk3->work2[0][j] = fields->psi[0][0][j]-fields->psi[1][0][j];
-     }
-   }
-   if ((firstrow+numrows) == im-1) {
-     for(j=firstcol;j<=lastcol;j++) {
-       wrk3->work2[im-1][j] = fields->psi[0][im-1][j]-fields->psi[1][im-1][j];
-     }
-   }
-   if (firstcol == 1) {
-     for(j=firstrow;j<=lastrow;j++) {
-       wrk3->work2[j][0] = fields->psi[0][j][0]-fields->psi[1][j][0];
-     }
-   }
-   if ((firstcol+numcols) == jm-1) {
-     for(j=firstrow;j<=lastrow;j++) {
-       wrk3->work2[j][jm-1] = fields->psi[0][j][jm-1]-fields->psi[1][j][jm-1];
-     }
-   }
-   for(i=firstrow;i<=lastrow;i++) {
-     for(iindex=firstcol;iindex<=lastcol;iindex++) {
-         wrk3->work2[i][iindex] = fields->psi[0][i][iindex]-fields->psi[1][i][iindex];
-     }
-   }
- 
-/* set values of work3 array to h3/h * psi1 + h1/h * psi3  */
-
-   hh3 = h3/h;
-   hh1 = h1/h;
-   if (procid == MASTER) {
-     wrk2->work3[0][0] = hh3*fields->psi[0][0][0]+hh1*fields->psi[1][0][0];
-   }
-   if (procid == nprocs-xprocs) {
-     wrk2->work3[im-1][0] = hh3*fields->psi[0][im-1][0]+hh1*fields->psi[1][im-1][0];
-   }
-   if (procid == xprocs-1) {
-     wrk2->work3[0][jm-1] = hh3*fields->psi[0][0][jm-1]+hh1*fields->psi[1][0][jm-1];
-   }
-   if (procid == nprocs-1) {
-     wrk2->work3[im-1][jm-1] = hh3*fields->psi[0][im-1][jm-1]+hh1*fields->psi[1][im-1][jm-1];
-   }
-   if (firstrow == 1) {
-     for(j=firstcol;j<=lastcol;j++) {
-       wrk2->work3[0][j] = hh3*fields->psi[0][0][j]+hh1*fields->psi[1][0][j];
-     }
-   }
-   if ((firstrow+numrows) == im-1) {
-     for(j=firstcol;j<=lastcol;j++) {
-       wrk2->work3[im-1][j] = hh3*fields->psi[0][im-1][j]+hh1*fields->psi[1][im-1][j];
-     }
-   }
-   if (firstcol == 1) {
-     for(j=firstrow;j<=lastrow;j++) {
-       wrk2->work3[j][0] = hh3*fields->psi[0][j][0]+hh1*fields->psi[1][j][0];
-     }
-   }
-   if ((firstcol+numcols) == jm-1) {
-     for(j=firstrow;j<=lastrow;j++) {
-       wrk2->work3[j][jm-1] = hh3*fields->psi[0][j][jm-1]+hh1*fields->psi[1][j][jm-1];
-     }
-   }
-   for(i=firstrow;i<=lastrow;i++) {
-     for(iindex=firstcol;iindex<=lastcol;iindex++) {
-        wrk2->work3[i][iindex] = hh3*fields->psi[0][i][iindex]+hh1*fields->psi[1][i][iindex];
-     }
-   }
-
-/* set values of temparray{1,3} to psim{1,3}  */
-
-   for(psiindex=0;psiindex<=1;psiindex++) {
-     if (procid == MASTER) {
-       wrk5->temparray[psiindex][0][0] = fields->psi[psiindex][0][0];
-     }
-     if (procid == nprocs-xprocs) {
-       wrk5->temparray[psiindex][im-1][0] = fields->psi[psiindex][im-1][0];
-     }
-     if (procid == xprocs-1) {
-       wrk5->temparray[psiindex][0][jm-1] = fields->psi[psiindex][0][jm-1];
-     }
-     if (procid == nprocs-1) {
-       wrk5->temparray[psiindex][im-1][jm-1] = fields->psi[psiindex][im-1][jm-1];
-     }
-     if (firstrow == 1) {
-       for(j=firstcol;j<=lastcol;j++) {
-         wrk5->temparray[psiindex][0][j] = fields->psi[psiindex][0][j];
-       }
-     }
-     if ((firstrow+numrows) == im-1) {
-       for(j=firstcol;j<=lastcol;j++) {
-         wrk5->temparray[psiindex][im-1][j] = fields->psi[psiindex][im-1][j];
-       }
-     }
-     if (firstcol == 1) {
-       for(j=firstrow;j<=lastrow;j++) {
-         wrk5->temparray[psiindex][j][0] = fields->psi[psiindex][j][0];
-       }
-     }
-     if ((firstcol+numcols) == jm-1) {
-       for(j=firstrow;j<=lastrow;j++) {
-         wrk5->temparray[psiindex][j][jm-1] = fields->psi[psiindex][j][jm-1];
-       }
-     }
-
-     for(i=firstrow;i<=lastrow;i++) {
-       for(iindex=firstcol;iindex<=lastcol;iindex++) {
-         wrk5->temparray[psiindex][i][iindex] = fields->psi[psiindex][i][iindex];
-       }
-     }
-   }
-
-   {;}
-
-/*     *******************************************************
-
-              s e c o n d   p h a s e
-
-       *******************************************************
-
-   set values of psi{1,3} to psim{1,3}   */
-
-   for(psiindex=0;psiindex<=1;psiindex++) {
-     if (procid == MASTER) {
-       fields->psi[psiindex][0][0] = fields->psim[psiindex][0][0];
-     }
-     if (procid == xprocs-1) {
-       fields->psi[psiindex][0][jm-1] = fields->psim[psiindex][0][jm-1];
-     }
-     if (procid == nprocs-xprocs) {
-       fields->psi[psiindex][im-1][0] = fields->psim[psiindex][im-1][0];
-     }
-     if (procid == nprocs-1) {
-       fields->psi[psiindex][im-1][jm-1] = fields->psim[psiindex][im-1][jm-1];
-     }
-     if (firstrow == 1) {
-       for(j=firstcol;j<=lastcol;j++) {
-         fields->psi[psiindex][0][j] = fields->psim[psiindex][0][j];
-       }
-     }
-     if ((firstrow+numrows) == im-1) {
-       for(j=firstcol;j<=lastcol;j++) {
-         fields->psi[psiindex][im-1][j] = fields->psim[psiindex][im-1][j];
-       }
-     }
-     if (firstcol == 1) {
-       for(j=firstrow;j<=lastrow;j++) {
-         fields->psi[psiindex][j][0] = fields->psim[psiindex][j][0];
-       }
-     }
-     if ((firstcol+numcols) == jm-1) {
-       for(j=firstrow;j<=lastrow;j++) {
-         fields->psi[psiindex][j][jm-1] = fields->psim[psiindex][j][jm-1];
-       }
-     }
-
-     for(i=firstrow;i<=lastrow;i++) {
-       for(iindex=firstcol;iindex<=lastcol;iindex++) {
-         fields->psi[psiindex][i][iindex] = fields->psim[psiindex][i][iindex];
-       }
-     }
-   }
-
-/* put the laplacian of the psim array 
-   into the work7 array; first part of a three-laplacian
-   calculation to compute the friction terms  */
-
-   for(psiindex=0;psiindex<=1;psiindex++) {
-     if (procid == MASTER) {
-       wrk5->work7[psiindex][0][0] = 0;
-     }
-     if (procid == nprocs-xprocs) {
-       wrk5->work7[psiindex][im-1][0] = 0;
-     }
-     if (procid == xprocs-1) {
-       wrk5->work7[psiindex][0][jm-1] = 0;
-     }
-     if (procid == nprocs-1) {
-       wrk5->work7[psiindex][im-1][jm-1] = 0;
-     }
-     laplacalc(&(fields->psim[psiindex][0][0]),&(wrk5->work7[psiindex][0][0]),firstrow,lastrow,firstcol,lastcol,numrows,numcols);
-   }
-
-/* to the values of the work1{1,2} arrays obtained from the
-   laplacians of psi{1,2} in the previous phase, add to the
-   elements of every column the corresponding value in the 
-   one-dimenional f array  */
-
-   for(psiindex=0;psiindex<=1;psiindex++) {
-     if (procid == MASTER) {
-       wrk3->work1[psiindex][0][0] = wrk3->work1[psiindex][0][0] + wrk2->f[0];
-     }
-     if (procid == nprocs-xprocs) {
-       wrk3->work1[psiindex][im-1][0] = wrk3->work1[psiindex][im-1][0] + wrk2->f[0];
-     }
-     if (procid == xprocs-1) {
-       wrk3->work1[psiindex][0][jm-1] = wrk3->work1[psiindex][0][jm-1] + wrk2->f[jm-1];
-     }
-     if (procid == nprocs-1) {
-       wrk3->work1[psiindex][im-1][jm-1] = wrk3->work1[psiindex][im-1][jm-1] + wrk2->f[jm-1];
-     }
-     if (firstrow == 1) {
-       for(j=firstcol;j<=lastcol;j++) {
-         wrk3->work1[psiindex][0][j] = wrk3->work1[psiindex][0][j] + wrk2->f[j];
-       }
-     }
-     if ((firstrow+numrows) == im-1) {
-       for(j=firstcol;j<=lastcol;j++) {
-         wrk3->work1[psiindex][im-1][j] = wrk3->work1[psiindex][im-1][j] + wrk2->f[j];
-       }
-     }
-     if (firstcol == 1) {
-       for(j=firstrow;j<=lastrow;j++) {
-         wrk3->work1[psiindex][j][0] = wrk3->work1[psiindex][j][0] + wrk2->f[j];
-       }
-     }
-     if ((firstcol+numcols) == jm-1) {
-       for(j=firstrow;j<=lastrow;j++) {
-         wrk3->work1[psiindex][j][jm-1] = wrk3->work1[psiindex][j][jm-1] + wrk2->f[j];
-       }
-     }
-     for(i=firstrow;i<=lastrow;i++) {
-       for(iindex=firstcol;iindex<=lastcol;iindex++) {
-         wrk3->work1[psiindex][i][iindex] = wrk3->work1[psiindex][i][iindex] + 
-					   wrk2->f[iindex];
-       }
-     }
-   }
-
-   {;}
-
-/* 	*******************************************************
-
-                 t h i r d   p h a s e
- 
- 	*******************************************************
-
-   put the jacobian of the work1{1,2} and psi{1,3} arrays
-   (the latter currently in temparray) in the work5{1,2} arrays  */
-     
-   for(psiindex=0;psiindex<=1;psiindex++) {
-     jacobcalc(&(wrk3->work1[psiindex][0][0]),&(wrk5->temparray[psiindex][0][0]),
-               &(wrk4->work5[psiindex][0][0]),procid,firstrow,lastrow,firstcol,lastcol,numrows,numcols);
-   }
-
-
-/* set values of psim{1,3} to temparray{1,3}  */
-
-   for(psiindex=0;psiindex<=1;psiindex++) {
-     if (procid == MASTER) {
-       fields->psim[psiindex][0][0] = wrk5->temparray[psiindex][0][0];
-     }
-     if (procid == nprocs-xprocs) {
-       fields->psim[psiindex][im-1][0] = wrk5->temparray[psiindex][im-1][0];
-     }
-     if (procid == xprocs-1) {
-       fields->psim[psiindex][0][jm-1] = wrk5->temparray[psiindex][0][jm-1];
-     }
-     if (procid == nprocs-1) {
-       fields->psim[psiindex][im-1][jm-1] = wrk5->temparray[psiindex][im-1][jm-1];
-     }
-     if (firstrow == 1) {
-       for(j=firstcol;j<=lastcol;j++) {
-         fields->psim[psiindex][0][j] = wrk5->temparray[psiindex][0][j];
-       }
-     }
-     if ((firstrow+numrows) == im-1) {
-       for(j=firstcol;j<=lastcol;j++) {
-         fields->psim[psiindex][im-1][j] = wrk5->temparray[psiindex][im-1][j];
-       }
-     }
-     if (firstcol == 1) {
-       for(j=firstrow;j<=lastrow;j++) {
-         fields->psim[psiindex][j][0] = wrk5->temparray[psiindex][j][0];
-       }
-     }
-     if ((firstcol+numcols) == jm-1) {
-       for(j=firstrow;j<=lastrow;j++) {
-         fields->psim[psiindex][j][jm-1] = wrk5->temparray[psiindex][j][jm-1];
-       }
-     }
-     for(i=firstrow;i<=lastrow;i++) {
-       for(iindex=firstcol;iindex<=lastcol;iindex++) {
-         fields->psim[psiindex][i][iindex] = wrk5->temparray[psiindex][i][iindex];
-       }
-     }
-   }
-
-/* put the laplacian of the work7{1,2} arrays in the work4{1,2}
-   arrays; second step in the three-laplacian friction calculation  */
-
-   for(psiindex=0;psiindex<=1;psiindex++) {
-     laplacalc(&(wrk5->work7[psiindex][0][0]),
-	       &(wrk4->work4[psiindex][0][0]),
-               firstrow,lastrow,firstcol,lastcol,numrows,numcols);
-   }
-
-   {;}
-
-/*     *******************************************************
-
-                f o u r t h   p h a s e
-
-       *******************************************************
-
-   put the jacobian of the work2 and work3 arrays in the work6
-   array  */
-
-   jacobcalc(wrk3->work2,wrk2->work3,wrk6->work6,procid,firstrow,
-             lastrow,firstcol,lastcol,numrows,numcols);
-
-/* put the laplacian of the work4{1,2} arrays in the work7{1,2}
-   arrays; third step in the three-laplacian friction calculation  */
-
-   for(psiindex=0;psiindex<=1;psiindex++) {
-     laplacalc(&(wrk4->work4[psiindex][0][0]),
-               &(wrk5->work7[psiindex][0][0]),
-               firstrow,lastrow,firstcol,lastcol,numrows,numcols);
-   } 
-
-   {;}
-
-/*     *******************************************************
-
-                f i f t h   p h a s e
-
-       *******************************************************
-
-   use the values of the work5, work6 and work7 arrays
-   computed in the previous time-steps to compute the
-   ga and gb arrays   */
-   
-   hinv = 1.0/h;
-   h1inv = 1.0/h1;
-
-   if (procid == MASTER) {     
-     wrk1->ga[0][0] = wrk4->work5[0][0][0]-wrk4->work5[1][0][0]+eig2*wrk6->work6[0][0]+h1inv*
-                frcng->tauz[0][0]+lf*wrk5->work7[0][0][0]-lf*wrk5->work7[1][0][0];
-     wrk1->gb[0][0] = hh1*wrk4->work5[0][0][0]+hh3*wrk4->work5[1][0][0]+hinv*frcng->tauz[0][0]+
-                lf*hh1*wrk5->work7[0][0][0]+lf*hh3*wrk5->work7[1][0][0];
-   }
-   if (procid == nprocs-xprocs) {     
-     wrk1->ga[im-1][0] = wrk4->work5[0][im-1][0]-wrk4->work5[1][im-1][0]+eig2*wrk6->work6[im-1][0]+h1inv*
-                   frcng->tauz[im-1][0]+lf*wrk5->work7[0][im-1][0]-lf*wrk5->work7[1][im-1][0];
-     wrk1->gb[im-1][0] = hh1*wrk4->work5[0][im-1][0]+hh3*wrk4->work5[1][im-1][0]+hinv*frcng->tauz[im-1][0]+
-                   lf*hh1*wrk5->work7[0][im-1][0]+lf*hh3*wrk5->work7[1][im-1][0];
-   }
-   if (procid == xprocs-1) {
-     wrk1->ga[0][jm-1] = wrk4->work5[0][0][jm-1]-wrk4->work5[1][0][jm-1]+eig2*wrk6->work6[0][jm-1]+h1inv*
-                   frcng->tauz[0][jm-1]+lf*wrk5->work7[0][0][jm-1]-lf*wrk5->work7[1][0][jm-1];
-     wrk1->gb[0][jm-1] = hh1*wrk4->work5[0][0][jm-1]+hh3*wrk4->work5[1][0][jm-1]+hinv*frcng->tauz[0][jm-1]+
-                   lf*hh1*wrk5->work7[0][0][jm-1]+lf*hh3*wrk5->work7[1][0][jm-1];
-   }
-   if (procid == nprocs-1) {
-     wrk1->ga[im-1][jm-1] = wrk4->work5[0][im-1][jm-1]-wrk4->work5[1][im-1][jm-1]+eig2*wrk6->work6[im-1][jm-1]+
-                      h1inv*frcng->tauz[im-1][jm-1]+lf*wrk5->work7[0][im-1][jm-1]-lf*wrk5->work7[1][im-1][jm-1];
-     wrk1->gb[im-1][jm-1] = hh1*wrk4->work5[0][im-1][jm-1]+hh3*wrk4->work5[1][im-1][jm-1]+hinv*
-		    frcng->tauz[im-1][jm-1]+lf*hh1*wrk5->work7[0][im-1][jm-1]+lf*hh3*wrk5->work7[1][im-1][jm-1];
-   }
-   if (firstrow == 1) {
-     for(j=firstcol;j<=lastcol;j++) {
-       wrk1->ga[0][j] = wrk4->work5[0][0][j]-wrk4->work5[1][0][j]+eig2*
-                    wrk6->work6[0][j]+h1inv*frcng->tauz[0][j]+lf*wrk5->work7[0][0][j]-lf*wrk5->work7[0][0][j];
-       wrk1->gb[0][j] = hh1*wrk4->work5[0][0][j]+hh3*wrk4->work5[1][0][j]+hinv*
-                    frcng->tauz[0][j]+lf*hh1*wrk5->work7[0][0][j]+lf*hh3*wrk5->work7[1][0][j];
-     }
-   }
-   if ((firstrow+numrows) == im-1) {
-     for(j=firstcol;j<=lastcol;j++) {
-       wrk1->ga[im-1][j] = wrk4->work5[0][im-1][j]-wrk4->work5[1][im-1][j]+eig2*
-                       wrk6->work6[im-1][j]+h1inv*frcng->tauz[im-1][j]+
-                       lf*wrk5->work7[0][im-1][j]-lf*wrk5->work7[1][im-1][j];
-       wrk1->gb[im-1][j] = hh1*wrk4->work5[0][im-1][j]+hh3*wrk4->work5[1][im-1][j]+hinv*
-                       frcng->tauz[im-1][j]+lf*hh1*wrk5->work7[0][im-1][j]+
-                       lf*hh3*wrk5->work7[1][im-1][j];
-     }
-   }
-   if (firstcol == 1) {
-     for(j=firstrow;j<=lastrow;j++) {
-       wrk1->ga[j][0] = wrk4->work5[0][j][0]-wrk4->work5[1][j][0]+eig2*
-                  wrk6->work6[j][0]+h1inv*frcng->tauz[j][0]+lf*wrk5->work7[0][j][0]-lf*wrk5->work7[1][j][0];
-       wrk1->gb[j][0] = hh1*wrk4->work5[0][j][0]+hh3*wrk4->work5[1][j][0]+hinv*
-                  frcng->tauz[j][0]+lf*hh1*wrk5->work7[0][j][0]+lf*hh3*wrk5->work7[1][j][0];
-     }
-   }
-   if ((firstcol+numcols) == jm-1) {
-     for(j=firstrow;j<=lastrow;j++) {
-       wrk1->ga[j][jm-1] = wrk4->work5[0][j][jm-1]-wrk4->work5[1][j][jm-1]+eig2*
-                       wrk6->work6[j][jm-1]+h1inv*frcng->tauz[j][jm-1]+
-                       lf*wrk5->work7[0][j][jm-1]-lf*wrk5->work7[1][j][jm-1];
-       wrk1->gb[j][jm-1] = hh1*wrk4->work5[0][j][jm-1]+hh3*wrk4->work5[1][j][jm-1]+hinv*
-                       frcng->tauz[j][jm-1]+lf*hh1*wrk5->work7[0][j][jm-1]+
-                       lf*hh3*wrk5->work7[1][j][jm-1];
-     }
-   }
-   for(i=firstrow;i<=lastrow;i++) {
-     for(iindex=firstcol;iindex<=lastcol;iindex++) {
-       wrk1->ga[i][iindex] = wrk4->work5[0][i][iindex]-wrk4->work5[1][i][iindex]+eig2*
-                          wrk6->work6[i][iindex]+h1inv*frcng->tauz[i][iindex]+
-                          lf*wrk5->work7[0][i][iindex]-lf*wrk5->work7[1][i][iindex];
-       wrk1->gb[i][iindex] = hh1*wrk4->work5[0][i][iindex]+hh3*wrk4->work5[1][i][iindex]+hinv*
-                          frcng->tauz[i][iindex]+lf*hh1*wrk5->work7[0][i][iindex]+
-                          lf*hh3*wrk5->work7[1][i][iindex];
-     }
-   }
-   
-   {;}
-
-/*     *******************************************************
-
-               s i x t h   p h a s e
-
-       *******************************************************  */
-
-   istart = gp[procid].rel_start_y[numlev-1];
-   iend = istart + gp[procid].rel_num_y[numlev-1] - 1;
-   jstart = gp[procid].rel_start_x[numlev-1];
-   jend = jstart + gp[procid].rel_num_x[numlev-1] - 1;
-   ist = istart;
-   ien = iend;
-   jst = jstart;
-   jen = jend;
-   if (istart == 1) {
-     istart = 0;
-   }
-   if (jstart == 1) {
-     jstart = 0;
-   }
-   if (iend == im-2) {
-     iend = im-1;
-   }
-   if (jend == jm-2) {
-     jend = jm-1;
-   }
-   for(i=istart;i<=iend;i++) {
-     for(j=jstart;j<=jend;j++) {
-       multi->rhs_multi[numlev-1][i][j] = wrk1->ga[i][j] * ressqr;
-     }
-   }
-   if (istart == 0) {
-     for(j=jstart;j<=jend;j++) {
-       multi->q_multi[numlev-1][0][j] = wrk1->ga[0][j];
-     }
-   }
-   if (iend == im-1) {
-     for(j=jstart;j<=jend;j++) {
-       multi->q_multi[numlev-1][im-1][j] = wrk1->ga[im-1][j];
-     }
-   }
-   if (jstart == 0) {
-     for(i=istart;i<=iend;i++) {
-       multi->q_multi[numlev-1][i][0] = wrk1->ga[i][0];
-     }
-   }
-   if (jend == jm-1) {
-     for(i=istart;i<=iend;i++) {
-       multi->q_multi[numlev-1][i][jm-1] = wrk1->ga[i][jm-1];
-     }
-   }
-
-   fac = 1.0 / (4.0 - ressqr*eig2);
-   for(i=ist;i<=ien;i++) {
-     for(j=jst;j<=jen;j++) {
-       multi->q_multi[numlev-1][i][j] = guess->oldga[i][j];
-     }
-   }
-
-   if ((procid == MASTER) || (do_stats)) {
-     {long time(); (multi_start) = time(0);};
-   }
-
-   multig(procid);
-
-   if ((procid == MASTER) || (do_stats)) {
-     {long time(); (multi_end) = time(0);};
-     gp[procid].multi_time += (multi_end - multi_start);
-   }
-
-   if (procid == MASTER) {
-     global->psiai=0.0;
-   }
-
-/*  copy the solution for use as initial guess in next time-step  */
-
-   for(i=istart;i<=iend;i++) {
-     for(j=jstart;j<=jend;j++) {
-       wrk1->ga[i][j] = multi->q_multi[numlev-1][i][j];
-       guess->oldga[i][j] = multi->q_multi[numlev-1][i][j];
-     }
-   }
-
-   {;}
-
-/*     *******************************************************
-
-                s e v e n t h   p h a s e
-
-       *******************************************************
-
-   every process computes the running sum for its assigned portion
-   in a private variable psiaipriv   */
-    
-
-
-   psiaipriv=0.0;
-   if (procid == MASTER) {
-     psiaipriv = psiaipriv + 0.25*(wrk1->ga[0][0]);
-   }
-   if (procid == xprocs - 1) {
-     psiaipriv = psiaipriv + 0.25*(wrk1->ga[0][jm-1]);
-   }
-   if (procid == nprocs-xprocs) {
-     psiaipriv=psiaipriv+0.25*(wrk1->ga[im-1][0]);
-   }
-   if (procid == nprocs-1) {
-     psiaipriv=psiaipriv+0.25*(wrk1->ga[im-1][jm-1]);
-   }
-   if (firstrow == 1) {
-     for(j=firstcol;j<=lastcol;j++) {
-       psiaipriv = psiaipriv + 0.5*wrk1->ga[0][j];
-     }
-   }
-   if ((firstrow+numrows) == im-1) {
-     for(j=firstcol;j<=lastcol;j++) {
-       psiaipriv = psiaipriv + 0.5*wrk1->ga[im-1][j];
-     }
-   }
-   if (firstcol == 1) {
-     for(j=firstrow;j<=lastrow;j++) {
-       psiaipriv = psiaipriv + 0.5*wrk1->ga[j][0];
-     }
-   }
-   if ((firstcol+numcols) == jm-1) {
-     for(j=firstrow;j<=lastrow;j++) {
-       psiaipriv = psiaipriv + 0.5*wrk1->ga[j][jm-1];
-     }
-   }
-     for(iindex=firstcol;iindex<=lastcol;iindex++) {
-   for(i=firstrow;i<=lastrow;i++) {
-       psiaipriv = psiaipriv + wrk1->ga[i][iindex];
-     }
-   }
-
-/* after computing its private sum, every process adds that to the
-   shared running sum psiai  */
-   
-   {;}
-   global->psiai = global->psiai + psiaipriv;
-   {;}
-
-   {;}
-
-/*      *******************************************************
-
-                e i g h t h   p h a s e
-
-        *******************************************************
-
-   augment ga(i,j) with [-psiai/psibi]*psib(i,j)
-
-   %%%%%%%%%%%%%%% f4 should be private  */
-
-   f4 = (-global->psiai)/(global->psibi);
-
-   if (procid == MASTER) {
-     wrk1->ga[0][0] = wrk1->ga[0][0]+f4*wrk1->psib[0][0];
-   }
-   if (procid == nprocs-xprocs) {
-     wrk1->ga[im-1][0] = wrk1->ga[im-1][0]+f4*wrk1->psib[im-1][0];
-   }
-   if (procid == xprocs-1) {
-     wrk1->ga[0][jm-1] = wrk1->ga[0][jm-1]+f4*wrk1->psib[0][jm-1];
-   }
-   if (procid == nprocs-1) {
-     wrk1->ga[im-1][jm-1] = wrk1->ga[im-1][jm-1]+f4*wrk1->psib[im-1][jm-1];
-   }
-   if (firstrow == 1) {
-     for(j=firstcol;j<=lastcol;j++) {
-       wrk1->ga[0][j] = wrk1->ga[0][j]+f4*wrk1->psib[0][j];
-     }
-   }
-   if ((firstrow+numrows) == im-1) {
-     for(j=firstcol;j<=lastcol;j++) {
-       wrk1->ga[im-1][j] = wrk1->ga[im-1][j]+f4*wrk1->psib[im-1][j];
-     }
-   }
-   if (firstcol == 1) {
-     for(j=firstrow;j<=lastrow;j++) {
-       wrk1->ga[j][0] = wrk1->ga[j][0]+f4*wrk1->psib[j][0];
-     }
-   }
-   if ((firstcol+numcols) == jm-1) {
-     for(j=firstrow;j<=lastrow;j++) {
-       wrk1->ga[j][jm-1] = wrk1->ga[j][jm-1]+f4*wrk1->psib[j][jm-1];
-     }
-   }
-   for(i=firstrow;i<=lastrow;i++) {
-     for(iindex=firstcol;iindex<=lastcol;iindex++) {
-       wrk1->ga[i][iindex] = wrk1->ga[i][iindex]+f4*wrk1->psib[i][iindex];
-     }
-   }
-
-   {;}
-
-   for(i=istart;i<=iend;i++) {
-     for(j=jstart;j<=jend;j++) {
-       multi->rhs_multi[numlev-1][i][j] = wrk1->gb[i][j] * ressqr;
-     }
-   }
-   if (istart == 0) {
-     for(j=jstart;j<=jend;j++) {
-       multi->q_multi[numlev-1][0][j] = wrk1->gb[0][j];
-     }
-   }
-   if (iend == im-1) {
-     for(j=jstart;j<=jend;j++) {
-       multi->q_multi[numlev-1][im-1][j] = wrk1->gb[im-1][j];
-     }
-   }
-   if (jstart == 0) {
-     for(i=istart;i<=iend;i++) {
-       multi->q_multi[numlev-1][i][0] = wrk1->gb[i][0];
-     }
-   }
-   if (jend == jm-1) {
-     for(i=istart;i<=iend;i++) {
-       multi->q_multi[numlev-1][i][jm-1] = wrk1->gb[i][jm-1];
-     }
-   }
-
-   fac = 1.0 / (4.0 - ressqr*eig2);
-   for(i=ist;i<=ien;i++) {
-     for(j=jst;j<=jen;j++) {
-       multi->q_multi[numlev-1][i][j] = guess->oldgb[i][j];
-     }
-   }
-
-   if ((procid == MASTER) || (do_stats)) {
-     {long time(); (multi_start) = time(0);};
-   }
-
-   multig(procid);
-
-   if ((procid == MASTER) || (do_stats)) {
-     {long time(); (multi_end) = time(0);};
-     gp[procid].multi_time += (multi_end - multi_start);
-   }
-
-   for(i=istart;i<=iend;i++) {
-     for(j=jstart;j<=jend;j++) {
-       wrk1->gb[i][j] = multi->q_multi[numlev-1][i][j];
-       guess->oldgb[i][j] = multi->q_multi[numlev-1][i][j];
-     }
-   }
-
-   {;}
-
-/*      *******************************************************
-
-                n i n t h   p h a s e
-
-        *******************************************************
-
-   put appropriate linear combinations of ga and gb in work2 and work3;
-   note that here (as in most cases) the constant multipliers are made
-   private variables; the specific order in which things are done is
-   chosen in order to hopefully reuse things brought into the cache
-   
-   note that here again we choose to have all processes share the work
-   on both matrices despite the fact that the work done per element
-   is the same, because the operand matrices are the same in both cases */
-
-   if (procid == MASTER) {
-     wrk3->work2[0][0] = wrk1->gb[0][0]-hh1*wrk1->ga[0][0];
-     wrk2->work3[0][0] = wrk1->gb[0][0]+hh3*wrk1->ga[0][0];
-   }
-   if (procid == nprocs-xprocs) {
-     wrk3->work2[im-1][0] = wrk1->gb[im-1][0]-hh1*wrk1->ga[im-1][0];
-     wrk2->work3[im-1][0] = wrk1->gb[im-1][0]+hh3*wrk1->ga[im-1][0];
-   }
-   if (procid == xprocs-1) {
-     wrk3->work2[0][jm-1] = wrk1->gb[0][jm-1]-hh1*wrk1->ga[0][jm-1];
-     wrk2->work3[0][jm-1] = wrk1->gb[0][jm-1]+hh3*wrk1->ga[0][jm-1];
-   }
-   if (procid == nprocs-1) {
-     wrk3->work2[im-1][jm-1] = wrk1->gb[im-1][jm-1]-hh1*wrk1->ga[im-1][jm-1];
-     wrk2->work3[im-1][jm-1] = wrk1->gb[im-1][jm-1]+hh3*wrk1->ga[im-1][jm-1];
-   }
-   if (firstrow == 1) {
-     for(j=firstcol;j<=lastcol;j++) {
-       wrk2->work3[0][j] = wrk1->gb[0][j]+hh3*wrk1->ga[0][j];
-       wrk3->work2[0][j] = wrk1->gb[0][j]-hh1*wrk1->ga[0][j];
-     }
-   }
-   if ((firstrow+numrows) == im-1) {
-     for(j=firstcol;j<=lastcol;j++) {
-       wrk2->work3[im-1][j] = wrk1->gb[im-1][j]+hh3*wrk1->ga[im-1][j];
-       wrk3->work2[im-1][j] = wrk1->gb[im-1][j]-hh1*wrk1->ga[im-1][j];
-     }
-   }
-   if (firstcol == 1) {
-     for(j=firstrow;j<=lastrow;j++) {
-       wrk2->work3[j][0] = wrk1->gb[j][0]+hh3*wrk1->ga[j][0];
-       wrk3->work2[j][0] = wrk1->gb[j][0]-hh1*wrk1->ga[j][0];
-     }
-   }
-   if ((firstcol+numcols) == jm-1) {
-     for(j=firstrow;j<=lastrow;j++) {
-       wrk2->work3[j][jm-1] = wrk1->gb[j][jm-1]+hh3*wrk1->ga[j][jm-1];
-       wrk3->work2[j][jm-1] = wrk1->gb[j][jm-1]-hh1*wrk1->ga[j][jm-1];
-     }
-   }
-
-   for(i=firstrow;i<=lastrow;i++) {
-     for(iindex=firstcol;iindex<=lastcol;iindex++) {
-       wrk2->work3[i][iindex] = wrk1->gb[i][iindex]+hh3*wrk1->ga[i][iindex];
-       wrk3->work2[i][iindex] = wrk1->gb[i][iindex]-hh1*wrk1->ga[i][iindex];
-     }
-   }
-
-   {;}
-
-/*      *******************************************************
-
-                t e n t h    p h a s e
-
-        *******************************************************/
-
-
-   timst = 2*dtau;
-
-/* update the psi{1,3} matrices by adding 2*dtau*work3 to each */
-
-   if (procid == MASTER) {
-     fields->psi[0][0][0] = fields->psi[0][0][0] + timst*wrk2->work3[0][0];
-   }
-   if (procid == nprocs-xprocs) {
-     fields->psi[0][im-1][0] = fields->psi[0][im-1][0] + timst*wrk2->work3[im-1][0];
-   }
-   if (procid == xprocs-1) {
-     fields->psi[0][0][jm-1] = fields->psi[0][0][jm-1] + timst*wrk2->work3[0][jm-1];
-   }
-   if (procid == nprocs-1) {
-     fields->psi[0][im-1][jm-1] = fields->psi[0][im-1][jm-1] + timst*wrk2->work3[im-1][jm-1];
-   }
-   if (firstrow == 1) {
-     for(j=firstcol;j<=lastcol;j++) {
-       fields->psi[0][0][j] = fields->psi[0][0][j] + timst*wrk2->work3[0][j];
-     }
-   }
-   if ((firstrow+numrows) == im-1) {
-     for(j=firstcol;j<=lastcol;j++) {
-       fields->psi[0][im-1][j] = fields->psi[0][im-1][j] + timst*wrk2->work3[im-1][j];
-     }
-   }
-   if (firstcol == 1) {
-     for(j=firstrow;j<=lastrow;j++) {
-       fields->psi[0][j][0] = fields->psi[0][j][0] + timst*wrk2->work3[j][0];
-     }
-   }
-   if ((firstcol+numcols) == jm-1) {
-     for(j=firstrow;j<=lastrow;j++) {
-       fields->psi[0][j][jm-1] = fields->psi[0][j][jm-1] + timst*wrk2->work3[j][jm-1];
-     }
-   }
-   for(i=firstrow;i<=lastrow;i++) {
-     for(iindex=firstcol;iindex<=lastcol;iindex++) {
-         fields->psi[0][i][iindex] = fields->psi[0][i][iindex] + timst*wrk2->work3[i][iindex];
-     }
-   }
-
-   if (procid == MASTER) {
-     fields->psi[1][0][0] = fields->psi[1][0][0] + timst*wrk3->work2[0][0];
-   }
-   if (procid == nprocs-xprocs) {
-     fields->psi[1][im-1][0] = fields->psi[1][im-1][0] + timst*wrk3->work2[im-1][0];
-   }
-   if (procid == xprocs-1) {
-     fields->psi[1][0][jm-1] = fields->psi[1][0][jm-1] + timst*wrk3->work2[0][jm-1];
-   }
-   if (procid == nprocs-1) {
-     fields->psi[1][im-1][jm-1] = fields->psi[1][im-1][jm-1] + timst*wrk3->work2[im-1][jm-1];
-   }
-   if (firstrow == 1) {
-     for(j=firstcol;j<=lastcol;j++) {
-       fields->psi[1][0][j] = fields->psi[1][0][j] + timst*wrk3->work2[0][j];
-     }
-   }
-   if ((firstrow+numrows) == im-1) {
-     for(j=firstcol;j<=lastcol;j++) {
-       fields->psi[1][im-1][j] = fields->psi[1][im-1][j] + timst*wrk3->work2[im-1][j];
-     }
-   }
-   if (firstcol == 1) {
-     for(j=firstrow;j<=lastrow;j++) {
-       fields->psi[1][j][0] = fields->psi[1][j][0] + timst*wrk3->work2[j][0];
-     }
-   }
-   if ((firstcol+numcols) == jm-1) {
-     for(j=firstrow;j<=lastrow;j++) {
-       fields->psi[1][j][jm-1] = fields->psi[1][j][jm-1] + timst*wrk3->work2[j][jm-1];
-     }
-   }
-
-   for(i=firstrow;i<=lastrow;i++) {
-     for(iindex=firstcol;iindex<=lastcol;iindex++) {
-         fields->psi[1][i][iindex] = fields->psi[1][i][iindex] + timst*wrk3->work2[i][iindex];
-     }
-   }
-
-   {;}   
-}
diff -Naur splash2/codes/apps/ocean/non_contiguous_partitions/slave2.C splash2-modified/codes/apps/ocean/non_contiguous_partitions/slave2.C
--- splash2/codes/apps/ocean/non_contiguous_partitions/slave2.C	1994-10-15 00:06:43.000000000 -0400
+++ splash2-modified/codes/apps/ocean/non_contiguous_partitions/slave2.C	2007-03-20 00:00:10.000000000 -0400
@@ -21,43 +21,34 @@
 #include <stdio.h>
 #include <math.h>
 #include <time.h>
-#include "decs.h" 
-
-void slave2(procid,firstrow,lastrow,numrows,firstcol,lastcol,numcols)
-
-int procid,firstrow,lastrow,numrows,firstcol,lastcol,numcols;
+#include <stdlib.h>
+#include "decs.h"
 
+void slave2(long procid, long firstrow, long lastrow, long numrows, long firstcol, long lastcol, long numcols)
 {
-   int i;
-   int j;
-   int nstep;
-   int iindex;
-   int iday;
-   double ysca1;
-   double y;
-   double factor;
-   double sintemp;
-   double curlt;
+   long i;
+   long j;
+   long iindex;
    double hh1;
    double hh3;
    double hinv;
    double h1inv;
-   int istart; 
-   int iend; 
-   int jstart; 
-   int jend;
-   int ist; 
-   int ien; 
-   int jst; 
-   int jen;
+   long istart;
+   long iend;
+   long jstart;
+   long jend;
+   long ist;
+   long ien;
+   long jst;
+   long jen;
    double fac;
    double ressqr;
    double timst;
    double f4;
-   int psiindex;
+   long psiindex;
    double psiaipriv;
-   int multi_start;
-   int multi_end;
+   long multi_start;
+   long multi_end;
 
    ressqr = lev_res[numlev-1] * lev_res[numlev-1];
 
@@ -143,7 +134,7 @@
      }
    }
 
-/* put the laplacian of psi{1,3} in work1{1,2} 
+/* put the laplacian of psi{1,3} in work1{1,2}
    note that psi(i,j,2) represents the psi3 array in
    the original equations  */
 
@@ -160,16 +151,17 @@
      if (procid == nprocs-1) {
        wrk3->work1[psiindex][im-1][jm-1] = 0;
      }
-     laplacalc(&(fields->psi[psiindex][0][0]),
-	       &(wrk3->work1[psiindex][0][0]),
+     laplacalc(fields->psi[psiindex],
+	       wrk3->work1[psiindex],
 	       firstrow,lastrow,firstcol,lastcol,numrows,numcols);
+
    }
- 
- 
-   if (procid == MASTER) {	
+
+
+   if (procid == MASTER) {
      wrk3->work2[0][0] = fields->psi[0][0][0]-fields->psi[1][0][0];
    }
-   if (procid == nprocs-xprocs) {	
+   if (procid == nprocs-xprocs) {
      wrk3->work2[im-1][0] = fields->psi[0][im-1][0]-fields->psi[1][im-1][0];
    }
    if (procid == xprocs-1) {
@@ -203,7 +195,7 @@
          wrk3->work2[i][iindex] = fields->psi[0][i][iindex]-fields->psi[1][i][iindex];
      }
    }
- 
+
 /* set values of work3 array to h3/h * psi1 + h1/h * psi3  */
 
    hh3 = h3/h;
@@ -288,9 +280,11 @@
        }
      }
    }
-
+#if defined(MULTIPLE_BARRIERS)
    BARRIER(bars->sl_phase_1,nprocs)
-
+#else
+   BARRIER(bars->barrier,nprocs)
+#endif
 /*     *******************************************************
 
               s e c o n d   p h a s e
@@ -340,7 +334,7 @@
      }
    }
 
-/* put the laplacian of the psim array 
+/* put the laplacian of the psim array
    into the work7 array; first part of a three-laplacian
    calculation to compute the friction terms  */
 
@@ -357,12 +351,12 @@
      if (procid == nprocs-1) {
        wrk5->work7[psiindex][im-1][jm-1] = 0;
      }
-     laplacalc(&(fields->psim[psiindex][0][0]),&(wrk5->work7[psiindex][0][0]),firstrow,lastrow,firstcol,lastcol,numrows,numcols);
+     laplacalc(fields->psim[psiindex],wrk5->work7[psiindex],firstrow,lastrow,firstcol,lastcol,numrows,numcols);
    }
 
 /* to the values of the work1{1,2} arrays obtained from the
    laplacians of psi{1,2} in the previous phase, add to the
-   elements of every column the corresponding value in the 
+   elements of every column the corresponding value in the
    one-dimenional f array  */
 
    for(psiindex=0;psiindex<=1;psiindex++) {
@@ -400,26 +394,28 @@
      }
      for(i=firstrow;i<=lastrow;i++) {
        for(iindex=firstcol;iindex<=lastcol;iindex++) {
-         wrk3->work1[psiindex][i][iindex] = wrk3->work1[psiindex][i][iindex] + 
+         wrk3->work1[psiindex][i][iindex] = wrk3->work1[psiindex][i][iindex] +
 					   wrk2->f[iindex];
        }
      }
    }
-
+#if defined(MULTIPLE_BARRIERS)
    BARRIER(bars->sl_phase_2,nprocs)
-
+#else
+   BARRIER(bars->barrier,nprocs)
+#endif
 /* 	*******************************************************
 
                  t h i r d   p h a s e
- 
+
  	*******************************************************
 
    put the jacobian of the work1{1,2} and psi{1,3} arrays
    (the latter currently in temparray) in the work5{1,2} arrays  */
-     
+
    for(psiindex=0;psiindex<=1;psiindex++) {
-     jacobcalc(&(wrk3->work1[psiindex][0][0]),&(wrk5->temparray[psiindex][0][0]),
-               &(wrk4->work5[psiindex][0][0]),procid,firstrow,lastrow,firstcol,lastcol,numrows,numcols);
+     jacobcalc(wrk3->work1[psiindex],wrk5->temparray[psiindex],
+               wrk4->work5[psiindex],procid,firstrow,lastrow,firstcol,lastcol,numrows,numcols);
    }
 
 
@@ -469,13 +465,15 @@
    arrays; second step in the three-laplacian friction calculation  */
 
    for(psiindex=0;psiindex<=1;psiindex++) {
-     laplacalc(&(wrk5->work7[psiindex][0][0]),
-	       &(wrk4->work4[psiindex][0][0]),
+     laplacalc(wrk5->work7[psiindex],
+	       wrk4->work4[psiindex],
                firstrow,lastrow,firstcol,lastcol,numrows,numcols);
    }
-
+#if defined(MULTIPLE_BARRIERS)
    BARRIER(bars->sl_phase_3,nprocs)
-
+#else
+   BARRIER(bars->barrier,nprocs)
+#endif
 /*     *******************************************************
 
                 f o u r t h   p h a s e
@@ -492,13 +490,15 @@
    arrays; third step in the three-laplacian friction calculation  */
 
    for(psiindex=0;psiindex<=1;psiindex++) {
-     laplacalc(&(wrk4->work4[psiindex][0][0]),
-               &(wrk5->work7[psiindex][0][0]),
+     laplacalc(wrk4->work4[psiindex],
+               wrk5->work7[psiindex],
                firstrow,lastrow,firstcol,lastcol,numrows,numcols);
-   } 
-
+   }
+#if defined(MULTIPLE_BARRIERS)
    BARRIER(bars->sl_phase_4,nprocs)
-
+#else
+   BARRIER(bars->barrier,nprocs)
+#endif
 /*     *******************************************************
 
                 f i f t h   p h a s e
@@ -508,17 +508,17 @@
    use the values of the work5, work6 and work7 arrays
    computed in the previous time-steps to compute the
    ga and gb arrays   */
-   
+
    hinv = 1.0/h;
    h1inv = 1.0/h1;
 
-   if (procid == MASTER) {     
+   if (procid == MASTER) {
      wrk1->ga[0][0] = wrk4->work5[0][0][0]-wrk4->work5[1][0][0]+eig2*wrk6->work6[0][0]+h1inv*
                 frcng->tauz[0][0]+lf*wrk5->work7[0][0][0]-lf*wrk5->work7[1][0][0];
      wrk1->gb[0][0] = hh1*wrk4->work5[0][0][0]+hh3*wrk4->work5[1][0][0]+hinv*frcng->tauz[0][0]+
                 lf*hh1*wrk5->work7[0][0][0]+lf*hh3*wrk5->work7[1][0][0];
    }
-   if (procid == nprocs-xprocs) {     
+   if (procid == nprocs-xprocs) {
      wrk1->ga[im-1][0] = wrk4->work5[0][im-1][0]-wrk4->work5[1][im-1][0]+eig2*wrk6->work6[im-1][0]+h1inv*
                    frcng->tauz[im-1][0]+lf*wrk5->work7[0][im-1][0]-lf*wrk5->work7[1][im-1][0];
      wrk1->gb[im-1][0] = hh1*wrk4->work5[0][im-1][0]+hh3*wrk4->work5[1][im-1][0]+hinv*frcng->tauz[im-1][0]+
@@ -582,9 +582,11 @@
                           lf*hh3*wrk5->work7[1][i][iindex];
      }
    }
-   
+#if defined(MULTIPLE_BARRIERS)
    BARRIER(bars->sl_phase_5,nprocs)
-
+#else
+   BARRIER(bars->barrier,nprocs)
+#endif
 /*     *******************************************************
 
                s i x t h   p h a s e
@@ -667,9 +669,11 @@
        guess->oldga[i][j] = multi->q_multi[numlev-1][i][j];
      }
    }
-
+#if defined(MULTIPLE_BARRIERS)
    BARRIER(bars->sl_phase_6,nprocs)
-
+#else
+   BARRIER(bars->barrier,nprocs)
+#endif
 /*     *******************************************************
 
                 s e v e n t h   p h a s e
@@ -678,7 +682,7 @@
 
    every process computes the running sum for its assigned portion
    in a private variable psiaipriv   */
-    
+
 
 
    psiaipriv=0.0;
@@ -722,13 +726,15 @@
 
 /* after computing its private sum, every process adds that to the
    shared running sum psiai  */
-   
+
    LOCK(locks->psibilock)
    global->psiai = global->psiai + psiaipriv;
    UNLOCK(locks->psibilock)
-
+#if defined(MULTIPLE_BARRIERS)
    BARRIER(bars->sl_phase_7,nprocs)
-
+#else
+   BARRIER(bars->barrier,nprocs)
+#endif
 /*      *******************************************************
 
                 e i g h t h   p h a s e
@@ -778,9 +784,11 @@
        wrk1->ga[i][iindex] = wrk1->ga[i][iindex]+f4*wrk1->psib[i][iindex];
      }
    }
-
+#if defined(MULTIPLE_BARRIERS)
    BARRIER(bars->sl_phase_8,nprocs)
-
+#else
+   BARRIER(bars->barrier,nprocs)
+#endif
    for(i=istart;i<=iend;i++) {
      for(j=jstart;j<=jend;j++) {
        multi->rhs_multi[numlev-1][i][j] = wrk1->gb[i][j] * ressqr;
@@ -831,9 +839,11 @@
        guess->oldgb[i][j] = multi->q_multi[numlev-1][i][j];
      }
    }
-
+#if defined(MULTIPLE_BARRIERS)
    BARRIER(bars->sl_phase_8,nprocs)
-
+#else
+   BARRIER(bars->barrier,nprocs)
+#endif
 /*      *******************************************************
 
                 n i n t h   p h a s e
@@ -844,7 +854,7 @@
    note that here (as in most cases) the constant multipliers are made
    private variables; the specific order in which things are done is
    chosen in order to hopefully reuse things brought into the cache
-   
+
    note that here again we choose to have all processes share the work
    on both matrices despite the fact that the work done per element
    is the same, because the operand matrices are the same in both cases */
@@ -896,9 +906,11 @@
        wrk3->work2[i][iindex] = wrk1->gb[i][iindex]-hh1*wrk1->ga[i][iindex];
      }
    }
-
+#if defined(MULTIPLE_BARRIERS)
    BARRIER(bars->sl_phase_9,nprocs)
-
+#else
+   BARRIER(bars->barrier,nprocs)
+#endif
 /*      *******************************************************
 
                 t e n t h    p h a s e
@@ -986,6 +998,9 @@
          fields->psi[1][i][iindex] = fields->psi[1][i][iindex] + timst*wrk3->work2[i][iindex];
      }
    }
-
-   BARRIER(bars->sl_phase_10,nprocs)   
+#if defined(MULTIPLE_BARRIERS)
+   BARRIER(bars->sl_phase_10,nprocs)
+#else
+   BARRIER(bars->barrier,nprocs)
+#endif
 }
diff -Naur splash2/codes/apps/ocean/non_contiguous_partitions/slave2.o splash2-modified/codes/apps/ocean/non_contiguous_partitions/slave2.o
--- splash2/codes/apps/ocean/non_contiguous_partitions/slave2.o	1994-10-15 00:18:37.000000000 -0400
+++ splash2-modified/codes/apps/ocean/non_contiguous_partitions/slave2.o	1969-12-31 19:00:00.000000000 -0500
@@ -1,49 +0,0 @@
-ELF                            4     ( 	                                                 H                                "             )             0             3             6             ;              E             L             O             Q             T             Y             ^              h             m             r             w             }                                                                                                                                   .symtab .shstrtab .strtab .text .options .reginfo .rel.text .mdebug  .text slave2 lev_res numlev wrk1 nprocs xprocs im jm wrk3 laplacalc fields h3 h h1 wrk2 wrk5 jacobcalc wrk4 wrk6 eig2 frcng lf gp multi guess do_stats time multig global dtau _gp_disp               <  '  !'x       t x p l h d ` \ X T P L @ D 8 < 0 4 ( ,!!  	F   < O  D D !   $          D D x#/ <   X  .     .!  x!p!        ' % 
-      O         !6p!    9    %  /  N   !    ! p.!x!$ ! 2`0%K*  +K8#$ 0   ! X  $ x!!9  8 $$c %N   X  $ x!!9  8 $N      !x! ( ,Y      #p!! 0 4O  %X !6p! 8 <$c  8  p!%  F K*  C`0%K8#$ 0   + ! 8  N   yx! y !#!p!$ $c %O  - 8  Y   qp! q .x!!!98/  N   !  !#x!p!9  X   yx! y p!!6! $.  O   .!  !p!x!%Y $ (,&$c  $ a 9 0%*  28#$ 0  ! !  ! ! Y  $ $p!x!   $f$    $x   !  ! ! Y  $ $p!x!   $X      !6p!(0(4O      !!90@80DN  $y x!!8P8T&$ @  nx!%  Q |0%/*  K/8#$ 0   ! N  &!    ! p!6x!$  f     $x  3     N  &!    x! p!6! q  O  p!   q ! x/p!!(((, yY  x!   y /p! x!!080< N  &!    x! p!6!$o $ 8H8L    D 0*  Q  %'( K*  H`%     8#$ 0   !    q  p! q !#!x!&R    $R$c $  ,      !  8x!p!! y9  8 $  x! y p!!6! ( , q  p! q !#!x! 0 4   0!  !x!p!$ &R  8 <2$c        & K*    D   `%  < O      p!@@@D        x#/ <   N       8!  x!!8084        % % 
-$   O         p!4!@8@<  9    %    X   qp!   q ! 8p!x!8(8,$ ! 2 0%L*  +L8#$ 0    ! N  $ x!!9@@8@D$c %X   N  $ x!!9@@8@DX      p!x!@H@LY      #!p!@P@TO  %N !4!@X@\$c     '8  EL*  C0%L8#$ 0   !   Y   !  8p!x!!$ 980884$c %X  -   N   /!  !x!p!8084  Y   yx! y /p!!!98888<  O   !  !#p!x!8@8D  X   qp! q x!!4!%N $ 8H8L$c  $  ; |0%o*  4o8#$ 0   /! !  !   ! X  $ p!!9@@8@Df$%o   !  ! ! X  $ p!!9@@8@DO      !p!HPHTY      $x!!P`PdN  %x !4x!XpXt$ @       |  '/  M    x*  G 0%x8#$ 0   8! yN  x!   y ! p.x!!$ @8f@<%y & / yN  x!   y ! px!! q9@88@<X  p!   q x! p!!9HH8HL O  !    p! x!!9PX8P\ yN  x!   y ! px!!%x $ 9Xh8Xl        n*  O%i L*  G         8#$ 0  !      !  8p!x!!&R 9@@8@DR$c $  ,    y  x! y !#!p! @@@D  0!  !p!x!@H@L   !  8p!x!!9@P8@T q  p! q x!!4!$ &R @X@\$c   %& 0L*          @%               3!       O    #  yx!   z   x!9   y@p! !  x!         y'.  x!   z   x!   y@! 8x!X  % 8  qp!   r   p!   q@! yx!   y   /p! x!          !(! 	  l< 4!  D D   % a!               Vp!   $E  D 4x!F&"@D@@        #     B     yx! y ! v!kj/x!F0Tp!  8084          ' %              x! V!  ED/x!F&"p!@8@<    ' /            %!   px!! % Vp!   %!KJ  x!F0Tp!!8(8,$  ]     @0%"*  W"8#$ 0   !     ! V!   $E  D #x!F&"p!$ @@@D$c     ' & <     ! Vp!   $K  J !F0T4x!@@@D    ! V! ( ,E D #x!F&"p!@H@L    ! V!1 00 4K J p!F0T!@P@T    #! Vx! 8 <E D !F&"!$ $ )@X(@\$c           '  $  @0%*  8#$ 0   !@!        %!  x!! V!   %!KJ  x!F0T!p!$ 8084$c     $ & a        !  p!! V!   !'&ED  p!F&"!4x!8084     qp! q !#! Vx! q  p!KJ q !F0T#x!!888<     %!  x!! V!   %! $E D  x!F&"!p!8@8D     yx! y /!! y   Vp!x! y (,KJ/!F0Tp!!$ $ 38H28L$c      $ A ^     0%*  Y8#$ 0  ! !  ! !     $! Vx!   $E  D p!F&"!$ )@@(@Df$    %  < !  ! !     ! V!1  0 $K  J !F0Tp!@@@D    $! Vx!(0(4EDp!F&"!)HP(HT    ! V!0@0DK J$!F0T4x!P`Pd    ! Vp!8P8TE0D4$x!F&"!$n $ 	XpXt$ @   |9  % 8  0%*  8#$ 0  "      (!d   q  p! q  x!!  % V! q  p!1 0 KJ q x!F0T!4!$ @8@<    $  h      d     !   x8p!! % Vx!   !  ED  8p!F&"x!!)@8(@<d   y  x! y  !8!  % V! y  x!(((,KJ y !F0T$!p!HHHLd     !   x8p!! % Vx!   !080<ED  8p!F&"x!!)PX(P\ y  d  x! y ! 8!  % y  x! V! y 8H8LK(J,!F0T$!p!$ $ XhXl        %*      '%     *  8#$ 0   !    0!  !! Vp!   0!   $E  D   !F&"p!x!&R @@@D$c     '8  \  y  x! y !#! V! y  x!   $K  J  y !F0T#!p! @@@D  0!  !! Vp!   0! ( ,E D   !F&"p!x!@H@L   !  8p!! Vx!   ! 0 4K J   8p!F0Tx!!3@P2@T q  p! q x!! q  p! V! q ' 8& <E D x!F&"!4!$ &R 	@X@\$c       @%& {      !          +  *   F U1  0   F      V!   $G  F6F   F&F("         9    %#     B     qp! q .! vx!gF6fp!  F&F$           '/               ! V!+ * GF6TF!F&F2     % /            %!   x!!  % V!	GF6BF   %!F&  x!!F0T$  q     0%*  k8#$ 0   ) !   $  !S  R  Vx!F2   $  $ F6!$c F23  2   !S  R  Vx!F2   $  F6!$c F22 3      $  ?         ! V!   $G  F6F #p!$ F&F("       ! V! ( ,G F6F #p!F&F$       ! V! 0
- 4G F6TF #p!F&F2       ! V!	 8 <G F6BF #p!$ $c  F&F0T     9  % /  % 0%*  8#$ 0   "8@!        qp! q !#! V!GF6"F q  p!F& q !#!$ F*D $c     $  e        %!  !! Vx!GF6F   %!F&  !x!$ F("     %!  !! Vx!GF6F   %!F&  !x!F$      %!  !! Vx! $G F6TF   %!F&  !x!F2       %!  !! Vx!(,GF6BF   %!F&  !x!$ F0T$c      $ a t     0%*  n8#$ 0  *! !  ! !   $ f !S  R  V!F2   $  $ F6!$F23  2   f!S  R  V!F2   $  F6!$F22 3      $n  @ !  ! !     ! Vx!   $G  F6F $p!$ F&F("       ! Vx!(0(4GF6F$p!F&F$     ! Vx!0@0DG F6TF$$p!F&F2 $     ! Vx!8P8TG0F6BF4$p!$x $ @F&F0T40   |  '.    @% @0%*  8#$ 0   $  "(!d     x !   %!/!SR Vx!F2     F6!  !$x!F2$     %  l      d   q  p! q  !!  % V!3 2 GF6F q  p!F& q !! F("!*+d       x!/! % Vx!(((,GF6F   !F&  !$x! F$ &!d       px!! % Vp!080<GF6TF   &!F&  x!p! yF2 x!d     y  /p!!  % V!	8H8LG(F6BF, y  x!F& y /p!!$ F0T$ ,&(    < *      %     *  8#$ 0     !  y  x! y /p!! V!   $G  F6"F  y  x!F& y /p!!&R F*D $c        '/  `    !  !#! Vx!   $G  F6F    !F&  !#x! F("!       !#! Vx! ( ,G F6F    !F&  !#x! F$ !      !#! Vx! 0 4G F6TF    !F&  !#x! F2 !      !#! Vx! 8 <G F6BF    !F&  !#x!$ F0T&R   $c       @%& v      7              9    !3x!   p!@@@D      9  %x#    !    B  ! @8x! q p!  !  p!9  ! @8x!p!!  )80(84          '   !      !   @8x!  p %!  p!9  ! @8x!p!!'@8&@<    '  %       y  x!   % z   x!  y@%!  p!!x! (!  .  (! y @x! y !p!!4!8(
-8,$      0% *  } 8#$ 0   .!  yx! z   x! y@! yx! z #p!8  x! y@   !#p!!$ $c @@F@D    $O  [      qp! r   p! q@.! qp! r x!9  p! q@   .!x! !!  3@@2@D  ! @x! !  !.  ! @% $ x!!4p! yx! z @H@L  x! y@! yx! z #p!8  x! y@  !#p!! (!  	@P@T  (! @p! (!  /  (!! @p!  !x!$Y $ $c  @X&@\     %      *  0%8#$ 0   )!    q  p! r   p! y q@x! y .!!#p! yx! z 8  x! q y@p! q !.!x!!$ $c +80F*84    %          E  (!    (!  @!  p!x!! !10  .  !  @%!  x!p!!x! q8084E  p! r   p! y q@x! y .!!#p! yx! z 8  x! q y@p! q !.!x!! 38828<E  !    !  @%!  x!p!! (!   /  (!  @!  p!x!!4p! y8@8DE  x! z   x! q y@p! q !.!x! qp! r 9  p! y q@x! y .!!#p!!$ $ $c  	8H8L$ !     0% *   8#$ 0    ! !  ! !  (!    (! @! (!  p!/  (! @   !p!x!$ $@@F@D    $Y & \ !  ! !  qp! r   p! q@x! qp! r !8  p! q@+  * x!! y4!x! z @@
-@D  x! y@! yx! z $!.  x! y@!$!p! (!  HPHT  (! @! (!  p!/  (! @ $!p!x! !  P`Pd  ! @8p! !  9  !x! @8p!04x!!$X $ $ @%Xp$Xt   |  %   `0%*  8#$ 0  *!      d   ! p %    ! qp! @ q 8x!!$! qp!	 r /  p! ! q@  !8x!p!!$ )@8F(@<    '        D   ! p %    ! qp! @ q 8x!!$! qp! r /  p! ! q@  !8x!p!!'@8&@<D   qp!   % r   p! ! q@  !8x!p! !  9  ! qp! @ q 8x!!$!x!HHHLD   ! p %    ! qp! @ q 8x!!$! qp! r /  p! ! q@  !8x!p!!1PX0P\D   qp!   % r   p! ! q@  !8x!p! !(,  9  ! qp! @ q 8x!!$!x!$n $ Xh~Xl    #*  '8   *   8#$ 0  * ! (!    (! yx! @ y !p!! yx!%  $  z 8  x! 0! y@  p!!x!p!&R $c @@R@D    $Y 2 |  yx! z   x! 0! y@  p!!x! (!     .  (! yx! @ y !p!!4! qp!	@@@D r   p! ! q@  !8x!p! !    9  ! qp! @ q 8x!!#!x! (!@H@L    (! yx! @ y !p!! yx!+ *  z 8  x! 0! y@  p!!x!p! !@P@T    ! qp! @ q 8x!!#! qp!   r /  p! ! q@  !8x!p!!$X &R $c  1@X0@\ `% & R *    % )  D  @%      
-         x! Tp!@@@DS  R     '8   qp!   r   p!   q@! x/! Tp!@8@<  ED        c   q e# p!   r   p!9   q@! yx! y ! Tp!8084  IHc       q'8  p!   r   p!   q@! yx!   y   /p! ! Tx!8(8,GF$  [    0% n*  U n8#$ 0   . !  !    ! @!#! Tp!@@@D$ $c K  J     $  ;      (!    (! @p!! Tx!@@@D (!  Q  P   (! @p!! Tx!@H@L (!  S R   (! @p!! Tx!@P@T (!  E D   (! @p!! Tx!@X@\$ $ $c  I H    9  % / w 0%*  p8#$ 0   8 !    qp! r   p!   q@! yx! y /p!! T!8084$ $c GF    '/  Q    !    !   @! qp! q .!! Tx!8084 qp! r KJ  p!   q@.! /!  p!! Tx!888< (!  QP  (!   @p! !  !#! Tx!8@8D !  S R  !   @! qp! q .!! Tx!8H8L$ $ $c  E&D$  ^     0% *  X 8#$ 0  ! !  ! !  qp! r   p! q@.x!! T!	@@@D$ $I  fH     '.  < !  ! !  !    ! @!$! Tp!@@@D !  G  F   ! @!$! Tp!HPHT !  KJ  ! @!$! Tp!P`Pd !  Q P$  ! @!$! Tp!XpXt$o $ $ @S0R4   |  '.  z @0%*  s8#$ 0     "! qp! r   p! q@ &!x!    ! x! T!%@8$@<$ EfD    %  T       (!    (! @ !p!y    x! p! T!	@8@< yx! z IH  x! y@ !/p!o    ! p.! T!HHHL (!  GF  (! @ !p!y    x! p! T!PX
-P\ yx! z KJ  x! y@ !/p!o    ! p.! T!XhXl$ $ Q(P,    "*  z'.   b*  n b8#$ 0     ! (!    (! ! @  p!x!! T!3@@2@D&R $c S  R     $  L  yx! z   x! qp! y@ q !.!! Tx!@@@D qp! r E  D   p! yx! q@ y .!!#! Tp!@H@L yx! z I H   x! qp! y@ q !.!! Tx!@P@T qp! r G F   p! yx! q@ y .!!#! Tp!@X@\$ &R $c  K J  @% & 0 b*    % )  o  @%  %<  4!@@8      x!           #8  qp!   r /  p!   q@! yx! y /p!         q' % p!   r /  p!9   q@! xp!    '8   (!    .  (!   @! qp!   q   ! 8p!9    3(! !     !   	  l< 4!  a!% ) D D        @%                   6!   $  x!S  R     F2 D E          #  yx!   z   x!9   y@p!   !  !!)  ( $GF  F&BJK          %   q  p!   r   p! q@ x.!! %  S!6p!  R    F2 DE  9  '     y  x! p %   z   x!   y@! !    8x!!6!!GF	      F&BJK$  t    0%.*  n.8#$ 0    !  (!    (! @  !x!!!S  R 1  0 $$ F2 $c D E      '  O      (!    (! @  !x!!!G  F )  ( $ qF&Bp! r J K    p! q@  x!#!p!!S R  ( , F2 (!  D E   (! @  !x!!!G F ) 0( 4 qF&Bp! r J K   p! q@  x!#!p!!S R  8 <$ F2 $ D E $c       %   % 0%*  8#$ 0   " !    qp! r   p!   q@! yx! y   p!#!x!!GF   $$ F&B$c JK    % & e    yx! z   x!   y@p! !    x!#p!!!SR   $ F2 (!  DE  (!   @p! yx! y   !p!x!#!GF ( , F&B!  JK  !   @8p! /!    !p!!!S R1 00 4 yF2 x! z DE   x!   y@p! !    x!#p!!!GF	 8 <$ F&B$ JK$c      $ A {     0%*  u8#$ 0   (! !  ! !   qp! r   p! q@  !#x!p!!S  R    $$ F2 $D E  $c     ' & R !  ! !   qp! r   p! q@  !#x!p!!G  F    $ F&B(!  J K    (! @  x!!!!SR1 (0 , qF2 p! r DE  p! q@  !#x!p!!G F$ 0 4 F&B(!  J$K   (! @  x!!!!S0R41 80 <$ F2 $ D4E0$ @$c     |  '  0%*  8#$ 0  # !    !    ! @ yx!8p! y   !   p.!!!)  ( $GF$ F&B$c JK    %  i    (!    (! @ yx!p! y   !   p!!6!   $SR yF2 x! z DE  x! y@ !!    8p!   !x!p! ( ,GF F&B!  JK  ! @ qp!8x! q   !   x/!!!1 00 4SR qF2 p! r DE  p! q@ &!!    x!   !#p!x! 8 <G(F,$ F&B$ J,K($c      "*  '.      *  8#$ 0    8 !  yx! z   x! y@ !!    8p!!6!!S  R    $&R F2 $c D E      $  _      (!    (! @ qp!! q   x!#!p!!G  F    $ F&B(!  J K    (! @ qp!! q   x!#!p!!S R  ( , F2 (!  D E   (! @ qp!! q   x!#!p!!G F  0 4 F&B(!  J K   (! @ qp!! q   x!#!p!!S R  8 <$ F2 &R D E $c       & 0u    % )  <   6@@  %.      < x!4B@@ !(!3!0!        $ 	  l< 4!  a!w*           @%           8      p!x!3!@@@Dp!@@@D      9  %#     yB  x! z 9  x! q y@p!  /!p! !  !  ! @'80&84p!!4x!  8084          '     !    /  ! @   %p!! qp! r 4x!  p! q@@8@<!$x!!@8
-@<    % / &         (!   %  .  (!  @!  x!p!!4x! qp!8(8, r   p! y q@x! y !/!p!!18(08,$       0%*  8#$ 0    8!  qp! r /  p! q@!#! (!  x!  (! @@@@D!x!p!$ $c @@F@D    '8  _      qp! r /  p! q@!#! (!  x!  (! @@@@D!x! p!!  @@@D9  ! @8x!p! yx! z !  x! y@)@H(@Lp!!4! qp! r 	@H@L/  p! q@!#! (!  x!  (! @@P@T!x!p! !  @P@T9  ! @8x!p! yx! z   x!! y@p!+@X*@\!4!$O $ $c  @X
-@\   9  ' / 0%*  8#$ 0   *.!      !  /  ! q @p! q !.x!!! yx!180084 z   x!  y@%!  !p!x!!$ $c 80F84    '.      E  !  /  ! q @p! q !.x!!! yx!380284 z   x!  y@%!  !p!x!! q8084E  p! r 9  p!  q@!  .x!!#p!x! (!888<    (! y @x! y p!!!4p! 888<E  !  /  ! q @p! q !.x!!! yx!)8@(8D z   x!  y@%!  !p!x!! q	8@8DE  p! r 9  p!  q@!  .x!!#p!x! (!8H8L    (! y @x! y p!!!4p!$ $ $c  8H8L$       0%*  8#$ 0  !! !  ! !  qp! r 8  p! q@x!! yx! z 4!  x! y@@@
-@D!$!p!$ $@@F@D    % & ` !  ! !  qp! r 8  p! q@x!! yx! z 4!  x! y@@@@D!$! p!(!  @@@D/  (! @!p! !  x!  ! @HPHT8p!x!! qp! r 3HP2HT8  p! q@x!! yx! z 4!  x! y@P`Pd!$!p! (!  P`Pd/  (! @!p! !    !x! @8p!XpXtx!!$X $ $ @)Xp(Xt   |  %   0%*  8#$ 0  ,  !d   qp!   % r /  p! &! q@  !x!p!! yx!@8@< z   x! ! y@  /p!!$x!p!$ @8F@<    ' &       D   ! x %  .  ! yx! @ y !/p!!! qp!+@8*@< r   p! &! q@  !x!p!!@8
-@<D   qp!   % r /  p! &! q@  !x!p!! yx!HHHL z   x! ! y@  /p!!$x!p!HHHLD   yx!   % z 9  x! ! y@  /p!!$x!p! (!PXP\    (! qp! @ q x!!!4x!PXP\D   (! p %  8  (! qp! @ q x!!!4x! !XhXl    ! yx! @ y !/p!!!$o $ %Xhz$Xl    *  %      /*  /8#$ 0  (!  (!  8  (! yx! @ y p!!!4p! !@@@D    ! qp! @ q !.x!!!&R $c )@@R(@D    $N        !  /  ! qp! @ q !.x!!! yx!'@@&@D z   x! 0! y@  !p!x!! qp!@@@D r 9  p! ! q@  .x!!#p!x! (!@H@L    (! yx! @ y p!!!4p! !@H@L  /  ! qp! @ q !.x!!! yx!1@P0@T z   x! 0! y@  !p!x!! qp!@P@T r 9  p! ! q@  .x!!#p!x! (!@X@\    (! yx! @ y p!!!4p!$O &R $c  @X@\     & M    % )  )< 6@@  %9    3 !(!      	  l< 4!  a!w*                    < 4!@@     $    ! 	  l<   6@@  %  .  3 !(!      	  l< 4!  a!  w    <?D   D  %  $   )  ( F$ LF(      <  g! t!  @@@D+``*`ds  r      F$F*4     F*tF("  !    Q  P F21  V!F0   $  F 4F("      6p!F2T $       tx!@@@D g!F$```d1  0 F&  !  "    F0aF*DJ K   Vp!F6F$ $  !F*DF4F04F("F2Q@D@@              x#/ [<   $X     9  k  j !          !   tx!" ! g!!8084  32XPXTF2QF$!F&D F$r p!y  F*F("x!!F F& F*"	N     9    !    ! t!8084 gp!F2" !  XPXT"x!F0 !n  F(dF$2!F6F2T 4x!F$2F4F(F&F*$ 8480          '  X          8   !    %! Tp! G!!@8@<  
-3`X2`\e  d F2A!F*$32!    F2qF02 fg vx!F$B F&         F AF0Tp!!F$& '      x!8   T!+@8*@< %! Gx!F*`X`\    F(p!!  F&bF2 rs v!F6F*" * +   F2!p!F4F&A F0TF$ @<@8    '/      E     y  x! y /! p %! .  %!  x!! T! y  x!8(8, y  Gp!/!XHXLp! y  x!e  d  y /!F2"F*4p!F(pF*qq!     v!F$4&F0'   o  F 1!F(  p!F$T!6x!E  .     %!  x!   %! q  p! q !$! Tx!8(8, G! F2  %!XHXL  x!F&!  F0d!  F*A jkF6F2! vp!F*D yy  x! y F4F01 /!p!!F(F$Q&8,'8($  V     *  P ($   9    3  2 q  p !#x!     F2T T!@@
-@D   Gp!```d#x!F(R     F*p!   #x!F0tF*B!F0T F2 F2   $.    3  2  !F6  #! Tx!@@F4@D G!	```dF*   !%  F($  x!   $F$aF(R       p!F&F$A !$c F2F&!F&'@@&@D     '   "*  z P%J       9    3  2  yx! y p!! !  8x!  q  p  ! Tp!8084 G!)XP(XT yF(Rx! y p!  !+*F* yx! y F&F*Bp!o  !)( !F(r qp!F2F(R  q !#!F&Ax!F24  .    3  2  F6%!  ! qF4p! ! q !  #! T!	8084 Gx!F(XPXT %!F*  !F04F*Bx!y  F(b p! F24F(R !  8x!F0D p!F0 !$c 180C084$       !*    ! ) (! ) $ !   9  !   T!$!@@@D Gx!!  $3  2 ```dk  j  Rx!F2QF(  #  " F&!   a  F$q`    vp!  F F$1  $$!x!F"PF   F"    $.    #  " !F6  $! T!@@F4@Dg  f  Gx!F$```d!1  F20    v!  F0dF(! 
- $p!!F&F2! $F"PF&!F&'@@&@D  9  !   T!@@@D$!  k  j  Gx!```d!3  2 x!F2QF(#  " a  F&!   ` F$q vp!   $  F F$1   $$!F"PF   x!F"  $  " #    F6$! T!.  @@F4@D Gx!!  F$```d!1  F20 g  f  v!F0d  
- $  F&F(! p!!$F"PF2! F&!F&&@D'@@   |  %      &*  '/         &!  x!   %! q8  p! q !$!  Tx!  &!@8@<   G!x!`X`\!   &!k  j   x!F0RF$4!F(rF$rs!     vp!F*4  F2    yY  F 2x!F(  y /!F*$p!!3 2  q8    p! q ! x %/!   !  p!! T!1@80@< Gx! qF0  p!`X`\ q !F&$x!  F2d!  F$BdeF6F0Q v!  F$D N  &!  F4F22x!!p!F($ F*!@<@8     &        *  %   8*  y ($   9    3  2  qp! q !! yx! y /p!   !q  p  T!@@
-@D G!)``(`d qF(Rp! q !  !+  *   F*  qp! q F&F*B!  !)  (  x!F(r   $ !F2F(R   !#x!F&Ap!F24    $8    3  2 0!F6  x! !F4 !  !  #! Tx!@@@D Gp!F(```d 0!F*     x!F04F*Bp!     F(b !   $ yF24F(R x! y /p!F0D !F0 !$c 1@@0@D     &    8! 8# 8#        x! p!C0YxKXT    # !H!$%)$      P%a `h%  %$ a $   X% %. $  *&	 `%$     $ $ < A+*  `0%+ #$ 0   $+!      y  x! y p!!  6! .!  	   $.!/   qF:Ap! @ q !x!!>!$  F$c %.  p          O  0!  !p!  x! qp! r    $p!9   F:4! q@  .x!!#p!x!  X  0!  p!x!  ! yx! z  (
- ,x!9   qF:Tp! y@ q /!!#x!! N  0!  x!!  p! !   0 4!9   yF:Ax! @ y 8p!!#!p! O  0!  !p!  x! qp! r p! 8 <9   ! q@F:4  .x!!#p!x!%8 $ $c  & e+*$    q< A+*  n`0%+ #$ 0  (!<    6s  O  .  !  ! !  !+  * $ @!#x!p!$ $c __%8  M<    6s  Y  8  #x!  p! yx! z x!   $ y@p!!3!__O  8  p!  ! qp! r p!) (( , q@!#x!!	__N  8  !  6x! .!  .! 0 4 @x!p!!__Y  8  #x!  p! yx! z x! 8 < y@p!!3!%/ $ $c  __     <% 8 6s +*  `0%+ #$ 0  %@!       E     %!  !x!  p! yx! z x!9    y@!  /p!!#x!p!$ $c WW%8  q           E     yx! y /p!!  ! !  !/   q+* @p! q !.x!!!+W*WE     yx! y !!  6p! 8!  8!/    @!  p!x!!3p!WWE     yx! y !#p!  ! qp! r p!/   	 $ q@%!  !x!p!!	WWE     yx! y /p!!  ! !  !/   q%($, @p! q !.x!!!%. $ $c  %W$W` v    $ %*  p#$c 0y   /(!  O!      n  /  !  ! !  !'  & $ @!"p!x!& $B__     ' 0 N  P!       n  9  x!  ! yx! z x!   $ y@/!p!!1_0_o  9  !  p! !  !(0(4 @8p!x!!+g*gx  9  p!  x! qp! r p!0@0D q@.x!!!3p 2pn  9  x!  ! yx! z x!	8P8T y@/!p!!$ & $B @)x(x  %8        $  %*  #$c 0x   )       0!D   o  !   p %!.p!  x! qp! r p!8     0! q@  x!!p!x!& __     '8  y               D   o  0!   p %!p!  x! qp! r p!9     ! q@  .x!!$p!x!__D   qy  p! q    %.x!!  ! !  !.   y1((0(,x! @ y !/p!!!1g0gD   n  !   x %!/x!  p! yx! z x!8   080<0! y@  p!!x!p!ooD   yx  x! y    %p!!  6! .!  .!/   q8H8Lp! @ q !x!!3!$ & xx    0*        '% M*  0%M #$ 0   !!    y  x! y !  #! /!  /!.   y	   x! @ y !p!!3!$ $c 	_F_%O  g          0!  !Y  x! !  !.      0! @  x!p!!x! q__  p! q .!N  x! !  !9   q  p! @ q 8x!!#!x! __  0!  !Y  x! !  !.     0! @  x!p!!x! q__  p! q .!N  x! !  !9   q  p! @ q 8x!!#!x!%N $ $c  __& qM*                               % 	 l   	 l                  "     % 	 l xx! xx#   xx#9   N#D@  y /!FA!s rF$fg       $              $     * % +* `0%+ #$ 0   ;!       9   qp! r p! yx! q@ y .!!#p!!   0!  __p!!x!   $  9   !  ! qp! @ q 8x!!#!x!   0!  __!x!$ $c   F %.           X  9   yx! z x! ! y@  /p!!#x!p!   0!  __x!p!!	   $O  9   qp! r p! yx! q@ y .!!#p!!   0!  __p!!   Y  /   qp! r p! 0! q@  !x!p!! y  x! y __/p!!!% ($ ,N  /   !  ! qp! @ q !.x!!! y  x! y '_&_!!' & O  .   !  ! yx! @ y !/p!!! q  p! q 1_0_!!6x! 0 4X  .   8!  8! ! @  x!p!!3x! q  p! q __!#x!  N  8   .!  .! qp! @ q x!!!3x!   !  __!#x!p! 8 <Y  8   yx! z x! 0! y@  p!!x!p!   !  __8x!p!%9 $ $c   &9 & +*  F   <?  D p!D    $    F"!F80   <?  D D '8               !p!      F"F P     c     e#              yx! y !6p!    F"DF      '     q9  p! q  x.!!6p!    F"!F 0 $  B 0%/*  ;/8#  $ 0    ! <?!D D 6 !$   F      $$ F" ($ FF   $$ F"F      %  <? !D D 6 !   $ (F"D , 0 4 <F"! 8F  $ $N F"F 0 $  F"DF P F   <?D D %  ? *  8 0%  !    8#$ !0  !  xp! !$ F F"$ $ F  FF"$ F      % &   xp! !F" $,F"D(F P $ $O F"!F  $  F"F 0 F P $ ! @ | 0%*  98#  $ 0    ! 8!  p!!$ y  F     x $$ F"y(0$cFF  x $$cF"F      %   &!  p!!e  d $q(0F"!p(4i0@h0Dd8TF"e8PF 0 $ $O F"DF P $c @F"!F  F 0  |    '  C0%*  <8#  $ 0        .!  x!!!!$ y F     x $ F"y(($cFF  x $cF"F      % &  yx! y !p!!i h e((F"Dd(,q08p0<h8LF"!i8HF  $ $Y F"F 0 $c @F"DF P &F       O*  <$F     *  2 @%  8#$ 0       yx! y !.!!6 !   $& $PF       %   !  !#p! !   $(0(4F 0 0@0DF  8P8TF P & $O $ @F @     &R       B      S R     F  D E   B  G F K J F 4  F*            	   !F"DE  D $    F$F $G          x#/          .!  !qp v!F"IH  F(TRS          %          9     x!ED V!F"!q p     F02j k     % 8          .!      ! x!IH V!F"Ded    F$fg$ ! f    0%*  `8#$ 0  $@!     $  #!Y  X  V !F"   $$c $ F2   $  #!Y  X  V !F"   $$c F2 $      '  9         $ !E  D  V !F"!   $$ F02 $        #!I H  V !F"D ( ,    F$ , (      !Q P  V !F" 0 4    F(T 4 0      !E D  V !F"! 8 <$c  F02 < 8   9  ' / q0%*  j8#$ 0   .@!          8!  p!!IH V !F"D$ $c F$    '  L          !  8x!!QP V !F"$ F(T     !  x!!ED V !F"!    F02     !  8x!!I H V !F"D $    F$$      !  x!!QP V !F"(,% $c  F(T,&($  i     0%*  c8#$ 0   %8@! !  !   !   $  !Y  X  V!F"s  r $$$ F2s  r $  !Y  X  V!F"s  r $$F2r $s      % & : !  !   !   $ !I  H  V!F"De  d $$ F$f $g        !QP V!F"i(0h(4    F(Tr(4s(0      !E D$ V!F"!q0@p0D    F02j0Dk0@      $!I0H4 V!F"De8Pd8T$ @F$f8Tg8P   |  %   0%*  8#$ 0  2    @! y%x!    y   /p! !YX V!F"s r $  yF2x!s r    y   /p! !YX V!F"s r % $ F2r s     %  M           &!    x! p!ED V!F"!q p  !F02  j k     8x! !IH V!F"De((d(, qp!F$ q f(,g((    x! !QP V!F"i08h0< &!F(T  r0<s08    x! p!E(D, V!F"!q8Hp8L$ $ F02j8L&k8H    *  '  "*  w @%/8#$ 0   ,(!   &R     0!  !!Y  X  V !F"   $&R $c F2    $  0!  !!Y  X  V !F"   $$c F2 $      %  F      !  8x!!Q  P  V !F"   $ 0!F(T   $    &R !!E D  V !F"! ( , qp!F02 q  , (      !#!I H  V !F"D 0 4 yx!F$ y  4 0  $ p!!Q P  V !F" 8 <$c  F(T <2 8     & $     *  % +*  `0%+ #$ 0   $+!      y  x! y p!!  4! .!  @@@D.!/   qF:!p! @ q !x!!>!$  F$c %.  p          O  0!  !p!  x! qp! r @@@Dp!9   F:! q@  .x!!#p!x!  X  0!  p!x!  ! yx! z 	@H@Lx!9   qF:Dp! y@ q /!!#x!! N  0!  x!!  p! !  @P@T!9   yF:!x! @ y 8p!!#!p! O  0!  !p!  x! qp! r p!@X@\9   ! q@F:  .x!!#p!x!%8 $ $c  & e+*$      m+*  k`0%+ #$ 0  (!     O  .  !  ! !  !)@@(@D @!#x!p!$ $c __%8  L         Y  8  #x!  p! yx! z x!@@@D y@p!!3!__O  8  p!  ! qp! r p!%@H$@L q@!#x!!__N  8  !  4x! .!  .!@P@T @x!p!!__Y  8  #x!  p! yx! z x!@X@\ y@p!!3!%/ $ $c  __     % 8 +*  `0%+ #$ 0  %@!       E     %!  !x!  p! yx! z x!9   8084 y@!  /p!!#x!p!$ $c WW%8  q           E     yx! y /p!!  ! !  !/   q)80(84 @p! q !.x!!!)W(WE     yx! y !!  4p! 8!  8!/   888< @!  p!x!!3p!WWE     yx! y !#p!  ! qp! r p!/   8@8D q@%!  !x!p!!WWE     yx! y /p!!  ! !  !/   q'8H&8L @p! q !.x!!!%. $ $c  'W&W` v    $ %*  p#$c 0y   /(!  O!      n  /  !  ! !  !1@@0@D @!"p!x!& $B__     ' 0 N  P!       n  9  x!  ! yx! z x!@@
-@D y@/!p!!+_*_o  9  !  p! !  !HPHT @8p!x!!)g(gx  9  p!  x! qp! r p!P`Pd q@.x!!!3p 2pn  9  x!  ! yx! z x!XpXt y@/!p!!$ & $B @%x$x  %8        $  %*  #$c 0x   )       0!D   o  !   p %!.p!  x! qp! r p!8   @8@<0! q@  x!!p!x!& __     '8  y               D   o  0!   p %!p!  x! qp! r p!9   @8@<! q@  .x!!$p!x!__D   qy  p! q    %.x!!  ! !  !.   y+HH*HLx! @ y !/p!!!+g*gD   n  !   x %!/x!  p! yx! z x!8   PXP\0! y@  p!!x!p!ooD   yx  x! y    %p!!  4! .!  .!/   qXhXlp! @ q !x!!3!$ & xx    0*  '% M*  0%M #$ 0   "!    y  x! y !#!  p! !  !/      $0! @  p!x!!p!$ $c _F_%Y & k          !  p!!N  6x! .!  .!8   q   $p! @ q x!!!3x! __  !  !#x!Y  p! yx! z x!8    ( ,0! y@  p!!x!p! __  !  8x!p!O  ! qp! r p!8   y+ 0* 4x! q@ y !/!p!! +_*_  !  p!!N  6x! .!  .!8   q 8 <p! @ q x!!!3x!%N $ $c  __& lM*                9        
-         % 	 l   	 l                   $   ! # #     % 	 l   Op#9  D  0!F!s rF&     pq $      p* $g +* `0%+ #$ 0   <!       9   qp! r p! yx! q@ y .!!#p!!   0!  _
-_p!!x!@@@D  9   !  ! qp! @ q 8x!!#!x!   0!  __!x!p!$ $c   F $%9 &          O  8   qp! r p! yx! q@ y !/!p!!   !  %_$_p!!4x!@@@DN  8   .!  .! qp! @ q x!!!3x!   !  __!#x!p!   $Y  8   yx! z x! 0! y@  p!!x!p!   !  __8x!p!!'@H&@LO  8   qp! r p! yx! q@ y !/!p!!   !  1_0_p!!6x! ( ,N  8   .!  .! qp! @ q x!!!3x!   !  __!#x!p!@P@TY  8   yx! z x! 0! y@  p!!x!p!   !  __8x!p!!) 0( 4O  8   qp! r p! yx! q@ y !/!p!!   !  %_$_p!!4x!@X@\N  8   .!  .! qp! @ q x!!!   !3x!  !__#x!p!%8 $ $c   85 <& +*            p!   $x!F6@@@D!F*2(@D)@@    x!   $p!F4$@@@D    F0           p#. -    B     !  ! vp! t!F6A+80*84    F$Tx!!  380284B     qp!  ! vx! t!F4)80(84  F(2!
-        % % '               p! V!3 2  Tx!F6 %  @8@<!F0!x!  @8@<     ! V!	   Tx!F4B@8@<  %  F2Q $p!  9  '  ;         y  x! y ! p.! V! %F62 Tp! 8(8,  %!  p!F(!x!  8(8,         !   x!!  % V!32 Tp!F4 y8(8,  x! y F&$ !$p!$ a     @0%**  *8#$ 0   F
-(!   
-    ! V!9  8 $ Tp!F4@@@D$  !F2x!       #! V!   $ Tp!F6@@@D!4p!F8$c @@@D    ! V!9  8 $ Tp!F4@@@D$ F2x!       #! V!   $ Tp!F6@@@D!4p!F8$c @D@@%8  {           ! V!3  2 $ Tp!F4@@@Dx!$ F0!       #! V!  
- $ Tp!F6T@@@D!4p!F2A@D@@    ! Vx! ( , T!F4+@H*@L!F*2  	     ! Vp! ( , T!F6$3@H2@Lx!!F0&@L'@H    ! V! 0
- 4 Tx!F4R@P@T#p!F$D      ! V!' 0& 4 Tx!F62@P@T!x!F*@T@P    #! Vp! 8 < T!F4$@X@\!F& 0 1     ! Vx! 8 < T!F6A@X
-@\#p!!F$T%/ @\@X$c     9  % 8	** @0%*8#$ 0  ;@!          %!  !! Vx! Tp!F44 8084  !  F(8x!p!     !  8x!! V!32 Tp!F6 y8084  x! y p!F&$!4!$ 8084$c     %            %!  !! Vx! Tp!F4B 8084  !  F2Q 8x!p!     !  8x!! V!10 Tp!F6 y8084  x! y p!F(2!4!80
-84     qp! q !#! V! Tx!F4 888<  %!  F0!!x!     %!  !! Vp! Tx!F6T 888<  !  8x!F2Ap!!%88$8<     yx! y p!! V!1 0$ T!F4 q8@
-8D  p! q F*2 !#!	      qp! q !#! Vx! $ T!F6$ 8@8D  %!  !F0x!p!8@8D     !  8x!! Vp!(, T!F4R y%8H$8L  x! y F$Dp!!32     yx! y p!! V!(, T!F62 q  p!18H08L q !F*#!x!% $ 8H8LA$c      $ A     `0%+*  +8#$ 0   I(! !  !   ! o    ! Vp!   $ T!F43@@2@D$  !F2x!   n    ! V!   $ T!F63@@2@Dp!!F8$9@@8@Do    ! Vp!   $ T!F43@@2@D$ F2x!   n    ! V!   $ T!F63@@2@Dp!!F8$8@D9@@    '  } !  !   ! n    ! V!'  & $ T!F44	@@@Dp!$ F(   y    $! Vx!   $ T!F6@@@D!4!F&$@D@@o    ! Vp!(0(4 T!F4B3HP2HTx!F2Q n    ! V!(0(4 T!F6'HP&HTp!!F(2*HT+HPx    ! Vx!0@0D Tp!F4P`Pd$!F0!$ o    ! V!+0@*0D Tp!F6TP`Pdx!p!F2APdP`y    $! V!8P8T Tx!F4XpXt!F*2 (4)0x    ! Vp!8P8T Tx!F6$XpXt$!x!F0$ XtXp$ @       |9  ' /`0%* 8#$ 0   ?        @!d     !   x!/! % Vx!   Tp!F4R @8@<  &!  F$Dx!p! y  d  x! y /p! ! V!' &   %F62 T! q@8@<  p! q !F*!4x!$ @8@<    %          d   q  p! q  !!  % V!% $  Tx!F4$ @8@<  !  F& !$x!   d  &!  x! p! V!	   %F6A Tp! y@8@<  x! y /p!F$T!!3@82@<d     !   x!/! % Vx!(((, Tp!F44 HHHL  &!  F(x!p! y  d  x! y /p! ! V!3((2(,  %F6 T! qHHHL  p! q !F&$!4x!HHHLd     &!   px!! % Vp!080< T!F4B yPXP\  x! y F2Q /p!! q  d  p! q ! ! Vx!080<  %F6 T! 'PX&P\  !  !F(2$x!p!PXP\d   y  x! y  /p!!  % V!8H8L T!F4 q1Xh0Xl  p! q F0!!!'(&,   d  !  ! x/! Vp!8H8L %F6T Tx!   &!XhXl  x!F2Ap!!$ $ Xh&2Xl    * <@ %  *   % 8#$ 0   6 !    y  x! y /p!! V!   $ T!F4 q+@@*@D  p! q F*2 !!)  (  q  p! q !! Vx!   $ T!F6$ 3@@2@D  !  !F0#x!p!&R @@@D$c $          y  x! y /p!! V!  
- $ T!F4R q%@@$@D  p! q F$D!!3  2  q  p! q !! Vx!   $ T!F62 1@@0@D  !  !F*#x!p! @@@D  0!  x!! Vp! ( , T!F4$ y@H@L  x! y F& /p!!   y  x! y /p!! V!) (( , T!F6A q@H
-@L  p! q !F$T!4x!@H@L   !  !#! Vx! 0 4 Tp!F44 @P@T  0!  F(x!p!     0!  x!! V! 0 4 Tp!F6 y@P@T  x! y /p!F&$!!1@P0@T q  p! q !! V!) 8( < Tx!F4B @X@\  !  F2Q !#x!     !  !#! Vp! 8 < Tx!F6   0!@X@\  x!F(2p!!$ &R @X
-@\2I$c  & 0 *    <@ D   D %  $  F$       I  F H     F(2J K          %x#     B     qp! q x!.!F qp  F0!fg          % %          !)(!F BSR    F2Q DE  '           y  x! y p!   %!   !  8x!p!IF H    F(2JK$ a S     0% *  M 8#$ 0   ) ! 	    p!   !F Q  P $ $c F0!F G  $ & 6     p!   !F BS  R $ F2Q D E      x!  #!F I H     F(2J K     #!  !F Q P $ F0!F G     !) ( !F BS R $c  F2Q D E      %   *   0% 8#$ 0    	 !        yx! y ! q  p! q #!x!!10IF H$ $c F(2JK    '  _        !  8p!   %!  !!p!QF P$ F0!FG     %!  ! y  x! y !!#!	SF BR    F2Q DE     yx! y ! q  p! q #!x!!1 0I F H    F(2JK      qp! q x!   !  !8p!x!QF P$ $c  F0!F&G    $ ! Z    `0%K*  UK8#$ 0    !  ! ! !    $!	   !F BS  R $ $F2Q D fE  %N  8 !  ! !     $!   !F I  H $ F(2J K      !32!F QP    F0!FG    x! $!F BS R$%O F2Q D$E     p!04$!F I0H4$ @F(2J4K0       |9  ' . K*  `0%K8#$ 0  !      (! qd    p! q  .x!!   %  &!  p!x!QF P$ F0!FG    $  d       yd    x! y  !! q  %  p! q .x!!	SF BR yx! y F2Q DE  d  !   %! q  p! q .x!!IF H yx! y F(2JK  d  !   %! q  p! q .x!!QF P yx! y F0!FG  d  !   %! q  p! q .x!!	(,S(F BR,$ $ F2Q D,&E(    K*  %H  *   % 8#$ 0  2 ! &R       !  ! yx!#! y !!;  : Y  F X &R $c  F8 Y  X   !  ! y  x! y #!!!;  : Y  F X $c F8 X Y  $  U    !  ! y  x! y #!!!3  2 Q  F P  yx! y F0!&R F G      ! qp! q !.x!!	  S F BR  qp! q F2Q D E     .x! 0!  !p!x!  I F H  0!  F(2J K     p! !  !!#p!  Q F P $ $c  F0!F G & q *                  !	@@@D!F BS  R $    F2Q D $E          x#/     B     !  !!p!80846!F ih  F(2jk          '/           !!p!@8@<6!F Q P     F0!F G   '/           yx!   y /! p % y  p!x! y !/!p!!)8((8,SF BR    F2Q DE$ + o    @0% *  i 8#$ 0  & ! 
-    p!#x!!@@@D$  F !Y  X $$c F8 $ Y  X $    p!#x!!@@@DF !Y  X $$c F8 X $Y  $  ?     #x!p!!3@@2@D!F Q  P $$ F0!F $G      !!4x!@H@L!F BS (R ,    F2Q D ,E (    #x!p!!@P@T!F I 0H 4    F(2J 4K 0    !!p!@X@\6!F Q 8P <$ $c  F0!F <&G 8     '   *  @0% 8#$ 0   "*@!        yx! y p! y  !x! y 6!p!!4!	8084SF BR$ $c F2Q DE    %  g        yx! y p! y  !x! y 6!p!!4!8084IF H$ F(2JK     qp! q ! q  #!p! q !!#!x!888<QF P    F0!FG     %!  !   x!%!  !!x!p!8@8DS F BR$    F2Q D$E      !  8x!   p!!  !8x!p!!18H08LI(F H,$ $c  F(2J,K(    K v     0%	*  q	8#$ 0  ) !  ! ! !    $!p!!9@@8@D$ f F !Y  X $$F8 $ Y  X $    $!p!!9@@8@DfF !Y  X $$F8 X $Y  %  A !  ! !     p!$!x!@@@D!F BS  R $$ F2Q D $E      x!!p!HPHT6!F I(0H(4    F(2J(4K(0    p!$!!3P`2Pd!F Q0@P0D    F0!F0DG0@    !x!4!	XpXt!F BS8PR8T% $ @F2Q D8TE8P       |  '8  	*   0%	8#$ 0  >      (!$  d    !     %x!  ! !6!  x!!4p!@8@<Y F X $  F8 Y X   !d    x!   %   !!  6!x!!4p!@8@<Y F X $ $ F8 X Y %  k       q  p!d   q .! x % q  p!x! q !.!x!!3@82@<Q F P  yx! y F0!F G   d  ! p % y  x!.p! y !!$p!!	HHHLS((F BR(, qp! q F2Q D(,E((  d  .! x % q  p!x! q !.!x!!1PX0P\I08F H0< yx! y F(2J0<K08  d  ! p % y  x!.p! y !!$p!!XhXlQ8HF P8L% $ F0!F8LG8H    	*      %	  *   % 8#$ 0   6& ! &R     !  x!  ! !6!  x!!4p!@@@DY  F X $&R $c  F8 Y  X $  !  x!   !!  6!x!!4p!@@@DY  F X $$c F8 X $Y  $  `    0!  p!   0!!  !p!!x!@@@DI  F H $ qp! q F(2&R J $K        .! q  p!x! q !.!x!!3@H2@LQ (F P , !  F0!F ,G (      x!   !!  6!x!!4p!@P@TS 0F BR 4 yx! y F2Q D 4E 0      ! y  x!#p! y !!#p!!@X@\I 8F H <$ $c  F(2J <K 8& 0b * t ( , 0 4 8 < @ D L P T X \ ` d h p '                                                                 	     	     	     	     	     	     	     	    	  $  		  T  		  H  	  $  	  h  	    	  D  	  `  	  d  	    	    	    	    		    		    	  
-p  	    		    	    	    	    
-	    	    	    	  <  	  d  		    	    		      @  
-	    	    	    	    	    		  T  	  l  	  p  		  X  	    	    	     		  `  		    		    	    	    	     	  D  	  0  	  4  	  T  	    	    		    	    	     		  \  	    	  $  	  "  		  "  		  #X  		  'X  	  '  	  '  	  '  	  (  	  (D  		  (  	  (  	  (  		  +\  	  +  	  ,D  	  0`  		  0  		  1H  		  6  	  6  		  6  	  6  	  7  	  7D  	  7l  	  7  		  94  	  9t  	  9  	  <  		  <  		  =X  		  @  	  @  	  @  	  A$  	  AL  		  Ax  	  A  	  A  		  A    BD  	  BH  
-	  B  	  B  	  B  	  C  	  C8  		  C  	  C  		  C  	  E  	  F8  	  F  	  JD  		  J  		  K  		  O  	  Oh    O  	  O  
-	  O  	  O  	  P  	  Pp  	  P  		  P  	  Q  	  Q  		  S  	  T  	  T  	  X  		  Y8  		  Y  		  _4    _p  	  _t  	  _x  
-	  _  	  _    _  	  `    `@  	  `T  	  `d  	  a  	  `  	  `  	  `  	  a  	  a  	  a  	  a  	  a  	  a  	  b   	  b  	  cT  		  c  	  d  	  d  		  d  	  e  	  f  	  h   	  hT  	  hd  	  j  	  m   		  m4  		  n  	  op  	  qX  	  qt  	  q  	  q  		  r  	  rH  	  rL  	  r  	  r  	  t  	  t  	  t  	  u<  	  u@  	  vl  	  v  	  v  	  v  	  w8  	  w<  	  w@  	  y0  	  y4  	  y  	  y  	  z  		  {  	  {  	  {  		  {  	  {  	  {  		  }  	  }  	  ~P  	    	    	      P      	        	  4  	    	    	  l  	  p  	    	    	    	     		  0  	  4  		  T  	  P  	    	    	     	    	     	  ,  	  L  	    	  D  	  p  	    	    	    	    	     	  0  	  ,  		  l  	    	    	    		    	    	    	    	    	  0  	  4  	    	  (  	    		  D  	  H  		    	    		  x  	  (  	    	    	    	    	    	    	  l  	  p  	    	    	    	    	  \  	  `  	  d  	  T  	  X  	    	    	    		  8  	  <  	  @  		    	    	    		    	  p  	  4  	  L    p      	    
-	    	      $  	  (  
-	    	  l  	  p  	  X  	  \  	    	    	    	  <  	  8  	    	  x  	    	    		  @  		    	    	    		    	     		    	    	    	    	     	    	    	  <  	  \  	  P  		    	    		    		    	    	    	    	  4  	  8  	  T  	    	    		    	    		    	    	    	  |  		    		  8  		  t  	  x  	    	    	     		  \  	  `  		    	    	  X  	    		    		    		  l8  	p	  6f    P   $       D     x                 @     \                        $!  #""%CB BEA 0 0` *&  ! $""%AB BABD 
-% # (  '$% #BB B E F    $"$% $ ABXC BA  @   ' #%% BB E F W 3$ " %E EFW   -  & $ (  &#%$ ABXBF E  4 '#%$ BBD FE  +   `a   00(4110(5(7(4(30F8@@T (4(5F8B 	08@@ Q  R @0!0 0 0( PPh BAX B E g`g6 '3T 0   "'%$@CDE F 
-     8'$%$FDFG  S E A E eh 5 '3   ' "% $RRRUh! @@X&$$ $BBCBB Dc&$$# ABBABKKT x                                    ,     
-         
-                       ,                                  	       !   
-                                           	       !   
-                 slave2.c slave2  ./decs.h  slave2 lev_res numlev wrk1 nprocs xprocs im jm wrk3 laplacalc fields h3 h h1 wrk2 wrk5 jacobcalc wrk4 wrk6 eig2 frcng lf gp multi guess do_stats time multig global dtau    _gp_disp                               6f                                               
-                                                                                                             "          )          ,          /           4          >          E          H          J          M          R           W          a          f          k          p          v          y          |                                                                                                                                           	   
-                                                                                                                            4                 	             D   E                                                              P                   !p                                 *p                               3   	          (                 =p                            
\ No newline at end of file
diff -Naur splash2/codes/apps/radiosity/display.C splash2-modified/codes/apps/radiosity/display.C
--- splash2/codes/apps/radiosity/display.C	1994-10-18 13:37:23.000000000 -0400
+++ splash2-modified/codes/apps/radiosity/display.C	2007-03-17 14:36:21.000000000 -0400
@@ -19,26 +19,24 @@
 EXTERN_ENV;
 
 include(radiosity.h)
-  
-  
+
+static void add_radiosity_to_vertex(Edge *edge, long reverse, Element *elem, Vertex *p_c, long process_id);
+static void _display_shaded_triangle(ElemVertex *ev1, ElemVertex *ev2, ElemVertex *ev3, Edge *e12, Edge *e23, Edge *e31, long process_id);
+static void _disp_interactions(Element *elem, Interaction *inter, long mode, long process_id);
+static void _ps_disp_interactions(Element *elem, Interaction *inter, long mode, long process_id);
+
 /************************************************************************
  *
  *    radiosity_averaging
  *
  *************************************************************************/
-  
-  static void add_radiosity_to_vertex() ;
 
-void radiosity_averaging( elem, mode, process_id )
-  
-  Element *elem ;
-  int mode ;
-  unsigned process_id;
+void radiosity_averaging(Element *elem, long mode, long process_id)
 {
     float inv_weight ;
     Vertex pc ;
-    int reverse ;
-    
+    long reverse ;
+
     if( ! LEAF_ELEMENT(elem) )
         {
             create_radavg_task( elem->center, mode, process_id ) ;
@@ -47,21 +45,18 @@
             create_radavg_task( elem->left,   mode, process_id ) ;
             return ;
         }
-    
+
     else if( mode == RAD_AVERAGING_MODE )
         {
             /* Compute center point */
             center_point( &elem->ev1->p, &elem->ev2->p, &elem->ev3->p, &pc ) ;
-            
+
             reverse = EDGE_REVERSE( elem->e12, elem->ev1, elem->ev2 ) ;
-            foreach_leaf_edge( elem->e12, reverse,
-                              add_radiosity_to_vertex, (int)elem, (int)&pc, process_id ) ;
+            foreach_leaf_edge( elem->e12, reverse, add_radiosity_to_vertex, (long)elem, (long)&pc, process_id ) ;
             reverse = EDGE_REVERSE( elem->e23, elem->ev2, elem->ev3 ) ;
-            foreach_leaf_edge( elem->e23, reverse,
-                              add_radiosity_to_vertex, (int)elem, (int)&pc, process_id ) ;
+            foreach_leaf_edge( elem->e23, reverse, add_radiosity_to_vertex, (long)elem, (long)&pc, process_id ) ;
             reverse = EDGE_REVERSE( elem->e31, elem->ev3, elem->ev1 ) ;
-            foreach_leaf_edge( elem->e31, reverse,
-                              add_radiosity_to_vertex, (int)elem, (int)&pc, process_id ) ;
+            foreach_leaf_edge( elem->e31, reverse, add_radiosity_to_vertex, (long)elem, (long)&pc, process_id ) ;
         }
     else
         {
@@ -76,7 +71,7 @@
                     elem->ev1->weight = 1.0 ;
                 }
             UNLOCK(elem->ev1->ev_lock->lock);
-            
+
             LOCK(elem->ev2->ev_lock->lock);
             if( elem->ev2->weight != 1.0 )
                 {
@@ -87,7 +82,7 @@
                     elem->ev2->weight = 1.0 ;
                 }
             UNLOCK(elem->ev2->ev_lock->lock);
-            
+
             LOCK(elem->ev3->ev_lock->lock);
             if( elem->ev3->weight != 1.0 )
                 {
@@ -101,22 +96,16 @@
         }
 }
 
-static void add_radiosity_to_vertex( edge, reverse, elem, p_c, process_id )
-  
-  Edge *edge ;
-  int reverse ;			/* Direction */
-  Element *elem ;
-  Vertex *p_c ;
-  unsigned process_id;
+static void add_radiosity_to_vertex(Edge *edge, long reverse, Element *elem, Vertex *p_c, long process_id)
 {
     ElemVertex *ev ;
     float weight ;
-    
+
     if( reverse )
         ev = edge->pb ;
     else
         ev = edge->pa ;
-    
+
     weight = (float)1.0 / distance( &ev->p, p_c ) ;
     weight = 1.0 ;
     weight = elem->area ;
@@ -139,38 +128,35 @@
 static float view_rot_x, view_rot_y, view_dist, view_zoom ;
 
 
-void setup_view( rot_x, rot_y, dist, zoom, process_id )
-  
-  float rot_x, rot_y, dist, zoom ;
-  unsigned process_id;
+void setup_view(float rot_x, float rot_y, float dist, float zoom, long process_id)
 {
     Vertex v1, v2 ;
     float cc, ss ;
-    
+
     /* Save parameters */
     view_rot_x = rot_x ;
     view_rot_y = rot_y ;
     view_dist  = dist ;
     view_zoom  = zoom ;
-    
+
     /* Compute view vector */
     v1.x = 0.0 ;
     v1.y = 0.0 ;
     v1.z = 1.0 ;
-    
+
     /* Rotate view vector */
     cc = cos( -rot_x * (M_PI / 180.0) ) ;
     ss = sin( -rot_x * (M_PI / 180.0) ) ;
     v2.x = v1.x ;
     v2.y = cc * v1.y - ss * v1.z ;
     v2.z = ss * v1.y + cc * v1.z ;
-    
+
     cc = cos( -rot_y * (M_PI / 180.0) ) ;
     ss = sin( -rot_y * (M_PI / 180.0) ) ;
     v1.z = cc * v2.z - ss * v2.x ;
     v1.x = ss * v2.z + cc * v2.x ;
     v1.y = v2.y ;
-    
+
     /* Store view vector */
     view_vec = v1 ;
 }
@@ -182,17 +168,14 @@
  *
  *************************************************************************/
 
-void display_scene( fill_sw, patch_sw, mesh_sw, interaction_sw, process_id )
-  
-  int fill_sw, patch_sw, mesh_sw, interaction_sw ;
-  unsigned process_id;
+void display_scene(long fill_sw, long patch_sw, long mesh_sw, long interaction_sw, long process_id)
 {
     /* Clear the screen */
     g_clear() ;
-    
-    /* Set matrix */ 
+
+    /* Set matrix */
     g_setup_view( view_rot_x, view_rot_y, view_dist, view_zoom ) ;
-    
+
     if( fill_sw == 2 )
         {
             /* Fill surfaces */
@@ -219,7 +202,7 @@
             g_color( G_GREEN ) ;
             display_interactions_in_bsp_tree(process_id) ;
         }
-    
+
     /* Flush */
     g_flush() ;
 }
@@ -230,38 +213,34 @@
  *
  *************************************************************************/
 
-void display_patch( patch, mode, process_id )
-  
-  Patch *patch ;
-  int   mode ;
-  unsigned process_id;
+void display_patch(Patch *patch, long mode, long process_id)
 {
     Vertex p_buf[4] ;
     Rgb   c_buf[4] ;
-    
+
     if( mode == DISPLAY_SHADED )
         {
             if( inner_product( &patch->plane_equ.n, &view_vec ) < F_ZERO )
                 return ;
-            
+
             p_buf[0] = patch->p1 ;
             p_buf[1] = patch->p2 ;
             p_buf[2] = patch->p3 ;
             c_buf[0] = patch->color ;
             c_buf[1] = patch->color ;
             c_buf[2] = patch->color ;
-            
+
             g_spolygon( 3, p_buf, c_buf ) ;
         }
     else if( mode == DISPLAY_FILLED )
         {
             if( inner_product( &patch->plane_equ.n, &view_vec ) < F_ZERO )
                 return ;
-            
+
             p_buf[0] = patch->p1 ;
             p_buf[1] = patch->p2 ;
             p_buf[2] = patch->p3 ;
-            
+
             g_polygon( 3, p_buf ) ;
         }
     else
@@ -279,12 +258,9 @@
  *
  *************************************************************************/
 
-void display_patches_in_bsp_tree( mode, process_id )
-  
-  int mode ;
-  unsigned process_id;
+void display_patches_in_bsp_tree(long mode, long process_id)
 {
-    foreach_depth_sorted_patch( &view_vec, display_patch, (int)mode, process_id ) ;
+    foreach_depth_sorted_patch( &view_vec, display_patch, (long)mode, process_id ) ;
 }
 
 
@@ -295,19 +271,13 @@
  *
  *************************************************************************/
 
-static void _display_shaded_triangle() ;
-  
-  void display_element( element, mode, process_id )
-  
-  Element *element ;
-  int   mode ;
-  unsigned process_id;
+void display_element(Element *element, long mode, long process_id)
 {
     Vertex p_buf[4] ;
-    
+
     if( inner_product( &element->patch->plane_equ.n, &view_vec ) < F_ZERO )
         return ;
-    
+
     if( mode == DISPLAY_SHADED )
         {
             _display_shaded_triangle( element->ev1, element->ev2,
@@ -320,7 +290,7 @@
             p_buf[0] = element->ev1->p ;
             p_buf[1] = element->ev2->p ;
             p_buf[2] = element->ev3->p ;
-            
+
             g_polygon( 3, p_buf ) ;
         }
     else
@@ -331,15 +301,11 @@
         }
 }
 
-static void _display_shaded_triangle( ev1, ev2, ev3, e12, e23, e31, process_id )
-  
-  ElemVertex *ev1, *ev2, *ev3 ;
-  Edge *e12, *e23, *e31 ;
-  unsigned process_id;
+static void _display_shaded_triangle(ElemVertex *ev1, ElemVertex *ev2, ElemVertex *ev3, Edge *e12, Edge *e23, Edge *e31, long process_id)
 {
     Vertex p_buf[4] ;
     Rgb   c_buf[4] ;
-    
+
     p_buf[0] = ev1->p ;
     p_buf[1] = ev2->p ;
     p_buf[2] = ev3->p ;
@@ -356,11 +322,7 @@
  *
  *************************************************************************/
 
-void display_elements_in_patch( patch, mode, process_id )
-  
-  Patch *patch ;
-  int mode ;
-  unsigned process_id;
+void display_elements_in_patch(Patch *patch, long mode, long process_id)
 {
     foreach_leaf_element_in_patch( patch, display_element, mode, process_id ) ;
     g_flush() ;
@@ -373,10 +335,7 @@
  *
  *************************************************************************/
 
-void display_elements_in_bsp_tree( mode, process_id )
-  
-  int mode ;
-  unsigned process_id;
+void display_elements_in_bsp_tree(long mode, long process_id)
 {
     foreach_depth_sorted_patch( &view_vec, display_elements_in_patch, mode, process_id );
 }
@@ -387,41 +346,30 @@
  *
  *************************************************************************/
 
-static void _disp_interactions() ;
-  
-  void display_interactions_in_element( elem, mode, process_id )
-  
-  Element *elem ;
-  int mode ;
-  unsigned process_id;
+void display_interactions_in_element(Element *elem, long mode, long process_id)
 {
-    
+
     foreach_interaction_in_element( elem, _disp_interactions, mode, process_id ) ;
     g_flush() ;
 }
 
 
-static void _disp_interactions( elem, inter, mode, process_id )
-  
-  Element *elem ;
-  Interaction *inter ;
-  int mode ;
-  unsigned process_id;
+static void _disp_interactions(Element *elem, Interaction *inter, long mode, long process_id)
 {
     Vertex pa, pb ;
     Element *edst ;
-    
-    
+
+
     /* Display interactions only with a particular patch */
     if(   (mode == DISPLAY_HALF_INTERACTIONS)
        && (inter->destination->patch->seq_no >= elem->patch->seq_no ) )
         return ;
-    
+
     /* Compute mid point of the element */
     edst = inter->destination ;
     center_point( &elem->ev1->p, &elem->ev2->p, &elem->ev3->p, &pa ) ;
     center_point( &edst->ev1->p, &edst->ev2->p, &edst->ev3->p, &pb ) ;
-    
+
     /* Draw a line */
     g_line( &pa, &pb ) ;
 }
@@ -434,11 +382,7 @@
  *
  *************************************************************************/
 
-void display_interactions_in_patch( patch, mode, process_id )
-  
-  Patch *patch ;
-  int mode ;  
-  unsigned process_id;
+void display_interactions_in_patch(Patch *patch, long mode, long process_id)
 {
     foreach_element_in_patch( patch, display_interactions_in_element, mode, process_id );
 }
@@ -449,11 +393,9 @@
  *
  *************************************************************************/
 
-void display_interactions_in_bsp_tree(process_id)
-  unsigned process_id;
+void display_interactions_in_bsp_tree(long process_id)
 {
-    foreach_patch_in_bsp( display_interactions_in_patch,
-                         DISPLAY_ALL_INTERACTIONS, process_id ) ;
+    foreach_patch_in_bsp( display_interactions_in_patch, DISPLAY_ALL_INTERACTIONS, process_id ) ;
 }
 
 
@@ -473,10 +415,7 @@
  *************************************************************************/
 
 
-void ps_display_scene( fill_sw, patch_sw, mesh_sw, interaction_sw, process_id )
-  
-  int fill_sw, patch_sw, mesh_sw, interaction_sw ;
-  unsigned process_id;
+void ps_display_scene(long fill_sw, long patch_sw, long mesh_sw, long interaction_sw, long process_id)
 {
     if( fill_sw )
         {
@@ -501,7 +440,7 @@
             ps_linewidth( 0.2 ) ;
             ps_display_interactions_in_bsp_tree(process_id) ;
         }
-    
+
 }
 
 /************************************************************************
@@ -510,15 +449,11 @@
  *
  *************************************************************************/
 
-void ps_display_patch( patch, mode, process_id )
-  
-  Patch *patch ;
-  int   mode ;
-  unsigned process_id;
+void ps_display_patch(Patch *patch, long mode, long process_id)
 {
     Vertex p_buf[4] ;
     Rgb   c_buf[4] ;
-    
+
     if( mode == DISPLAY_SHADED )
         {
             if( inner_product( &patch->plane_equ.n, &view_vec ) < F_ZERO )
@@ -529,7 +464,7 @@
             c_buf[0] = patch->color ;
             c_buf[1] = patch->color ;
             c_buf[2] = patch->color ;
-            
+
             ps_spolygon( 3, p_buf, c_buf ) ;
         }
     else if( mode == DISPLAY_FILLED )
@@ -539,7 +474,7 @@
             p_buf[0] = patch->p1 ;
             p_buf[1] = patch->p2 ;
             p_buf[2] = patch->p3 ;
-            
+
             ps_polygon( 3, p_buf ) ;
         }
     else
@@ -547,7 +482,7 @@
             p_buf[0] = patch->p1 ;
             p_buf[1] = patch->p2 ;
             p_buf[2] = patch->p3 ;
-            
+
             ps_polygonedge( 3, p_buf ) ;
         }
 }
@@ -559,12 +494,9 @@
  *
  *************************************************************************/
 
-void ps_display_patches_in_bsp_tree( mode, process_id )
-  
-  int mode ;
-  unsigned process_id;
+void ps_display_patches_in_bsp_tree(long mode, long process_id)
 {
-    foreach_depth_sorted_patch( &view_vec, ps_display_patch, (int)mode, process_id ) ;
+    foreach_depth_sorted_patch( &view_vec, ps_display_patch, (long)mode, process_id ) ;
 }
 
 
@@ -575,15 +507,11 @@
  *
  *************************************************************************/
 
-void ps_display_element( element, mode, process_id )
-  
-  Element *element ;
-  int   mode ;
-  unsigned process_id;
+void ps_display_element(Element *element, long mode, long process_id)
 {
     Vertex p_buf[4] ;
     Rgb   c_buf[4] ;
-    
+
     if( mode == DISPLAY_SHADED )
         {
             if( inner_product( &element->patch->plane_equ.n, &view_vec )
@@ -595,7 +523,7 @@
             c_buf[0] = element->rad ;
             c_buf[1] = element->rad ;
             c_buf[2] = element->rad ;
-            
+
             ps_spolygon( 3, p_buf, c_buf ) ;
         }
     else if( mode == DISPLAY_FILLED )
@@ -606,7 +534,7 @@
             p_buf[0] = element->ev1->p ;
             p_buf[1] = element->ev2->p ;
             p_buf[2] = element->ev3->p ;
-            
+
             ps_polygon( 3, p_buf ) ;
         }
     else
@@ -614,7 +542,7 @@
             p_buf[0] = element->ev1->p ;
             p_buf[1] = element->ev2->p ;
             p_buf[2] = element->ev3->p ;
-            
+
             ps_polygonedge( 3, p_buf ) ;
         }
 }
@@ -626,11 +554,7 @@
  *
  *************************************************************************/
 
-void ps_display_elements_in_patch( patch, mode, process_id )
-  
-  Patch *patch ;
-  int mode ;
-  unsigned process_id;
+void ps_display_elements_in_patch(Patch *patch, long mode, long process_id)
 {
     foreach_leaf_element_in_patch( patch, ps_display_element, mode, process_id ) ;
 }
@@ -642,13 +566,9 @@
  *
  *************************************************************************/
 
-void ps_display_elements_in_bsp_tree( mode, process_id )
-  
-  int mode ;
-  unsigned process_id;
+void ps_display_elements_in_bsp_tree(long mode, long process_id)
 {
-    foreach_depth_sorted_patch( &view_vec, 
-                               ps_display_elements_in_patch, mode, process_id ) ;
+    foreach_depth_sorted_patch( &view_vec, ps_display_elements_in_patch, mode, process_id ) ;
 }
 
 /************************************************************************
@@ -657,39 +577,27 @@
  *
  *************************************************************************/
 
-static void _ps_disp_interactions() ;
-  
-  
-  void ps_display_interactions_in_element( elem, mode, process_id )
-  
-  Element *elem ;
-  int mode ;
-  unsigned process_id;
+void ps_display_interactions_in_element(Element *elem, long mode, long process_id)
 {
     foreach_interaction_in_element( elem, _ps_disp_interactions, mode, process_id ) ;
 }
 
 
-static void _ps_disp_interactions( elem, inter, mode, process_id )
-  
-  Element *elem ;
-  Interaction *inter ;
-  int mode ;
-  unsigned process_id;
+static void _ps_disp_interactions(Element *elem, Interaction *inter, long mode, long process_id)
 {
     Vertex pa, pb ;
     Element *edst ;
-    
+
     /* Display interactions only with a particular patch */
     if(   (mode == DISPLAY_HALF_INTERACTIONS)
        && (inter->destination->patch->seq_no >= elem->patch->seq_no ) )
         return ;
-    
+
     /* Compute mid point of the element */
     edst = inter->destination ;
     center_point( &elem->ev1->p, &elem->ev2->p, &elem->ev3->p, &pa ) ;
     center_point( &edst->ev1->p, &edst->ev2->p, &edst->ev3->p, &pb ) ;
-    
+
     /* Draw a line */
     ps_line( &pa, &pb ) ;
 }
@@ -702,14 +610,9 @@
  *
  *************************************************************************/
 
-void ps_display_interactions_in_patch( patch, mode, process_id )
-  
-  Patch *patch ;
-  int mode ;  
-  unsigned process_id;
+void ps_display_interactions_in_patch(Patch *patch, long mode, long process_id)
 {
-    foreach_element_in_patch( patch,
-                             ps_display_interactions_in_element, mode, process_id );
+    foreach_element_in_patch( patch, ps_display_interactions_in_element, mode, process_id );
 }
 
 /************************************************************************
@@ -718,10 +621,8 @@
  *
  *************************************************************************/
 
-void ps_display_interactions_in_bsp_tree(process_id)
-  unsigned process_id;
+void ps_display_interactions_in_bsp_tree(long process_id)
 {
-    foreach_patch_in_bsp( ps_display_interactions_in_patch,
-                         DISPLAY_ALL_INTERACTIONS, process_id ) ;
+    foreach_patch_in_bsp( ps_display_interactions_in_patch, DISPLAY_ALL_INTERACTIONS, process_id ) ;
 }
 
diff -Naur splash2/codes/apps/radiosity/elemman.C splash2-modified/codes/apps/radiosity/elemman.C
--- splash2/codes/apps/radiosity/elemman.C	1994-10-18 13:37:23.000000000 -0400
+++ splash2-modified/codes/apps/radiosity/elemman.C	2007-03-17 14:12:01.000000000 -0400
@@ -29,6 +29,15 @@
 
 include(radiosity.h)
 
+static void _foreach_element(Element *elem, void (*func)(), long arg1, long process_id);
+static void _foreach_leaf_element(Element *elem, void (*func)(), long arg1, long process_id);
+static long bf_refine_element(long subdiv, Element *elem, Interaction *inter, long process_id);
+static void process_rays2(Element *e, long process_id);
+static void process_rays3(Element *e, long process_id);
+static void elem_join_operation(Element *e, Element *ec, long process_id);
+static void gather_rays(Element *elem, long process_id);
+static float _diff_disc_formfactor(Vertex *p, Element *e_src, Vertex *p_disc, float area, Vertex *normal, long process_id);
+static float compute_diff_disc_formfactor(Vertex *p, Element *e_src, Vertex *p_disc, Element *e_dst, long process_id);
 
 /***************************************************************************
  ****************************************************************************
@@ -48,32 +57,17 @@
  *
  ****************************************************************************/
 
-static void _foreach_element(), _foreach_leaf_element() ;
-  
-  
-  void foreach_element_in_patch( patch, func, arg1, process_id )
-  
-  Patch *patch ;
-  void (*func)() ;
-  int  arg1 ;
-  unsigned process_id;
+void foreach_element_in_patch(Patch *patch, void (*func)(), long  arg1, long process_id)
 {
-    void _foreach_element() ;
-    
     _foreach_element( patch->el_root, func, arg1, process_id ) ;
 }
 
 
-static void _foreach_element( elem, func, arg1, process_id )
-  
-  Element *elem ;
-  void (*func)() ;
-  int   arg1 ;
-  unsigned process_id;
+static void _foreach_element(Element *elem, void (*func)(), long   arg1, long process_id)
 {
     if( elem == 0 )
         return ;
-    
+
     /* Process children */
     if( ! LEAF_ELEMENT( elem ) )
         {
@@ -82,34 +76,23 @@
             _foreach_element( elem->left,   func, arg1, process_id ) ;
             _foreach_element( elem->right,  func, arg1, process_id ) ;
         }
-    
+
     /* Apply function to this node */
     func( elem, arg1, process_id ) ;
 }
 
 
-void foreach_leaf_element_in_patch( patch, func, arg1, process_id )
-  
-  Patch *patch ;
-  void (*func)() ;
-  int  arg1 ;
-  unsigned process_id;
+void foreach_leaf_element_in_patch(Patch *patch, void (*func)(), long  arg1, long process_id)
 {
-    void _foreach_leaf_element() ;
-    
     _foreach_leaf_element( patch->el_root, func, arg1, process_id ) ;
 }
 
 
-static void _foreach_leaf_element( elem, func, arg1, process_id )
-  
-  Element *elem ;
-  void (*func)() ;
-  int   arg1 ;
+static void _foreach_leaf_element(Element *elem, void (*func)(), long arg1, long process_id )
 {
     if( elem == 0 )
         return ;
-    
+
     /* Process children */
     if( LEAF_ELEMENT( elem ) )
         func( elem, arg1, process_id ) ;
@@ -132,40 +115,36 @@
  *
  ****************************************************************************/
 
-void    ff_refine_elements( e1, e2, level, process_id )
-  
-  Element *e1, *e2 ;		     /* A pair of elements to be refined */
-  int level ;			     /* Interaction level */
-  unsigned process_id;
+void ff_refine_elements(Element *e1, Element *e2, long level, long process_id)
 {
-    int subdiv_advice ;
+    long subdiv_advice ;
     Interaction i12, i21 ;
     Interaction *inter ;
-    
+
 #if PATCH_ASSIGNMENT == PATCH_ASSIGNMENT_COSTBASED
 #if defined(SUN4)
     Patch_Cost *pc1, *pc2 ;
 #else
     volatile Patch_Cost *pc1, *pc2 ;
 #endif
-    int cost1, cost2 ;
+    long cost1, cost2 ;
 #endif
-    
-    
+
+
     /* Now compute formfactor.
        As the BSP tree is being modified at this moment, don't test
        visibility. */
     compute_formfactor( e1, e2, &i12, process_id ) ;
     compute_formfactor( e2, e1, &i21, process_id ) ;
-    
+
     /* Analyze the error of FF */
     subdiv_advice = error_analysis( e1, e2, &i12, &i21, process_id ) ;
-    
+
     /* Execute subdivision procedure */
     if( NO_INTERACTION(subdiv_advice) )
         /* Two elements are mutually invisible. Do nothing */
         return ;
-    
+
     else if( NO_REFINEMENT_NECESSARY(subdiv_advice) )
         {
             /* Create links and finish the job */
@@ -173,26 +152,26 @@
             *inter = i12 ;
             inter->visibility = VISIBILITY_UNDEF ;
             insert_vis_undef_interaction( e1, inter, process_id ) ;
-            
+
             inter = get_interaction(process_id) ;
             *inter = i21 ;
             inter->visibility = VISIBILITY_UNDEF ;
             insert_vis_undef_interaction( e2, inter, process_id ) ;
-            
+
 #if PATCH_ASSIGNMENT == PATCH_ASSIGNMENT_COSTBASED
             /* Update cost variable */
             pc1 = &global->patch_cost[ e1->patch->seq_no ] ;
             pc2 = &global->patch_cost[ e2->patch->seq_no ] ;
             if( pc1->n_total_inter <= 13 )
-                cost1 = (int)ceil(e1->area / Area_epsilon) ;
+                cost1 = (long)ceil(e1->area / Area_epsilon) ;
             else
                 cost1 = 1 ;
-            
+
             if( pc2->n_total_inter <= 13 )
-                cost2 = (int)ceil(e2->area / Area_epsilon) ;
+                cost2 = (long)ceil(e2->area / Area_epsilon) ;
             else
                 cost2 = 1 ;
-            
+
             LOCK(global->cost_sum_lock);
             pc1->cost_estimate += cost1 ;
             pc1->n_total_inter++ ;
@@ -203,12 +182,12 @@
             UNLOCK(global->cost_sum_lock);
 #endif
         }
-    
+
     else if( REFINE_PATCH_1(subdiv_advice) )
         {
             /* Refine patch 1 */
             subdivide_element( e1, process_id ) ;
-            
+
             /* Locally solve it */
             ff_refine_elements( e1->top,    e2, level+1, process_id ) ;
             ff_refine_elements( e1->center, e2, level+1, process_id ) ;
@@ -219,7 +198,7 @@
         {
             /* Refine patch 2 */
             subdivide_element( e2, process_id ) ;
-            
+
             /* Locally solve it */
             ff_refine_elements( e1, e2->top,    level+1, process_id ) ;
             ff_refine_elements( e1, e2->center, level+1, process_id ) ;
@@ -238,26 +217,23 @@
  *
  ****************************************************************************/
 
-int error_analysis( e1, e2, inter12, inter21, process_id )
-  Element *e1, *e2 ;		       /* Element pair */
-  Interaction *inter12, *inter21 ;   /* Interaction */
-  unsigned process_id;
+long error_analysis(Element *e1, Element *e2, Interaction *inter12, Interaction *inter21, long process_id)
 {
-    int cc ;
-    
+    long cc ;
+
     /* Check visibility */
     cc = patch_intersection( &e1->patch->plane_equ,
                             &e2->ev1->p, &e2->ev2->p, &e2->ev3->p, process_id ) ;
     if( NEGATIVE_SIDE(cc) )
         /* If negative or on the plane, then do nothing */
         return( _NO_INTERACTION ) ;
-    
+
     cc = patch_intersection( &e2->patch->plane_equ,
                             &e1->ev1->p, &e1->ev2->p, &e1->ev3->p, process_id ) ;
     if( NEGATIVE_SIDE(cc) )
         /* If negative or on the plane, then do nothing */
         return( _NO_INTERACTION ) ;
-    
+
     return( _NO_REFINEMENT_NECESSARY ) ;
 }
 
@@ -274,28 +250,23 @@
  *
  ****************************************************************************/
 
-static int  bf_refine_element( subdiv, elem, inter, process_id )
-  
-  int subdiv ;		      /* Subdivision code */
-  Element *elem ;		      /* Element to be refined */
-  Interaction *inter ;	      /* Interaction to be refined */
-  unsigned process_id;
+static long  bf_refine_element(long subdiv, Element *elem, Interaction *inter, long process_id)
 {
     Element *e_dst = inter->destination ;
     Interaction *pi ;
     float visibility_val ;
-    int new_inter = 0 ;
-    
-    
+    long new_inter = 0 ;
+
+
     visibility_val = NO_VISIBILITY_NECESSARY(subdiv)?
         (float)1.0 : VISIBILITY_UNDEF ;
-    
+
     if( REFINE_PATCH_1(subdiv) )
         {
             /* Refine this element */
             /* (1) Make sure it has children */
             subdivide_element( elem, process_id ) ;
-            
+
             /* (2) For each of the patch, create an interaction */
             if( element_completely_invisible( elem->center, e_dst, process_id ) == 0 )
                 {
@@ -335,11 +306,11 @@
             /* Refine source element */
             /* (1) Make sure it has children */
             subdivide_element( e_dst, process_id ) ;
-            
+
             /* (2) Insert four new interactions
                NOTE: Use *inter as a place holder to link 4 new interactions
                since *prev may be NULL */
-            
+
             if( element_completely_invisible( elem, e_dst->center, process_id ) == 0 )
                 {
                     pi = get_interaction(process_id) ;
@@ -373,7 +344,7 @@
                     new_inter++ ;
                 }
         }
-    
+
     return( new_inter ) ;
 }
 
@@ -391,25 +362,21 @@
  *
  ****************************************************************************/
 
-void bf_error_analysis_list( elem, i_list, process_id )
-  
-  Element *elem ;		     /* Element to be analyzed */
-  Interaction *i_list ;	     /* Top of the interaction list */
-  unsigned process_id;
+void bf_error_analysis_list(Element *elem, Interaction *i_list, long process_id)
 {
-    int subdiv_advice ;
+    long subdiv_advice ;
     Interaction *prev = 0 ;
     Interaction *inter = i_list ;
     Interaction *refine_inter ;
-    int i_len = 0 ;
-    int delta_n_inter = 0 ;
-    
-    
+    long i_len = 0 ;
+    long delta_n_inter = 0 ;
+
+
     while( inter )
         {
             /* Analyze error */
             subdiv_advice = bf_error_analysis( elem, inter, process_id ) ;
-            
+
             if( NO_REFINEMENT_NECESSARY(subdiv_advice) )
                 {
                     /* Go on to the next interaction */
@@ -426,17 +393,17 @@
                         i_list = inter ;
                     else
                         prev->next = inter ;
-                    
+
                     /* Perform refine */
                     delta_n_inter += bf_refine_element( subdiv_advice,
                                                        elem, refine_inter, process_id ) ;
-                    
+
                     /* Delete this inter anyway */
                     free_interaction( refine_inter, process_id ) ;
                     delta_n_inter-- ;
                 }
         }
-    
+
     /* Link good interactions to elem->intearctions */
     if( i_len > 0 )
         {
@@ -446,13 +413,13 @@
             elem->n_interactions += i_len ;
             UNLOCK(elem->elem_lock->lock);
         }
-    
+
 #if PATCH_ASSIGNMENT == PATCH_ASSIGNMENT_COSTBASED
     /* Update patch interaction count */
     if( delta_n_inter != 0 )
         {
             Patch_Cost *pc ;
-            
+
             pc = &global->patch_cost[ elem->patch->seq_no ] ;
             LOCK(pc->cost_lock->lock);
             pc->n_total_inter += delta_n_inter ;
@@ -472,42 +439,39 @@
  *
  ****************************************************************************/
 
-int bf_error_analysis( elem, inter, process_id )
-  Element *elem ;		     /* Elem that the interaction belongs to */
-  Interaction *inter ;	     /* Interaction to be analyzed */
-  unsigned process_id;
+long bf_error_analysis(Element *elem, Interaction *inter, long process_id)
 {
     float rad_avg ;		     /* Average radiosity */
     float total_error ;
     float visibility_error ;
-    int   vis_code = 0 ;
-    
+    long   vis_code = 0 ;
+
     /* Compute amount of error associated with the BF.
-       
+
        FFcomputed = (F + Ferr)(V + Verr) = FV + (Ferr V + F Verr + Ferr Verr)
        BFcomputed = BF + BFerr
        = B FV + B (Ferr V + F Verr + Ferr Verr)
        */
-    
+
     if( (0.0 < inter->visibility) && (inter->visibility < 1.0) )
         visibility_error = 1.0 ;
     else
         visibility_error = FF_VISIBILITY_ERROR ;
-    
+
     rad_avg =( inter->destination->rad.r
               + inter->destination->rad.g
               + inter->destination->rad.b ) * (float)(1.0 / 3.0) ;
-    
+
     total_error = (inter->visibility * inter->formfactor_err
                    + visibility_error * inter->formfactor_out
                    + visibility_error * inter->formfactor_err) * rad_avg ;
-    
+
     /* If BF is smaller than the threshold, then not subdivide */
     if( (total_error <= BFepsilon) && (elem->n_interactions <= 10) )
         return( _NO_REFINEMENT_NECESSARY ) ;
     else if( total_error <= BFepsilon * 0.5 )
         return( _NO_REFINEMENT_NECESSARY ) ;
-    
+
     /* Subdivide light source or receiver whichever is larger */
     if( elem->area > inter->destination->area )
         {
@@ -518,11 +482,11 @@
     else
         {
             if( inter->destination->area > Area_epsilon )
-                
+
                 /* Subdivide source element */
                 return( _REFINE_PATCH_2 | vis_code ) ;
         }
-    
+
     return( _NO_REFINEMENT_NECESSARY ) ;
 }
 
@@ -538,23 +502,22 @@
  *
  ****************************************************************************/
 
-int radiosity_converged(process_id)
-  unsigned process_id;
+long radiosity_converged(long process_id)
 {
     float prev_total, current_total ;
     float difference ;
     Rgb rad ;
-    
+
     /* Check radiosity value */
     prev_total = global->prev_total_energy.r + global->prev_total_energy.g
         + global->prev_total_energy.b ;
     current_total = global->total_energy.r + global->total_energy.g
         + global->total_energy.b ;
-    
+
     /* Compute difference from the previous iteration */
     prev_total += 1.0e-4 ;
     difference = fabs( (current_total / prev_total) - (float)1.0 ) ;
-    
+
     if( verbose_mode )
         {
             rad = global->total_energy ;
@@ -562,12 +525,12 @@
             rad.g /= global->total_patch_area ;
             rad.b /= global->total_patch_area ;
             printf( "Total energy:     " ) ;
-            print_rgb( &global->total_energy, process_id ) ;
+            print_rgb( &global->total_energy ) ;
             printf( "Average radiosity:" ) ;
-            print_rgb( &rad, process_id ) ;
+            print_rgb( &rad ) ;
             printf( "Difference %.2f%%\n", difference * 100.0 ) ;
         }
-    
+
     if( difference <=  Energy_epsilon )
         return( 1 ) ;
     else
@@ -583,27 +546,24 @@
  *
  ****************************************************************************/
 
-void subdivide_element( e, process_id )
-  
-  Element *e ;		     /* Parent element of the new children */
-  unsigned process_id;
+void subdivide_element(Element *e, long process_id)
 {
     float quarter_area ;
     ElemVertex *ev_12, *ev_23, *ev_31 ;
     Edge *e_12_23, *e_23_31, *e_31_12 ;
     Element *enew, *ecenter ;
-    int rev_12, rev_23, rev_31 ;
-    
+    long rev_12, rev_23, rev_31 ;
+
     /* Lock the element before checking the value */
     LOCK(e->elem_lock->lock);
-    
+
     /* Check if the element already has children */
     if( ! _LEAF_ELEMENT(e) )
         {
             UNLOCK(e->elem_lock->lock);
             return ;
         }
-    
+
     /* Subdivide edge structures */
     subdivide_edge( e->e12, (float)0.5, process_id ) ;
     subdivide_edge( e->e23, (float)0.5, process_id ) ;
@@ -611,15 +571,15 @@
     ev_12 = e->e12->ea->pb ;
     ev_23 = e->e23->ea->pb ;
     ev_31 = e->e31->ea->pb ;
-    
+
     /* Then create new edges */
     e_12_23 = create_edge( ev_12, ev_23, process_id ) ;
     e_23_31 = create_edge( ev_23, ev_31, process_id ) ;
     e_31_12 = create_edge( ev_31, ev_12, process_id ) ;
-    
+
     /* Area parameters */
     quarter_area = e->area * (float)0.25 ;
-    
+
     /* (1) Create the center patch */
     enew = get_element(process_id) ;
     ecenter = enew ;
@@ -633,12 +593,12 @@
     enew->e31   = e_12_23 ;
     enew->area  = quarter_area ;
     enew->rad   = e->rad ;
-    
+
     /* (2) Create the top patch */
     rev_12 = EDGE_REVERSE( e->e12, e->ev1, e->ev2 ) ;
     rev_23 = EDGE_REVERSE( e->e23, e->ev2, e->ev3 ) ;
     rev_31 = EDGE_REVERSE( e->e31, e->ev3, e->ev1 ) ;
-    
+
     enew = get_element(process_id) ;
     e->top = enew ;
     enew->parent= e ;
@@ -651,7 +611,7 @@
     enew->e31   = (!rev_31)? e->e31->eb : e->e31->ea ;
     enew->area  = quarter_area ;
     enew->rad   = e->rad ;
-    
+
     /* (3) Create the left patch */
     enew = get_element(process_id) ;
     e->left = enew ;
@@ -665,7 +625,7 @@
     enew->e31   = e_12_23 ;
     enew->area  = quarter_area ;
     enew->rad   = e->rad ;
-    
+
     /* (4) Create the right patch */
     enew = get_element(process_id) ;
     e->right = enew ;
@@ -679,10 +639,10 @@
     enew->e31   = (!rev_31)? e->e31->ea : e->e31->eb ;
     enew->area  = quarter_area ;
     enew->rad   = e->rad ;
-    
+
     /* Finally, set e->center */
     e->center = ecenter ;
-    
+
     /* Unlock the element */
     UNLOCK(e->elem_lock->lock);
 }
@@ -707,7 +667,7 @@
  *    After all the interactions are examined, the light energy is
  *    gathered. This gathered energy and the energy passed from the ancestors
  *    are added and pushed down to descendants. The descendants in turn pop up
- *    the area weighted energy gathered at descendant level. Thus, the 
+ *    the area weighted energy gathered at descendant level. Thus, the
  *    radiosity at level i is:
  *          Bi =  E
  *              + Sum(j=0 to i-1) gather(j)        --- gathered at ancestors
@@ -736,29 +696,20 @@
  ****************************************************************************/
 
 
-static  void process_rays2(), process_rays3() ;
-  static  void gather_rays() ;
-  static  void elem_join_operation() ;
-  
-  
-  
-  void process_rays( e, process_id )
-  
-  Element *e ;
-  unsigned process_id;
+void process_rays(Element *e, long process_id)
 {
     Interaction *i_list ;
-    
+
     /* Detach interactions from the list */
     LOCK(e->elem_lock->lock);
     i_list = e->interactions ;
     e->interactions = (Interaction *)0 ;
     e->n_interactions = 0 ;
     UNLOCK(e->elem_lock->lock);
-    
+
     /* For each interaction, do BF-error-analysis */
     bf_error_analysis_list( e, i_list, process_id ) ;
-    
+
     if( e->n_vis_undef_inter == 0 )
         process_rays3( e, process_id ) ;
     else
@@ -770,13 +721,10 @@
 
 
 
-static void process_rays2( e, process_id )
-  
-  Element *e ;
-  unsigned process_id;
+static void process_rays2(Element *e, long process_id)
 {
     Interaction *i_list ;
-    
+
     /* Detach interactions from the vis-undef-list. They now have their
        visibility computed */
     LOCK(e->elem_lock->lock);
@@ -784,10 +732,10 @@
     e->vis_undef_inter = (Interaction *)0 ;
     e->n_vis_undef_inter = 0 ;
     UNLOCK(e->elem_lock->lock);
-    
+
     /* For each interaction, do BF-error-analysis */
     bf_error_analysis_list( e, i_list, process_id ) ;
-    
+
     if( e->n_vis_undef_inter == 0 )
         process_rays3( e, process_id ) ;
     else
@@ -798,17 +746,14 @@
 
 
 
-static void process_rays3( e, process_id )
-  
-  Element *e ;
-  unsigned process_id;
+static void process_rays3(Element *e, long process_id)
 {
     Rgb rad_push ;		          /* Radiosity value pushed down */
-    
-    
+
+
     /* Gather light rays that impinge on this element */
     gather_rays( e, process_id ) ;
-    
+
     /* Now visit children */
     if( ! LEAF_ELEMENT(e) )
         {
@@ -816,19 +761,19 @@
             rad_push.r = e->rad_in.r + e->rad_subtree.r ;
             rad_push.g = e->rad_in.g + e->rad_subtree.g ;
             rad_push.b = e->rad_in.b + e->rad_subtree.b ;
-            
+
             e->center->rad_in = rad_push ;
             e->top->   rad_in = rad_push ;
             e->right-> rad_in = rad_push ;
             e->left->  rad_in = rad_push ;
             e->join_counter = 4 ;
-            
+
             /* Create tasks to process children */
             create_ray_task( e->center, process_id ) ;
             create_ray_task( e->top, process_id ) ;
             create_ray_task( e->left, process_id ) ;
             create_ray_task( e->right, process_id ) ;
-            
+
             /* The rest of the job (pop up the computed radiosity) is
                handled by the continuation function, elem_join_operation().
                It is called when the lower level finishes.
@@ -844,7 +789,7 @@
             e->rad.r = e->rad_in.r + e->rad_subtree.r + e->patch->emittance.r ;
             e->rad.g = e->rad_in.g + e->rad_subtree.g + e->patch->emittance.g ;
             e->rad.b = e->rad_in.b + e->rad_subtree.b + e->patch->emittance.b ;
-            
+
             /* Ship out radiosity to the parent */
             elem_join_operation( e->parent, e, process_id ) ;
         }
@@ -869,18 +814,14 @@
 
 
 
-static void elem_join_operation( e, ec, process_id )
-  
-  Element *e ;			  /* This element */
-  Element *ec ;			  /* Child element */
-  unsigned process_id;
+static void elem_join_operation(Element *e, Element *ec, long process_id)
 {
-    int join_flag ;
+    long join_flag ;
 #if PATCH_ASSIGNMENT == PATCH_ASSIGNMENT_COSTBASED
     Patch_Cost *pc ;
 #endif
-    
-    
+
+
     while( e != 0 )
         {
             /* Get radiosity of the child and add to my radiosity */
@@ -891,23 +832,23 @@
             e->join_counter-- ;
             join_flag = (e->join_counter == 0) ;
             UNLOCK(e->elem_lock->lock);
-            
+
             if( join_flag == 0 )
                 /* Other children are not finished. Return. */
                 return ;
-            
+
             /* This is the continuation called by the last (4th) subprocess.
                Perform JOIN at this level */
             /* Update element radiosity */
             e->rad.r = e->rad_in.r + e->rad_subtree.r + e->patch->emittance.r ;
             e->rad.g = e->rad_in.g + e->rad_subtree.g + e->patch->emittance.g ;
             e->rad.b = e->rad_in.b + e->rad_subtree.b + e->patch->emittance.b ;
-            
+
             /* Traverse the tree one level up and repeat */
             ec = e ;
             e = e->parent ;
         }
-    
+
     /* Process RAY root level finished. Update energy variable */
     LOCK(global->avg_radiosity_lock);
     global->total_energy.r += ec->rad.r * ec->area ;
@@ -915,7 +856,7 @@
     global->total_energy.b += ec->rad.b * ec->area ;
     global->total_patch_area += ec->area ;
     UNLOCK(global->avg_radiosity_lock);
-    
+
 #if PATCH_ASSIGNMENT == PATCH_ASSIGNMENT_COSTBASED
     /* Then update the cost variable of the patch */
     pc = &global->patch_cost[ ec->patch->seq_no ] ;
@@ -924,14 +865,14 @@
     pc->cost_history[1] = pc->cost_history[0] ;
     pc->cost_history[0] = PATCH_COST( pc ) ;
     pc->cost_estimate   = PATCH_COST_ESTIMATE( pc ) ;
-    
+
     /* Also, update the global cost variable */
     LOCK(global->cost_sum_lock);
     global->cost_sum          += pc->cost_history[0] ;
     global->cost_estimate_sum += pc->cost_estimate ;
     UNLOCK(global->cost_sum_lock);
 #endif
-    
+
 }
 
 
@@ -942,17 +883,14 @@
  *
  ****************************************************************************/
 
-static void gather_rays( elem, process_id )
-  
-  Element *elem ;
-  unsigned process_id;
+static void gather_rays(Element *elem, long process_id)
 {
     Rgb rad_elem ;		/* Radiosity gathered by this elem */
     float ff_v ;		/* Form factor times visibility */
     float bf_r, bf_g, bf_b ;
     Interaction *inter ;
-    
-    
+
+
     /* Return immediately if there is no interaction */
     if( (inter = elem->interactions) == 0 )
         {
@@ -961,14 +899,14 @@
             elem->rad_subtree.b = 0.0 ;
             return ;
         }
-    
-    
+
+
     /* Gather rays of this element
        (do it directly without the driver function, 'Foreach-interaction') */
     rad_elem.r = 0.0 ;
     rad_elem.g = 0.0 ;
     rad_elem.b = 0.0 ;
-    
+
     while( inter )
         {
             /* Be careful !
@@ -977,20 +915,20 @@
             bf_r = ff_v * inter->destination->rad.r ;
             bf_g = ff_v * inter->destination->rad.g ;
             bf_b = ff_v * inter->destination->rad.b ;
-            
+
             rad_elem.r += bf_r ;
             rad_elem.g += bf_g ;
             rad_elem.b += bf_b ;
-            
+
             /* Update pointers */
             inter = inter->next ;
         }
-    
+
     /* Multiply the gathered radiosity by the diffuse color of this element */
     rad_elem.r *= elem->patch->color.r ;
     rad_elem.g *= elem->patch->color.g ;
     rad_elem.b *= elem->patch->color.b ;
-    
+
     /* Store the value at the initial value of 'rad_subtree' */
     elem->rad_subtree = rad_elem ;
 }
@@ -1006,26 +944,23 @@
  *
  ****************************************************************************/
 
-int element_completely_invisible( e1, e2, process_id )
-  
-  Element *e1, *e2 ;		    /* Two elements to be tested */
-  unsigned process_id;
+long element_completely_invisible(Element *e1, Element *e2, long process_id)
 {
-    int cc ;
-    
+    long cc ;
+
     /* Check visibility */
     cc = patch_intersection( &e1->patch->plane_equ,
                             &e2->ev1->p, &e2->ev2->p, &e2->ev3->p, process_id ) ;
     if( NEGATIVE_SIDE(cc) )
         /* If negative or on the plane, then do nothing */
         return( 1 ) ;
-    
+
     cc = patch_intersection( &e2->patch->plane_equ,
                             &e1->ev1->p, &e1->ev2->p, &e1->ev3->p, process_id ) ;
     if( NEGATIVE_SIDE(cc) )
         /* If negative or on the plane, then do nothing */
         return( 1 ) ;
-    
+
     return( 0 ) ;
 }
 
@@ -1038,14 +973,13 @@
  *
  ****************************************************************************/
 
-Element *get_element(process_id)
-  unsigned process_id;
+Element *get_element(long process_id)
 {
     Element *p ;
-    
+
     /* Lock the free list */
     LOCK(global->free_element_lock);
-    
+
     /* Test pointer */
     if( global->free_element == 0 )
         {
@@ -1053,15 +987,15 @@
             UNLOCK(global->free_element_lock);
             exit( 1 ) ;
         }
-    
+
     /* Get an element data structure */
     p = global->free_element ;
     global->free_element = p->center ;
     global->n_free_elements-- ;
-    
+
     /* Unlock the list */
     UNLOCK(global->free_element_lock);
-    
+
     /* Clear pointers just in case.. */
     p->parent             = 0 ;
     p->center             = 0 ;
@@ -1072,7 +1006,7 @@
     p->n_interactions     = 0 ;
     p->vis_undef_inter    = 0 ;
     p->n_vis_undef_inter  = 0 ;
-    
+
     return( p ) ;
 }
 
@@ -1090,17 +1024,14 @@
  *
  ****************************************************************************/
 
-int leaf_element( elem, process_id )
-  
-  Element *elem ;
-  unsigned process_id;
+long leaf_element(Element *elem, long process_id)
 {
-    int leaf ;
-    
+    long leaf ;
+
     LOCK(elem->elem_lock->lock);
     leaf  = _LEAF_ELEMENT(elem) ;
     UNLOCK(elem->elem_lock->lock);
-    
+
     return( leaf ) ;
 }
 
@@ -1113,11 +1044,10 @@
  *
  ****************************************************************************/
 
-void init_elemlist(process_id)
-  unsigned process_id;
+void init_elemlist(long process_id)
 {
-    int i ;
-    
+    long i ;
+
     /* Initialize Element free list */
     for( i = 0 ; i < MAX_ELEMENTS-1 ; i++ )
         {
@@ -1129,7 +1059,7 @@
     global->element_buf[ MAX_ELEMENTS-1 ].center = 0 ;
     global->element_buf[ MAX_ELEMENTS-1 ].elem_lock
         = get_sharedlock( SHARED_LOCK_SEG1, process_id ) ;
-    
+
     global->free_element = global->element_buf ;
     global->n_free_elements = MAX_ELEMENTS ;
     LOCKINIT(global->free_element_lock);
@@ -1143,18 +1073,15 @@
  *
  ****************************************************************************/
 
-void print_element( elem, process_id )
-  
-  Element *elem ;
-  unsigned process_id;
-{
-    printf( "Element (%x)\n", (int)elem ) ;
-    
-    print_point( &elem->ev1->p, process_id ) ;
-    print_point( &elem->ev2->p, process_id ) ;
-    print_point( &elem->ev3->p, process_id ) ;
-    
-    printf( "Radiosity:" ) ;     print_rgb( &elem->rad, process_id ) ;
+void print_element(Element *elem, long process_id)
+{
+    printf( "Element (%ld)\n", (long)elem ) ;
+
+    print_point( &elem->ev1->p ) ;
+    print_point( &elem->ev2->p ) ;
+    print_point( &elem->ev3->p ) ;
+
+    printf( "Radiosity:" ) ;     print_rgb( &elem->rad ) ;
 }
 
 
@@ -1179,18 +1106,13 @@
  *
  ****************************************************************************/
 
-void foreach_interaction_in_element( elem, func, arg1, process_id )
-  
-  Element *elem ;
-  void (*func)() ;
-  int arg1 ;
-  unsigned process_id;
+void foreach_interaction_in_element(Element *elem, void (*func)(), long arg1, long process_id)
 {
     Interaction *inter ;
-    
+
     if( elem == 0 )
         return ;
-    
+
     for( inter = elem->interactions ; inter ; inter = inter->next )
         func( elem, inter, arg1, process_id ) ;
 }
@@ -1208,23 +1130,14 @@
  *
  ****************************************************************************/
 
-static float compute_diff_disc_formfactor() ;
-  static float compute_diff_diff_formfactor() ;
-  
-  
-  void compute_formfactor( e_src, e_dst, inter, process_id )
-  
-  Element *e_src ;		    /* Source of the interaction */
-  Element *e_dst ;		    /* Destination of the interaction */
-  Interaction *inter ;	    /* Interaction data structure */
-  unsigned process_id;
+void compute_formfactor(Element *e_src, Element *e_dst, Interaction *inter, long process_id)
 {
     float ff_c, ff_1, ff_2, ff_3 ;
     float ff_c1, ff_c2, ff_c3, ff_avg ;
     Vertex pc_src, pc_dst ;
     Vertex pc1_src, pc2_src, pc3_src ;
     float ff_min, ff_max, ff_err ;
-    
+
     /* Estimate FF using disk approximation */
     /* (1) Compute FF(diff-disc) from the center of src to the destination */
     four_center_points( &e_src->ev1->p, &e_src->ev2->p, &e_src->ev3->p,
@@ -1246,7 +1159,7 @@
     if( ff_max < ff_c1 ) ff_max = ff_c1 ;
     if( ff_max < ff_c2 ) ff_max = ff_c2 ;
     if( ff_max < ff_c3 ) ff_max = ff_c3 ;
-    
+
     /* (2) Compute FF(diff-disc) from the 3 vertices of the source */
     ff_1 = compute_diff_disc_formfactor( &e_src->ev1->p, e_src,
                                         &pc_dst, e_dst, process_id ) ;
@@ -1254,7 +1167,7 @@
                                         &pc_dst, e_dst, process_id ) ;
     ff_3 = compute_diff_disc_formfactor( &e_src->ev3->p, e_src,
                                         &pc_dst, e_dst, process_id ) ;
-    
+
     /* (3) Find FF min and max */
     ff_min = ff_max = ff_c ;
     if( ff_min > ff_1 ) ff_min = ff_1 ;
@@ -1263,79 +1176,65 @@
     if( ff_max < ff_1 ) ff_max = ff_1 ;
     if( ff_max < ff_2 ) ff_max = ff_2 ;
     if( ff_max < ff_3 ) ff_max = ff_3 ;
-    
+
     /* (4) Clip FF(diff-disc) if it is negative */
     if( ff_avg < 0 )
         ff_avg = 0 ;
     inter->formfactor_out = ff_avg ;
-    
+
     /* (5) Then find maximum difference from the FF at the center */
     ff_err = (ff_max - ff_avg) ;
     if( ff_err < (ff_avg - ff_min) )
         ff_err = ff_avg - ff_min ;
     inter->formfactor_err = ff_err ;
-    
+
     /* (6) Correct visibility if partially visible */
     if( (ff_avg < 0) && (inter->visibility == 0) )
         /* All ray missed the visible portion of the elements.
            Set visibility to a non-zero value manually */
         /** inter->visibility = FF_VISIBILITY_ERROR **/ ;
-    
+
     /* (7) Fill destination */
     inter->destination = e_dst ;
 }
 
 
-static float _diff_disc_formfactor( p, e_src, p_disc, area, normal, process_id )
-  
-  Vertex *p ;
-  Element *e_src ;
-  Vertex *p_disc ;
-  float area ;
-  Vertex *normal ;
-  unsigned process_id;
+static float _diff_disc_formfactor(Vertex *p, Element *e_src, Vertex *p_disc, float area, Vertex *normal, long process_id)
 {
     Vertex vec_sd ;
     float dist_sq ;
     float fnorm ;
     float  cos_s, cos_d, angle_factor ;
-    
+
     vec_sd.x = p_disc->x - p->x ;
     vec_sd.y = p_disc->y - p->y ;
     vec_sd.z = p_disc->z - p->z ;
     dist_sq = vec_sd.x*vec_sd.x + vec_sd.y*vec_sd.y + vec_sd.z*vec_sd.z ;
-    
+
     fnorm = area / ((float)M_PI * dist_sq  + area) ;
-    
+
     /* (2) Now, consider angle to the other patch from the normal. */
     normalize_vector( &vec_sd, &vec_sd ) ;
     cos_s =  inner_product( &vec_sd, &e_src->patch->plane_equ.n ) ;
     cos_d = -inner_product( &vec_sd, normal ) ;
     angle_factor = cos_s * cos_d ;
-    
+
     /* Return the form factor */
     return( fnorm * angle_factor ) ;
 }
 
 
-static float compute_diff_disc_formfactor( p, e_src, p_disc, e_dst, process_id )
-  
-  Vertex *p ;
-  Element *e_src ;
-  Vertex *p_disc ;
-  Element *e_dst ;
-  unsigned process_id;
+static float compute_diff_disc_formfactor(Vertex *p, Element *e_src, Vertex *p_disc, Element *e_dst, long process_id)
 {
     Vertex p_c, p_c1, p_c2, p_c3 ;
     float quarter_area ;
     float ff_c, ff_c1, ff_c2, ff_c3 ;
-    float ff_dbg ;
-    
+
     four_center_points( &e_dst->ev1->p, &e_dst->ev2->p, &e_dst->ev3->p,
                        &p_c, &p_c1, &p_c2, &p_c3 ) ;
-    
+
     quarter_area = e_dst->area * (float)0.25 ;
-    
+
     ff_c = _diff_disc_formfactor( p, e_src, &p_c,  quarter_area,
                                  &e_dst->patch->plane_equ.n, process_id ) ;
     ff_c1= _diff_disc_formfactor( p, e_src, &p_c1, quarter_area,
@@ -1344,63 +1243,25 @@
                                  &e_dst->patch->plane_equ.n, process_id ) ;
     ff_c3= _diff_disc_formfactor( p, e_src, &p_c3, quarter_area,
                                  &e_dst->patch->plane_equ.n, process_id ) ;
-    
+
     if( ff_c  < 0 ) ff_c  = 0 ;
     if( ff_c1 < 0 ) ff_c1 = 0 ;
     if( ff_c2 < 0 ) ff_c2 = 0 ;
     if( ff_c3 < 0 ) ff_c3 = 0 ;
-    
-    return( ff_c + ff_c1 + ff_c2 + ff_c3 ) ;
-}
-
 
-static float compute_diff_diff_formfactor( p_src, e_src, p_dst, e_dst, process_id )
-  
-  Vertex *p_src ;
-  Element *e_src ;
-  Vertex *p_dst ;
-  Element *e_dst ;
-  unsigned process_id;
-{
-    Vertex vec_sd ;
-    float dist_sq ;
-    float fnorm ;
-    float  cos_s, cos_d, angle_factor ;
-    
-    vec_sd.x = p_dst->x - p_src->x ;
-    vec_sd.y = p_dst->y - p_src->y ;
-    vec_sd.z = p_dst->z - p_src->z ;
-    dist_sq = vec_sd.x*vec_sd.x + vec_sd.y*vec_sd.y + vec_sd.z*vec_sd.z ;
-    if( dist_sq < F_ZERO )
-        return( 0.0 ) ;
-    fnorm = (float)1.0 / ((float)M_PI * dist_sq) ;
-    
-    /* (2) Now, consider angle to the other patch from the normal. */
-    normalize_vector( &vec_sd, &vec_sd ) ;
-    cos_s =  inner_product( &vec_sd, &e_src->patch->plane_equ.n ) ;
-    cos_d = -inner_product( &vec_sd, &e_dst->patch->plane_equ.n ) ;
-    angle_factor = cos_s * cos_d ;
-    
-    /* Return the form factor */
-    return( fnorm * angle_factor ) ;
+    return( ff_c + ff_c1 + ff_c2 + ff_c3 ) ;
 }
 
 
-void compute_interaction( e_src, e_dst, inter, subdiv, process_id )
-  
-  Element *e_src ;		    /* Source of the interaction */
-  Element *e_dst ;		    /* Destination of the interaction */
-  Interaction *inter ;	    /* Interaction data structure */
-  int subdiv ;		    /* Subdivision code */
-  unsigned process_id;
+void compute_interaction(Element *e_src, Element *e_dst, Interaction *inter, long subdiv, long process_id)
 {
     /* (1) Check visibility. */
     if( NO_VISIBILITY_NECESSARY(subdiv) )
         inter->visibility = 1.0 ;
     else
         inter->visibility = VISIBILITY_UNDEF ;
-    
-    
+
+
     /* (2) Compute formfactor */
     compute_formfactor( e_src, e_dst, inter, process_id ) ;
 }
@@ -1419,11 +1280,7 @@
  ****************************************************************************/
 
 
-void insert_interaction( elem, inter, process_id )
-  
-  Element *elem ;		     /* Interacting elements */
-  Interaction *inter ;
-  unsigned process_id;
+void insert_interaction(Element *elem, Interaction *inter, long process_id)
 {
     /* Link from patch 1 to patch 2 */
     LOCK(elem->elem_lock->lock);
@@ -1435,11 +1292,7 @@
 
 
 
-void delete_interaction( elem, prev, inter, process_id )
-  
-  Element *elem ;
-  Interaction *prev, *inter ;
-  unsigned process_id;
+void delete_interaction(Element *elem, Interaction *prev, Interaction *inter, long process_id)
 {
     /* Remove from the list */
     LOCK(elem->elem_lock->lock);
@@ -1449,18 +1302,14 @@
         prev->next = inter->next ;
     elem->n_interactions-- ;
     UNLOCK(elem->elem_lock->lock);
-    
+
     /* Return to the free list */
     free_interaction( inter, process_id ) ;
 }
 
 
 
-void insert_vis_undef_interaction( elem, inter, process_id )
-  
-  Element *elem ;		     /* Interacting elements */
-  Interaction *inter ;
-  unsigned process_id;
+void insert_vis_undef_interaction(Element *elem, Interaction *inter, long process_id)
 {
     /* Link from patch 1 to patch 2 */
     LOCK(elem->elem_lock->lock);
@@ -1470,11 +1319,7 @@
     UNLOCK(elem->elem_lock->lock);
 }
 
-void delete_vis_undef_interaction( elem, prev, inter, process_id )
-  
-  Element *elem ;
-  Interaction *prev, *inter ;
-  unsigned process_id;
+void delete_vis_undef_interaction(Element *elem, Interaction *prev, Interaction *inter, long process_id)
 {
     /* Remove from the list */
     LOCK(elem->elem_lock->lock);
@@ -1496,14 +1341,13 @@
  *
  ****************************************************************************/
 
-Interaction *get_interaction(process_id)
-  unsigned process_id;
+Interaction *get_interaction(long process_id)
 {
     Interaction *p ;
-    
+
     /* Lock the free list */
     LOCK(global->free_interaction_lock);
-    
+
     /* Test pointer */
     if( global->free_interaction == 0 )
         {
@@ -1511,38 +1355,35 @@
             UNLOCK(global->free_interaction_lock);
             exit( 1 ) ;
         }
-    
+
     /* Get an element data structure */
     p = global->free_interaction ;
     global->free_interaction = p->next ;
     global->n_free_interactions-- ;
-    
+
     /* Unlock the list */
     UNLOCK(global->free_interaction_lock);
-    
+
     /* Clear pointers just in case.. */
     p->next   = 0 ;
     p->destination = 0 ;
-    
-    
+
+
     return( p ) ;
 }
 
 
 
-void free_interaction( interaction, process_id )
-  
-  Interaction *interaction ;
-  unsigned process_id;
+void free_interaction(Interaction *interaction, long process_id)
 {
     /* Lock the free list */
     LOCK(global->free_interaction_lock);
-    
+
     /* Get a task data structure */
     interaction->next = global->free_interaction ;
     global->free_interaction = interaction ;
     global->n_free_interactions++ ;
-    
+
     /* Unlock the list */
     UNLOCK(global->free_interaction_lock);
 }
@@ -1556,11 +1397,10 @@
  *
  ****************************************************************************/
 
-void init_interactionlist(process_id)
-  unsigned process_id;
+void init_interactionlist(long process_id)
 {
-    int i ;
-    
+    long i ;
+
     /* Initialize Interaction free list */
     for( i = 0 ; i < MAX_INTERACTIONS-1 ; i++ )
         global->interaction_buf[i].next = &global->interaction_buf[i+1] ;
@@ -1579,17 +1419,14 @@
  *
  ****************************************************************************/
 
-void print_interaction( inter, process_id )
-  
-  Interaction *inter ;
-  unsigned process_id;
-{
-    
-    printf( "Interaction(0x%x)\n", (int)inter ) ;
-    printf( "    Dest: Elem (0x%x) of patch %d\n",
-           (int)inter->destination, inter->destination->patch->seq_no ) ;
+void print_interaction(Interaction *inter, long process_id)
+{
+
+    printf( "Interaction(0x%ld)\n", (long)inter ) ;
+    printf( "    Dest: Elem (0x%ld) of patch %ld\n",
+           (long)inter->destination, inter->destination->patch->seq_no ) ;
     printf( "    Fout: %f    Vis: %f\n",
            inter->formfactor_out,
            inter->visibility ) ;
-    printf( "    Next: 0x%x\n", inter->next ) ;
+    printf( "    Next: 0x%p\n", inter->next ) ;
 }
diff -Naur splash2/codes/apps/radiosity/glibdumb/glib.c splash2-modified/codes/apps/radiosity/glibdumb/glib.c
--- splash2/codes/apps/radiosity/glibdumb/glib.c	1994-10-18 01:12:13.000000000 -0400
+++ splash2-modified/codes/apps/radiosity/glibdumb/glib.c	2007-03-13 18:20:07.000000000 -0400
@@ -15,17 +15,6 @@
 *************************************************************************/
 
 #include "glib.h"
-/*** Data structure used in radiosity algorithm ***/
-
-typedef struct {
-      float x, y, z ;
-} Point ;
-
-typedef struct {
-      float r, g, b ;
-} Rgb ;
-
-
 
 /**************************************************
 *
@@ -41,10 +30,7 @@
 *
 ***************************************************/
 
-void g_init( ac, av )
-
-    int ac ;
-    char *av[] ;
+void g_init(int ac, char *av[])
 {
 }
 
@@ -56,13 +42,7 @@
 *
 ***************************************************/
 
-void g_start( mouse_func, n_sliders, slider_def, n_choices, choice_def )
-
-    void (*mouse_func)() ;
-    int n_sliders ;
-    slider *slider_def ;
-    int n_choices ;
-    choice *choice_def ;
+void g_start(void (*mouse_func)(), long n_sliders, slider *slider_def, long n_choices, choice *choice_def)
 {
 }
 
@@ -73,9 +53,7 @@
 *
 ***************************************************/
 
-void g_color( color )
-
-    int color ;
+void g_color(long color)
 {
 }
 
@@ -92,9 +70,7 @@
 *
 ***************************************************/
 
-void g_line( p1, p2 )
-
-    Point *p1, *p2 ;
+void g_line(Vertex *p1, Vertex *p2)
 {
 }
 
@@ -105,10 +81,7 @@
 *
 ***************************************************/
 
-void g_polygon( n, p_list )
-
-    int n ;
-    Point *p_list ;
+void g_polygon(long n, Vertex *p_list)
 {
 }
 
@@ -119,11 +92,7 @@
 *
 ***************************************************/
 
-void g_spolygon( n, p_list, c_list )
-
-    int n ;
-    Point *p_list ;
-    Rgb   *c_list ;
+void g_spolygon(long n, Vertex *p_list, Rgb *c_list)
 {
 }
 
@@ -146,9 +115,7 @@
 *
 ***************************************************/
 
-void g_setup_view( rot_x, rot_y, dist, zoom )
-
-    float rot_x, rot_y, dist, zoom ;
+void g_setup_view(float rot_x, float rot_y, float dist, float zoom)
 {
 }
 
@@ -160,9 +127,7 @@
 *
 ***************************************************/
 
-void g_get_screen_size( u, v )
-
-    int *u, *v ;
+void g_get_screen_size(long *u, long *v)
 {
 }
 
@@ -177,4 +142,3 @@
 {
 }
 
-
diff -Naur splash2/codes/apps/radiosity/glibdumb/glib.h splash2-modified/codes/apps/radiosity/glibdumb/glib.h
--- splash2/codes/apps/radiosity/glibdumb/glib.h	1994-10-18 01:12:13.000000000 -0400
+++ splash2-modified/codes/apps/radiosity/glibdumb/glib.h	2007-03-13 18:20:33.000000000 -0400
@@ -14,6 +14,7 @@
 #ifndef _GLIB_H
 #define _GLIB_H
 
+#include "../structs.H"
 
 /****************************************
 *
@@ -41,9 +42,9 @@
 
 typedef struct {
     char *name;
-    int min, max;
-    int init_value;
-    int ticks;
+    long min, max;
+    long init_value;
+    long ticks;
     void (*callback)();
 } slider;
 
@@ -53,28 +54,26 @@
 typedef struct {
     char *name;
     char *possibilities[MAX_POSSIBILITIES];
-    int init_value;
+    long init_value;
     void (*callback)();
 } choice;
 
-
 /****************************************
 *
 *    Library function type definition
 *
 *****************************************/
 
-extern void g_init() ;
-extern void g_start() ;
-extern void g_color(), g_rgb() ;
-extern void g_line() ;
-extern void g_polygon() ;
-extern void g_spolygon() ;
-extern void g_clear() ;
-extern void g_setup_view() ;
-extern void g_get_screen_size() ;
-extern void g_flush() ;
-
-
+void g_init(int ac, char *av[]);
+void g_start(void (*mouse_func)(void), long n_sliders, slider *slider_def, long n_choices, choice *choice_def);
+void g_color(long color);
+void g_rgb(Rgb color);
+void g_line(Vertex *p1, Vertex *p2);
+void g_polygon(long n, Vertex *p_list);
+void g_spolygon(long n, Vertex *p_list, Rgb *c_list);
+void g_clear(void);
+void g_setup_view(float rot_x, float rot_y, float dist, float zoom);
+void g_get_screen_size(long *u, long *v);
+void g_flush(void);
 
 #endif
diff -Naur splash2/codes/apps/radiosity/glibdumb/Makefile splash2-modified/codes/apps/radiosity/glibdumb/Makefile
--- splash2/codes/apps/radiosity/glibdumb/Makefile	1994-10-18 01:12:13.000000000 -0400
+++ splash2-modified/codes/apps/radiosity/glibdumb/Makefile	2007-03-18 02:36:42.000000000 -0400
@@ -1,30 +1,15 @@
-# 
+#
 #  Device independent graphics package GLIB.
 #  NULL graphic device version
 #
 
 OBJS   = glib.o
 TARGET = glib.a
-PANELDIR = /usr/local/panel
-CCOPT  = -O 
-INCLUDE_DIRS = -I${PANELDIR}/include
-CFLAGS = $(CCOPT) $(CCDEFS) $(INCLUDE_DIRS)
-LDFLAGS =  -L${PANELDIR}/lib -lgl -lpanel -lm
 
+include ../../../Makefile.config
 
-all:	$(TARGET)
+$(TARGET): $(OBJS)
+	ar crv $(TARGET) $(OBJS)
 
 clean:
-	touch dummy~
-	rm -f core *.o *~ $(TARGET)
-
-lint:
-	lint $(INCLUDE_DIRS) $(SRCS)
-
-
-$(TARGET): glib.o
-	ar crv $(TARGET) glib.o
-
-testlib:
-	cc -O -o testlib testlib.c $(TARGET) $(LDFLAGS)
-
+	rm -rf $(OBJS) $(TARGET)
diff -Naur splash2/codes/apps/radiosity/glibps/glibps.c splash2-modified/codes/apps/radiosity/glibps/glibps.c
--- splash2/codes/apps/radiosity/glibps/glibps.c	1994-10-18 01:12:13.000000000 -0400
+++ splash2-modified/codes/apps/radiosity/glibps/glibps.c	2007-03-13 18:27:52.000000000 -0400
@@ -10,8 +10,7 @@
 
 #include <stdio.h>
 #include <math.h>
-
-
+#include "pslib.h"
 
 #define SCREEN_WIDTH   (6.0*72)
 #define SCREEN_HEIGHT  (4.8*72)
@@ -27,29 +26,6 @@
 #define DEFAULT_BACK_PLANE_Z  (-4000.0)
 #define DEFAULT_PRP_Z         (10000.0)    /* Projection point Z coord. */
 
-
-/*** Data structure used in radiosity algorithm ***/
-
-typedef struct {
-      float x, y, z ;
-} Point ;
-
-typedef struct {
-      float r, g, b ;
-} Rgb ;
-
-
-typedef struct
-{
-      float v[4] ;                   /* x, y, z, and w */
-} Vertex ;
-
-typedef struct
-{
-      float m[4][4] ;                /* m[row][column], row vector assumed */
-} Matrix ;
-
-
 /**************************************************
 *
 *    Globals
@@ -57,8 +33,8 @@
 ***************************************************/
 
 static Matrix  trans_mtx ;		/* WC -> DC */
-static Vertex  prp ;			/* Projection point */
-static Vertex  active_prp ;		/* Projection point in effect (WC) */
+static Vertex2  prp ;			/* Projection point */
+static Vertex2  active_prp ;		/* Projection point in effect (WC) */
 static float   view_rotx, view_roty ;	/* Viewing */
 static float   view_zoom ;
 
@@ -69,12 +45,18 @@
 
 static FILE *ps_fd ;
 
-
-
-void gset_unit_matrix(), gconcatenate_matrix(), gscale_matrix() ;
-void gtranslate_matrix(), grotate_x_matrix(), grotate_y_matrix() ;
-void grotate_z_matrix(), gtransform(), ginverse_matrix() ;
-
+static void setup_transformation(void);
+static void init_transformation(void);
+static void gset_unit_matrix(Matrix *mtx);
+static void gconcatenate_matrix(long precat, Matrix *m1, Matrix *m2);
+static void gscale_matrix(long precat, Matrix *m1, float sx, float sy, float sz);
+static void gtranslate_matrix(long precat, Matrix *m1, float tx, float ty, float tz);
+static void grotate_x_matrix(long precat, Matrix *m1, float rot);
+static void grotate_y_matrix(long precat, Matrix *m1, float rot);
+static void gtransform(Vertex2 *v1, Vertex2 *v2, Matrix *mtx);
+static void ginverse_matrix(Matrix *m1, Matrix *m2);
+static double det(Matrix *m);
+static double cdet(Matrix *m, long r0, long r1, long r2, long c0, long c1, long c2);
 
 /************************************************************************
 *
@@ -85,12 +67,8 @@
 
 
 
-int ps_open( file )
-    char *file ;
+long ps_open(char *file)
 {
-      void init_transformation() ;
-      void setup_transformation() ;
-
       if( (ps_fd = fopen( file, "w" )) == 0 )
       {
 	    perror( file ) ;
@@ -111,6 +89,7 @@
       /* Initialize transformation */
       init_transformation() ;
       setup_transformation() ;
+      return(0);
 }
 
 
@@ -136,9 +115,7 @@
 *
 ***************************************************/
 
-void ps_linewidth( w )
-   
-    float w ;
+void ps_linewidth(float w)
 {
       if( ps_fd == 0 )
 	    return ;
@@ -154,11 +131,9 @@
 *
 ***************************************************/
 
-void ps_line( p1, p2 )
-
-    Point *p1, *p2 ;
+void ps_line(Vertex *p1, Vertex *p2)
 {
-      Vertex  v1, v2 ;
+      Vertex2  v1, v2 ;
       float x1, y1, x2, y2 ;
 
       if( ps_fd == 0 )
@@ -185,14 +160,11 @@
 *
 ***************************************************/
 
-void ps_polygonedge( n, p_list )
-
-    int n ;
-    Point *p_list ;
+void ps_polygonedge(long n, Vertex *p_list)
 {
       float dcx, dcy ;
-      Vertex v ;
-      int i ;
+      Vertex2 v ;
+      long i ;
 
       if( ps_fd == 0 )
 	    return ;
@@ -203,8 +175,8 @@
       v.v[2] = p_list[0].z ;
       v.v[3] = 1.0 ;
       gtransform( &v, &v, &trans_mtx ) ;
-      dcx = v.v[0] / v.v[3] ; 
-      dcy = v.v[1] / v.v[3] ; 
+      dcx = v.v[0] / v.v[3] ;
+      dcy = v.v[1] / v.v[3] ;
       fprintf( ps_fd, "newpath\n%f %f moveto\n", dcx, dcy ) ;
 
       for( i = 1 ; i < n ; i++ )
@@ -215,12 +187,12 @@
 	    v.v[2] = p_list[i].z ;
 	    v.v[3] = 1.0 ;
 	    gtransform( &v, &v, &trans_mtx ) ;
-	    dcx = v.v[0] / v.v[3] ; 
-	    dcy = v.v[1] / v.v[3] ; 
+	    dcx = v.v[0] / v.v[3] ;
+	    dcy = v.v[1] / v.v[3] ;
 
 	    fprintf( ps_fd, "%f %f lineto\n", dcx, dcy ) ;
       }
-      
+
       fprintf( ps_fd, "closepath stroke\n" ) ;
 }
 
@@ -231,14 +203,11 @@
 *
 ***************************************************/
 
-void ps_polygon( n, p_list )
-
-    int n ;
-    Point *p_list ;
+void ps_polygon(long n, Vertex *p_list)
 {
       float dcx, dcy ;
-      Vertex v ;
-      int i ;
+      Vertex2 v ;
+      long i ;
 
       if( ps_fd == 0 )
 	    return ;
@@ -249,8 +218,8 @@
       v.v[2] = p_list[0].z ;
       v.v[3] = 1.0 ;
       gtransform( &v, &v, &trans_mtx ) ;
-      dcx = v.v[0] / v.v[3] ; 
-      dcy = v.v[1] / v.v[3] ; 
+      dcx = v.v[0] / v.v[3] ;
+      dcy = v.v[1] / v.v[3] ;
       fprintf( ps_fd, "newpath\n%f %f moveto\n", dcx, dcy ) ;
 
       for( i = 1 ; i < n ; i++ )
@@ -261,12 +230,12 @@
 	    v.v[2] = p_list[i].z ;
 	    v.v[3] = 1.0 ;
 	    gtransform( &v, &v, &trans_mtx ) ;
-	    dcx = v.v[0] / v.v[3] ; 
-	    dcy = v.v[1] / v.v[3] ; 
+	    dcx = v.v[0] / v.v[3] ;
+	    dcy = v.v[1] / v.v[3] ;
 
 	    fprintf( ps_fd, "%f %f lineto\n", dcx, dcy ) ;
       }
-      
+
       fprintf( ps_fd, "closepath fill\n" ) ;
 }
 
@@ -277,15 +246,11 @@
 *
 ***************************************************/
 
-void ps_spolygon( n, p_list, c_list )
-
-    int n ;
-    Point *p_list ;
-    Rgb   *c_list ;
+void ps_spolygon(long n, Vertex *p_list, Rgb *c_list)
 {
       float dcx, dcy ;
-      Vertex v ;
-      int i ;
+      Vertex2 v ;
+      long i ;
       float gray_scale ;
 
       if( ps_fd == 0 )
@@ -297,8 +262,8 @@
       v.v[2] = p_list[0].z ;
       v.v[3] = 1.0 ;
       gtransform( &v, &v, &trans_mtx ) ;
-      dcx = v.v[0] / v.v[3] ; 
-      dcy = v.v[1] / v.v[3] ; 
+      dcx = v.v[0] / v.v[3] ;
+      dcy = v.v[1] / v.v[3] ;
       fprintf( ps_fd, "newpath\n%f %f moveto\n", dcx, dcy ) ;
 
       for( i = 1 ; i < n ; i++ )
@@ -309,18 +274,18 @@
 	    v.v[2] = p_list[i].z ;
 	    v.v[3] = 1.0 ;
 	    gtransform( &v, &v, &trans_mtx ) ;
-	    dcx = v.v[0] / v.v[3] ; 
-	    dcy = v.v[1] / v.v[3] ; 
+	    dcx = v.v[0] / v.v[3] ;
+	    dcy = v.v[1] / v.v[3] ;
 
 	    fprintf( ps_fd, "%f %f lineto\n", dcx, dcy ) ;
       }
-      
+
       gray_scale = c_list[0].g ;
       if( gray_scale > 1.0 )
 	    gray_scale = 1.0 ;
       else if( gray_scale < 0.0 )
 	    gray_scale = 0.0 ;
-		  
+
       fprintf( ps_fd, "closepath %f setgray fill\n", gray_scale ) ;
 }
 
@@ -343,12 +308,8 @@
 *
 ***************************************************/
 
-void ps_setup_view( rot_x, rot_y, dist, zoom )
-
-    float rot_x, rot_y, dist, zoom ;
+void ps_setup_view(float rot_x, float rot_y, float dist, float zoom)
 {
-      void setup_transformation() ;
-
       prp.v[0] = 0.0 ;
       prp.v[1] = 0.0 ;
       prp.v[2] = (float)dist ;
@@ -371,9 +332,8 @@
 static void setup_transformation()
 {
       float cf_z, cb_z ;
-      int light ;
       Matrix pmat ;
-      
+
       /* Set to unit matrix */
       gset_unit_matrix( &trans_mtx ) ;
 
@@ -427,16 +387,16 @@
       prp.v[1] = 0.0 ;
       prp.v[2] = DEFAULT_PRP_Z ;
       prp.v[3] = 0.0 ;
- 
+
       /* Viewing */
       view_rotx = view_roty = 0.0 ;
       view_zoom = 1.0 ;
-  
+
       /* Initialize view volume boundary */
       clip_right =  DEFAULT_WINDOW_WIDTH / 2.0 ;
       clip_left  = -DEFAULT_WINDOW_WIDTH / 2.0 ;
       clip_top   =  DEFAULT_WINDOW_HEIGHT / 2.0 ;
-      clip_bottom= -DEFAULT_WINDOW_HEIGHT / 2.0 ; 
+      clip_bottom= -DEFAULT_WINDOW_HEIGHT / 2.0 ;
       clip_front =  DEFAULT_FRONT_PLANE_Z ;
       clip_back  =  DEFAULT_BACK_PLANE_Z ;
 }
@@ -444,46 +404,14 @@
 
 /********************************************
 *
-*    set_matrix()
-*
-*********************************************/
-
-static void  gset_matrix( mtx, m11, m12, m13, m14,  m21, m22, m23, m24,
-		       m31, m32, m33, m34,  m41, m42, m43, m44 )
-
-    Matrix *mtx ;
-    float m11, m12, m13, m14 ;
-    float m21, m22, m23, m24 ;
-    float m31, m32, m33, m34 ;
-    float m41, m42, m43, m44 ;
-{
-      mtx->m[0][0] = m11 ; mtx->m[0][1] = m12 ;
-      mtx->m[0][2] = m13 ; mtx->m[0][3] = m14 ;
-
-      mtx->m[1][0] = m21 ; mtx->m[1][1] = m22 ;
-      mtx->m[1][2] = m23 ; mtx->m[1][3] = m24 ;
-
-      mtx->m[2][0] = m31 ; mtx->m[2][1] = m32 ;
-      mtx->m[2][2] = m33 ; mtx->m[2][3] = m34 ;
-
-      mtx->m[3][0] = m41 ; mtx->m[3][1] = m42 ;
-      mtx->m[3][2] = m43 ; mtx->m[3][3] = m44 ;
-}    
-
-
-
-/********************************************
-*
 *    set_unit_matrix()
 *
 *********************************************/
 
-static void  gset_unit_matrix( mtx )
-
-    Matrix *mtx ;
+static void  gset_unit_matrix(Matrix *mtx)
 {
-      int  row, col ;
-      
+      long  row, col ;
+
       /* Clear the matrix */
       for( row = 0 ; row < 4 ; row++ )
 	    for( col = 0 ; col < 4 ; col++ )
@@ -492,7 +420,7 @@
       /* Set 1.0s along diagonal line */
       for( row = 0 ; row < 4 ; row++ )
 	    mtx->m[row][row] = 1.0 ;
-}    
+}
 
 
 
@@ -506,15 +434,12 @@
 *
 *********************************************/
 
-static void  gconcatenate_matrix( precat, m1, m2 )
-
-    int precat ;
-    Matrix *m1, *m2 ;
+static void  gconcatenate_matrix(long precat, Matrix *m1, Matrix *m2)
 {
-      int  row, col, scan ;
+      long  row, col, scan ;
       Matrix *dest ;
       Matrix temp ;
-      
+
 
       /* Swap pointer according to the concatenation mode */
       dest = m1 ;
@@ -523,10 +448,10 @@
 	    m1 = m2 ;
 	    m2 = dest ;
       }
-      
+
       /* concatenate it */
       for( row = 0 ; row < 4 ; row++ )
-	    for( col = 0 ; col < 4 ; col++ ) 
+	    for( col = 0 ; col < 4 ; col++ )
 	    {
 		  temp.m[row][col] = 0.0 ;
 		  for( scan = 0 ; scan < 4 ; scan++ )
@@ -547,14 +472,10 @@
 *
 *********************************************/
 
-static void  gscale_matrix( precat, m1, sx, sy, sz )
-
-    int precat ;
-    Matrix *m1 ;
-    float sx, sy, sz ;
+static void  gscale_matrix(long precat, Matrix *m1, float sx, float sy, float sz)
 {
       Matrix smat ;
-      
+
       /* Initialize to unit matrix */
       gset_unit_matrix( &smat ) ;
 
@@ -578,14 +499,10 @@
 *
 *********************************************/
 
-static void  gtranslate_matrix( precat, m1, tx, ty, tz )
-
-    int precat ;
-    Matrix *m1 ;
-    float tx, ty, tz ;
+static void  gtranslate_matrix(long precat, Matrix *m1, float tx, float ty, float tz)
 {
       Matrix tmat ;
-      
+
       /* Initialize to unit matrix */
       gset_unit_matrix( &tmat ) ;
 
@@ -611,15 +528,11 @@
 *
 *********************************************/
 
-static void  grotate_x_matrix( precat, m1, rot )
-
-    int precat ;
-    Matrix *m1 ;
-    float rot ;
+static void  grotate_x_matrix(long precat, Matrix *m1, float rot)
 {
       Matrix rmat ;
       float s_val, c_val ;
-      
+
       /* Initialize to unit matrix */
       gset_unit_matrix( &rmat ) ;
 
@@ -638,15 +551,11 @@
 
 
 
-static void  grotate_y_matrix( precat, m1, rot )
-
-    int precat ;
-    Matrix *m1 ;
-    float rot ;
+static void  grotate_y_matrix(long precat, Matrix *m1, float rot)
 {
       Matrix rmat ;
       float s_val, c_val ;
-      
+
       /* Initialize to unit matrix */
       gset_unit_matrix( &rmat ) ;
 
@@ -665,31 +574,6 @@
 
 
 
-static void  grotate_z_matrix( precat, m1, rot )
-
-    int precat ;
-    Matrix *m1 ;
-    float rot ;
-{
-      Matrix rmat ;
-      float s_val, c_val ;
-      
-      /* Initialize to unit matrix */
-      gset_unit_matrix( &rmat ) ;
-
-      /* Set scale values */
-      s_val = sin( rot * M_PI / 180.0 ) ;
-      c_val = cos( rot * M_PI / 180.0 ) ;
-      rmat.m[0][0] = c_val ;
-      rmat.m[0][1] = s_val ;
-      rmat.m[1][0] = -s_val ;
-      rmat.m[1][1] = c_val ;
-
-      /* concatenate */
-      gconcatenate_matrix( precat, m1, &rmat ) ;
-}
-
-
 /********************************************
 *
 *    transform()
@@ -698,10 +582,7 @@
 *
 *********************************************/
 
-static void gtransform( v1, v2, mtx )
-
-    Vertex *v1, *v2 ;
-    Matrix *mtx ;
+static void gtransform(Vertex2 *v1, Vertex2 *v2, Matrix *mtx)
 {
       float x, y, z, w ;
 
@@ -741,13 +622,10 @@
 *********************************************/
 
 
-static void ginverse_matrix( m1, m2 )
-
-    Matrix *m1, *m2 ;
+static void ginverse_matrix(Matrix *m1, Matrix *m2)
 {
       double detval ;
-      double det(), cdet() ;
-      
+
       /* det(m2) */
       detval = det( m2 ) ;
 
@@ -775,13 +653,10 @@
 
 
 
-static double det( m )
-
-    Matrix *m ;
+static double det(Matrix *m)
 {
       double det_sum ;
-      double cdet() ;
-      
+
       /* Expand with respect to column 4 */
       det_sum = 0.0 ;
       if( m->m[0][3] != 0.0 )
@@ -797,10 +672,7 @@
 }
 
 
-static double cdet( m, r0, r1, r2, c0, c1, c2 )
-
-    Matrix *m ;
-    int r0, r1, r2, c0, c1, c2 ;
+static double cdet(Matrix *m, long r0, long r1, long r2, long c0, long c1, long c2)
 {
         double temp ;
 
@@ -814,72 +686,3 @@
 
         return( temp ) ;
 }
-
-
-
-/********************************************
-*
-*    normalize_vector()
-*
-*          v1 <- normalized( v2 )
-*
-*          W component is ignored.
-*
-*********************************************/
-
-
-static void gnormalize_vector( v1, v2 )
-
-    Vertex *v1, *v2 ;
-{
-      float t0, t1, t2 ;
-
-      t0 = v2->v[0] * v2->v[0] ;
-       t1 = v2->v[1] * v2->v[1] ;
-        t2 = v2->v[2] * v2->v[2] ;
-
-      t0 = 1.0 / sqrt( t0 + t1 + t2 ) ;
-
-      v1->v[0] = v2->v[0] * t0 ;
-       v1->v[1] = v2->v[1] * t0 ;
-        v1->v[2] = v2->v[2] * t0 ;
-}
-
-
-/********************************************
-*
-*    inner_product()
-*
-*          (v1.v2) <- inner_product( v1, v2 )
-*
-*          W component is ignored.
-*
-*********************************************/
-
-static float ginner_product( v1, v2 )
-
-    Vertex *v1, *v2 ;
-{
-      float ip ;
-      
-      ip  = v1->v[0] * v2->v[0] ;
-      ip += v1->v[1] * v2->v[1] ;
-      ip += v1->v[2] * v2->v[2] ;
-
-      return( ip ) ;
-}
-
-
-/********************************************
-*
-*    print_vector()
-*
-*
-*********************************************/
-
-static void gprint_vector( v )
-
-    Vertex *v ;
-{
-      printf( "(%g,%g,%g,%g)\n", v->v[0], v->v[1], v->v[2], v->v[3] ) ;
-}
diff -Naur splash2/codes/apps/radiosity/glibps/Makefile splash2-modified/codes/apps/radiosity/glibps/Makefile
--- splash2/codes/apps/radiosity/glibps/Makefile	1994-10-18 01:12:13.000000000 -0400
+++ splash2-modified/codes/apps/radiosity/glibps/Makefile	2007-03-13 17:58:48.000000000 -0400
@@ -1,33 +1,16 @@
-# 
+#
 #  CS348C  Radiosity     Device independent graphics package GLIB.
 #                        SUN/Xview version makefile
 #
 #
 
-OBJS   = glibps.o
 TARGET = glibps.a
+OBJS   = glibps.o
 
-INCLUDE_DIRS =
-
-CCOPT  = -O -float
-CFLAGS = $(CCOPT) $(CCDEFS) $(INCLUDE_DIRS)
-LDFLAGS =  -lm
-
-
-all:	$(TARGET)
-
-clean:
-	touch dummy~
-	rm -f core *.o *~ $(TARGET)
-
-lint:
-	lint $(INCLUDE_DIRS) $(SRCS)
-
+include ../../../Makefile.config
 
 $(TARGET): $(OBJS)
 	ar crv $(TARGET) $(OBJS)
-#	ranlib $(TARGET)
-
-testlib:
-	cc -g -o testlib testlib.c $(TARGET) $(LDFLAGS)
 
+clean:
+	rm -rf *.o $(TARGET)
diff -Naur splash2/codes/apps/radiosity/glibps/pslib.h splash2-modified/codes/apps/radiosity/glibps/pslib.h
--- splash2/codes/apps/radiosity/glibps/pslib.h	1994-10-18 01:12:13.000000000 -0400
+++ splash2-modified/codes/apps/radiosity/glibps/pslib.h	2007-03-13 18:28:23.000000000 -0400
@@ -14,6 +14,19 @@
 #ifndef _PSLIB_H
 #define _PSLIB_H
 
+#include "../structs.H"
+
+#define M_PI           3.14159265358979323846
+
+typedef struct
+{
+	float v[4] ;                   /* x, y, z, and w */
+} Vertex2;
+
+typedef struct
+{
+	float m[4][4] ;                /* m[row][column], row vector assumed */
+} Matrix;
 
 /****************************************
 *
@@ -21,16 +34,14 @@
 *
 *****************************************/
 
-extern void ps_open() ;
-extern void ps_close() ;
-extern void ps_linewidth() ;
-extern void ps_line() ;
-extern void ps_polygonedge() ;
-extern void ps_polygon() ;
-extern void ps_spolygon() ;
-extern void ps_clear() ;
-extern void ps_setup_view() ;
-
-
+long ps_open(char *file);
+void ps_close(void);
+void ps_linewidth(float w);
+void ps_line(Vertex *p1, Vertex *p2);
+void ps_polygonedge(long n, Vertex *p_list);
+void ps_polygon(long n, Vertex *p_list);
+void ps_spolygon(long n, Vertex *p_list, Rgb *c_list);
+void ps_clear(void);
+void ps_setup_view(float rot_x, float rot_y, float dist, float zoom);
 
 #endif
diff -Naur splash2/codes/apps/radiosity/makefile splash2-modified/codes/apps/radiosity/makefile
--- splash2/codes/apps/radiosity/makefile	1994-10-18 01:16:54.000000000 -0400
+++ splash2-modified/codes/apps/radiosity/makefile	1969-12-31 19:00:00.000000000 -0500
@@ -1,59 +0,0 @@
-TARGET = RADIOSITY
-
-OBJS = rad_main.o patchman.o elemman.o taskman.o modelman.o smallobj.o\
-         display.o visible.o rad_tools.o room_model.o 
-HHS = model.H parallel.H patch.H radiosity.H task.H
-HS = model.h parallel.h patch.h radiosity.h task.h
-
-GLIBDIR = ./glibdumb
-GLIB    = glib.a
-# look me up in man sigfpe
-LIBFPE = -lfpe
-
-MACROS = ../../null_macros/c.m4.null
-CCOPTS = -I -float -I/usr/include $(CFLAGS)
-LDFLAGS = -O2 -lmpc -lm 
-CFLAGS = $(CINCLUDE) -O2 -cckr -Olimit 2500
-CINCLUDE = -I$(GLIBDIR) -I./glibps -I/usr/local/include
-
-LOADLIBES =  $(GLIBDIR)/$(GLIB) glibps/glibps.a
-
-CC = cc
-
-x = *
-
-$(TARGET): $(OBJS) 
-	$(CC) $(CFLAGS) $(LDFLAGS) $(OBJS) $(LOADLIBES) -o $(TARGET)
-
-.SUFFIXES:
-.SUFFIXES:	.o .c .C .h .H
-
-.H.h:	
-	m4 -Ulen -Uindex ${MACROS} $*.H > $*.h
-
-.C.c:	
-	m4 -Ulen -Uindex $(MACROS) $*.C > $*.c
-
-.c.o:	
-	cc -c $(CFLAGS) $*.c
-
-.C.o:	
-	m4 -Ulen -Uindex $(MACROS) $*.C > $*.c
-	cc -c $(CFLAGS) $*.c
-
-$(HS): $(HHS)
-
-radiosity.h: patch.h model.h parallel.h task.h
-rad_main.c: rad_main.C $(HS)
-patchman.c: patchman.C $(HS)
-elemman.c: elemman.C $(HS)
-taskman.c: taskman.C $(HS)
-modelman.c: modelman.C $(HS)
-smallobj.c: smallobj.C $(HS)
-display.c: display.C $(HS)
-visible.c: visible.C $(HS)
-rad_tools.c: rad_tools.C $(HS)
-room_model.c: room_model.C $(HS)
-
-clean:
-	$(RM) $(CS) $(ASMS) $(SS) $(OBJS) $(HS)
diff -Naur splash2/codes/apps/radiosity/Makefile splash2-modified/codes/apps/radiosity/Makefile
--- splash2/codes/apps/radiosity/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ splash2-modified/codes/apps/radiosity/Makefile	2007-03-16 23:52:51.000000000 -0400
@@ -0,0 +1,31 @@
+TARGET = RADIOSITY
+
+OBJS = display.o elemman.o modelman.o patchman.o rad_main.o rad_tools.o room_model.o smallobj.o taskman.o visible.o
+HHS = model.H parallel.H patch.H radiosity.H task.H
+HS = model.h parallel.h patch.h radiosity.h task.h
+
+include ../../Makefile.config
+
+CFLAGS := $(CFLAGS) -I./glibdumb -I./glibps
+
+#CCOPTS = -I -float -I/usr/include $(CFLAGS)
+#LDFLAGS = -lm -lpthread
+#CFLAGS = $(CINCLUDE) -O4 -march=i686 -mcpu=i686 -malign-double -funroll-loops -finline-functions -fomit-frame-pointer -D_REENTRANT
+#CINCLUDE = -I$(GLIBDIR) -I./glibps
+
+LOADLIBES = glibdumb/glib.a glibps/glibps.a
+
+$(TARGET): $(OBJS)
+	$(CC) $(OBJS) $(CFLAGS) $(LOADLIBES) -o $(TARGET) $(LDFLAGS)
+
+radiosity.h: patch.h model.h parallel.h task.h
+rad_main.c: rad_main.C $(HS)
+patchman.c: patchman.C $(HS)
+elemman.c: elemman.C $(HS)
+taskman.c: taskman.C $(HS)
+modelman.c: modelman.C $(HS)
+smallobj.c: smallobj.C $(HS)
+display.c: display.C $(HS)
+visible.c: visible.C $(HS)
+rad_tools.c: rad_tools.C $(HS)
+room_model.c: room_model.C $(HS)
diff -Naur splash2/codes/apps/radiosity/model.H splash2-modified/codes/apps/radiosity/model.H
--- splash2/codes/apps/radiosity/model.H	1994-10-18 13:37:23.000000000 -0400
+++ splash2-modified/codes/apps/radiosity/model.H	2007-03-17 13:11:28.000000000 -0400
@@ -59,15 +59,17 @@
 
 
 typedef struct {
-    int type ;
+    long type ;
     Model model ;
 } ModelDataBase ;
 
+/*
+ * modelman.C
+ */
+void init_modeling_tasks(long process_id);
+void process_model(Model *model, long type, long process_id);
 
-
-extern int model_selector ;
-extern void process_model() ;
-extern void init_modeling_tasks() ;
+extern long model_selector ;
 
 #endif
 
diff -Naur splash2/codes/apps/radiosity/modelman.C splash2-modified/codes/apps/radiosity/modelman.C
--- splash2/codes/apps/radiosity/modelman.C	1994-10-18 13:37:23.000000000 -0400
+++ splash2-modified/codes/apps/radiosity/modelman.C	2007-03-17 14:08:29.000000000 -0400
@@ -30,6 +30,10 @@
 
 include(radiosity.h)
 
+static void init_test_model_tasks(long process_id);
+static void init_room_model_tasks(ModelDataBase *model, long process_id);
+static void process_triangle(Model_Triangle *model, long process_id);
+static void process_rectangle(Model_Rectangle *model, long process_id);
 
 /***************************************************************************
  *
@@ -112,20 +116,17 @@
  *
  ****************************************************************************/
 
-int model_selector = MODEL_TEST_DATA ;
-static void init_test_model_tasks(), init_room_model_tasks() ;
-  static void init_largeroom_model_tasks() ;
-  
-  void init_modeling_tasks(process_id)
-  unsigned process_id;
+long model_selector = MODEL_TEST_DATA ;
+
+void init_modeling_tasks(long process_id)
 {
-    
+
     extern ModelDataBase room_model[] ;
     extern ModelDataBase largeroom_model[] ;
-    
-    if( ! check_task_counter(process_id) )
+
+    if( ! check_task_counter() )
         return ;
-    
+
     switch( model_selector )
         {
         case MODEL_TEST_DATA:
@@ -143,8 +144,7 @@
 
 
 
-static void init_test_model_tasks(process_id)
-  unsigned process_id;
+static void init_test_model_tasks(long process_id)
 {
     create_modeling_task( (Model*)&Floor, MODEL_RECTANGLE, process_id ) ;
     create_modeling_task( (Model*)&Ceiling, MODEL_RECTANGLE, process_id ) ;
@@ -157,75 +157,22 @@
 
 
 
-static void init_room_model_tasks( model, process_id )
-  
-  ModelDataBase *model ;
-  unsigned process_id;
+static void init_room_model_tasks(ModelDataBase *model, long process_id)
 {
     ModelDataBase *pm ;
-    
+
     for( pm = model ; pm->type != MODEL_NULL ; pm++ )
         create_modeling_task( &pm->model, pm->type, process_id ) ;
 }
 
 
-#define MODEL_START (140)
-
-static void init_room_model_tasks2( model, process_id )
-  
-  ModelDataBase *model ;
-  unsigned process_id;
-{
-    ModelDataBase *pm ;
-    int cnt = 0 ;
-    pm = &model[ cnt ] ;
-    
-    for( ; pm->type != MODEL_NULL ; pm++ )
-        {
-            if( pm->model.emittance.g == 0 )
-                pm->model.emittance.g = 0.5 + (cnt & 3)*0.1  ;
-            else
-                pm->model.emittance.g = 1.0 ;
-            if( cnt >= MODEL_START )
-                create_modeling_task( &pm->model, pm->type, process_id ) ;
-            if( pm->type == MODEL_TRIANGLE )
-                {
-                    pm++ ;
-                    if( pm->model.emittance.g == 0 )
-                        pm->model.emittance.g = 0.5 + (cnt & 3)*0.1  ;
-                    else
-                        pm->model.emittance.g = 1.0 ;
-                    if( cnt >= MODEL_START )
-                        create_modeling_task( &pm->model, pm->type, process_id ) ;
-                }
-            
-            if( cnt >= MODEL_START )
-                {
-                    printf( "Polygon %d\n", cnt ) ;
-                    g_clear() ;
-                    display_scene( 1, 1, 0, 0, process_id ) ;
-                    while( getchar() != '\n' ) ;
-                }
-            cnt++ ;
-        }
-}
-
-
-
 /***************************************************************************
  *
  *    process_model()
  *
  ****************************************************************************/
 
-static void process_triangle(), process_rectangle() ;
-  
-  
-  void process_model( model, type, process_id )
-  
-  Model *model ;
-  int    type ;
-  unsigned process_id;
+void process_model(Model *model, long  type, long process_id)
 {
     switch( type )
         {
@@ -236,7 +183,7 @@
             process_rectangle( (Model_Rectangle *)model, process_id ) ;
             break ;
         default:
-            fprintf( stderr, "Panic:process_model:Illegal type %d\n", type ) ;
+            fprintf( stderr, "Panic:process_model:Illegal type %ld\n", type ) ;
         }
 }
 
@@ -248,22 +195,19 @@
  *
  ****************************************************************************/
 
-static void process_triangle( model, process_id )
-  
-  Model_Triangle *model ;
-  unsigned process_id;
+static void process_triangle(Model_Triangle *model, long process_id)
 {
     Patch *p ;
     float length ;
-    
+
     /* Create a patch */
     p = get_patch(process_id) ;
-    
+
     /* (1) Set the Vertecies */
     p->p1  = model->p1 ;
     p->p2  = model->p2 ;
     p->p3  = model->p3 ;
-    
+
     /* (2) Create the Edges */
     p->ev1 = create_elemvertex( &p->p1, process_id ) ;
     p->ev2 = create_elemvertex( &p->p2, process_id ) ;
@@ -271,15 +215,15 @@
     p->e12 = create_edge( p->ev1, p->ev2, process_id ) ;
     p->e23 = create_edge( p->ev2, p->ev3, process_id ) ;
     p->e31 = create_edge( p->ev3, p->ev1, process_id ) ;
-    
+
     /* (3) Other patch properties */
     length = comp_plane_equ( &p->plane_equ,
                             &model->p1, &model->p2, &model->p3, process_id ) ;
     p->area      = length * (float)0.5 ;
     p->color     = model->color ;
     p->emittance = model->emittance ;
-    
-    
+
+
     /* Create a BSP insertion task */
     create_bsp_task( p, global->bsp_root, process_id ) ;
 }
@@ -291,22 +235,19 @@
  *
  ****************************************************************************/
 
-static void process_rectangle( model, process_id )
-  
-  Model_Rectangle *model ;
-  unsigned process_id;
+static void process_rectangle(Model_Rectangle *model, long process_id)
 {
     Patch *p, *q ;
     float length ;
-    
+
     /* Create a patch (P1-P2-P3) */
     p = get_patch(process_id) ;
-    
+
     /* (1) Set the Vertecies */
     p->p1  = model->p1 ;
     p->p2  = model->p2 ;
     p->p3  = model->p3 ;
-    
+
     /* (2) Create the Edges */
     p->ev1 = create_elemvertex( &p->p1, process_id ) ;
     p->ev2 = create_elemvertex( &p->p2, process_id ) ;
@@ -314,25 +255,25 @@
     p->e12 = create_edge( p->ev1, p->ev2, process_id ) ;
     p->e23 = create_edge( p->ev2, p->ev3, process_id ) ;
     p->e31 = create_edge( p->ev3, p->ev1, process_id ) ;
-    
+
     /* (3) Other patch properties */
     length = comp_plane_equ( &p->plane_equ,
                             &model->p1, &model->p2, &model->p3, process_id ) ;
     p->area     = length * (float)0.5 ;
     p->color    = model->color ;
     p->emittance= model->emittance ;
-    
-    
+
+
     /* Create a patch (P(2+3-1)-P3-P2) */
     q = get_patch(process_id) ;
-    
+
     /* (1) Set the Vertices */
     q->p1.x     = model->p2.x + model->p3.x - model->p1.x ;
     q->p1.y     = model->p2.y + model->p3.y - model->p1.y ;
     q->p1.z     = model->p2.z + model->p3.z - model->p1.z ;
     q->p2       = model->p3 ;
     q->p3       = model->p2 ;
-    
+
     /* (2) Create the Edges */
     q->ev1 = create_elemvertex( &q->p1, process_id ) ;
     q->ev2 = p->ev3 ;
@@ -340,13 +281,13 @@
     q->e12 = create_edge( q->ev1, q->ev2, process_id ) ;
     q->e23 = p->e23 ;
     q->e31 = create_edge( q->ev3, q->ev1, process_id ) ;
-    
+
     /* (3) Other patch properties */
     q->plane_equ= p->plane_equ ;
     q->area     = p->area ;
     q->color    = p->color ;
     q->emittance= p->emittance ;
-    
+
     /* Create BSP insertion tasks */
     create_bsp_task( p, global->bsp_root, process_id ) ;
     create_bsp_task( q, global->bsp_root, process_id ) ;
diff -Naur splash2/codes/apps/radiosity/parallel.H splash2-modified/codes/apps/radiosity/parallel.H
--- splash2/codes/apps/radiosity/parallel.H	1994-10-18 13:37:23.000000000 -0400
+++ splash2-modified/codes/apps/radiosity/parallel.H	2007-03-16 23:29:40.000000000 -0400
@@ -32,7 +32,7 @@
 *    Some machines provide only a limited number of lock variables. This
 *    data structure allows sharing of these lock variables.
 *    The shared locks are divided into 2 segments so that different types of
-*    objects are given different locks. 
+*    objects are given different locks.
 *
 ****************************************************************************/
 
@@ -47,9 +47,6 @@
 #define SHARED_LOCK_SEG1 (1)
 #define SHARED_LOCK_SEGANY (2)
 
-extern void init_sharedlock() ;
-extern Shared_Lock *get_sharedlock() ;
-
 /****************************************************************************
 *
 *    Memory Consistency Model of the machine
diff -Naur splash2/codes/apps/radiosity/patch.H splash2-modified/codes/apps/radiosity/patch.H
--- splash2/codes/apps/radiosity/patch.H	1994-10-18 13:37:23.000000000 -0400
+++ splash2-modified/codes/apps/radiosity/patch.H	2007-03-17 13:54:55.000000000 -0400
@@ -18,6 +18,7 @@
 #ifndef _PATCH_H
 #define _PATCH_H
 
+#include "structs.H"
 
 /************************************************************************
 *
@@ -26,7 +27,7 @@
 *************************************************************************/
 
 #define F_COPLANAR  (5.0e-2)     /* H(P) < F_COPLANAR then P is on the plane */
-#define N_VISIBILITY_TEST_RAYS  (10)	/* number of "random", "magic" rays fired 
+#define N_VISIBILITY_TEST_RAYS  (10)	/* number of "random", "magic" rays fired
 between patches to test visibility */
 
 #define FF_GEOMETRY_ERROR (1.0)		/* FF relative error due to Fdf approx
@@ -73,10 +74,6 @@
 covers about 95% of the total cache hits, so using
 more doesn't help too much. */
 
-extern float visibility() ;
-extern void  compute_visibility_values() ;
-extern void  visibility_task() ;
-
 /************************************************************************
 *
 *     Refinement Advice
@@ -98,43 +95,6 @@
 
 /************************************************************************
 *
-*     Vertex    -  3D coordinate
-*
-*************************************************************************/
-
-typedef struct {
-    float x, y, z ;
-} Vertex ;
-
-
-extern float vector_length() ;
-extern float distance() ;
-extern float normalize_vector() ;
-extern float inner_product() ;
-extern void cross_product() ;
-extern float plane_normal() ;
-extern void center_point(), four_center_points() ;
-extern void print_point() ;
-
-
-/************************************************************************
-*
-*     Color (R,G,B)
-*
-*************************************************************************/
-
-typedef struct {
-    float r, g, b ;
-} Rgb ;
-
-
-
-extern void print_rgb() ;
-
-
-
-/************************************************************************
-*
 *     Element Vertex
 *
 *     ElementVertex represents a vertex of an element. A vertex structure
@@ -152,10 +112,6 @@
 
 
 #define N_ELEMVERTEX_ALLOCATE (16)
-extern ElemVertex *get_elemvertex() ;
-extern ElemVertex *create_elemvertex() ; /* Constructor */
-extern void         init_elemvertex() ;	  /* Initialize free buffer */
-
 
 /************************************************************************
 *
@@ -179,11 +135,6 @@
 
 
 #define N_EDGE_ALLOCATE (16)
-extern Edge *get_edge() ;
-extern Edge *create_edge() ;		  /* Constructor */
-extern void subdivide_edge() ;
-extern void init_edge() ;		  /* Initialize free buffer */
-extern void foreach_leaf_edge() ;
 
 #define _LEAF_EDGE(e) ((e)->ea == 0)
 #define EDGE_REVERSE(e,a,b) ((e)->pa == (b))
@@ -208,21 +159,14 @@
 } PlaneEqu ;
 
 
-extern float plane_equ() ;
-extern float comp_plane_equ() ;
-extern int point_intersection() ;
-extern int patch_intersection() ;
-extern void print_plane_equ() ;
-
-
 /************************************************************************
 *
 *     Patch (also a node of the BSP tree)
 *
-*     The Patch represents a triangular patch (input polygon) of the given 
-*     geometric model (i.e., room scene). The Patch contains 'per-patch' 
-*     information such as the plane equation, area, and color. The Patch also 
-*     serves as a node of the BSP tree which is used to test patch-patch 
+*     The Patch represents a triangular patch (input polygon) of the given
+*     geometric model (i.e., room scene). The Patch contains 'per-patch'
+*     information such as the plane equation, area, and color. The Patch also
+*     serves as a node of the BSP tree which is used to test patch-patch
 *     visibility. The Patch points to the root level of the element quad-tree.
 *     Geometrically speaking, the Patch and the root represent the same
 *     triangle.
@@ -249,31 +193,23 @@
     Rgb      color ;			  /* Diffuse color of the patch */
     /*       (reflectance) */
     Rgb      emittance ;	          /* Radiant emmitence */
-    
+
     struct _patch  *bsp_positive ;	  /* BSP tree H(x,y,z) >= 0 */
     struct _patch  *bsp_negative ;	  /*          H(x,y,z) <  0 */
     struct _patch  *bsp_parent ;        /* BSP backpointer to the parent*/
-    
+
     struct _element *el_root ;	  /* Root of the element tree */
-    int      seq_no ;		          /* Patch sequence number */
+    long      seq_no ;		          /* Patch sequence number */
 } Patch ;
 
-extern void foreach_patch_in_bsp(), foreach_depth_sorted_patch() ;
-extern void define_patch() ;
-extern void refine_newpatch() ;
-extern Patch *get_patch() ;
-extern void init_patchlist() ;
-extern void print_patch() ;
-extern void print_bsp_tree() ;
-
 
 typedef struct {
     Patch    *patch ;
     Shared_Lock *cost_lock ;		  /* Cost variable lock */
-    int      n_bsp_node ;	          /* Number of BSP nodes visited */
-    int      n_total_inter ;	          /* Total number of interactions */
-    int      cost_estimate ;            /* Cost estimate */
-    int      cost_history[11] ;	  /* Cost history */
+    long      n_bsp_node ;	          /* Number of BSP nodes visited */
+    long      n_total_inter ;	          /* Total number of interactions */
+    long      cost_estimate ;            /* Cost estimate */
+    long      cost_history[11] ;	  /* Cost history */
 } Patch_Cost ;
 
 /* Patch cost:
@@ -290,7 +226,7 @@
 *
 *     Element
 *
-*     The Element represents each node of the quad-tree generated by the 
+*     The Element represents each node of the quad-tree generated by the
 *     hierarchical subdivision. The Element structure consists of:
 *      - pointers to maintain the tree structure
 *      - a linear list of interacting elements
@@ -307,40 +243,31 @@
 typedef struct _element {
     Shared_Lock *elem_lock ;	          /* Element lock variable (seg 1) */
     Patch *patch ;			  /* Original patch of the element */
-    
+
     struct _element *parent ;		  /* Quad tree (parent)          */
     struct _element *center ;		  /*           (center triangle) */
     struct _element *top ;		  /*           (top)             */
     struct _element *left ;		  /*           (left)            */
     struct _element *right ;		  /*           (right)           */
-    
+
     struct _interact *interactions ;	  /* Top of light interaction list */
-    int  n_interactions ;		  /* Total # of interactions */
+    long  n_interactions ;		  /* Total # of interactions */
     struct _interact *vis_undef_inter ; /* Top of visibility undef list */
-    int  n_vis_undef_inter ;		  /* # of interactions whose visibility
+    long  n_vis_undef_inter ;		  /* # of interactions whose visibility
     is not yet calculated */
     Rgb  rad ;			  /* Radiosity of this element
     (new guess of B) */
     Rgb  rad_in ;			  /* Sum of anscestor's radiosity */
     Rgb  rad_subtree ;		  /* Area weighted sum of subtree's
     radiosity (includes this elem) */
-    int  join_counter ;		  /* # of unfinished subprocesses */
-    
+    long  join_counter ;		  /* # of unfinished subprocesses */
+
     ElemVertex *ev1, *ev2, *ev3 ;	  /* Vertices of the element */
     Edge       *e12, *e23, *e31 ;	  /* Edges of the element */
     float area ;		          /* Area of the element */
 } Element ;
 
 
-extern void foreach_element_in_patch(), foreach_leaf_element_in_patch() ;
-extern void ff_refine_elements() ;
-extern void subdivide_element() ;
-extern int  element_completely_invisible() ;
-extern void process_rays() ;
-extern Element *get_element() ;
-extern void init_elemlist() ;
-extern void print_element() ;
-
 #define _LEAF_ELEMENT(e) ((e)->center == 0)
 
 #if MEM_CONSISTENCY_PROCESSOR
@@ -348,7 +275,7 @@
 #endif
 
 #if (MEM_CONSISTENCY_RELEASE || MEM_CONSISTENCY_WEAK)
-extern int leaf_element() ;
+extern long leaf_element() ;
 #define LEAF_ELEMENT(e) (leaf_element((e)))
 #endif
 
@@ -369,13 +296,21 @@
 } Interaction ;
 
 
-extern void foreach_interaction_in_element() ;
-extern void compute_interaction(), compute_formfactor() ;
-extern void insert_interaction(), delete_interaction() ;
-extern void insert_vis_undef_interaction(), delete_vis_undef_interaction() ;
-extern void init_interactionlist() ;
-extern Interaction *get_interaction() ;
-extern void free_interaction() ;
-extern void print_interaction() ;
+void foreach_patch_in_bsp(void (*func)(), long arg1, long process_id);
+void foreach_depth_sorted_patch(Vertex *sort_vec, void (*func)(), long arg1, long process_id);
+void define_patch(Patch *patch, Patch *root, long process_id);
+void split_patch(Patch *patch, Patch *node, long xing_code, long process_id);
+void attach_element(Patch *patch, long process_id);
+void refine_newpatch(Patch *patch, long newpatch, long process_id);
+Patch *get_patch(long process_id);
+void init_patchlist(long process_id);
+void print_patch(Patch *patch, long process_id);
+void print_bsp_tree(long process_id);
+void _pr_patch(Patch *patch, long dummy, long process_id);
+float plane_equ(PlaneEqu *plane, Vertex *point, long process_id);
+float comp_plane_equ(PlaneEqu *pln, Vertex *p1, Vertex *p2, Vertex *p3, long process_id);
+long point_intersection(PlaneEqu *plane, Vertex *point, long process_id);
+long patch_intersection(PlaneEqu *plane, Vertex *p1, Vertex *p2, Vertex *p3, long process_id);
+void print_plane_equ(PlaneEqu *peq, long process_id);
 
 #endif
diff -Naur splash2/codes/apps/radiosity/patchman.C splash2-modified/codes/apps/radiosity/patchman.C
--- splash2/codes/apps/radiosity/patchman.C	1994-10-18 13:37:23.000000000 -0400
+++ splash2-modified/codes/apps/radiosity/patchman.C	2007-03-17 14:22:08.000000000 -0400
@@ -30,6 +30,10 @@
 
 include(radiosity.h)
 
+static void _foreach_patch(Patch *node, void (*func)(), long arg1, long process_id);
+static void _foreach_d_s_patch(Vertex *svec, Patch *node, void (*func)(), long arg1, long process_id);
+static void split_into_3(Patch *patch, ElemVertex *ev1, ElemVertex *ev2, ElemVertex *ev3, Edge *e12, Edge *e23, Edge *e31, Patch *parent, long process_id);
+static void split_into_2(Patch *patch, ElemVertex *ev1, ElemVertex *ev2, ElemVertex *ev3, Edge *e12, Edge *e23, Edge *e31, Patch *parent, long process_id);
 
 /***************************************************************************
  ****************************************************************************
@@ -48,37 +52,24 @@
  *
  ****************************************************************************/
 
-static void _foreach_patch() ;
-  
-  void foreach_patch_in_bsp( func, arg1, process_id )
-  
-  void (*func)() ;
-  int  arg1 ;
-  unsigned process_id;
+void foreach_patch_in_bsp(void (*func)(), long  arg1, long process_id)
 {
-    void _foreach_patch() ;
-    
     _foreach_patch( global->bsp_root, func, arg1, process_id ) ;
 }
 
 
-static void _foreach_patch( node, func, arg1, process_id )
-  
-  Patch *node ;
-  void (*func)() ;
-  int   arg1 ;
-  unsigned process_id;
+static void _foreach_patch(Patch *node, void (*func)(), long   arg1, long process_id)
 {
     if( node == 0 )
         return ;
-    
+
     /* Process subtree(-) */
     if( node->bsp_negative )
         _foreach_patch( node->bsp_negative, func, arg1, process_id ) ;
-    
+
     /* Apply function to this node */
     func( node, arg1, process_id ) ;
-    
+
     /* Process subtree(+) */
     if( node->bsp_positive )
         _foreach_patch( node->bsp_positive, func, arg1, process_id ) ;
@@ -98,48 +89,33 @@
  *
  ****************************************************************************/
 
-static void _foreach_d_s_patch() ;
-  
-  void foreach_depth_sorted_patch( sort_vec, func, arg1, process_id )
-  
-  Vertex *sort_vec ;
-  void (*func)() ;
-  int  arg1 ;
-  unsigned process_id;
+void foreach_depth_sorted_patch(Vertex *sort_vec, void (*func)(), long  arg1, long process_id)
 {
-    void _foreach_d_s_patch() ;
-    
     _foreach_d_s_patch( sort_vec, global->bsp_root, func, arg1, process_id ) ;
 }
 
 
-static void _foreach_d_s_patch( svec, node, func, arg1, process_id )
-  
-  Vertex *svec ;
-  Patch *node ;
-  void (*func)() ;
-  int   arg1 ;
-  unsigned process_id;
+static void _foreach_d_s_patch(Vertex *svec, Patch *node, void (*func)(), long arg1, long process_id)
 {
     float sign ;
-    
+
     if( node == 0 )
         return ;
-    
+
     /* Compute inner product */
     sign = inner_product( svec, &node->plane_equ.n ) ;
-    
+
     if( sign >= 0.0 )
         {
             /* The vector is approaching from the negative side of the patch */
-            
+
             /* Process subtree(-) */
             if( node->bsp_negative )
                 _foreach_d_s_patch( svec, node->bsp_negative, func, arg1, process_id ) ;
-            
+
             /* Apply function to this node */
             func( node, arg1, process_id ) ;
-            
+
             /* Process subtree(+) */
             if( node->bsp_positive )
                 _foreach_d_s_patch( svec, node->bsp_positive, func, arg1, process_id ) ;
@@ -149,10 +125,10 @@
             /* Process subtree(+) */
             if( node->bsp_positive )
                 _foreach_d_s_patch( svec, node->bsp_positive, func, arg1, process_id ) ;
-            
+
             /* Apply function to this node */
             func( node, arg1, process_id ) ;
-            
+
             /* Process subtree(-) */
             if( node->bsp_negative )
                 _foreach_d_s_patch( svec, node->bsp_negative, func, arg1, process_id ) ;
@@ -170,20 +146,14 @@
  *
  ****************************************************************************/
 
-void define_patch( patch, root, process_id )
-  
-  Patch *patch ;
-  Patch *root ;
-  unsigned process_id;
+void define_patch(Patch *patch, Patch *root, long process_id)
 {
     Patch *parent = root ;
-    int xing_code ;
-    void split_patch() ;
-    void attach_element() ;
-    
+    long xing_code ;
+
     /* Lock the BSP tree */
     LOCK(global->bsp_tree_lock);
-    
+
     /* If this is the first patch, link directly */
     if( parent == 0 )
         {
@@ -196,7 +166,7 @@
                     patch->bsp_parent   = 0 ;
                     attach_element( patch, process_id ) ;
                     UNLOCK(global->bsp_tree_lock);
-                    
+
                     return ;
                 }
             else
@@ -204,14 +174,14 @@
                    created */
                 parent = global->bsp_root ;
         }
-    
+
     /* Traverse the BSP tree and get to the leaf node */
     while( 1 )
         {
             /* Check the sign */
             xing_code = patch_intersection( &parent->plane_equ, &patch->p1,
                                            &patch->p2, &patch->p3, process_id ) ;
-            
+
             /* Traverse down the tree according to the sign */
             if( POSITIVE_SIDE( xing_code ) )
                 {
@@ -222,8 +192,8 @@
                             patch->bsp_parent = parent ;
                             attach_element( patch, process_id ) ;
                             UNLOCK(global->bsp_tree_lock);
-                            
-                            foreach_patch_in_bsp( refine_newpatch, (int)patch, process_id ) ;
+
+                            foreach_patch_in_bsp( refine_newpatch, (long)patch, process_id ) ;
                             return ;
                         }
                     else
@@ -239,8 +209,8 @@
                             patch->bsp_parent = parent ;
                             attach_element( patch, process_id ) ;
                             UNLOCK(global->bsp_tree_lock);
-                            
-                            foreach_patch_in_bsp( refine_newpatch, (int)patch, process_id ) ;
+
+                            foreach_patch_in_bsp( refine_newpatch, (long)patch, process_id ) ;
                             return ;
                         }
                     else
@@ -275,22 +245,15 @@
  *
  ****************************************************************************/
 
-void split_into_3(), split_into_2() ;
-  
-  void split_patch( patch, node, xing_code, process_id )
-  
-  Patch *patch ;
-  Patch *node ;
-  int xing_code ;
-  unsigned process_id;
-{
-    int   c1, c2, c3 ;
-    
-    
+void split_patch(Patch *patch, Patch *node, long xing_code, long process_id)
+{
+    long   c1, c2, c3 ;
+
+
     c1 = P1_CODE( xing_code ) ;
     c2 = P2_CODE( xing_code ) ;
     c3 = P3_CODE( xing_code ) ;
-    
+
     /* Classify intersection type */
     if( c1 == c2 )
         /* P3 is on the oposite side */
@@ -320,13 +283,7 @@
 
 
 
-static void split_into_3( patch, ev1, ev2, ev3, e12, e23, e31, parent, process_id )
-  
-  Patch *patch ;
-  ElemVertex *ev1, *ev2, *ev3 ;
-  Edge  *e12, *e23, *e31 ;
-  Patch *parent ;
-  unsigned process_id;
+static void split_into_3(Patch *patch, ElemVertex *ev1, ElemVertex *ev2, ElemVertex *ev3, Edge *e12, Edge *e23, Edge *e31, Patch *parent, long process_id)
 {
     ElemVertex *ev_a ;	   /* Intersection of P1-P2 & the patch */
     ElemVertex *ev_b ;	   /* Intersection of P1-P3 & the patch */
@@ -334,155 +291,149 @@
     float u2, u3 ;
     Patch *new ;
     Edge  *e_ab, *e_3a ;
-    int   rev_e12, rev_e31 ;
-    
-    
+    long   rev_e12, rev_e31 ;
+
+
     /* Compute intersection in terms of parametarized distance from P1 */
     h1 = plane_equ( &parent->plane_equ, &ev1->p, process_id ) ;
     h2 = plane_equ( &parent->plane_equ, &ev2->p, process_id ) ;
     h3 = plane_equ( &parent->plane_equ, &ev3->p, process_id ) ;
-    
+
     /* NOTE: Length of P1-P2 and P1-P3 are at least 2*F_COPLANAR.
        So, no check is necessary before division */
     u2 = h1 / (h1 - h2) ;
-    if( rev_e12 = EDGE_REVERSE( e12, ev1, ev2 ) )
+    if( (rev_e12 = EDGE_REVERSE( e12, ev1, ev2 )) )
         subdivide_edge( e12, u2, process_id ) ;
     else
         subdivide_edge( e12, (float)1.0 - u2, process_id ) ;
     ev_a = e12->ea->pb ;
-    
+
     u3 = h1 / (h1 - h3) ;
-    if( rev_e31 = EDGE_REVERSE( e31, ev3, ev1 ) )
+    if( (rev_e31 = EDGE_REVERSE( e31, ev3, ev1 )) )
         subdivide_edge( e31, (float)1.0 - u3, process_id ) ;
     else
         subdivide_edge( e31, u3, process_id ) ;
     ev_b = e31->ea->pb ;
-    
+
     /* Now insert patches in the tree */
-    
+
     /* (1) Put P1-Pa-Pb */
     new = get_patch(process_id) ;
     new->p1        = ev1->p ;
     new->p2        = ev_a->p ;
     new->p3        = ev_b->p ;
-    
+
     new->ev1       = ev1 ;
     new->ev2       = e12->ea->pb ;
     new->ev3       = e31->ea->pb ;
-    
+
     new->e12       = (!rev_e12)? e12->ea : e12->eb ;
     new->e23       = e_ab = create_edge(ev_a, ev_b, process_id ) ;
     new->e31       = (!rev_e31)? e31->eb : e31->ea ;
-    
+
     new->plane_equ = patch->plane_equ ;
     new->area      = u2 * u3 * patch->area ;
     new->color     = patch->color ;
     new->emittance = patch->emittance ;
     define_patch( new, parent, process_id ) ;
-    
+
     /* (2) Put Pa-P2-P3 */
     new = get_patch(process_id) ;
     new->p1        = ev_a->p ;
     new->p2        = ev2->p ;
     new->p3        = ev3->p ;
-    
+
     new->ev1       = ev_a ;
     new->ev2       = ev2 ;
     new->ev3       = ev3 ;
-    
+
     new->e12       = (!rev_e12)? e12->eb : e12->ea ;
     new->e23       = e23 ;
     new->e31       = e_3a = create_edge( ev3, ev_a, process_id ) ;
-    
+
     new->plane_equ = patch->plane_equ ;
     new->area      = (1.0 - u2) * patch->area ;
     new->color     = patch->color ;
     new->emittance = patch->emittance ;
     define_patch( new, parent, process_id ) ;
-    
+
     /* (3) Put Pa-P3-Pb. Reuse the original patch */
     patch->p1      = ev_a->p ;
     patch->p2      = ev3->p ;
     patch->p3      = ev_b->p ;
-    
+
     patch->ev1     = ev_a ;
     patch->ev2     = ev3 ;
     patch->ev3     = ev_b ;
-    
+
     patch->e12     = e_3a ;
     patch->e23     = (!rev_e31)? e31->ea : e31->eb ;
     patch->e31     = e_ab ;
-    
+
     patch->area    = u2 * (1.0 - u3) * patch->area ;
     define_patch( patch, parent, process_id ) ;
 }
 
 
-static void split_into_2( patch, ev1, ev2, ev3, e12, e23, e31, parent, process_id )
-  
-  Patch *patch ;
-  ElemVertex *ev1, *ev2, *ev3 ;
-  Edge  *e12, *e23, *e31 ;
-  Patch *parent ;
-  unsigned process_id;
+static void split_into_2(Patch *patch, ElemVertex *ev1, ElemVertex *ev2, ElemVertex *ev3, Edge *e12, Edge *e23, Edge *e31, Patch *parent, long process_id)
 {
     ElemVertex *ev_a ;
     Edge *e_a1 ;
     float h2, h3 ;
     float u2 ;
     Patch *new ;
-    int  rev_e23 ;
-    
+    long  rev_e23 ;
+
     /* Compute intersection in terms of parameterized distance from P2 */
     h2 = plane_equ( &parent->plane_equ, &ev2->p, process_id ) ;
     h3 = plane_equ( &parent->plane_equ, &ev3->p, process_id ) ;
-    
+
     /* NOTE: Length of P2-P3 is at least 2*F_COPLANAR.
        So, no check is necessary before division */
     u2 = h2 / (h2 - h3) ;
-    if( rev_e23 = EDGE_REVERSE( e23, ev2, ev3 ) )
+    if( (rev_e23 = EDGE_REVERSE( e23, ev2, ev3 )) )
         subdivide_edge( e23, u2, process_id ) ;
     else
         subdivide_edge( e23, (float)1.0 - u2, process_id ) ;
     ev_a = e23->ea->pb ;
-    
-    
+
+
     /* Now put patches in the tree */
-    
+
     /* (1) Put P1-P2-Pa */
     new = get_patch(process_id) ;
-    
+
     new->p1        = ev1->p ;
     new->p2        = ev2->p ;
     new->p3        = ev_a->p ;
-    
+
     new->ev1       = ev1 ;
     new->ev2       = ev2 ;
     new->ev3       = ev_a ;
-    
+
     new->e12       = e12 ;
     new->e23       = (!rev_e23)? e23->ea : e23->eb ;
     new->e31       = e_a1 = create_edge( ev_a, ev1, process_id ) ;
-    
+
     new->plane_equ = patch->plane_equ ;
     new->area      = u2 * patch->area ;
     new->color     = patch->color ;
     new->emittance = patch->emittance ;
     define_patch( new, parent, process_id ) ;
-    
+
     /* (2) Put P1-Pa-P3.  Reuse the original patch */
     patch->p1      = ev1->p ;
     patch->p2      = ev_a->p ;
     patch->p3      = ev3->p ;
-    
+
     patch->ev1     = ev1 ;
     patch->ev2     = ev_a ;
     patch->ev3     = ev3 ;
-    
+
     patch->e12     = e_a1 ;
     patch->e23     = (!rev_e23)? e23->eb : e23->ea ;
     patch->e31     = e31 ;
-    
+
     patch->area    = (1.0 - u2) * patch->area ;
     define_patch( patch, parent, process_id ) ;
 }
@@ -498,27 +449,24 @@
  *
  ****************************************************************************/
 
-void attach_element( patch, process_id )
-  
-  Patch *patch ;
-  unsigned process_id;
+void attach_element(Patch *patch, long process_id)
 {
     Element *pelem ;
-    
+
     /* Create and link an element to the patch */
     pelem = get_element(process_id) ;
     patch->el_root = pelem ;
-    
+
     /* Initialization of the element */
     pelem->patch = patch ;
     pelem->ev1   = patch->ev1 ;
     pelem->ev2   = patch->ev2 ;
     pelem->ev3   = patch->ev3 ;
-    
+
     pelem->e12   = patch->e12 ;
     pelem->e23   = patch->e23 ;
     pelem->e31   = patch->e31 ;
-    
+
     pelem->area  = patch->area ;
     pelem->rad   = patch->emittance ;
 }
@@ -534,33 +482,29 @@
  ****************************************************************************/
 
 
-void refine_newpatch( patch, newpatch, process_id )
-  
-  Patch *patch ;
-  int   newpatch ;
-  unsigned process_id;
+void refine_newpatch(Patch *patch, long newpatch, long process_id)
 {
-    int cc ;
+    long cc ;
     Patch *new_patch = (Patch *)newpatch ;
-    
+
     /* Check sequence number */
     if( patch->seq_no >= new_patch->seq_no )
         /* Racing condition due to multiprocessing */
         return ;
-    
+
     /* Check visibility */
     cc = patch_intersection( &patch->plane_equ,
                             &new_patch->p1, &new_patch->p2, &new_patch->p3, process_id ) ;
     if( NEGATIVE_SIDE(cc) )
         /* If negative or on the plane, then do nothing */
         return ;
-    
+
     cc = patch_intersection( &new_patch->plane_equ,
                             &patch->p1, &patch->p2, &patch->p3, process_id ) ;
     if( NEGATIVE_SIDE(cc) )
         /* If negative or on the plane, then do nothing */
         return ;
-    
+
     /* Create a new task or do it by itself */
     create_ff_refine_task( patch->el_root, new_patch->el_root, 0, process_id ) ;
 }
@@ -574,14 +518,13 @@
  *
  ****************************************************************************/
 
-Patch *get_patch(process_id)
-  unsigned process_id;
+Patch *get_patch(long process_id)
 {
     Patch *p ;
-    
+
     /* LOCK the free list */
     LOCK(global->free_patch_lock);
-    
+
     /* Test pointer */
     if( global->free_patch == 0 )
         {
@@ -589,22 +532,22 @@
             UNLOCK(global->free_patch_lock);
             exit( 1 ) ;
         }
-    
+
     /* Get a patch data structure */
     p = global->free_patch ;
     global->free_patch = p->bsp_positive ;
     global->n_total_patches++ ;
     global->n_free_patches-- ;
-    
+
     /* Unlock the list */
     UNLOCK(global->free_patch_lock);
-    
+
     /* Clear pointers just in case.. */
     p->el_root = 0 ;
     p->bsp_positive = 0 ;
     p->bsp_negative = 0 ;
     p->bsp_parent   = 0 ;
-    
+
     return( p ) ;
 }
 
@@ -618,11 +561,10 @@
  *
  ****************************************************************************/
 
-void init_patchlist(process_id)
-  unsigned process_id;
+void init_patchlist(long process_id)
 {
-    int i ;
-    
+    long i ;
+
     /* Initialize Patch free list */
     for( i = 0 ; i < MAX_PATCHES-1 ; i++ )
         {
@@ -631,12 +573,12 @@
         }
     global->patch_buf[ MAX_PATCHES-1 ].bsp_positive = 0 ;
     global->patch_buf[ MAX_PATCHES-1 ].seq_no = MAX_PATCHES - 1 ;
-    
+
     global->free_patch = global->patch_buf ;
     global->n_total_patches = 0 ;
     global->n_free_patches  = MAX_PATCHES ;
     LOCKINIT(global->free_patch_lock) ;
-    
+
 #if PATCH_ASSIGNMENT == PATCH_ASSIGNMENT_COSTBASED
     /* Initialize Patch_Cost structure */
     for( i = 0 ; i < MAX_PATCHES ; i++ )
@@ -664,15 +606,12 @@
  *
  ****************************************************************************/
 
-void print_patch( patch, process_id )
-  
-  Patch *patch ;
-  unsigned process_id;
-{
-    printf( "Patch (%x)\n", (int)patch ) ;
-    print_point( &patch->p1, process_id ) ;
-    print_point( &patch->p2, process_id ) ;
-    print_point( &patch->p3, process_id ) ;
+void print_patch(Patch *patch, long process_id)
+{
+    printf( "Patch (%ld)\n", (long)patch ) ;
+    print_point( &patch->p1 ) ;
+    print_point( &patch->p2 ) ;
+    print_point( &patch->p3 ) ;
     print_plane_equ( &patch->plane_equ, process_id ) ;
     printf( "\tArea %f\n", patch->area ) ;
 }
@@ -687,20 +626,14 @@
  *
  ****************************************************************************/
 
-void print_bsp_tree(process_id)
-  unsigned process_id;
+void print_bsp_tree(long process_id)
 {
-    void _pr_patch() ;
-    
     printf( "**** BSP TREE ***\n" ) ;
     foreach_patch_in_bsp( _pr_patch, 0, process_id ) ;
     printf( "\n\n" ) ;
 }
 
-void _pr_patch( patch, dummy, process_id )
-  Patch *patch ;
-  int dummy ;
-  unsigned process_id;
+void _pr_patch(Patch *patch, long dummy, long process_id)
 {
     print_patch( patch, process_id ) ;
 }
@@ -722,16 +655,13 @@
  *
  ****************************************************************************/
 
-float plane_equ( plane, point, process_id )
-  PlaneEqu *plane ;
-  Vertex *point ;
-  unsigned process_id;
+float plane_equ(PlaneEqu *plane, Vertex *point, long process_id)
 {
     float h ;
     h = plane->c + point->x * plane->n.x
         + point->y * plane->n.y
             + point->z * plane->n.z ;
-    
+
     return( h ) ;
 }
 
@@ -743,20 +673,16 @@
  *
  ****************************************************************************/
 
-float comp_plane_equ( pln, p1, p2, p3, process_id )
-  
-  PlaneEqu *pln ;
-  Vertex    *p1, *p2, *p3 ;
-  unsigned process_id;
+float comp_plane_equ(PlaneEqu *pln, Vertex *p1, Vertex *p2, Vertex *p3, long process_id)
 {
     float length ;
-    
+
     /* Compute normal vector */
     length = plane_normal( &pln->n, p1, p2, p3 ) ;
-    
+
     /* Calculate constant factor */
     pln->c = -inner_product( &pln->n, p1 ) ;
-    
+
     return( length ) ;
 }
 
@@ -778,38 +704,30 @@
  *
  ****************************************************************************/
 
-int point_intersection( plane, point, process_id )
-  
-  PlaneEqu *plane ;
-  Vertex *point ;
-  unsigned process_id;
+long point_intersection(PlaneEqu *plane, Vertex *point, long process_id)
 {
     float h ;
-    int result_code = 0 ;
-    
+    long result_code = 0 ;
+
     /* Compare H(x,y,z) against allowance */
     if( (h = plane_equ( plane, point, process_id )) < -F_COPLANAR )
         result_code |= POINT_NEGATIVE_SIDE ;
     if( h > F_COPLANAR )
         result_code |= POINT_POSITIVE_SIDE ;
-    
+
     return( result_code ) ;
 }
 
 
 
-int patch_intersection( plane, p1, p2, p3, process_id )
-  
-  PlaneEqu *plane ;
-  Vertex *p1, *p2, *p3 ;
-  unsigned process_id;
+long patch_intersection(PlaneEqu *plane, Vertex *p1, Vertex *p2, Vertex *p3, long process_id)
 {
-    int c1, c2, c3 ;
-    
+    long c1, c2, c3 ;
+
     c1 = point_intersection( plane, p1, process_id ) ;
     c2 = point_intersection( plane, p2, process_id ) ;
     c3 = point_intersection( plane, p3, process_id ) ;
-    
+
     return( (c3 << 4) | (c2 << 2) | c1 ) ;
 }
 
@@ -822,10 +740,7 @@
  *
  ****************************************************************************/
 
-void print_plane_equ( peq, process_id )
-  
-  PlaneEqu *peq ;
-  unsigned process_id;
+void print_plane_equ(PlaneEqu *peq, long process_id)
 {
     printf( "\tPLN: %.3f x + %.3f y + %.3f z + %.3f\n",
            peq->n.x, peq->n.y, peq->n.z, peq->c ) ;
diff -Naur splash2/codes/apps/radiosity/radiosity.H splash2-modified/codes/apps/radiosity/radiosity.H
--- splash2/codes/apps/radiosity/radiosity.H	1994-10-18 13:37:23.000000000 -0400
+++ splash2-modified/codes/apps/radiosity/radiosity.H	2007-03-17 14:22:27.000000000 -0400
@@ -15,7 +15,7 @@
 /*************************************************************************/
 
 
-/*  This file contains many constant definitions that control the execution 
+/*  This file contains many constant definitions that control the execution
 of the program, as well as lobal data structure declarations */
 
 #ifndef _RADIOSITY_H
@@ -206,39 +206,37 @@
 
 typedef struct
 {
-    int visibility_comp ;
-    int ray_intersect_test ;
-    int tasks_from_myq ;
-    int tasks_from_otherq ;
-    int process_tasks_wait ;
+    long visibility_comp ;
+    long ray_intersect_test ;
+    long tasks_from_myq ;
+    long tasks_from_otherq ;
+    long process_tasks_wait ;
     struct _element *last_pr_task ;
 } PerIterationInfo ;
 
 
 typedef struct
 {
-    char pad1[PAGE_SIZE];	 	/* padding to avoid false-sharing 
-    and allow page-placement */	
-    int total_modeling_tasks ;
-    int total_def_patch_tasks ;
-    int total_ff_ref_tasks ;
-    int total_ray_tasks ;
-    int total_radavg_tasks ;
-    int total_direct_radavg_tasks ;
-    int total_interaction_comp ;
-    int total_visibility_comp ;
-    int partially_visible ;
-    int total_ray_intersect_test ;
-    int total_patch_cache_check ;
-    int total_patch_cache_hit ;
-    int patch_cache_hit[PATCH_CACHE_SIZE] ;
+    char pad1[PAGE_SIZE];	 	/* padding to avoid false-sharing
+    and allow page-placement */
+    long total_modeling_tasks ;
+    long total_def_patch_tasks ;
+    long total_ff_ref_tasks ;
+    long total_ray_tasks ;
+    long total_radavg_tasks ;
+    long total_direct_radavg_tasks ;
+    long total_interaction_comp ;
+    long total_visibility_comp ;
+    long partially_visible ;
+    long total_ray_intersect_test ;
+    long total_patch_cache_check ;
+    long total_patch_cache_hit ;
+    long patch_cache_hit[PATCH_CACHE_SIZE] ;
     PerIterationInfo per_iteration[ MAX_ITERATION_INFO ] ;
-    char pad2[PAGE_SIZE];	 	/* padding to avoid false-sharing 
-    and allow page-placement */	
+    char pad2[PAGE_SIZE];	 	/* padding to avoid false-sharing
+    and allow page-placement */
 } StatisticalInfo ;
 
-extern void init_stat_info() ;
-
 /****************************************
 *
 *    Shared data structure definition.
@@ -247,76 +245,76 @@
 
 typedef struct
 {
-    long int rad_start, rad_time, refine_time, wait_time, vertex_time;
+    long rad_start, rad_time, refine_time, wait_time, vertex_time;
 } Timing;
 
 typedef struct
 {
-    
+
     /* Task queue */
-    /* ***** */ int index;
+    /* ***** */ long index;
     /* ***** */	LOCKDEC(index_lock)
     Task_Queue task_queue[ MAX_TASKQUEUES ] ;
     Task task_buf[ MAX_TASKS ] ;
-    
+
     /* BSP tree root */
     LOCKDEC(bsp_tree_lock)
     Patch *bsp_root ;
-    
+
     /* Average radiosity value */
     LOCKDEC(avg_radiosity_lock)
-    int   converged ;
+    long   converged ;
     Rgb   prev_total_energy ;
     Rgb   total_energy ;
     float total_patch_area ;
-    int   iteration_count ;
-    
+    long   iteration_count ;
+
     /* Computation cost estimate */
     LOCKDEC(cost_sum_lock)
-    int cost_sum ;
-    int cost_estimate_sum ;
+    long cost_sum ;
+    long cost_estimate_sum ;
     Patch_Cost patch_cost[ MAX_PATCHES ] ;
-    
+
     /* Barrier */
     BARDEC(barrier)
-    
+
     /* Private varrier */
-    int pbar_count ;
+    long pbar_count ;
     LOCKDEC(pbar_lock)
-    
+
     /* Task initializer counter */
-    int task_counter ;
+    long task_counter ;
     LOCKDEC(task_counter_lock)
-    
+
     /* Resource buffers */
     LOCKDEC(free_patch_lock)
     Patch *free_patch ;
-    int   n_total_patches ;
-    int   n_free_patches ;
+    long   n_total_patches ;
+    long   n_free_patches ;
     Patch patch_buf[ MAX_PATCHES ] ;
-    
+
     LOCKDEC(free_element_lock)
     Element *free_element ;
-    int     n_free_elements ;
+    long     n_free_elements ;
     Element element_buf[ MAX_ELEMENTS ] ;
-    
+
     LOCKDEC(free_interaction_lock)
     Interaction *free_interaction ;
-    int         n_free_interactions ;
+    long         n_free_interactions ;
     Interaction interaction_buf[ MAX_INTERACTIONS ] ;
-    
+
     LOCKDEC(free_elemvertex_lock)
-    int         free_elemvertex ;
+    long         free_elemvertex ;
     ElemVertex  elemvertex_buf[ MAX_ELEMVERTICES ] ;
-    
+
     LOCKDEC(free_edge_lock)
-    int   free_edge ;
+    long   free_edge ;
     Edge  edge_buf[ MAX_EDGES ] ;
-    
+
     Shared_Lock sh_lock[ MAX_SHARED_LOCK ] ;
-    
+
     StatisticalInfo stat_info[ MAX_PROCESSORS ] ;
-    
+
 } Global ;
 
 
@@ -328,20 +326,20 @@
 
 extern Timing **timing ;
 extern Global *global ;
-extern int    n_processors ;
-extern int    n_taskqueues ;
-extern int    n_tasks_per_queue ;
+extern long    n_processors ;
+extern long    n_taskqueues ;
+extern long    n_tasks_per_queue ;
 
-extern int    N_inter_parallel_bf_refine ;
-extern int    N_visibility_per_task ;
+extern long    N_inter_parallel_bf_refine ;
+extern long    N_visibility_per_task ;
 extern float  Area_epsilon ;
 extern float  Energy_epsilon ;
 extern float  BFepsilon ;
 
-extern int batch_mode, verbose_mode ;
-extern int taskqueue_id[] ; 
+extern long batch_mode, verbose_mode ;
+extern long taskqueue_id[] ;
 
-extern int time_rad_start, time_rad_end, time_process_start[] ;
+extern long time_rad_start, time_rad_end, time_process_start[] ;
 
 
 /****************************************
@@ -350,34 +348,132 @@
 *
 *****************************************/
 
-extern void init_global() ;
-extern void init_visibility_module() ;
-
-extern void radiosity_averaging() ;
-extern void setup_view() ;
-extern void display_scene() ;
-extern void display_patch(), display_patches_in_bsp_tree() ;
-extern void display_element(), display_elements_in_patch() ;
-extern void display_elements_in_bsp_tree() ;
-extern void display_interactions_in_element() ;
-extern void display_interactions_in_patch() ;
-extern void display_interactions_in_bsp_tree() ;
-
-extern void ps_display_scene() ;
-extern void ps_display_patch(), ps_display_patches_in_bsp_tree() ;
-extern void ps_display_element(), ps_display_elements_in_patch() ;
-extern void ps_display_elements_in_bsp_tree() ;
-extern void ps_display_interactions_in_element() ;
-extern void ps_display_interactions_in_patch() ;
-extern void ps_display_interactions_in_bsp_tree() ;
-
-extern void print_statistics() ;
-extern void print_running_time(), print_fork_time() ;
-extern void print_usage() ;
-
-extern void clear_radiosity(), clear_patch_radiosity() ;
-
-extern void exit() ;
-
+/*
+ * display.C
+ */
+void radiosity_averaging(Element *elem, long mode, long process_id);
+void setup_view(float rot_x, float rot_y, float dist, float zoom, long process_id);
+void display_scene(long fill_sw, long patch_sw, long mesh_sw, long interaction_sw, long process_id);
+void display_patch(Patch *patch, long mode, long process_id);
+void display_patches_in_bsp_tree(long mode, long process_id);
+void display_element(Element *element, long mode, long process_id);
+void display_elements_in_patch(Patch *patch, long mode, long process_id);
+void display_elements_in_bsp_tree(long mode, long process_id);
+void display_interactions_in_element(Element *elem, long mode, long process_id);
+void display_interactions_in_patch(Patch *patch, long mode, long process_id);
+void display_interactions_in_bsp_tree(long process_id);
+void ps_display_scene(long fill_sw, long patch_sw, long mesh_sw, long interaction_sw, long process_id);
+void ps_display_patch(Patch *patch, long mode, long process_id);
+void ps_display_patches_in_bsp_tree(long mode, long process_id);
+void ps_display_element(Element *element, long mode, long process_id);
+void ps_display_elements_in_patch(Patch *patch, long mode, long process_id);
+void ps_display_elements_in_bsp_tree(long mode, long process_id);
+void ps_display_interactions_in_element(Element *elem, long mode, long process_id);
+void ps_display_interactions_in_patch(Patch *patch, long mode, long process_id);
+void ps_display_interactions_in_bsp_tree(long process_id);
+
+/*
+ * elemman.C
+ */
+void foreach_element_in_patch(Patch *patch, void (*func)(), long arg1, long process_id);
+void foreach_leaf_element_in_patch(Patch *patch, void (*func)(), long arg1, long process_id);
+void ff_refine_elements(Element *e1, Element *e2, long level, long process_id);
+long error_analysis(Element *e1, Element *e2, Interaction *inter12, Interaction *inter21, long process_id);
+void bf_error_analysis_list(Element *elem, Interaction *i_list, long process_id);
+long bf_error_analysis(Element *elem, Interaction *inter, long process_id);
+long radiosity_converged(long process_id);
+void subdivide_element(Element *e, long process_id);
+void process_rays(Element *e, long process_id);
+long element_completely_invisible(Element *e1, Element *e2, long process_id);
+Element *get_element(long process_id);
+long leaf_element(Element *elem, long process_id);
+void init_elemlist(long process_id);
+void print_element(Element *elem, long process_id);
+void foreach_interaction_in_element(Element *elem, void (*func)(), long arg1, long process_id);
+void compute_formfactor(Element *e_src, Element *e_dst, Interaction *inter, long process_id);
+void compute_interaction(Element *e_src, Element *e_dst, Interaction *inter, long subdiv, long process_id);
+void insert_interaction(Element *elem, Interaction *inter, long process_id);
+void delete_interaction(Element *elem, Interaction *prev, Interaction *inter, long process_id);
+void insert_vis_undef_interaction(Element *elem, Interaction *inter, long process_id);
+void delete_vis_undef_interaction(Element *elem, Interaction *prev, Interaction *inter, long process_id);
+Interaction *get_interaction(long process_id);
+void free_interaction(Interaction *interaction, long process_id);
+void init_interactionlist(long process_id);
+void print_interaction(Interaction *inter, long process_id);
+
+/*
+ * rad_main.C
+ */
+void start_radiosity(long val);
+void change_display(long val);
+void change_view_x(long val);
+void change_view_y(long val);
+void change_view_zoom(long val);
+void change_BFepsilon(long val);
+void change_area_epsilon(long val);
+void select_model(long val);
+void utility_tools(long val);
+void radiosity(void);
+long init_ray_tasks(long process_id);
+void init_radavg_tasks(long mode, long process_id);
+void init_global(long process_id);
+void print_usage(void);
+
+/*
+ * rad_tools.C
+ */
+void print_statistics(FILE *fd, long process_id);
+void print_per_process_info(FILE *fd, long process);
+void get_patch_stat(Patch *patch, long dummy, long process_id);
+void get_elem_stat(Element *elem, long dummy, long process_id);
+void count_interaction(Element *es, Element *e1, Element *e2, Element *e3, long *c3, long *c2, long *c1, long *c0, long process_id);
+long search_intearction(Interaction *int_list, Interaction *inter, long process_id);
+void print_running_time(long process_id);
+void print_fork_time(long process_id);
+void init_stat_info(long process_id);
+void clear_radiosity(long process_id);
+void clear_patch_radiosity(Patch *patch, long dummy, long process_id);
+
+/*
+ * smallobj.C
+ */
+float vector_length(Vertex *v);
+float distance(Vertex *p1, Vertex *p2);
+float normalize_vector(Vertex *v1, Vertex *v2);
+float inner_product(Vertex *v1, Vertex *v2);
+void cross_product(Vertex *vc, Vertex *v1, Vertex *v2);
+float plane_normal(Vertex *vc, Vertex *p1, Vertex *p2, Vertex *p3);
+void center_point(Vertex *p1, Vertex *p2, Vertex *p3, Vertex *pc);
+void four_center_points(Vertex *p1, Vertex *p2, Vertex *p3, Vertex *pc, Vertex *pc1, Vertex *pc2, Vertex *pc3);
+void print_point(Vertex *point);
+void print_rgb(Rgb *rgb);
+ElemVertex *create_elemvertex(Vertex *p, long process_id);
+ElemVertex *get_elemvertex(long process_id);
+void init_elemvertex(long process_id);
+void foreach_leaf_edge(Edge *edge, long reverse, void (*func)(), long arg1, long arg2, long process_id);
+Edge *create_edge(ElemVertex *v1, ElemVertex *v2, long process_id);
+void subdivide_edge(Edge *e, float a_ratio, long process_id);
+Edge *get_edge(long process_id);
+void init_edge(long process_id);
+void init_sharedlock(long process_id);
+Shared_Lock *get_sharedlock(long segment, long process_id);
+
+/*
+ * visible.C
+ */
+void init_visibility_module(long process_id);
+void get_test_rays(Vertex *p_src, Ray *v, long no, long process_id);
+long v_intersect(Patch *patch, Vertex *p, Ray *ray, float t);
+long traverse_bsp(Patch *src_node, Vertex *p, Ray *ray, float r_min, float r_max, long process_id);
+long traverse_subtree(Patch *node, Vertex *p, Ray *ray, float r_min, float r_max, long process_id);
+long intersection_type(Patch *patch, Vertex *p, Ray *ray, float *tval, float range_min, float range_max);
+long test_intersection(Patch *patch, Vertex *p, Ray *ray, float tval, long process_id);
+void update_patch_cache(Patch *patch, long process_id);
+long check_patch_cache(Vertex *p, Ray *ray, float r_min, float r_max, long process_id);
+void init_patch_cache(long process_id);
+long patch_tested(Patch *p, long process_id);
+float visibility(Element *e1, Element *e2, long n_rays, long process_id);
+void compute_visibility_values(Element *elem, Interaction *inter, long n_inter, long process_id);
+void visibility_task(Element *elem, Interaction *inter, long n_inter, void (*k)(), long process_id);
 
 #endif
diff -Naur splash2/codes/apps/radiosity/rad_main.C splash2-modified/codes/apps/radiosity/rad_main.C
--- splash2/codes/apps/radiosity/rad_main.C	1994-11-13 17:47:49.000000000 -0500
+++ splash2-modified/codes/apps/radiosity/rad_main.C	2007-03-17 14:24:38.000000000 -0400
@@ -23,6 +23,7 @@
  ***************************************************************/
 
 #include <stdio.h>
+#include <string.h>
 #if defined(SGI_GL)
 #include <gl.h>
 #if defined(GL_NASA)
@@ -35,148 +36,137 @@
 MAIN_ENV;
 
 include(radiosity.h)
-  
-  
-  
+
+
+
   /***************************************
    *
    *    Global shared variables
    *
    ****************************************/
-  
+
   Global *global;
   Timing **timing;
-  
-  
+
+
   /***************************************
    *
    *    Global variables (not shared)
    *
    ****************************************/
-  
-  int   n_processors              = DEFAULT_N_PROCESSORS ;
-  int   n_taskqueues              = DEFAULT_N_TASKQUEUES ;
-  int   n_tasks_per_queue         = DEFAULT_N_TASKS_PER_QUEUE ;
-  int   N_inter_parallel_bf_refine= DEFAULT_N_INTER_PARALLEL_BF_REFINEMENT ;
-  int   N_visibility_per_task     = DEFAULT_N_VISIBILITY_PER_TASK ;
+
+  long   n_processors              = DEFAULT_N_PROCESSORS ;
+  long   n_taskqueues              = DEFAULT_N_TASKQUEUES ;
+  long   n_tasks_per_queue         = DEFAULT_N_TASKS_PER_QUEUE ;
+  long   N_inter_parallel_bf_refine= DEFAULT_N_INTER_PARALLEL_BF_REFINEMENT ;
+  long   N_visibility_per_task     = DEFAULT_N_VISIBILITY_PER_TASK ;
   float Area_epsilon              = DEFAULT_AREA_EPSILON ;
   float Energy_epsilon            = DEFAULT_ENERGY_EPSILON ;
   float BFepsilon                 = DEFAULT_BFEPSILON ;
-  
-  int batch_mode = 0 ;
-  int verbose_mode = 0 ;
-  
+
+  long batch_mode = 0 ;
+  long verbose_mode = 0 ;
+
   /*
     in converting from a fork process model to an sproc (threads) model,
     taskqueue_id and time_process_start are converted to individual arrays
-    without worrying about false sharing.  This is because taskqueue_id is 
-    read-only  once written by the parent process, and time_process_start 
+    without worrying about false sharing.  This is because taskqueue_id is
+    read-only  once written by the parent process, and time_process_start
     is written only once by each process.
     */
-  
-  int taskqueue_id[MAX_PROCESSORS] ; 		/* Task queue ID */
-  int time_rad_start, time_rad_end, time_process_start[MAX_PROCESSORS] ;
-  
-  
+
+  long taskqueue_id[MAX_PROCESSORS] ; 		/* Task queue ID */
+  long time_rad_start, time_rad_end, time_process_start[MAX_PROCESSORS] ;
+
+
   /*********************************************************
    *
    *    Global variables (used only by the master process)
    *
    **********************************************************/
-  
+
 #define N_SLIDERS (5)
-  
-  void change_view_x(), change_view_y(), change_view_zoom() ;
-  void change_BFepsilon(), change_EXepsilon(), change_area_epsilon() ;
-  
+
   slider sliders[N_SLIDERS] = {
-      { "View(X)  deg ", -100,  100, (int)DFLT_VIEW_ROT_X,  5,  change_view_x },
-      { "View(Y)  deg ", -100,  100, (int)DFLT_VIEW_ROT_Y,  5,  change_view_y },
-      { "View(Zoom)   ",   0,  50, (int)DFLT_VIEW_ZOOM*10,6,  change_view_zoom },
-      { "BF-e      0.1%",  0,  50,  (int)(DEFAULT_BFEPSILON *1000.0),
+      { "View(X)  deg ", -100,  100, (long)DFLT_VIEW_ROT_X,  5,  change_view_x },
+      { "View(Y)  deg ", -100,  100, (long)DFLT_VIEW_ROT_Y,  5,  change_view_y },
+      { "View(Zoom)   ",   0,  50, (long)DFLT_VIEW_ZOOM*10,6,  change_view_zoom },
+      { "BF-e      0.1%",  0,  50,  (long)(DEFAULT_BFEPSILON *1000.0),
             11, change_BFepsilon },
-      { "Area-e       ",   0, 5000, (int)DEFAULT_AREA_EPSILON,
+      { "Area-e       ",   0, 5000, (long)DEFAULT_AREA_EPSILON,
             11, change_area_epsilon },
   } ;
-  
+
 #define N_CHOICES (4)
-  
+
 #define CHOICE_RAD_RUN    (0)
 #define CHOICE_RAD_STEP   (1)
 #define CHOICE_RAD_RESET  (2)
-  
+
 #define CHOICE_DISP_RADIOSITY   (0)
 #define CHOICE_DISP_SHADED      (1)
 #define CHOICE_DISP_PATCH       (2)
 #define CHOICE_DISP_MESH        (3)
 #define CHOICE_DISP_INTERACTION (4)
-  
+
 #define CHOICE_UTIL_PS        (0)
 #define CHOICE_UTIL_STAT_CRT  (1)
 #define CHOICE_UTIL_STAT_FILE (2)
 #define CHOICE_UTIL_CLEAR_RAD (3)
-  
-  void change_display() ;
-  void start_radiosity() ;
-  void select_model() ;
-  void utility_tools() ;
-  
+
   choice choices[N_CHOICES] = {
       { "Run",
             { "Run", "Step", "Reset", 0 },
-            0, start_radiosity }, 
+            0, start_radiosity },
       { "Display",
             { "Filled",   "Smooth shading", "Show polygon edges",
                   "Show element edges",  "Show interactions", 0 },
-            0, change_display }, 
+            0, change_display },
       { "Models",
             { "Test", "Room", "LargeRoom", 0 },
-            0, select_model }, 
+            0, select_model },
       { "Tools",
             { "HardCopy(PS)", "Statistics", "Statistics(file)",
                   "Clear Radiosity Value", 0 },
-            0, utility_tools }, 
+            0, utility_tools },
   } ;
-  
-  static void expose_callback() ;
-  
+
   /***************************************
    *
    *    Main function.
    *
    ****************************************/
-  
-  static void parse_args() ;
-  
-  static int dostats = 0;
-  
-  main( ac, av )
-  
-  int ac ;
-  char *av[] ;
-{
-    void radiosity(), parse_args() ;
-    int i;
-    unsigned long int total_rad_time, max_rad_time, min_rad_time;
-    unsigned long int total_refine_time, max_refine_time, min_refine_time;
-    unsigned long int total_wait_time, max_wait_time, min_wait_time;
-    unsigned long int total_vertex_time, max_vertex_time, min_vertex_time;
-    
+
+static void change_view(void);
+static void expose_callback(void);
+static void _init_radavg_tasks(Patch *p, long mode, long process_id);
+static void parse_args(int argc, char *argv[]);
+
+static long dostats = 0;
+
+int main(int argc, char *argv[])
+{
+    long i;
+    long total_rad_time, max_rad_time, min_rad_time;
+    long total_refine_time, max_refine_time, min_refine_time;
+    long total_wait_time, max_wait_time, min_wait_time;
+    long total_vertex_time, max_vertex_time, min_vertex_time;
+
     /* Parse arguments */
-    parse_args( ac, av ) ;
+    parse_args(argc, argv) ;
     choices[2].init_value = model_selector ;
-    
+
     /* Initialize graphic device */
     if( batch_mode == 0 )
         {
-            g_init( ac, av ) ;
+            g_init(argc, argv) ;
             setup_view( DFLT_VIEW_ROT_X, DFLT_VIEW_ROT_Y,
                        DFLT_VIEW_DIST, DFLT_VIEW_ZOOM,0 ) ;
         }
-    
+
     /* Initialize ANL macro */
     MAIN_INITENV(,60000000) ;
-    
+
     /* Allocate global shared memory and initialize */
     global = (Global *) G_MALLOC(sizeof(Global)) ;
     if( global == 0 )
@@ -185,24 +175,24 @@
             exit(1) ;
         }
     init_global(0) ;
-    
+
     timing = (Timing **) G_MALLOC(n_processors * sizeof(Timing *));
     for (i = 0; i < n_processors; i++)
         timing[i] = (Timing *) G_MALLOC(sizeof(Timing));
-    
+
     /* Initialize shared lock */
     init_sharedlock(0) ;
-    
+
     /* Initial random testing rays array for visibility test. */
     init_visibility_module(0) ;
-    
-/* POSSIBLE ENHANCEMENT:  Here is where one might distribute the 
-   sobj_struct, task_struct, and vis_struct data structures across 
+
+/* POSSIBLE ENHANCEMENT:  Here is where one might distribute the
+   sobj_struct, task_struct, and vis_struct data structures across
    physically distributed memories as desired.
 
    One way to place data is as follows:
 
-   int i;
+   long i;
 
    for (i=0;i<n_processors;i++) {
      Place all addresses x such that
@@ -218,97 +208,94 @@
     if( batch_mode )
         {
             /* In batch mode, create child processes and start immediately */
-            
+
             /* Time stamp */
             CLOCK( time_rad_start );
-            
+
             global->index = 0;
-            for( i = 0 ; i < n_processors-1 ; i++ )
+            for( i = 0 ; i < n_processors ; i++ )
                 {
                     taskqueue_id[i] = assign_taskq(0) ;
-                    CREATE(radiosity);
                 }
-            
+
             /* And start processing */
-            taskqueue_id[n_processors] = assign_taskq(0) ;
-            radiosity() ;
-            
-            WAIT_FOR_END(n_processors-1);
-            
+            CREATE(radiosity, n_processors);
+            WAIT_FOR_END(n_processors);
+
             /* Time stamp */
             CLOCK( time_rad_end );
-            
+
             /* Print out running time */
             printf("TIMING STATISTICS MEASURED BY MAIN PROCESS:\n");
-            
+
             print_running_time(0);
-            
+
             if (dostats) {
                 printf("\n\n\nPER-PROCESS STATISTICS:\n");
-                
+
                 printf("%8s%20s%20s%12s%12s\n","Proc","Total","Refine","Wait","Smooth");
                 printf("%8s%20s%20s%12s%12s\n\n","","Time","Time","Time","Time");
                 for (i = 0; i < n_processors; i++)
-                    printf("%8d%20lu%20lu%12lu%12lu\n",i,timing[i]->rad_time, timing[i]->refine_time, timing[i]->wait_time, timing[i]->vertex_time);
-                
+                    printf("%8ld%20lu%20lu%12lu%12lu\n",i,timing[i]->rad_time, timing[i]->refine_time, timing[i]->wait_time, timing[i]->vertex_time);
+
                 total_rad_time = timing[0]->rad_time;
                 max_rad_time = timing[0]->rad_time;
                 min_rad_time = timing[0]->rad_time;
-                
+
                 total_refine_time = timing[0]->refine_time;
                 max_refine_time = timing[0]->refine_time;
                 min_refine_time = timing[0]->refine_time;
-                
+
                 total_wait_time = timing[0]->wait_time;
                 max_wait_time = timing[0]->wait_time;
                 min_wait_time = timing[0]->wait_time;
-                
+
                 total_vertex_time = timing[0]->vertex_time;
                 max_vertex_time = timing[0]->vertex_time;
                 min_vertex_time = timing[0]->vertex_time;
-                
+
                 for (i = 1; i < n_processors; i++) {
                     total_rad_time += timing[i]->rad_time;
                     if (timing[i]->rad_time > max_rad_time)
                         max_rad_time = timing[i]->rad_time;
                     if (timing[i]->rad_time < min_rad_time)
                         min_rad_time = timing[i]->rad_time;
-                    
+
                     total_refine_time += timing[i]->refine_time;
                     if (timing[i]->refine_time > max_refine_time)
                         max_refine_time = timing[i]->refine_time;
                     if (timing[i]->refine_time < min_refine_time)
                         min_refine_time = timing[i]->refine_time;
-                    
+
                     total_wait_time += timing[i]->wait_time;
                     if (timing[i]->wait_time > max_wait_time)
                         max_wait_time = timing[i]->wait_time;
                     if (timing[i]->wait_time < min_wait_time)
                         min_wait_time = timing[i]->wait_time;
-                    
+
                     total_vertex_time += timing[i]->vertex_time;
                     if (timing[i]->vertex_time > max_vertex_time)
                         max_vertex_time = timing[i]->vertex_time;
                     if (timing[i]->vertex_time < min_vertex_time)
                         min_vertex_time = timing[i]->vertex_time;
                 }
-                
+
                 printf("\n\n%8s%20lu%20lu%12lu%12lu\n","Max", max_rad_time, max_refine_time, max_wait_time, max_vertex_time);
                 printf("\n%8s%20lu%20lu%12lu%12lu\n","Min", min_rad_time, min_refine_time, min_wait_time, min_vertex_time);
-                printf("\n%8s%20lu%20lu%12lu%12lu\n","Avg", (int) (((double) total_rad_time) / ((double) (1.0 * n_processors))), (int) (((double) total_refine_time) / ((double) (1.0 * n_processors))), (int) (((double) total_wait_time) / ((double) (1.0 * n_processors))), (int) (((double) total_vertex_time) / ((double) (1.0 * n_processors))));
+                printf("\n%8s%20lu%20lu%12lu%12lu\n","Avg", (long) (((double) total_rad_time) / ((double) (1.0 * n_processors))), (long) (((double) total_refine_time) / ((double) (1.0 * n_processors))), (long) (((double) total_wait_time) / ((double) (1.0 * n_processors))), (long) (((double) total_vertex_time) / ((double) (1.0 * n_processors))));
                 printf("\n\n");
-                
+
             }
-            
+
             /*	print_fork_time(0) ; */
-            
+
             print_statistics( stdout, 0 ) ;
         }
     else
         {
             /* In interactive mode, start workers, and the master starts
                notification loop */
-            
+
             /* Start notification loop */
             g_start( expose_callback,
                     N_SLIDERS, sliders, N_CHOICES, choices ) ;
@@ -327,41 +314,36 @@
  *
  ****************************************/
 
-static int disp_fill_switch = 1 ;
-static int disp_shade_switch = 0 ;
-static int disp_fill_mode = 1 ;
-static int disp_patch_switch = 0 ;
-static int disp_mesh_switch  = 0 ;
-static int disp_interaction_switch = 0 ;
-static int disp_crnt_view_x = (int)DFLT_VIEW_ROT_X ;
-  static int disp_crnt_view_y = (int)DFLT_VIEW_ROT_Y ;
+static long disp_fill_switch = 1 ;
+static long disp_shade_switch = 0 ;
+static long disp_fill_mode = 1 ;
+static long disp_patch_switch = 0 ;
+static long disp_mesh_switch  = 0 ;
+static long disp_interaction_switch = 0 ;
+static long disp_crnt_view_x = (long)DFLT_VIEW_ROT_X ;
+  static long disp_crnt_view_y = (long)DFLT_VIEW_ROT_Y ;
   static float disp_crnt_zoom = DFLT_VIEW_ZOOM ;
-  
-  
+
+
 #if defined(SGI_GL) && defined(GL_NASA)
-  void start_radiosity( ap )
-  Actuator *ap ;
+void start_radiosity(Actuator *ap)
 #else
-  void start_radiosity( val )
-  int val ;
+void start_radiosity(long val)
 #endif
 {
-    static int state = 0 ;
-    void radiosity() ;
-    int init_ray_tasks() ;
-    void init_radavg_tasks() ;
-    int i;
-    unsigned total_rad_time, max_rad_time, min_rad_time;
-    unsigned total_refine_time, max_refine_time, min_refine_time;
-    unsigned total_wait_time, max_wait_time, min_wait_time;
-    unsigned total_vertex_time, max_vertex_time, min_vertex_time;
-    
+    static long state = 0 ;
+    long i;
+    long total_rad_time, max_rad_time, min_rad_time;
+    long total_refine_time, max_refine_time, min_refine_time;
+    long total_wait_time, max_wait_time, min_wait_time;
+    long total_vertex_time, max_vertex_time, min_vertex_time;
+
 #if defined(SGI_GL) && defined(GL_NASA)
-    int val ;
-    
+    long val ;
+
     val = g_get_choice_val( ap, &choices[0] ) ;
 #endif
-    
+
     if( val == CHOICE_RAD_RUN )
         {
             if( state == -1 )
@@ -369,104 +351,101 @@
                     printf( "Please reset first\007\n" ) ;
                     return ;
                 }
-            
+
             /* Time stamp */
             CLOCK( time_rad_start ) ;
-            
-            
+
+
             global->index = 0;
-            
+
             /* Create slave processes */
-            for (i = 0 ; i < n_processors-1 ; i++ )
+            for (i = 0 ; i < n_processors ; i++ )
                 {
                     taskqueue_id[i] = assign_taskq(0) ;
-                    CREATE(radiosity);
                 }
-            
+
             /* And start processing */
-            taskqueue_id[n_processors] = assign_taskq(0) ;
-            radiosity() ;
-            
-            WAIT_FOR_END(n_processors-1);
+            CREATE(radiosity, n_processors);
+            WAIT_FOR_END(n_processors);
             /* Time stamp */
             CLOCK( time_rad_end );
-            
+
             /* Print out running time */
             /* Print out running time */
             printf("TIMING STATISTICS MEASURED BY MAIN PROCESS:\n");
-            
+
             print_running_time(0);
-            
+
             if (dostats) {
                 printf("\n\n\nPER-PROCESS STATISTICS:\n");
-                
+
                 printf("%8s%20s%20s%12s%12s\n","Proc","Total","Refine","Wait","Smooth");
                 printf("%8s%20s%20s%12s%12s\n\n","","Time","Time","Time","Time")
                     ;
                 for (i = 0; i < n_processors; i++)
-                    printf("%8d%20lu%20lu%12lu%12lu\n",i,timing[i]->rad_time, timing[i]->refine_time, timing[i]->wait_time, timing[i]->vertex_time);
-                
+                    printf("%8ld%20lu%20lu%12lu%12lu\n",i,timing[i]->rad_time, timing[i]->refine_time, timing[i]->wait_time, timing[i]->vertex_time);
+
                 total_rad_time = timing[0]->rad_time;
                 max_rad_time = timing[0]->rad_time;
                 min_rad_time = timing[0]->rad_time;
-                
+
                 total_refine_time = timing[0]->refine_time;
                 max_refine_time = timing[0]->refine_time;
                 min_refine_time = timing[0]->refine_time;
-                
+
                 total_wait_time = timing[0]->wait_time;
                 max_wait_time = timing[0]->wait_time;
                 min_wait_time = timing[0]->wait_time;
-                
+
                 total_vertex_time = timing[0]->vertex_time;
                 max_vertex_time = timing[0]->vertex_time;
                 min_vertex_time = timing[0]->vertex_time;
-                
+
                 for (i = 1; i < n_processors; i++) {
                     total_rad_time += timing[i]->rad_time;
                     if (timing[i]->rad_time > max_rad_time)
                         max_rad_time = timing[i]->rad_time;
                     if (timing[i]->rad_time < min_rad_time)
                         min_rad_time = timing[i]->rad_time;
-                    
+
                     total_refine_time += timing[i]->refine_time;
                     if (timing[i]->refine_time > max_refine_time)
                         max_refine_time = timing[i]->refine_time;
                     if (timing[i]->refine_time < min_refine_time)
                         min_refine_time = timing[i]->refine_time;
-                    
+
                     total_wait_time += timing[i]->wait_time;
                     if (timing[i]->wait_time > max_wait_time)
                         max_wait_time = timing[i]->wait_time;
                     if (timing[i]->wait_time < min_wait_time)
                         min_wait_time = timing[i]->wait_time;
-                    
+
                     total_vertex_time += timing[i]->vertex_time;
                     if (timing[i]->vertex_time > max_vertex_time)
                         max_vertex_time = timing[i]->vertex_time;
                     if (timing[i]->vertex_time < min_vertex_time)
                         min_vertex_time = timing[i]->vertex_time;
                 }
-                
-                
+
+
                 printf("\n\n%8s%20lu%20lu%12lu%12lu\n","Max", max_rad_time, max_refine_time, max_wait_time, max_vertex_time);
                 printf("\n%8s%20lu%20lu%12lu%12lu\n","Min", min_rad_time, min_refine_time, min_wait_time, min_vertex_time);
-                printf("\n%8s%20lu%20lu%12lu%12lu\n","Avg", (int) (((double) total_rad_time) / ((double) (1.0 * n_processors))), (int) (((double) total_refine_time) / ((double) (1.0 * n_processors))), (int) (((double) total_wait_time) / ((double) (1.0 * n_processors))), (int) (((double) total_vertex_time) / ((double) (1.0 * n_processors))));
+                printf("\n%8s%20lu%20lu%12lu%12lu\n","Avg", (long) (((double) total_rad_time) / ((double) (1.0 * n_processors))), (long) (((double) total_refine_time) / ((double) (1.0 * n_processors))), (long) (((double) total_wait_time) / ((double) (1.0 * n_processors))), (long) (((double) total_vertex_time) / ((double) (1.0 * n_processors))));
                 printf("\n\n");
-                
+
             }
-            
+
             /*      print_fork_time(0) ; */
-            
+
             print_statistics( stdout, 0 ) ;
-            
+
             /* Display image */
             display_scene( disp_fill_mode, disp_patch_switch,
                           disp_mesh_switch, disp_interaction_switch, 0) ;
-            
+
             state = -1 ;
         }
-    
+
     else if( val == CHOICE_RAD_STEP )
         {
             if( state == -1 )
@@ -474,23 +453,22 @@
                     printf( "Please reset first\007\n" ) ;
                     return ;
                 }
-            
+
             /* Step execution */
             switch( state )
                 {
                 case 0:
                     /* Step execute as a single process */
-                    
+
                     global->index = 1;
                     /* Create slave processes */
-                    for ( i = 0 ; i < n_processors-1 ; i++ )
+                    for ( i = 0 ; i < n_processors ; i++ )
                         {
                             taskqueue_id[i] = assign_taskq(0) ;
-                            CREATE(radiosity);
                         }
-                    
-                    taskqueue_id[n_processors] = assign_taskq(0) ;
-                    
+
+                    CREATE(radiosity, n_processors/* - 1*/);
+
                     /* Decompose model objects into patches and build
                        the BSP tree */
                     /* Create the first tasks (MASTER only) */
@@ -498,7 +476,7 @@
                     process_tasks(0) ;
                     state ++ ;
                     break ;
-                    
+
                 case 1:
                     if( init_ray_tasks(0) )
                         {
@@ -514,16 +492,16 @@
                     process_tasks(0) ;
                     init_radavg_tasks( RAD_NORMALIZING_MODE, 0 ) ;
                     process_tasks(0) ;
-                    
-                    WAIT_FOR_END(n_processors-1)
+
+                    WAIT_FOR_END(n_processors/* - 1*/)
                         state = -1 ;
                 }
-            
+
             /* Display image */
             display_scene( disp_fill_mode, disp_patch_switch,
                           disp_mesh_switch, disp_interaction_switch, 0) ;
         }
-    
+
     else if( val == CHOICE_RAD_RESET )
         {
             /* Initialize global variables again */
@@ -545,21 +523,17 @@
 
 
 #if defined(SGI_GL) && defined(GL_NASA)
-void change_display( ap )
-  
-  Actuator *ap ;
+void change_display(Actuator *ap)
 #else
-  void change_display( val )
-  
-  int val ;
+void change_display(long val)
 #endif
 {
 #if defined(SGI_GL) && defined(GL_NASA)
-    int val ;
-    
+    long val ;
+
     val = g_get_choice_val( ap, &choices[1] ) ;
 #endif
-    
+
     /* Display image */
     switch( val )
         {
@@ -581,7 +555,7 @@
         default:
             return ;
         }
-    
+
     if( disp_fill_switch == 0 )
         disp_fill_mode = 0 ;
     else
@@ -591,7 +565,7 @@
             else
                 disp_fill_mode = 2 ;
         }
-    
+
     /* Display image */
     display_scene( disp_fill_mode, disp_patch_switch,
                   disp_mesh_switch, disp_interaction_switch, 0 ) ;
@@ -613,7 +587,7 @@
     /* Change the view */
     setup_view( (float)disp_crnt_view_x, (float)disp_crnt_view_y,
                DFLT_VIEW_DIST, disp_crnt_zoom, 0 ) ;
-    
+
     /* And redraw */
     display_scene( disp_fill_mode, disp_patch_switch,
                   disp_mesh_switch, disp_interaction_switch, 0 ) ;
@@ -621,17 +595,15 @@
 
 
 #if defined(SGI_GL) && defined(GL_NASA)
-void change_view_x( ap )
-  Actuator *ap ;
+void change_view_x(Actuator *ap)
 #else
-  void change_view_x( val )
-  int val ;
+void change_view_x(long val)
 #endif
 {
 #if defined(SGI_GL) && defined(GL_NASA)
-    int val = g_get_slide_val( ap ) ;
+    long val = g_get_slide_val( ap ) ;
 #endif
-    
+
     /* Save current rot-X value */
     disp_crnt_view_x = val ;
     change_view() ;
@@ -639,17 +611,15 @@
 
 
 #if defined(SGI_GL) && defined(GL_NASA)
-void change_view_y( ap )
-  Actuator *ap ;
+void change_view_y(Actuator *ap)
 #else
-  void change_view_y( val )
-  int val ;
+void change_view_y(long val )
 #endif
 {
 #if defined(SGI_GL) && defined(GL_NASA)
-    int val = g_get_slide_val( ap ) ;
+    long val = g_get_slide_val( ap ) ;
 #endif
-    
+
     /* Save current rot-Y value */
     disp_crnt_view_y = val ;
     change_view() ;
@@ -657,17 +627,15 @@
 
 
 #if defined(SGI_GL) && defined(GL_NASA)
-void change_view_zoom( ap )
-  Actuator *ap ;
+void change_view_zoom(Actuator *ap)
 #else
-  void change_view_zoom( val )
-  int val ;
+void change_view_zoom(long val)
 #endif
 {
 #if defined(SGI_GL) && defined(GL_NASA)
-    int val = g_get_slide_val( ap ) ;
+    long val = g_get_slide_val( ap ) ;
 #endif
-    
+
     /* Save current zoom value */
     disp_crnt_zoom = (float)val / 10.0 ;
     change_view() ;
@@ -675,15 +643,13 @@
 
 
 #if defined(SGI_GL) && defined(GL_NASA)
-void change_BFepsilon( ap )
-  Actuator *ap ;
+void change_BFepsilon(Actuator *ap)
 #else
-  void change_BFepsilon( val )
-  int val ;
+void change_BFepsilon(long val)
 #endif
 {
 #if defined(SGI_GL) && defined(GL_NASA)
-    int val = g_get_slide_val( ap ) ;
+    long val = g_get_slide_val( ap ) ;
 #endif
     BFepsilon = (float)val / 1000.0 ;
 }
@@ -691,15 +657,13 @@
 
 
 #if defined(SGI_GL) && defined(GL_NASA)
-void change_area_epsilon( ap )
-  Actuator *ap ;
+void change_area_epsilon(Actuator *ap)
 #else
-  void change_area_epsilon( val )
-  int val ;
+void change_area_epsilon(long val)
 #endif
 {
 #if defined(SGI_GL) && defined(GL_NASA)
-    int val = g_get_slide_val( ap ) ;
+    long val = g_get_slide_val( ap ) ;
 #endif
     Area_epsilon = (float)val ;
 }
@@ -714,15 +678,13 @@
  ****************************************/
 
 #if defined(SGI_GL) && defined(GL_NASA)
-void select_model( ap )
-  Actuator *ap ;
+void select_model(Actuator *ap)
 #else
-  void select_model( val )
-  int val ;
+void select_model(long val)
 #endif
 {
 #if defined(SGI_GL) && defined(GL_NASA)
-    int val = g_get_choice_val( ap, &choices[2] ) ;
+    long val = g_get_choice_val( ap, &choices[2] ) ;
 #endif
     switch( val )
         {
@@ -750,32 +712,30 @@
 
 
 #if defined(SGI_GL) && defined(GL_NASA)
-void utility_tools( ap )
-  Actuator *ap ;
+void utility_tools(Actuator *ap)
 #else
-  void utility_tools( val )
-  int val ;
+void utility_tools(long val)
 #endif
 {
     FILE *fd ;
 #if defined(SGI_GL) && defined(GL_NASA)
-    int val = g_get_choice_val( ap, &choices[3] ) ;
+    long val = g_get_choice_val( ap, &choices[3] ) ;
 #endif
-    
+
     switch( val )
         {
         case CHOICE_UTIL_PS:
             /* Open PS file */
             ps_open( "radiosity.ps" ) ;
-            
+
             /* Change the view */
             ps_setup_view( DFLT_VIEW_ROT_X, (float)disp_crnt_view_y,
-                          DFLT_VIEW_DIST, DFLT_VIEW_ZOOM, 0 ) ;
-            
+                          DFLT_VIEW_DIST, DFLT_VIEW_ZOOM) ;
+
             /* And redraw */
             ps_display_scene( disp_fill_mode, disp_patch_switch,
                              disp_mesh_switch, disp_interaction_switch, 0 ) ;
-            
+
             /* Close */
             ps_close() ;
             break ;
@@ -820,19 +780,18 @@
 
 void radiosity()
 {
-    int init_ray_tasks() ;
-    unsigned process_id;
-    void init_radavg_tasks() ;
-    unsigned long int rad_start, refine_done, vertex_start, vertex_done;
-    
+    long process_id;
+    long rad_start, refine_done, vertex_start, vertex_done;
+
     LOCK(global->index_lock);
     process_id = global->index++;
     UNLOCK(global->index_lock);
     process_id = process_id % n_processors;
-    
+
+    BARINCLUDE(global->barrier);
     if ((process_id == 0) || (dostats))
         CLOCK(rad_start);
-    
+
     /* POSSIBLE ENHANCEMENT:  Here is where one might pin processes to
        processors to avoid migration */
 
@@ -843,7 +802,7 @@
     /* Create the initial tasks */
     init_modeling_tasks(process_id) ;
     process_tasks(process_id) ;
-    
+
     /* Gather rays & do BF refinement */
     while( init_ray_tasks(process_id) )
         {
@@ -853,26 +812,26 @@
                solution converges */
             process_tasks(process_id) ;
         }
-    
+
     if ((process_id == 0) || (dostats))
         CLOCK(refine_done);
-    
+
     BARRIER(global->barrier, n_processors);
-    
+
     if ((process_id == 0) || (dostats))
         CLOCK(vertex_start);
-    
+
     /* Compute area-weighted radiosity value at each vertex */
     init_radavg_tasks( RAD_AVERAGING_MODE, process_id ) ;
     process_tasks(process_id) ;
-    
+
     /* Then normalize the radiosity at vertices */
     init_radavg_tasks( RAD_NORMALIZING_MODE, process_id ) ;
     process_tasks(process_id) ;
-    
+
     if ((process_id == 0) || (dostats))
         CLOCK(vertex_done);
-    
+
     if ((process_id == 0) || (dostats)) {
         timing[process_id]->rad_start = rad_start;
         timing[process_id]->rad_time = vertex_done - rad_start;
@@ -880,7 +839,7 @@
         timing[process_id]->vertex_time = vertex_done - vertex_start;
         timing[process_id]->wait_time = vertex_start - refine_done;
     }
-    
+
 }
 
 
@@ -895,123 +854,113 @@
 
 
 #if PATCH_ASSIGNMENT == PATCH_ASSIGNMENT_STATIC
-static void _init_ray_tasks_static() ;
+static void _init_ray_tasks_static(Patch *p, long dummy, long process_id);
 #define _INIT_RAY_TASK  _init_ray_tasks_static
 #endif
-  
-  
-  static void _init_ray_tasks_cost2() ;
-  static int avg_cost_of_q ;
-  static int avg_cost_of_patch ;
-  static int cost_of_this_q ;
-  static int crnt_qid ;
-  static int queue_cost[MAX_TASKQUEUES] ;
-  
+
 #if PATCH_ASSIGNMENT == PATCH_ASSIGNMENT_COSTBASED
+static long avg_cost_of_q ;
+static long avg_cost_of_patch ;
+static long queue_cost[MAX_TASKQUEUES] ;
+
+static void _init_ray_tasks_cost2(Patch *p, long layer, long process_id);
 #define _INIT_RAY_TASK  _init_ray_tasks_cost2
 #endif
-  
-  
-  
-  
-  int init_ray_tasks(process_id)
-  unsigned process_id;
+
+
+
+
+long init_ray_tasks(long process_id)
 {
-    int conv ;
-    
+    long conv ;
+
     /* If this is not the first process to initialize, then return */
     LOCK(global->avg_radiosity_lock);
-    if( ! check_task_counter(process_id) )
+    if( ! check_task_counter() )
         {
             conv = global->converged ;
             UNLOCK(global->avg_radiosity_lock);
             return( conv == 0 ) ;
         }
-    
+
     /* Check radiosity convergence */
     conv = radiosity_converged(process_id) ;
     global->converged = conv ;
-    
+
     /* Reset total energy variable */
     global->prev_total_energy = global->total_energy ;
     global->total_energy.r = 0.0 ;
     global->total_energy.g = 0.0 ;
     global->total_energy.b = 0.0 ;
     global->total_patch_area = 0.0 ;
-    
+
     /* Increment iteration counter */
     global->iteration_count++ ;
     UNLOCK(global->avg_radiosity_lock);
-    
+
     /* If radiosity converged, then return 0 */
     if( conv )
         return( 0 ) ;
-    
-    
+
+
 #if PATCH_ASSIGNMENT == PATCH_ASSIGNMENT_COSTBASED
     /* Compute average cost per queue. Also reset the cost variable.
        The 'cost_sum' is not locked since no one is processing rays
        at this moment */
-    
+
     for( crnt_qid = 0 ; crnt_qid < n_taskqueues ; crnt_qid++ )
         queue_cost[ crnt_qid ] = 0 ;
-    
+
     avg_cost_of_q = global->cost_estimate_sum / n_taskqueues ;
     avg_cost_of_patch = global->cost_estimate_sum / global->n_total_patches ;
     cost_of_this_q = 0 ;
     crnt_qid = 0 ;
-    
+
     global->cost_sum = 0 ;
     global->cost_estimate_sum = 0 ;
-    
+
     /* layered selection of tasks */
     foreach_patch_in_bsp( _INIT_RAY_TASK, 2, process_id ) ;
     foreach_patch_in_bsp( _INIT_RAY_TASK, 1, process_id ) ;
 #endif
-    
+
     /* Create BF refinement tasks */
     foreach_patch_in_bsp( _INIT_RAY_TASK, 0, process_id ) ;
-    
+
     return( 1 ) ;
 }
 
 
-static void _init_ray_tasks_static( p, dummy, process_id )
-  Patch *p ;
-  int dummy ;
-  unsigned process_id;
+static void _init_ray_tasks_static(Patch *p, long dummy, long process_id)
 {
     /* Clear incoming energy variable */
     p->el_root->rad_in.r = 0.0 ;
     p->el_root->rad_in.g = 0.0 ;
     p->el_root->rad_in.b = 0.0 ;
-    
+
     enqueue_ray_task( (p->seq_no >> 2) % n_taskqueues, p->el_root,
                      TASK_APPEND, process_id ) ;
 }
 
-
-static void _init_ray_tasks_cost2( p, layer, process_id )
-  Patch *p ;
-  int layer ;
-  unsigned process_id;
+#if PATCH_ASSIGNMENT == PATCH_ASSIGNMENT_COSTBASED
+static void _init_ray_tasks_cost2(Patch *p, long layer, long process_id)
 {
     Patch_Cost *pc ;
-    int c_est ;
-    int qid ;
-    int min_cost_q, min_cost ;
-    
-    
+    long c_est ;
+    long qid ;
+    long min_cost_q, min_cost ;
+
+
     pc = &global->patch_cost[ p->seq_no ] ;
     c_est = pc->cost_estimate ;
-    
+
     if( c_est < 0 )
         /* Already processed */
         return ;
-    
+
     if( c_est < avg_cost_of_patch * layer )
         return ;
-    
+
     /* Find the first available queue */
     min_cost_q = 0 ;
     min_cost = queue_cost[ 0 ] ;
@@ -1019,38 +968,38 @@
         {
             if( (c_est + queue_cost[ qid ]) <= avg_cost_of_q )
                 break ;
-            
+
             if( min_cost > queue_cost[ qid ] )
                 {
                     min_cost_q = qid ;
                     min_cost = queue_cost[ qid ] ;
                 }
         }
-    
+
     if( qid >= n_taskqueues )
         {
             /* All queues are nearly full. Put to min-cost queue */
             qid = min_cost_q ;
         }
-    
+
     /* Update queue cost */
     queue_cost[ qid ] += c_est ;
-    
-    
+
+
     /* Clear incoming energy variable */
     p->el_root->rad_in.r = 0.0 ;
     p->el_root->rad_in.g = 0.0 ;
     p->el_root->rad_in.b = 0.0 ;
-    
+
     /* Clear cost value */
     pc->cost_estimate = -1 ;
     pc->n_bsp_node    = 0 ;
-    
+
     /* Enqueue */
     enqueue_ray_task( qid, p->el_root, TASK_APPEND, process_id ) ;
-    
-}
 
+}
+#endif
 
 
 
@@ -1062,27 +1011,19 @@
  *
  ****************************************************************************/
 
-static void _init_radavg_tasks() ;
-  
-  void init_radavg_tasks( mode, process_id )
-  
-  int mode ;
-  unsigned process_id;
+void init_radavg_tasks(long mode, long process_id)
 {
-    
+
     /* If this is not the first process to initialize, then return */
-    if( ! check_task_counter(process_id ) )
+    if( ! check_task_counter() )
         return ;
-    
+
     /* Create RadAvg tasks */
     foreach_patch_in_bsp( _init_radavg_tasks, mode, process_id ) ;
 }
 
 
-static void _init_radavg_tasks( p, mode, process_id )
-  Patch *p ;
-  int mode ;
-  unsigned process_id;
+static void _init_radavg_tasks(Patch *p, long mode, long process_id)
 {
     enqueue_radavg_task( p->seq_no % n_taskqueues, p->el_root, mode, process_id  ) ;
 }
@@ -1096,54 +1037,53 @@
  ****************************************/
 
 
-void init_global(process_id)
-  unsigned process_id;
+void init_global(long process_id)
 {
     /* Clear BSP root pointer */
     global->index = 1;  /* ****** */
     global->bsp_root = 0 ;
     LOCKINIT(global->index_lock);
     LOCKINIT(global->bsp_tree_lock);
-    
+
     /* Initialize radiosity statistics variables */
     LOCKINIT(global->avg_radiosity_lock);
     global->converged = 0 ;
-    global->prev_total_energy.r = 0.0 ;   
-    global->prev_total_energy.g = 0.0 ;   
-    global->prev_total_energy.b = 0.0 ;   
-    global->total_energy.r = 1.0 ;   
-    global->total_energy.g = 1.0 ;   
-    global->total_energy.b = 1.0 ;   
+    global->prev_total_energy.r = 0.0 ;
+    global->prev_total_energy.g = 0.0 ;
+    global->prev_total_energy.b = 0.0 ;
+    global->total_energy.r = 1.0 ;
+    global->total_energy.g = 1.0 ;
+    global->total_energy.b = 1.0 ;
     global->total_patch_area = 1.0 ;
     global->iteration_count = -1 ;     /* init_ray_task() increments to 0 */
-    
+
     /* Initialize the cost sum */
     LOCKINIT(global->cost_sum_lock);
     global->cost_sum = 0 ;
     global->cost_estimate_sum = 0 ;
-    
+
     /* Initialize the barrier */
-    BARINIT(global->barrier);
+    BARINIT(global->barrier, n_processors);
     LOCKINIT(global->pbar_lock);
     global->pbar_count = 0 ;
-    
+
     /* Initialize task counter */
     global->task_counter = 0 ;
     LOCKINIT(global->task_counter_lock);
-    
+
     /* Initialize task queue */
     init_taskq(process_id) ;
-    
+
     /* Initialize Patch, Element, Interaction free lists */
     init_patchlist(process_id) ;
     init_elemlist(process_id) ;
     init_interactionlist(process_id) ;
     init_elemvertex(process_id) ;
     init_edge(process_id) ;
-    
+
     /* Initialize statistical info */
     init_stat_info(process_id) ;
-    
+
 }
 
 
@@ -1153,60 +1093,57 @@
  *
  **************************************************************/
 
-static void parse_args( ac, av )
-  
-  int ac ;
-  char *av[] ;
+static void parse_args(int argc, char *argv[])
 {
-    int cnt ;
-    
+    long cnt ;
+
     /* Parse arguments */
-    for( cnt = 1 ; cnt < ac ; cnt++ ) 
+    for( cnt = 1 ; cnt < argc ; cnt++ )
         {
-            if( strcmp( av[cnt], "-p" ) == 0 ) {
-                sscanf( av[++cnt], "%d", &n_processors ) ;
+            if( strcmp( argv[cnt], "-p" ) == 0 ) {
+                sscanf( argv[++cnt], "%ld", &n_processors ) ;
                 n_taskqueues = n_processors;
-            }	
-            else if( strcmp( av[cnt], "-tq" ) == 0 ) 
-                sscanf( av[++cnt], "%d", &n_tasks_per_queue ) ;
-            else if( strcmp( av[cnt], "-ae" ) == 0 )
-                sscanf( av[++cnt], "%f", &Area_epsilon ) ;
-            else if( strcmp( av[cnt], "-pr" ) == 0 ) 
-                sscanf( av[++cnt], "%d", &N_inter_parallel_bf_refine ) ;
-            else if( strcmp( av[cnt], "-pv" ) == 0 ) 
-                sscanf( av[++cnt], "%d", &N_visibility_per_task ) ;
-            else if( strcmp( av[cnt], "-bf" ) == 0 )
-                sscanf( av[++cnt], "%f", &BFepsilon ) ;
-            else if( strcmp( av[cnt], "-en" ) == 0 )
-                sscanf( av[++cnt], "%f", &Energy_epsilon ) ;
-            
-            else if( strcmp( av[cnt], "-batch" ) == 0 )
+            }
+            else if( strcmp( argv[cnt], "-tq" ) == 0 )
+                sscanf( argv[++cnt], "%ld", &n_tasks_per_queue ) ;
+            else if( strcmp( argv[cnt], "-ae" ) == 0 )
+                sscanf( argv[++cnt], "%f", &Area_epsilon ) ;
+            else if( strcmp( argv[cnt], "-pr" ) == 0 )
+                sscanf( argv[++cnt], "%ld", &N_inter_parallel_bf_refine ) ;
+            else if( strcmp( argv[cnt], "-pv" ) == 0 )
+                sscanf( argv[++cnt], "%ld", &N_visibility_per_task ) ;
+            else if( strcmp( argv[cnt], "-bf" ) == 0 )
+                sscanf( argv[++cnt], "%f", &BFepsilon ) ;
+            else if( strcmp( argv[cnt], "-en" ) == 0 )
+                sscanf( argv[++cnt], "%f", &Energy_epsilon ) ;
+
+            else if( strcmp( argv[cnt], "-batch" ) == 0 )
                 batch_mode = 1 ;
-            else if( strcmp( av[cnt], "-verbose" ) == 0 )
+            else if( strcmp( argv[cnt], "-verbose" ) == 0 )
                 verbose_mode = 1 ;
-            else if( strcmp( av[cnt], "-s" ) == 0 )
+            else if( strcmp( argv[cnt], "-s" ) == 0 )
                 dostats = 1 ;
-            else if( strcmp( av[cnt], "-room" ) == 0 )
+            else if( strcmp( argv[cnt], "-room" ) == 0 )
                 model_selector = MODEL_ROOM_DATA ;
-            else if( strcmp( av[cnt], "-largeroom" ) == 0 )
+            else if( strcmp( argv[cnt], "-largeroom" ) == 0 )
                 model_selector = MODEL_LARGEROOM_DATA ;
-            else if(( strcmp( av[cnt], "-help" ) == 0 ) || ( strcmp( av[cnt], "-h" ) == 0 ) || ( strcmp( av[cnt], "-H" ) == 0 ))	    {
+            else if(( strcmp( argv[cnt], "-help" ) == 0 ) || ( strcmp( argv[cnt], "-h" ) == 0 ) || ( strcmp( argv[cnt], "-H" ) == 0 ))	    {
                 print_usage() ;
                 exit(0) ;
             }
         }
-    
-    
+
+
     /* Then check the arguments */
     if( (n_processors < 1) || (MAX_PROCESSORS < n_processors) )
         {
-            fprintf( stderr, "Bad number of processors: %d\n",
+            fprintf( stderr, "Bad number of processors: %ld\n",
                     n_processors ) ;
             exit(1) ;
         }
     if( (n_taskqueues < 1) || (MAX_TASKQUEUES < n_taskqueues) )
         {
-            fprintf( stderr, "Bad number of task queues: %d\n",
+            fprintf( stderr, "Bad number of task queues: %ld\n",
                     n_taskqueues ) ;
             exit(1) ;
         }
diff -Naur splash2/codes/apps/radiosity/rad_tools.C splash2-modified/codes/apps/radiosity/rad_tools.C
--- splash2/codes/apps/radiosity/rad_tools.C	1994-10-18 13:37:23.000000000 -0400
+++ splash2-modified/codes/apps/radiosity/rad_tools.C	2007-03-17 13:46:26.000000000 -0400
@@ -25,27 +25,29 @@
 EXTERN_ENV;
 
 include(radiosity.h)
-  
+
+static void clear_element_radiosity(Element *elem, long dummy, long process_id);
+
 /***************************************
  *
- *    Global variables 
+ *    Global variables
  *
  ****************************************/
-  
+
 #define MAX_INTERACTION_PER_ELEMENT (100)
-  
-int total_patches ;
-int total_elements ;
-int total_equiv_elements ;
-int total_interactions ;
-int total_comp_visible_interactions ;
-int total_invisible_interactions ;
-int total_match3, total_match2, total_match1, total_match0 ;
+
+long total_patches ;
+long total_elements ;
+long total_equiv_elements ;
+long total_interactions ;
+long total_comp_visible_interactions ;
+long total_invisible_interactions ;
+long total_match3, total_match2, total_match1, total_match0 ;
 
 
 typedef struct
 {
-    int count ;
+    long count ;
     float area ;
 } Elem_Interaction ;
 
@@ -59,16 +61,10 @@
  *
  ****************************************/
 
-void print_statistics( fd, process_id )
-  
-  FILE *fd ;
-  unsigned process_id;
-{
-    int i ;
-    void get_patch_stat() ;
-    void print_per_process_info() ;
-    
-    
+void print_statistics(FILE *fd, long process_id)
+{
+    long i ;
+
     /* Initialize information */
     total_patches = 0 ;
     total_elements = 0 ;
@@ -80,7 +76,7 @@
     total_match2 = 0 ;
     total_match1 = 0 ;
     total_match0 = 0 ;
-    
+
     for( i = 0 ; i < MAX_INTERACTION_PER_ELEMENT ; i++ )
         {
             elem_interaction[i].count = 0 ;
@@ -88,17 +84,17 @@
         }
     many_interaction.count = 0 ;
     many_interaction.area  = 0 ;
-    
+
     foreach_patch_in_bsp( get_patch_stat,  0, 0 ) ;
-    
+
     fprintf( fd, "Rasiosity Statistics\n\n" ) ;
-    
+
     fprintf( fd, "    Histogram of interactions/elem\n" ) ;
     fprintf( fd, "\t Interactions  Occurrence\n" ) ;
     fprintf( fd, "\t -------------------------------\n" ) ;
     if( many_interaction.count > 0 )
         {
-            fprintf( fd, "\t (Over %d)      %d (%f)\n",
+            fprintf( fd, "\t (Over %d)      %ld (%f)\n",
                     MAX_INTERACTION_PER_ELEMENT,
                     many_interaction.count,
                     many_interaction.area / many_interaction.count ) ;
@@ -109,17 +105,17 @@
         {
             if( elem_interaction[i].count == 0 )
                 continue ;
-            
+
             if( elem_interaction[i].count == 0 )
-                fprintf( fd, "\t    %d          %d (---)\n",
+                fprintf( fd, "\t    %ld          %ld (---)\n",
                         i, elem_interaction[i].count ) ;
-            
+
             else
-                fprintf( fd, "\t    %d          %d (%f)\n",
+                fprintf( fd, "\t    %ld          %ld (%f)\n",
                         i, elem_interaction[i].count,
                         elem_interaction[i].area / elem_interaction[i].count);
         }
-    
+
     fprintf( fd, "    Configurations\n" ) ;
 #if PATCH_ASSIGNMENT == PATCH_ASSIGNMENT_COSTBASED
     fprintf( fd, "\tPatch assignment: Costbased\n" ) ;
@@ -128,50 +124,50 @@
 #if PATCH_ASSIGNMENT == PATCH_ASSIGNMENT_STATIC
     fprintf( fd, "\tPatch assignment: Static equal number\n" ) ;
 #endif
-    
+
     fprintf( fd, "\tAlways inserting at top of list for visibility testing (not sorted)\n" ) ;
     fprintf( fd, "\tRecursive pruning enabled for BSP tree traversal\n" ) ;
     fprintf( fd, "\tPatch cache:      Enabled\n" ) ;
     fprintf( fd, "\tAlways check all other queues when task stealing (not neighbor scheme)\n" ) ;
-    
-    
+
+
     fprintf( fd, "    Parameters\n" ) ;
-    fprintf( fd, "\tNumber of processors:    %d\n", n_processors ) ;
-    fprintf( fd, "\tNumber of task queues:   %d\n", n_taskqueues ) ;
-    fprintf( fd, "\tNumber of tasks / queue: %d\n", n_tasks_per_queue ) ;
+    fprintf( fd, "\tNumber of processors:    %ld\n", n_processors ) ;
+    fprintf( fd, "\tNumber of task queues:   %ld\n", n_taskqueues ) ;
+    fprintf( fd, "\tNumber of tasks / queue: %ld\n", n_tasks_per_queue ) ;
     fprintf( fd, "\tArea epsilon:            %f\n", Area_epsilon ) ;
-    fprintf( fd, "\t#inter parallel refine:  %d\n",
+    fprintf( fd, "\t#inter parallel refine:  %ld\n",
             N_inter_parallel_bf_refine);
-    fprintf( fd, "\t#visibility comp / task: %d\n", N_visibility_per_task ) ;
+    fprintf( fd, "\t#visibility comp / task: %ld\n", N_visibility_per_task ) ;
     fprintf( fd, "\tBF epsilon:              %f\n", BFepsilon ) ;
     fprintf( fd, "\tEnergy convergence:      %f\n", Energy_epsilon ) ;
-    
-    fprintf( fd, "    Iterations to converge:   %d times\n",
+
+    fprintf( fd, "    Iterations to converge:   %ld times\n",
             global->iteration_count ) ;
-    
+
     fprintf( fd, "    Resource Usage\n" ) ;
-    fprintf( fd, "\tNumber of patches:            %d\n", total_patches ) ;
-    fprintf( fd, "\tTotal number of elements:     %d\n", total_elements ) ;
-    fprintf( fd, "\tTotal number of interactions: %d\n", total_interactions);
-    fprintf( fd, "\t          completely visible: %d\n",
+    fprintf( fd, "\tNumber of patches:            %ld\n", total_patches ) ;
+    fprintf( fd, "\tTotal number of elements:     %ld\n", total_elements ) ;
+    fprintf( fd, "\tTotal number of interactions: %ld\n", total_interactions);
+    fprintf( fd, "\t          completely visible: %ld\n",
             total_comp_visible_interactions ) ;
-    fprintf( fd, "\t        completely invisible: %d\n",
+    fprintf( fd, "\t        completely invisible: %ld\n",
             total_invisible_interactions ) ;
-    fprintf( fd, "\t           partially visible: %d\n",
+    fprintf( fd, "\t           partially visible: %ld\n",
             total_interactions - total_comp_visible_interactions
             - total_invisible_interactions ) ;
     fprintf( fd, "\tInteraction coherence (root interaction not counted)\n");
-    fprintf( fd, "\t       Common for 4 siblings: %d\n", total_match3 ) ;
-    fprintf( fd, "\t       Common for 3 siblings: %d\n", total_match2 ) ;
-    fprintf( fd, "\t       Common for 2 siblings: %d\n", total_match1 ) ;
-    fprintf( fd, "\t       Common for no sibling: %d\n", total_match0 ) ;
+    fprintf( fd, "\t       Common for 4 siblings: %ld\n", total_match3 ) ;
+    fprintf( fd, "\t       Common for 3 siblings: %ld\n", total_match2 ) ;
+    fprintf( fd, "\t       Common for 2 siblings: %ld\n", total_match1 ) ;
+    fprintf( fd, "\t       Common for no sibling: %ld\n", total_match0 ) ;
     fprintf( fd, "\tAvg. elements per patch:      %.1f\n",
             (float)total_elements / (float)total_patches ) ;
     fprintf( fd, "\tAvg. interactions per patch:  %.1f\n",
             (float)total_interactions / (float)total_patches ) ;
     fprintf( fd, "\tAvg. interactions per element:%.1f\n",
             (float)total_interactions / (float)total_elements ) ;
-    fprintf( fd, "\tNumber of elements in equivalent uniform mesh: %d\n",
+    fprintf( fd, "\tNumber of elements in equivalent uniform mesh: %ld\n",
             total_equiv_elements ) ;
     fprintf( fd, "\tElem(hierarchical)/Elem(uniform): %.2f%%\n",
             (float)total_elements / (float)total_equiv_elements * 100.0 ) ;
@@ -186,59 +182,56 @@
  *
  ***********************************************************/
 
-void print_per_process_info( fd, process )
-  
-FILE *fd ;
-unsigned process ;
+void print_per_process_info(FILE *fd, long process)
 {
-    int cache_line ;
-    int iteration ;
+    long cache_line ;
+    long iteration ;
     StatisticalInfo *ps ;
     Element *e ;
-    
+
     ps = &global->stat_info[process] ;
-    
-    fprintf( fd, "\t\tModeling tasks:            %d\n",
+
+    fprintf( fd, "\t\tModeling tasks:            %ld\n",
     ps->total_modeling_tasks ) ;
-    fprintf( fd, "\t\tDefine patch tasks:        %d\n",
+    fprintf( fd, "\t\tDefine patch tasks:        %ld\n",
     ps->total_def_patch_tasks ) ;
-    fprintf( fd, "\t\tFF refinement tasks:       %d\n",
+    fprintf( fd, "\t\tFF refinement tasks:       %ld\n",
     ps->total_ff_ref_tasks ) ;
-    fprintf( fd, "\t\tRay processing tasks:      %d\n",
+    fprintf( fd, "\t\tRay processing tasks:      %ld\n",
     ps->total_ray_tasks ) ;
-    fprintf( fd, "\t\tRadiosity Avg/Norm tasks:  %d\n",
+    fprintf( fd, "\t\tRadiosity Avg/Norm tasks:  %ld\n",
     ps->total_radavg_tasks ) ;
-    fprintf( fd, "\t\tInteraction computations:  %d\n",
+    fprintf( fd, "\t\tInteraction computations:  %ld\n",
     ps->total_interaction_comp ) ;
-    fprintf( fd, "\t\tVisibility computations:   %d\n",
+    fprintf( fd, "\t\tVisibility computations:   %ld\n",
     ps->total_visibility_comp ) ;
-    fprintf( fd, "\t\t   (%d of %d were partially visible)\n",
+    fprintf( fd, "\t\t   (%ld of %ld were partially visible)\n",
     ps->partially_visible,
     ps->total_visibility_comp ) ;
-    fprintf( fd, "\t\tRay intersection tests:    %d\n",
+    fprintf( fd, "\t\tRay intersection tests:    %ld\n",
     ps->total_ray_intersect_test ) ;
     fprintf( fd, "\t\tPatch cache hit ratio:     %.2f%%\n",
     ps->total_patch_cache_hit * 100 /
     (ps->total_patch_cache_check + 0.01) ) ;
     for( cache_line = 0 ; cache_line < PATCH_CACHE_SIZE ; cache_line++ )
-    fprintf( fd, "\t\t    (level %d):             %.2f%%\n",
+    fprintf( fd, "\t\t    (level %ld):             %.2f%%\n",
     cache_line,
     ps->patch_cache_hit[cache_line] * 100 /
     (ps->total_patch_cache_check + 0.01));
-    
+
     /* Per iteration info */
     fprintf( fd, "\t\tPer iteration info.\n" ) ;
     for( iteration = 0 ; iteration < global->iteration_count ; iteration++ )
     {
-        fprintf( fd, "\t\t     [%d]  Interaction comp:   %d\n",
+        fprintf( fd, "\t\t     [%ld]  Interaction comp:   %ld\n",
         iteration, ps->per_iteration[iteration].visibility_comp ) ;
-        fprintf( fd, "\t\t          Ray Intersection:   %d\n",
+        fprintf( fd, "\t\t          Ray Intersection:   %ld\n",
         ps->per_iteration[iteration].ray_intersect_test ) ;
-        fprintf( fd, "\t\t          Tasks from my Q:    %d\n",
+        fprintf( fd, "\t\t          Tasks from my Q:    %ld\n",
         ps->per_iteration[iteration].tasks_from_myq ) ;
-        fprintf( fd, "\t\t          Tasks from other Q: %d\n",
+        fprintf( fd, "\t\t          Tasks from other Q: %ld\n",
         ps->per_iteration[iteration].tasks_from_otherq ) ;
-        fprintf( fd, "\t\t     Process_task wait count: %d\n",
+        fprintf( fd, "\t\t     Process_task wait count: %ld\n",
         ps->per_iteration[iteration].process_tasks_wait ) ;
         e = ps->per_iteration[iteration].last_pr_task ;
         if( e == 0 )
@@ -246,13 +239,13 @@
         if( e->parent == 0 )
         {
             fprintf( fd, "\t\t          Last task: Patch level\n" ) ;
-            fprintf( fd, "\t\t           (%d root inter)\n",
+            fprintf( fd, "\t\t           (%ld root inter)\n",
             e->n_interactions ) ;
         }
         else
         {
             fprintf( fd, "\t\t          Last task: Elem level\n" ) ;
-            fprintf( fd, "\t\t           (%d inter, %.3f Elem/Patch)\n",
+            fprintf( fd, "\t\t           (%ld inter, %.3f Elem/Patch)\n",
             e->n_interactions, e->area / e->patch->area ) ;
         }
     }
@@ -266,22 +259,16 @@
 *
 ***********************************************************/
 
-int   n_elements_in_patch ;
-int   n_equiv_elem_in_patch ;
+long   n_elements_in_patch ;
+long   n_equiv_elem_in_patch ;
 float min_elem_area ;
-int   n_interactions_in_patch ;
-int   n_comp_visible_interactions ;
-int   n_invisible_interactions ;
-
+long   n_interactions_in_patch ;
+long   n_comp_visible_interactions ;
+long   n_invisible_interactions ;
 
-void get_patch_stat( patch, dummy, process_id )
 
-Patch *patch ;
-int dummy ;
-unsigned process_id;
+void get_patch_stat(Patch *patch, long dummy, long process_id)
 {
-    void get_elem_stat() ;
-    
     /* Initialize stat info for element */
     n_elements_in_patch = 0 ;
     n_equiv_elem_in_patch = 1 ;
@@ -289,10 +276,10 @@
     n_interactions_in_patch = 0 ;
     n_comp_visible_interactions = 0 ;
     n_invisible_interactions = 0 ;
-    
+
     /* Traverse the quad tree */
     foreach_element_in_patch( patch, get_elem_stat, 0, process_id ) ;
-    
+
     /* Update global stat variables */
     total_patches++ ;
     total_elements += n_elements_in_patch ;
@@ -300,7 +287,7 @@
     total_interactions += n_interactions_in_patch ;
     total_comp_visible_interactions += n_comp_visible_interactions ;
     total_invisible_interactions += n_invisible_interactions ;
-    
+
 #if PATCH_ASSIGNMENT == PATCH_ASSIGNMENT_COSTBASED
     if( n_interactions_in_patch
     != global->patch_cost[patch->seq_no].n_total_inter )
@@ -313,28 +300,22 @@
 #endif
 }
 
-void get_elem_stat( elem,  dummy, process_id )
-
-Element *elem ;
-int dummy ;
-unsigned process_id;
+void get_elem_stat(Element *elem, long dummy, long process_id)
 {
     Interaction *pi ;
-    int p_visible = 0 ;
-    int c_visible = 0 ;
-    int i_visible = 0 ;
-    int match0, match1, match2, match3 ;
-    void count_interaction() ;
-    
-    
+    long p_visible = 0 ;
+    long c_visible = 0 ;
+    long i_visible = 0 ;
+    long match0, match1, match2, match3 ;
+
     n_elements_in_patch++ ;
-    
+
     while( elem->area < min_elem_area )
     {
         min_elem_area *= 0.25 ;
         n_equiv_elem_in_patch *= 4 ;
     }
-    
+
     /* Classify visibility */
     n_interactions_in_patch += elem->n_interactions ;
     for( pi = elem->interactions ; pi ; pi = pi->next )
@@ -349,15 +330,15 @@
     if( i_visible + c_visible + p_visible != elem->n_interactions )
     printf( "Fatal: Interactions count miss match\n" ) ;
     if( elem->n_vis_undef_inter != 0 )
-    printf( "Fatal: Visibility undef list count non zero(%d)\n",
+    printf( "Fatal: Visibility undef list count non zero(%ld)\n",
     elem->n_vis_undef_inter ) ;
     if( elem->vis_undef_inter != 0 )
     printf( "Fatal: Visibility undef list not empty\n" ) ;
-    
+
     n_comp_visible_interactions += c_visible ;
     n_invisible_interactions    += i_visible ;
-    
-    
+
+
     /* Count interactions / element */
     if( elem->n_interactions > MAX_INTERACTION_PER_ELEMENT )
     {
@@ -369,12 +350,12 @@
         elem_interaction[ elem->n_interactions ].count++ ;
         elem_interaction[ elem->n_interactions ].area += elem->area ;
     }
-    
+
     /* Analyze object coherence */
     if( ! LEAF_ELEMENT( elem ) )
     {
         match0 = match1 = match2 = match3 = 0 ;
-        
+
         count_interaction(elem->center, elem->top, elem->right, elem->left,
         &match3, &match2, &match1, &match0, process_id ) ;
         count_interaction(elem->top, elem->right, elem->left, elem->center,
@@ -383,7 +364,7 @@
         &match3, &match2, &match1, &match0, process_id ) ;
         count_interaction(elem->left, elem->center, elem->top, elem->right,
         &match3, &match2, &match1, &match0, process_id ) ;
-        
+
         total_match3 += match3 ;
         total_match2 += match2 ;
         total_match1 += match1 ;
@@ -393,14 +374,11 @@
 
 
 
-void count_interaction( es, e1, e2, e3, c3, c2, c1, c0, process_id )
-Element *es, *e1, *e2, *e3 ;
-int *c3, *c2, *c1, *c0 ;
-unsigned process_id;
+void count_interaction(Element *es, Element *e1, Element *e2, Element *e3, long *c3, long *c2, long *c1, long *c0, long process_id)
 {
     Interaction *pi ;
-    int occurrence ;
-    
+    long occurrence ;
+
     for( pi = es->interactions ; pi ; pi = pi->next )
     {
         occurrence  = search_intearction( e1->interactions, pi, process_id ) ;
@@ -416,19 +394,16 @@
     }
 }
 
-int search_intearction( int_list, inter, process_id )
-
-Interaction *int_list, *inter ;
-unsigned process_id;
+long search_intearction(Interaction *int_list, Interaction *inter, long process_id)
 {
     while( int_list )
     {
         if( int_list->destination == inter->destination )
         return( 1 ) ;
-        
+
         int_list = int_list->next ;
     }
-    
+
     return( 0 ) ;
 }
 
@@ -438,18 +413,17 @@
 *
 ****************************************/
 
-void print_running_time(process_id)
-unsigned process_id;
+void print_running_time(long process_id)
 {
-    int time_diff, time_diff1 ;
-    
+    long time_diff, time_diff1 ;
+
     time_diff = time_rad_end - time_rad_start ;
     time_diff1 = time_rad_end - timing[0]->rad_start;
     if( time_diff < 0 )
     time_diff += CLOCK_MAX_VAL ;
     if( time_diff1 < 0 )
     time_diff1 += CLOCK_MAX_VAL ;
-    
+
     printf( "\tOverall start time\t%20lu\n", time_rad_start);
     printf( "\tOverall end time\t%20lu\n", time_rad_end);
     printf( "\tTotal time with initialization\t%20lu\n", time_diff);
@@ -463,22 +437,21 @@
 *
 ****************************************/
 
-void print_fork_time(process_id)
-unsigned process_id;
+void print_fork_time(long process_id)
 {
-    int pid ;
-    
+    long pid ;
+
     if( n_processors <= 1 )
     return ;
-    
+
     printf( "\tProcess fork overhead\n" ) ;
     for( pid = 0 ; pid < n_processors-1 ; pid++ )
     {
-        printf( "\t Process %d  %.2f mS\n",
+        printf( "\t Process %ld  %.2f mS\n",
         pid,
         (timing[pid]->rad_start - time_rad_start) / 1000.0 ) ;
     }
-    
+
     printf( "\t (total)    %.2f mS\n",
     (time_process_start[n_processors-2] - time_rad_start) / 1000.0 ) ;
 }
@@ -490,13 +463,12 @@
 *
 ****************************************/
 
-void init_stat_info(process_id)
-unsigned process_id;
+void init_stat_info(long process_id)
 {
-    int pid ;
-    int i ;
+    long pid ;
+    long i ;
     StatisticalInfo *ps ;
-    
+
     for( pid = 0 ; pid < MAX_PROCESSORS ; pid++ )
     {
         ps = &global->stat_info[ pid ] ;
@@ -511,10 +483,10 @@
         ps->total_ray_intersect_test= 0 ;
         ps->total_patch_cache_check = 0 ;
         ps->total_patch_cache_hit   = 0 ;
-        
+
         for( i = 0 ; i < PATCH_CACHE_SIZE ; i++ )
         ps->patch_cache_hit[i]   = 0 ;
-        
+
         for( i = 0 ; i < MAX_ITERATION_INFO ; i++ )
         {
             ps->per_iteration[ i ].visibility_comp    = 0 ;
@@ -535,41 +507,28 @@
 ***********************************************************/
 
 
-void clear_radiosity(process_id)
-unsigned process_id;
+void clear_radiosity(long process_id)
 {
-    void clear_patch_radiosity() ;
-    
     foreach_patch_in_bsp( clear_patch_radiosity,  0, 0 ) ;
 }
 
 
-static void clear_element_radiosity() ;
-
-void clear_patch_radiosity( patch, dummy, process_id )
-
-Patch *patch ;
-int dummy ;
-unsigned process_id;
+void clear_patch_radiosity(Patch *patch, long dummy, long process_id)
 {
     foreach_element_in_patch( patch, clear_element_radiosity, 0, process_id ) ;
 }
 
 
-static void clear_element_radiosity( elem, dummy, process_id )
-
-Element *elem ;
-int dummy ;
-unsigned process_id;
+static void clear_element_radiosity(Element *elem, long dummy, long process_id)
 {
     elem->rad.r = 0 ;
     elem->rad.g = 0 ;
     elem->rad.b = 0 ;
-    
+
     elem->rad_subtree.r = 0 ;
     elem->rad_subtree.g = 0 ;
     elem->rad_subtree.b = 0 ;
-    
+
     global->prev_total_energy = global->total_energy ;
     global->total_energy.r = 0 ;
     global->total_energy.g = 0 ;
diff -Naur splash2/codes/apps/radiosity/room_model.C splash2-modified/codes/apps/radiosity/room_model.C
--- splash2/codes/apps/radiosity/room_model.C	1994-10-18 13:37:23.000000000 -0400
+++ splash2-modified/codes/apps/radiosity/room_model.C	2007-03-16 23:50:28.000000000 -0400
@@ -28,3579 +28,3581 @@
 
 EXTERN_ENV;
 
+#include <stdio.h>
+
 include(radiosity.h)
-  
 
-ModelDataBase room_model[] = 
+
+ModelDataBase room_model[] =
 {
-    
+
     /** Patch 0 **/
     { MODEL_RECTANGLE,
         { { 0.615686, 0.737255, 0.870588 }, { 0.000000, 0.000000, 0.000000 },
             { { 847.000000, -800.002014, 700.000000 },
                 { -847.000000, -800.002014, 700.000000 },
                 { 847.000000, 800.002014, 700.000000 } } } },
-    
+
     /** Patch 1 **/
     { MODEL_RECTANGLE,
         { { 0.615686, 0.737255, 0.870588 }, { 0.000000, 0.000000, 0.000000 },
             { { -847.000000, -800.002014, -1001.000000 },
                 { 847.000000, -800.002014, -1001.000000 },
                 { -847.000000, 800.002014, -1001.000000 } } } },
-    
+
     /** Patch 2 **/
     { MODEL_RECTANGLE,
         { { 0.615686, 0.737255, 0.870588 }, { 0.000000, 0.000000, 0.000000 },
             { { 847.000000, -800.002014, -1001.000000 },
                 { 847.000000, -800.002014, 700.000000 },
                 { 847.000000, 800.002014, -1001.000000 } } } },
-    
+
     /** Patch 3 **/
     { MODEL_RECTANGLE,
         { { 0.615686, 0.737255, 0.870588 }, { 0.000000, 0.000000, 0.000000 },
             { { -847.000000, -800.002014, 700.000000 },
                 { -847.000000, -800.002014, -1001.000000 },
                 { -847.000000, 800.002014, 700.000000 } } } },
-    
+
     /** Patch 4 **/
     { MODEL_RECTANGLE,
         { { 0.603921, 0.603921, 0.603921 }, { 0.000000, 0.000000, 0.000000 },
             { { 847.000000, 800.002014, 700.000000 },
                 { -847.000000, 800.002014, 700.000000 },
                 { 847.000000, 800.002014, -1001.000000 } } } },
-    
+
     /** Patch 5 **/
     { MODEL_RECTANGLE,
         { { 0.501961, 0.501961, 0.501961 }, { 0.000000, 0.000000, 0.000000 },
             { { 847.000000, -800.002014, -1001.000000 },
                 { -847.000000, -800.002014, -1001.000000 },
                 { 847.000000, -800.002014, 700.000000 } } } },
-    
+
     /** Patch 6 **/
     { MODEL_RECTANGLE,
         { { 0.576470, 0.521569, 0.521568 }, { 0.000000, 0.000000, 0.000000 },
             { { -269.149994, -216.666794, -1001.000000 },
                 { 165.895096, -216.666794, -1001.000000 },
                 { -269.149994, 281.666687, -1001.000000 } } } },
-    
+
     /** Patch 7 **/
     { MODEL_RECTANGLE,
         { { 0.098034, 0.086275, 0.074510 }, { 0.000000, 0.000000, 0.000000 },
             { { -840.000061, -159.999695, 285.980103 },
                 { -840.000061, -159.999695, -404.214966 },
                 { -840.000061, 298.332977, 285.980103 } } } },
-    
+
     /** Patch 8 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -84.000000, -350.000000, -999.999023 },
                 { -840.000061, -350.000000, -159.998962 },
                 { -84.000000, -299.999695, -999.999023 } } } },
-    
+
     /** Patch 9 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -840.000061, -350.000000, -159.998962 },
                 { -84.000000, -350.000000, -999.999023 },
                 { -336.000000, -350.000000, 155.000305 } } } },
-    
+
     /** Patch 10 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -336.000000, -299.999695, 155.000305 },
                 { 420.000031, -299.999695, -684.999023 },
                 { -840.000061, -299.999695, -159.998962 } } } },
-    
+
     /** Patch 11 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -336.000000, -350.000000, 155.000305 },
                 { 420.000031, -350.000000, -684.999023 },
                 { -336.000000, -299.999695, 155.000305 } } } },
-    
+
     /** Patch 12 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 420.000031, -350.000000, -684.999023 },
                 { -84.000000, -350.000000, -999.999023 },
                 { 420.000031, -299.999695, -684.999023 } } } },
-    
+
     /** Patch 13 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -840.000061, -350.000000, -159.998962 },
                 { -336.000000, -350.000000, 155.000305 },
                 { -840.000061, -299.999695, -159.998962 } } } },
-    
+
     /** Patch 14 **/
     { MODEL_RECTANGLE,
         { { 0.682353, 0.247059, 0.011765 }, { 0.000000, 0.000000, 0.000000 },
             { { -306.000092, -800.002014, 80.000183 },
                 { -786.001953, -800.002014, -220.003052 },
                 { -306.000092, -350.000000, 80.000183 } } } },
-    
+
     /** Patch 15 **/
     { MODEL_RECTANGLE,
         { { 0.682353, 0.247059, 0.011765 }, { 0.000000, 0.000000, 0.000000 },
             { { -341.999695, -800.002014, 120.000305 },
                 { -306.000092, -800.002014, 80.000183 },
                 { -341.999695, -350.000000, 120.000305 } } } },
-    
+
     /** Patch 16 **/
     { MODEL_RECTANGLE,
         { { 0.682353, 0.247059, 0.011765 }, { 0.000000, 0.000000, 0.000000 },
             { { -786.001953, -800.002014, -220.003052 },
                 { -822.002930, -800.002014, -179.998047 },
                 { -786.001953, -350.000000, -220.003052 } } } },
-    
+
     /** Patch 17 **/
     { MODEL_RECTANGLE,
         { { 0.682353, 0.247059, 0.011765 }, { 0.000000, 0.000000, 0.000000 },
             { { -822.002930, -800.002014, -179.998047 },
                 { -341.999695, -800.002014, 120.000305 },
                 { -822.002930, -350.000000, -179.998047 } } } },
-    
+
     /** Patch 18 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 113.999901, -533.332825, -345.001953 },
                 { 420.000031, -533.332825, -684.999023 },
                 { 113.999901, -500.000214, -345.001953 } } } },
-    
+
     /** Patch 19 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 420.000031, -533.332825, -684.999023 },
                 { -84.000000, -533.332825, -999.999023 },
                 { 420.000031, -500.000214, -684.999023 } } } },
-    
+
     /** Patch 20 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 113.999901, -500.000214, -345.001953 },
                 { 420.000031, -500.000214, -684.999023 },
                 { -390.000092, -500.000214, -660.001953 } } } },
-    
+
     /** Patch 21 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -390.000092, -533.332825, -660.001953 },
                 { -84.000000, -533.332825, -999.999023 },
                 { 113.999901, -533.332825, -345.001953 } } } },
-    
+
     /** Patch 22 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -84.000000, -533.332825, -999.999023 },
                 { -390.000092, -533.332825, -660.001953 },
                 { -84.000000, -500.000214, -999.999023 } } } },
-    
+
     /** Patch 23 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -390.000092, -533.332825, -660.001953 },
                 { 113.999901, -533.332825, -345.001953 },
                 { -390.000092, -500.000214, -660.001953 } } } },
-    
+
     /** Patch 24 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 113.999901, -700.000000, -345.001953 },
                 { 420.000031, -700.000000, -684.999023 },
                 { 113.999901, -666.666687, -345.001953 } } } },
-    
+
     /** Patch 25 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 420.000031, -700.000000, -684.999023 },
                 { -84.000000, -700.000000, -999.999023 },
                 { 420.000031, -666.666687, -684.999023 } } } },
-    
+
     /** Patch 26 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 113.999901, -666.666687, -345.001953 },
                 { 420.000031, -666.666687, -684.999023 },
                 { -390.000092, -666.666687, -660.001953 } } } },
-    
+
     /** Patch 27 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -390.000092, -700.000000, -660.001953 },
                 { -84.000000, -700.000000, -999.999023 },
                 { 113.999901, -700.000000, -345.001953 } } } },
-    
+
     /** Patch 28 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -84.000000, -700.000000, -999.999023 },
                 { -390.000092, -700.000000, -660.001953 },
                 { -84.000000, -666.666687, -999.999023 } } } },
-    
+
     /** Patch 29 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -390.000092, -700.000000, -660.001953 },
                 { 113.999901, -700.000000, -345.001953 },
                 { -390.000092, -666.666687, -660.001953 } } } },
-    
+
     /** Patch 30 **/
     { MODEL_RECTANGLE,
         { { 0.682353, 0.247059, 0.011765 }, { 0.000000, 0.000000, 0.000000 },
             { { -138.000107, -500.000214, -940.001953 },
                 { 341.999695, -500.000214, -640.002930 },
                 { -138.000107, -350.000000, -940.001953 } } } },
-    
+
     /** Patch 31 **/
     { MODEL_RECTANGLE,
         { { 0.682353, 0.247059, 0.011765 }, { 0.000000, 0.000000, 0.000000 },
             { { 341.999695, -500.000214, -640.002930 },
                 { 378.000000, -500.000214, -680.000977 },
                 { 341.999695, -350.000000, -640.002930 } } } },
-    
+
     /** Patch 32 **/
     { MODEL_RECTANGLE,
         { { 0.682353, 0.247059, 0.011765 }, { 0.000000, 0.000000, 0.000000 },
             { { 378.000000, -500.000214, -680.000977 },
                 { -101.999802, -500.000214, -980.000122 },
                 { 378.000000, -350.000000, -680.000977 } } } },
-    
+
     /** Patch 33 **/
     { MODEL_RECTANGLE,
         { { 0.682353, 0.247059, 0.011765 }, { 0.000000, 0.000000, 0.000000 },
             { { -101.999802, -500.000214, -980.000122 },
                 { -138.000107, -500.000214, -940.001953 },
                 { -101.999802, -350.000000, -980.000122 } } } },
-    
+
     /** Patch 34 **/
     { MODEL_RECTANGLE,
         { { 0.682353, 0.247059, 0.011765 }, { 0.000000, 0.000000, 0.000000 },
             { { -138.000107, -666.666687, -940.001953 },
                 { 341.999695, -666.666687, -640.002930 },
                 { -138.000107, -533.332825, -940.001953 } } } },
-    
+
     /** Patch 35 **/
     { MODEL_RECTANGLE,
         { { 0.682353, 0.247059, 0.011765 }, { 0.000000, 0.000000, 0.000000 },
             { { 341.999695, -666.666687, -640.002930 },
                 { 378.000000, -666.666687, -680.000977 },
                 { 341.999695, -533.332825, -640.002930 } } } },
-    
+
     /** Patch 36 **/
     { MODEL_RECTANGLE,
         { { 0.682353, 0.247059, 0.011765 }, { 0.000000, 0.000000, 0.000000 },
             { { 378.000000, -666.666687, -680.000977 },
                 { -101.999802, -666.666687, -980.000122 },
                 { 378.000000, -533.332825, -680.000977 } } } },
-    
+
     /** Patch 37 **/
     { MODEL_RECTANGLE,
         { { 0.682353, 0.247059, 0.011765 }, { 0.000000, 0.000000, 0.000000 },
             { { -101.999802, -666.666687, -980.000122 },
                 { -138.000107, -666.666687, -940.001953 },
                 { -101.999802, -533.332825, -980.000122 } } } },
-    
+
     /** Patch 38 **/
     { MODEL_RECTANGLE,
         { { 0.682353, 0.247059, 0.011765 }, { 0.000000, 0.000000, 0.000000 },
             { { -138.000107, -800.002014, -940.001953 },
                 { 341.999695, -800.002014, -640.002930 },
                 { -138.000107, -700.000000, -940.001953 } } } },
-    
+
     /** Patch 39 **/
     { MODEL_RECTANGLE,
         { { 0.682353, 0.247059, 0.011765 }, { 0.000000, 0.000000, 0.000000 },
             { { 341.999695, -800.002014, -640.002930 },
                 { 378.000000, -800.002014, -680.000977 },
                 { 341.999695, -700.000000, -640.002930 } } } },
-    
+
     /** Patch 40 **/
     { MODEL_RECTANGLE,
         { { 0.682353, 0.247059, 0.011765 }, { 0.000000, 0.000000, 0.000000 },
             { { 378.000000, -800.002014, -680.000977 },
                 { -101.999802, -800.002014, -980.000122 },
                 { 378.000000, -700.000000, -680.000977 } } } },
-    
+
     /** Patch 41 **/
     { MODEL_RECTANGLE,
         { { 0.682353, 0.247059, 0.011765 }, { 0.000000, 0.000000, 0.000000 },
             { { -101.999802, -800.002014, -980.000122 },
                 { -138.000107, -800.002014, -940.001953 },
                 { -101.999802, -700.000000, -980.000122 } } } },
-    
+
     /** Patch 42 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { 108.000198, -500.000214, -380.002075 },
                 { 120.000298, -500.000214, -393.337036 },
                 { 108.000198, -350.000000, -380.002075 } } } },
-    
+
     /** Patch 43 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { 104.000397, -500.000214, -403.333008 },
                 { 91.999603, -500.000214, -389.998047 },
                 { 104.000397, -350.000000, -403.333008 } } } },
-    
+
     /** Patch 44 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { 120.000298, -500.000214, -393.337036 },
                 { 104.000397, -500.000214, -403.333008 },
                 { 120.000298, -350.000000, -393.337036 } } } },
-    
+
     /** Patch 45 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { 91.999603, -500.000214, -389.998047 },
                 { 108.000198, -500.000214, -380.002075 },
                 { 91.999603, -350.000000, -389.998047 } } } },
-    
+
     /** Patch 46 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { 108.000198, -666.666687, -380.002075 },
                 { 120.000298, -666.666687, -393.337036 },
                 { 108.000198, -533.332825, -380.002075 } } } },
-    
+
     /** Patch 47 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { 104.000397, -666.666687, -403.333008 },
                 { 91.999603, -666.666687, -389.998047 },
                 { 104.000397, -533.332825, -403.333008 } } } },
-    
+
     /** Patch 48 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { 120.000298, -666.666687, -393.337036 },
                 { 104.000397, -666.666687, -403.333008 },
                 { 120.000298, -533.332825, -393.337036 } } } },
-    
+
     /** Patch 49 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { 91.999603, -666.666687, -389.998047 },
                 { 108.000198, -666.666687, -380.002075 },
                 { 91.999603, -533.332825, -389.998047 } } } },
-    
+
     /** Patch 50 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -308.000000, -500.000214, -640.002930 },
                 { -295.999207, -500.000214, -653.331055 },
                 { -308.000000, -350.000000, -640.002930 } } } },
-    
+
     /** Patch 51 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -295.999207, -500.000214, -653.331055 },
                 { -311.999786, -500.000214, -663.333984 },
                 { -295.999207, -350.000000, -653.331055 } } } },
-    
+
     /** Patch 52 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -311.999786, -500.000214, -663.333984 },
                 { -323.999908, -500.000214, -649.999023 },
                 { -311.999786, -350.000000, -663.333984 } } } },
-    
+
     /** Patch 53 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -323.999908, -500.000214, -649.999023 },
                 { -308.000000, -500.000214, -640.002930 },
                 { -323.999908, -350.000000, -649.999023 } } } },
-    
+
     /** Patch 54 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -308.000000, -666.666687, -640.002930 },
                 { -295.999207, -666.666687, -653.331055 },
                 { -308.000000, -533.332825, -640.002930 } } } },
-    
+
     /** Patch 55 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -295.999207, -666.666687, -653.331055 },
                 { -311.999786, -666.666687, -663.333984 },
                 { -295.999207, -533.332825, -653.331055 } } } },
-    
+
     /** Patch 56 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -311.999786, -666.666687, -663.333984 },
                 { -323.999908, -666.666687, -649.999023 },
                 { -311.999786, -533.332825, -663.333984 } } } },
-    
+
     /** Patch 57 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -323.999908, -666.666687, -649.999023 },
                 { -308.000000, -666.666687, -640.002930 },
                 { -323.999908, -533.332825, -649.999023 } } } },
-    
+
     /** Patch 58 **/
     { MODEL_RECTANGLE,
         { { 0.183806, 0.551419, 0.919032 }, { 0.000000, 0.000000, 0.000000 },
             { { 433.708832, -566.666809, -144.088013 },
                 { 298.470917, -566.666809, 97.593323 },
                 { 424.914001, -534.328918, -147.503967 } } } },
-    
+
     /** Patch 59 **/
     { MODEL_RECTANGLE,
         { { 0.183806, 0.551419, 0.919032 }, { 0.000000, 0.000000, 0.000000 },
             { { 298.470917, -566.666809, 97.593323 },
                 { 509.488007, -518.146973, 179.592041 },
                 { 289.676117, -534.328918, 94.175232 } } } },
-    
+
     /** Patch 60 **/
     { MODEL_RECTANGLE,
         { { 0.183806, 0.551419, 0.919032 }, { 0.000000, 0.000000, 0.000000 },
             { { 644.725891, -518.146973, -62.090027 },
                 { 433.708832, -566.666809, -144.088013 },
                 { 635.931091, -485.809113, -65.505981 } } } },
-    
+
     /** Patch 61 **/
     { MODEL_RECTANGLE,
         { { 0.183806, 0.551419, 0.919032 }, { 0.000000, 0.000000, 0.000000 },
             { { 433.708832, -566.666809, -144.088013 },
                 { 644.725891, -518.146973, -62.090027 },
                 { 298.470917, -566.666809, 97.593323 } } } },
-    
+
     /** Patch 62 **/
     { MODEL_RECTANGLE,
         { { 0.183806, 0.551419, 0.919032 }, { 0.000000, 0.000000, 0.000000 },
             { { 509.488007, -518.146973, 179.592041 },
                 { 644.725891, -518.146973, -62.090027 },
                 { 500.693207, -485.809113, 176.174622 } } } },
-    
+
     /** Patch 63 **/
     { MODEL_RECTANGLE,
         { { 0.183806, 0.551419, 0.919032 }, { 0.000000, 0.000000, 0.000000 },
             { { 289.676117, -534.328918, 94.175232 },
                 { 500.693207, -485.809113, 176.174622 },
                 { 424.914001, -534.328918, -147.503967 } } } },
-    
+
     /** Patch 64 **/
     { MODEL_RECTANGLE,
         { { 0.183806, 0.551419, 0.919032 }, { 0.000000, 0.000000, 0.000000 },
             { { 188.395203, -633.333435, -257.802979 },
                 { 356.457520, -695.767822, -192.500000 },
                 { 36.252300, -633.333435, 14.087463 } } } },
-    
+
     /** Patch 65 **/
     { MODEL_RECTANGLE,
         { { 0.183806, 0.551419, 0.919032 }, { 0.000000, 0.000000, 0.000000 },
             { { 36.252300, -633.333435, 14.087463 },
                 { 204.315292, -695.767822, 79.394714 },
                 { 49.833000, -602.427002, 19.364807 } } } },
-    
+
     /** Patch 66 **/
     { MODEL_RECTANGLE,
         { { 0.183806, 0.551419, 0.919032 }, { 0.000000, 0.000000, 0.000000 },
             { { 356.457520, -695.767822, -192.500000 },
                 { 188.395203, -633.333435, -257.802979 },
                 { 370.038208, -664.861389, -187.221985 } } } },
-    
+
     /** Patch 67 **/
     { MODEL_RECTANGLE,
         { { 0.183806, 0.551419, 0.919032 }, { 0.000000, 0.000000, 0.000000 },
             { { 204.315292, -695.767822, 79.394714 },
                 { 356.457520, -695.767822, -192.500000 },
                 { 217.895294, -664.861389, 84.671997 } } } },
-    
+
     /** Patch 68 **/
     { MODEL_RECTANGLE,
         { { 0.183806, 0.551419, 0.919032 }, { 0.000000, 0.000000, 0.000000 },
             { { 188.395203, -633.333435, -257.802979 },
                 { 36.252300, -633.333435, 14.087463 },
                 { 201.975204, -602.427002, -252.524963 } } } },
-    
+
     /** Patch 69 **/
     { MODEL_RECTANGLE,
         { { 0.183806, 0.551419, 0.919032 }, { 0.000000, 0.000000, 0.000000 },
             { { 49.833000, -602.427002, 19.364807 },
                 { 217.895294, -664.861389, 84.671997 },
                 { 201.975204, -602.427002, -252.524963 } } } },
-    
+
     /** Patch 70 **/
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { 650.722107, -800.002014, 10.894836 },
                 { 580.434387, -800.002014, 136.506287 },
                 { 533.348206, -541.608887, -85.043030 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { 416.794708, -541.608887, 123.246887 },
                 { 533.348206, -541.608887, -85.043030 },
                 { 580.434387, -800.002014, 136.506287 } } } },
-    
+
     /** Patch 71 **/
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { 650.722107, -800.002014, 10.894836 },
                 { 533.348206, -541.608887, -85.043030 },
                 { 689.917908, -800.002014, 29.029724 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { 568.779419, -533.325073, -69.986023 },
                 { 689.917908, -800.002014, 29.029724 },
                 { 533.348206, -541.608887, -85.043030 } } } },
-    
+
     /** Patch 72 **/
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { 416.794708, -541.608887, 123.246887 },
                 { 580.434387, -800.002014, 136.506287 },
                 { 453.411713, -533.325073, 136.186401 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { 622.298584, -800.002014, 149.870728 },
                 { 453.411713, -533.325073, 136.186401 },
                 { 580.434387, -800.002014, 136.506287 } } } },
-    
+
     /** Patch 73 **/
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { 622.298584, -800.002014, 149.870728 },
                 { 689.917908, -800.002014, 29.029724 },
                 { 453.411713, -533.325073, 136.186401 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { 568.779419, -533.325073, -69.986023 },
                 { 453.411713, -533.325073, 136.186401 },
                 { 689.917908, -800.002014, 29.029724 } } } },
-    
+
     /** Patch 74 **/
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { 67.053001, -800.002014, -25.025024 },
                 { 172.239197, -800.002014, -213.003052 },
                 { 147.604797, -670.852722, 34.824341 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { 279.033295, -670.852722, -200.052979 },
                 { 147.604797, -670.852722, 34.824341 },
                 { 172.239197, -800.002014, -213.003052 } } } },
-    
+
     /** Patch 75 **/
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { 279.033295, -670.852722, -200.052979 },
                 { 172.239197, -800.002014, -213.003052 },
                 { 244.124313, -658.100830, -212.344971 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { 126.785400, -800.002014, -226.576050 },
                 { 244.124313, -658.100830, -212.344971 },
                 { 172.239197, -800.002014, -213.003052 } } } },
-    
+
     /** Patch 76 **/
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { 67.053001, -800.002014, -25.025024 },
                 { 147.604797, -670.852722, 34.824341 },
                 { 25.356800, -800.002014, -45.317932 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { 113.862701, -658.100830, 20.442810 },
                 { 25.356800, -800.002014, -45.317932 },
                 { 147.604797, -670.852722, 34.824341 } } } },
-    
+
     /** Patch 77 **/
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { 126.785400, -800.002014, -226.576050 },
                 { 25.356800, -800.002014, -45.317932 },
                 { 244.124313, -658.100830, -212.344971 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { 113.862701, -658.100830, 20.442810 },
                 { 244.124313, -658.100830, -212.344971 },
                 { 25.356800, -800.002014, -45.317932 } } } },
-    
+
     /** Patch 78 **/
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { 185.036591, -766.667969, -183.266968 },
                 { 102.610901, -766.667969, -35.966003 },
                 { 623.555115, -766.667969, 20.008118 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { 571.348389, -766.667969, 113.306213 },
                 { 623.555115, -766.667969, 20.008118 },
                 { 102.610901, -766.667969, -35.966003 } } } },
-    
+
     /** Patch 79 **/
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { 641.077515, -800.002014, 28.130920 },
                 { 161.664307, -800.002014, -194.102966 },
                 { 623.555115, -766.667969, 20.008118 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { 185.036591, -766.667969, -183.266968 },
                 { 623.555115, -766.667969, 20.008118 },
                 { 161.664307, -800.002014, -194.102966 } } } },
-    
+
     /** Patch 80 **/
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { 77.628601, -800.002014, -43.924988 },
                 { 590.078308, -800.002014, 119.270935 },
                 { 102.610901, -766.667969, -35.966003 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { 571.348389, -766.667969, 113.306213 },
                 { 102.610901, -766.667969, -35.966003 },
                 { 590.078308, -800.002014, 119.270935 } } } },
-    
+
     /** Patch 81 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -360.000183, -66.666603, -999.999023 },
                 { -840.000061, -66.666603, -999.999023 },
                 { -360.000183, -66.666603, -700.000000 } } } },
-    
+
     /** Patch 82 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -479.999817, -233.333084, -999.999023 },
                 { -840.000061, -233.333084, -999.999023 },
                 { -479.999817, -233.333084, -599.997925 } } } },
-    
+
     /** Patch 83 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -479.999817, -266.666412, -599.997925 },
                 { -840.000061, -266.666412, -599.997925 },
                 { -479.999817, -266.666412, -999.999023 } } } },
-    
+
     /** Patch 84 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -479.999817, -266.666412, -999.999023 },
                 { -840.000061, -266.666412, -999.999023 },
                 { -479.999817, -233.333084, -999.999023 } } } },
-    
+
     /** Patch 85 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -840.000061, -266.666412, -999.999023 },
                 { -840.000061, -266.666412, -599.997925 },
                 { -840.000061, -233.333084, -999.999023 } } } },
-    
+
     /** Patch 86 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -840.000061, -266.666412, -599.997925 },
                 { -479.999817, -266.666412, -599.997925 },
                 { -840.000061, -233.333084, -599.997925 } } } },
-    
+
     /** Patch 87 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -479.999817, -266.666412, -599.997925 },
                 { -479.999817, -266.666412, -999.999023 },
                 { -479.999817, -233.333084, -599.997925 } } } },
-    
+
     /** Patch 88 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -800.002014, -800.002014, -999.999023 },
                 { -840.000061, -800.002014, -999.999023 },
                 { -800.002014, -266.666412, -999.999023 } } } },
-    
+
     /** Patch 89 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -840.000061, -800.002014, -999.999023 },
                 { -840.000061, -800.002014, -966.665039 },
                 { -840.000061, -266.666412, -999.999023 } } } },
-    
+
     /** Patch 90 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -840.000061, -800.002014, -966.665039 },
                 { -800.002014, -800.002014, -966.665039 },
                 { -840.000061, -266.666412, -966.665039 } } } },
-    
+
     /** Patch 91 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -800.002014, -800.002014, -966.665039 },
                 { -800.002014, -800.002014, -999.999023 },
                 { -800.002014, -266.666412, -966.665039 } } } },
-    
+
     /** Patch 92 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -360.000183, -99.999901, -700.000000 },
                 { -840.000061, -99.999901, -700.000000 },
                 { -360.000183, -99.999901, -999.999023 } } } },
-    
+
     /** Patch 93 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -360.000183, -99.999901, -999.999023 },
                 { -840.000061, -99.999901, -999.999023 },
                 { -360.000183, -66.666603, -999.999023 } } } },
-    
+
     /** Patch 94 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -840.000061, -99.999901, -999.999023 },
                 { -840.000061, -99.999901, -700.000000 },
                 { -840.000061, -66.666603, -999.999023 } } } },
-    
+
     /** Patch 95 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -840.000061, -99.999901, -700.000000 },
                 { -360.000183, -99.999901, -700.000000 },
                 { -840.000061, -66.666603, -700.000000 } } } },
-    
+
     /** Patch 96 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -360.000183, -99.999901, -700.000000 },
                 { -360.000183, -99.999901, -999.999023 },
                 { -360.000183, -66.666603, -700.000000 } } } },
-    
+
     /** Patch 97 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -800.002014, -233.333084, -999.999023 },
                 { -840.000061, -233.333084, -999.999023 },
                 { -800.002014, -99.999901, -999.999023 } } } },
-    
+
     /** Patch 98 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -840.000061, -233.333084, -999.999023 },
                 { -840.000061, -233.333084, -966.665039 },
                 { -840.000061, -99.999901, -999.999023 } } } },
-    
+
     /** Patch 99 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -840.000061, -233.333084, -966.665039 },
                 { -800.002014, -233.333084, -966.665039 },
                 { -840.000061, -99.999901, -966.665039 } } } },
-    
+
     /** Patch 100 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -800.002014, -233.333084, -966.665039 },
                 { -800.002014, -233.333084, -999.999023 },
                 { -800.002014, -99.999901, -966.665039 } } } },
-    
+
     /** Patch 101 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -800.002014, 400.000305, -999.999023 },
                 { -840.000061, 400.000305, -999.999023 },
                 { -800.002014, 400.000305, -966.665039 } } } },
-    
+
     /** Patch 102 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -479.999817, 99.999901, -999.999023 },
                 { -840.000061, 99.999901, -999.999023 },
                 { -479.999817, 99.999901, -599.997925 } } } },
-    
+
     /** Patch 103 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -479.999817, 66.666603, -599.997925 },
                 { -840.000061, 66.666603, -599.997925 },
                 { -479.999817, 66.666603, -999.999023 } } } },
-    
+
     /** Patch 104 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -479.999817, 66.666603, -999.999023 },
                 { -840.000061, 66.666603, -999.999023 },
                 { -479.999817, 99.999901, -999.999023 } } } },
-    
+
     /** Patch 105 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -840.000061, 66.666603, -999.999023 },
                 { -840.000061, 66.666603, -599.997925 },
                 { -840.000061, 99.999901, -999.999023 } } } },
-    
+
     /** Patch 106 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -840.000061, 66.666603, -599.997925 },
                 { -479.999817, 66.666603, -599.997925 },
                 { -840.000061, 99.999901, -599.997925 } } } },
-    
+
     /** Patch 107 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -479.999817, 66.666603, -599.997925 },
                 { -479.999817, 66.666603, -999.999023 },
                 { -479.999817, 99.999901, -599.997925 } } } },
-    
+
     /** Patch 108 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -800.002014, -66.666603, -999.999023 },
                 { -840.000061, -66.666603, -999.999023 },
                 { -800.002014, 66.666603, -999.999023 } } } },
-    
+
     /** Patch 109 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -840.000061, -66.666603, -999.999023 },
                 { -840.000061, -66.666603, -966.665039 },
                 { -840.000061, 66.666603, -999.999023 } } } },
-    
+
     /** Patch 110 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -840.000061, -66.666603, -966.665039 },
                 { -800.002014, -66.666603, -966.665039 },
                 { -840.000061, 66.666603, -966.665039 } } } },
-    
+
     /** Patch 111 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -800.002014, -66.666603, -966.665039 },
                 { -800.002014, -66.666603, -999.999023 },
                 { -800.002014, 66.666603, -966.665039 } } } },
-    
+
     /** Patch 112 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -360.000183, 233.333084, -700.000000 },
                 { -360.000183, 233.333084, -999.999023 },
                 { -360.000183, 266.666412, -700.000000 } } } },
-    
+
     /** Patch 113 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -360.000183, 266.666412, -999.999023 },
                 { -840.000061, 266.666412, -999.999023 },
                 { -360.000183, 266.666412, -700.000000 } } } },
-    
+
     /** Patch 114 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -360.000183, 233.333084, -700.000000 },
                 { -840.000061, 233.333084, -700.000000 },
                 { -360.000183, 233.333084, -999.999023 } } } },
-    
+
     /** Patch 115 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -360.000183, 233.333084, -999.999023 },
                 { -840.000061, 233.333084, -999.999023 },
                 { -360.000183, 266.666412, -999.999023 } } } },
-    
+
     /** Patch 116 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -840.000061, 233.333084, -999.999023 },
                 { -840.000061, 233.333084, -700.000000 },
                 { -840.000061, 266.666412, -999.999023 } } } },
-    
+
     /** Patch 117 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -840.000061, 233.333084, -700.000000 },
                 { -360.000183, 233.333084, -700.000000 },
                 { -840.000061, 266.666412, -700.000000 } } } },
-    
+
     /** Patch 118 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -800.002014, 99.999901, -999.999023 },
                 { -840.000061, 99.999901, -999.999023 },
                 { -800.002014, 233.333084, -999.999023 } } } },
-    
+
     /** Patch 119 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -840.000061, 99.999901, -999.999023 },
                 { -840.000061, 99.999901, -966.665039 },
                 { -840.000061, 233.333084, -999.999023 } } } },
-    
+
     /** Patch 120 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -840.000061, 99.999901, -966.665039 },
                 { -800.002014, 99.999901, -966.665039 },
                 { -840.000061, 233.333084, -966.665039 } } } },
-    
+
     /** Patch 121 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -800.002014, 99.999901, -966.665039 },
                 { -800.002014, 99.999901, -999.999023 },
                 { -800.002014, 233.333084, -966.665039 } } } },
-    
+
     /** Patch 122 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -800.002014, 266.666412, -999.999023 },
                 { -840.000061, 266.666412, -999.999023 },
                 { -800.002014, 400.000305, -999.999023 } } } },
-    
+
     /** Patch 123 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -840.000061, 266.666412, -999.999023 },
                 { -840.000061, 266.666412, -966.665039 },
                 { -840.000061, 400.000305, -999.999023 } } } },
-    
+
     /** Patch 124 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -840.000061, 266.666412, -966.665039 },
                 { -800.002014, 266.666412, -966.665039 },
                 { -840.000061, 400.000305, -966.665039 } } } },
-    
+
     /** Patch 125 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -800.002014, 266.666412, -966.665039 },
                 { -800.002014, 266.666412, -999.999023 },
                 { -800.002014, 400.000305, -966.665039 } } } },
-    
+
     /** Patch 126 **/
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 392.043396, 243.630798, -351.567993 },
                 { 242.694885, 183.257202, -315.875000 },
                 { 510.173309, 243.630798, -8.260010 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 398.162109, 198.350601, 18.507324 },
                 { 510.173309, 243.630798, -8.260010 },
                 { 242.694885, 183.257202, -315.875000 } } } },
-    
+
     /** Patch 127 **/
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 396.395996, 235.538788, -352.604004 },
                 { 512.350281, 239.584793, -8.778015 },
                 { 247.047501, 175.165207, -316.917969 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 400.338379, 194.304596, 17.987915 },
                 { 247.047501, 175.165207, -316.917969 },
                 { 512.350281, 239.584793, -8.778015 } } } },
-    
+
     /** Patch 128 **/
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 356.604492, 243.630798, -454.558960 },
                 { 238.473892, 243.630798, -797.867065 },
                 { 207.255997, 183.257202, -418.873047 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 126.462692, 198.350601, -771.098877 },
                 { 207.255997, 183.257202, -418.873047 },
                 { 238.473892, 243.630798, -797.867065 } } } },
-    
+
     /** Patch 129 **/
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 360.957123, 235.538788, -455.595093 },
                 { 211.608612, 175.165207, -419.908936 },
                 { 240.650208, 239.584793, -798.384888 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 128.639008, 194.304596, -771.616943 },
                 { 240.650208, 239.584793, -798.384888 },
                 { 211.608612, 175.165207, -419.908936 } } } },
-    
+
     /** Patch 130 **/
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 312.337189, 53.784500, -332.520996 },
                 { 461.685730, 114.158798, -368.207031 },
                 { 467.804382, 68.877899, 1.866211 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 579.816284, 114.158798, -24.899048 },
                 { 467.804382, 68.877899, 1.866211 },
                 { 461.685730, 114.158798, -368.207031 } } } },
-    
+
     /** Patch 131 **/
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 308.116211, 114.158798, -814.505981 },
                 { 426.246765, 114.158798, -471.197998 },
                 { 196.104996, 68.877899, -787.744995 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 276.898285, 53.784500, -435.511963 },
                 { 196.104996, 68.877899, -787.744995 },
                 { 426.246765, 114.158798, -471.197998 } } } },
-    
+
     /** Patch 132 **/
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 765.387024, 266.184113, -515.088013 },
                 { 777.203064, 266.184113, -480.753052 },
                 { 426.246765, 114.158798, -471.197998 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 461.685730, 114.158798, -368.207031 },
                 { 426.246765, 114.158798, -471.197998 },
                 { 777.203064, 266.184113, -480.753052 } } } },
-    
+
     /** Patch 133 **/
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 777.203064, 266.184113, -480.753052 },
                 { 759.794006, 298.552094, -476.594971 },
                 { 461.685730, 114.158798, -368.207031 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 426.864197, 178.894806, -359.884033 },
                 { 461.685730, 114.158798, -368.207031 },
                 { 759.794006, 298.552094, -476.594971 } } } },
-    
+
     /** Patch 134 **/
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 759.794006, 298.552094, -476.594971 },
                 { 747.977966, 298.552094, -510.922974 },
                 { 426.864197, 178.894806, -359.884033 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 391.425293, 178.894806, -462.881958 },
                 { 426.864197, 178.894806, -359.884033 },
                 { 747.977966, 298.552094, -510.922974 } } } },
-    
+
     /** Patch 135 **/
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 747.977966, 298.552094, -510.922974 },
                 { 765.387024, 266.184113, -515.088013 },
                 { 391.425293, 178.894806, -462.881958 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 426.246765, 114.158798, -471.197998 },
                 { 391.425293, 178.894806, -462.881958 },
                 { 765.387024, 266.184113, -515.088013 } } } },
-    
+
     /** Patch 136 **/
     { MODEL_RECTANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 765.387024, 266.184113, -515.088013 },
                 { 747.977966, 298.552094, -510.922974 },
                 { 777.203064, 266.184113, -480.753052 } } } },
-    
+
     /** Patch 137 **/
     { MODEL_RECTANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 426.246765, 114.158798, -471.197998 },
                 { 276.898285, 53.784500, -435.511963 },
                 { 391.425293, 178.894806, -462.881958 } } } },
-    
+
     /** Patch 138 **/
     { MODEL_RECTANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 312.337189, 53.784500, -332.520996 },
                 { 461.685730, 114.158798, -368.207031 },
                 { 277.516418, 118.520500, -324.197998 } } } },
-    
+
     /** Patch 139 **/
     { MODEL_RECTANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 391.425293, 178.894806, -462.881958 },
                 { 242.076797, 118.520500, -427.188965 },
                 { 426.864197, 178.894806, -359.884033 } } } },
-    
+
     /** Patch 140 **/
     { MODEL_RECTANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 461.685730, 114.158798, -368.207031 },
                 { 312.337189, 53.784500, -332.520996 },
                 { 426.246765, 114.158798, -471.197998 } } } },
-    
+
     /** Patch 141 **/
     { MODEL_RECTANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 242.669006, 54.875099, -390.179932 },
                 { 254.482208, 54.875099, -355.844971 },
                 { 225.257904, 87.243103, -386.021973 } } } },
-    
+
     /** Patch 142 **/
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 242.076797, 118.520500, -427.188965 },
                 { 225.257904, 87.243103, -386.021973 },
                 { 277.516418, 118.520500, -324.197998 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 237.071091, 87.243103, -351.687012 },
                 { 277.516418, 118.520500, -324.197998 },
                 { 225.257904, 87.243103, -386.021973 } } } },
-    
+
     /** Patch 143 **/
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 242.669006, 54.875099, -390.179932 },
                 { 276.898285, 53.784500, -435.511963 },
                 { 254.482208, 54.875099, -355.844971 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 312.337189, 53.784500, -332.520996 },
                 { 254.482208, 54.875099, -355.844971 },
                 { 276.898285, 53.784500, -435.511963 } } } },
-    
+
     /** Patch 144 **/
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 242.076797, 118.520500, -427.188965 },
                 { 276.898285, 53.784500, -435.511963 },
                 { 225.257904, 87.243103, -386.021973 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 242.669006, 54.875099, -390.179932 },
                 { 225.257904, 87.243103, -386.021973 },
                 { 276.898285, 53.784500, -435.511963 } } } },
-    
+
     /** Patch 145 **/
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 312.337189, 53.784500, -332.520996 },
                 { 277.516418, 118.520500, -324.197998 },
                 { 254.482208, 54.875099, -355.844971 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 237.071091, 87.243103, -351.687012 },
                 { 254.482208, 54.875099, -355.844971 },
                 { 277.516418, 118.520500, -324.197998 } } } },
-    
+
     /** Patch 146 **/
     { MODEL_RECTANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 356.604492, 243.630798, -454.558960 },
                 { 207.255997, 183.257202, -418.873047 },
                 { 392.043396, 243.630798, -351.567993 } } } },
-    
+
     /** Patch 147 **/
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 752.408997, 298.552094, -498.050049 },
                 { 675.556702, 272.411285, -479.688965 },
                 { 717.583984, 363.288818, -489.727051 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 680.249512, 348.194702, -480.808960 },
                 { 717.583984, 363.288818, -489.727051 },
                 { 675.556702, 272.411285, -479.688965 } } } },
-    
+
     /** Patch 148 **/
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 678.510010, 272.411285, -471.106934 },
                 { 755.362976, 298.552094, -489.468018 },
                 { 683.202820, 348.194702, -472.227051 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 720.538025, 363.288818, -481.145020 },
                 { 683.202820, 348.194702, -472.227051 },
                 { 755.362976, 298.552094, -489.468018 } } } },
-    
+
     /** Patch 149 **/
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 758.855957, 278.322113, -513.526978 },
                 { 681.231567, 248.135315, -504.265991 },
                 { 723.421997, 278.322113, -616.518066 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 686.083313, 263.228699, -607.593018 },
                 { 723.421997, 278.322113, -616.518066 },
                 { 681.231567, 248.135315, -504.265991 } } } },
-    
+
     /** Patch 150 **/
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 676.879028, 256.227295, -503.223022 },
                 { 754.509033, 286.414093, -512.484009 },
                 { 681.730652, 271.320679, -606.557007 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 719.068054, 286.414093, -615.474976 },
                 { 681.730652, 271.320679, -606.557007 },
                 { 754.509033, 286.414093, -512.484009 } } } },
-    
+
     /** Patch 151 **/
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 766.317993, 286.414093, -478.156006 },
                 { 694.598816, 256.227295, -451.730957 },
                 { 801.759033, 286.414093, -375.164917 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 764.421021, 271.320679, -366.239990 },
                 { 801.759033, 286.414093, -375.164917 },
                 { 694.598816, 256.227295, -451.730957 } } } },
-    
+
     /** Patch 152 **/
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 698.951416, 248.135315, -452.767090 },
                 { 770.671997, 278.322113, -479.192017 },
                 { 768.775024, 263.228699, -367.283081 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 806.112976, 278.322113, -376.201050 },
                 { 768.775024, 263.228699, -367.283081 },
                 { 770.671997, 278.322113, -479.192017 } } } },
-    
+
     /** Patch 153 **/
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 577.639282, 118.204796, -24.380981 },
                 { 457.333099, 122.250793, -367.164062 },
                 { 465.628113, 72.923897, 2.386292 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 307.984589, 61.876499, -331.477905 },
                 { 465.628113, 72.923897, 2.386292 },
                 { 457.333099, 122.250793, -367.164062 } } } },
-    
+
     /** Patch 154 **/
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 272.545715, 61.876499, -434.468994 },
                 { 421.894196, 122.250793, -470.161987 },
                 { 193.928696, 72.923897, -787.219971 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 305.939880, 118.204796, -813.987915 },
                 { 193.928696, 72.923897, -787.219971 },
                 { 421.894196, 122.250793, -470.161987 } } } },
-    
+
     /** Patch 155 **/
     { MODEL_RECTANGLE,
         { { 1.000000, 1.000000, 1.000000 }, { 300.000000, 300.000000, 300.000000 },
             { { -229.925507, 290.945190, -923.173950 },
                 { -297.808014, 290.945190, -866.606934 },
                 { -258.613617, 218.439896, -947.078979 } } } },
-    
+
     /** Patch 156 **/
     { MODEL_TRIANGLE,
         { { 0.373419, 0.373419, 0.373419 }, { 0.000000, 0.000000, 0.000000 },
             { { -329.024506, 295.358704, -920.905884 },
                 { -343.368195, 259.105713, -932.854980 },
                 { -297.808014, 290.945190, -866.606934 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.373419, 0.373419, 0.373419 }, { 0.000000, 0.000000, 0.000000 },
             { { -326.496094, 218.439896, -890.512085 },
                 { -297.808014, 290.945190, -866.606934 },
                 { -343.368195, 259.105713, -932.854980 } } } },
-    
+
     /** Patch 157 **/
     { MODEL_TRIANGLE,
         { { 0.373419, 0.373419, 0.373419 }, { 0.000000, 0.000000, 0.000000 },
             { { -343.368195, 259.105713, -932.854980 },
                 { -309.427307, 259.105713, -961.141968 },
                 { -326.496094, 218.439896, -890.512085 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.373419, 0.373419, 0.373419 }, { 0.000000, 0.000000, 0.000000 },
             { { -258.613617, 218.439896, -947.078979 },
                 { -326.496094, 218.439896, -890.512085 },
                 { -309.427307, 259.105713, -961.141968 } } } },
-    
+
     /** Patch 158 **/
     { MODEL_TRIANGLE,
         { { 0.373419, 0.373419, 0.373419 }, { 0.000000, 0.000000, 0.000000 },
             { { -309.427307, 259.105713, -961.141968 },
                 { -295.082886, 295.358704, -949.185913 },
                 { -258.613617, 218.439896, -947.078979 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.373419, 0.373419, 0.373419 }, { 0.000000, 0.000000, 0.000000 },
             { { -229.925507, 290.945190, -923.173950 },
                 { -258.613617, 218.439896, -947.078979 },
                 { -295.082886, 295.358704, -949.185913 } } } },
-    
+
     /** Patch 159 **/
     { MODEL_TRIANGLE,
         { { 0.373419, 0.373419, 0.373419 }, { 0.000000, 0.000000, 0.000000 },
             { { -295.082886, 295.358704, -949.185913 },
                 { -329.024506, 295.358704, -920.905884 },
                 { -229.925507, 290.945190, -923.173950 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.373419, 0.373419, 0.373419 }, { 0.000000, 0.000000, 0.000000 },
             { { -297.808014, 290.945190, -866.606934 },
                 { -229.925507, 290.945190, -923.173950 },
                 { -329.024506, 295.358704, -920.905884 } } } },
-    
+
     /** Patch 160 **/
     { MODEL_RECTANGLE,
         { { 1.000000, 1.000000, 1.000000 }, { 300.000000, 300.000000, 300.000000 },
             { { -651.277222, 370.474304, -517.432983 },
                 { -691.848511, 370.474304, -444.927002 },
                 { -694.779419, 301.192505, -534.338013 } } } },
-    
+
     /** Patch 161 **/
     { MODEL_TRIANGLE,
         { { 0.373419, 0.373419, 0.373419 }, { 0.000000, 0.000000, 0.000000 },
             { { -742.811951, 379.820679, -486.801025 },
                 { -764.567993, 345.179810, -495.250000 },
                 { -691.848511, 370.474304, -444.927002 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.373419, 0.373419, 0.373419 }, { 0.000000, 0.000000, 0.000000 },
             { { -735.350037, 301.192505, -461.832031 },
                 { -691.848511, 370.474304, -444.927002 },
                 { -764.567993, 345.179810, -495.250000 } } } },
-    
+
     /** Patch 162 **/
     { MODEL_TRIANGLE,
         { { 0.373419, 0.373419, 0.373419 }, { 0.000000, 0.000000, 0.000000 },
             { { -764.567993, 345.179810, -495.250000 },
                 { -744.281982, 345.179810, -531.502930 },
                 { -735.350037, 301.192505, -461.832031 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.373419, 0.373419, 0.373419 }, { 0.000000, 0.000000, 0.000000 },
             { { -694.779419, 301.192505, -534.338013 },
                 { -735.350037, 301.192505, -461.832031 },
                 { -744.281982, 345.179810, -531.502930 } } } },
-    
+
     /** Patch 163 **/
     { MODEL_TRIANGLE,
         { { 0.373419, 0.373419, 0.373419 }, { 0.000000, 0.000000, 0.000000 },
             { { -744.281982, 345.179810, -531.502930 },
                 { -722.525940, 379.820679, -523.046997 },
                 { -694.779419, 301.192505, -534.338013 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.373419, 0.373419, 0.373419 }, { 0.000000, 0.000000, 0.000000 },
             { { -651.277222, 370.474304, -517.432983 },
                 { -694.779419, 301.192505, -534.338013 },
                 { -722.525940, 379.820679, -523.046997 } } } },
-    
+
     /** Patch 164 **/
     { MODEL_TRIANGLE,
         { { 0.373419, 0.373419, 0.373419 }, { 0.000000, 0.000000, 0.000000 },
             { { -722.525940, 379.820679, -523.046997 },
                 { -742.811951, 379.820679, -486.801025 },
                 { -651.277222, 370.474304, -517.432983 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.373419, 0.373419, 0.373419 }, { 0.000000, 0.000000, 0.000000 },
             { { -691.848511, 370.474304, -444.927002 },
                 { -651.277222, 370.474304, -517.432983 },
                 { -742.811951, 379.820679, -486.801025 } } } },
-    
+
     /** Patch 165 **/
     { MODEL_RECTANGLE,
         { { 0.186700, 0.186700, 0.186700 }, { 0.000000, 0.000000, 0.000000 },
             { { -420.000031, 654.000183, -299.999023 },
                 { 420.000031, 654.000183, -299.999023 },
                 { -420.000031, 600.000061, -299.999023 } } } },
-    
+
     /** Patch 166 **/
     { MODEL_RECTANGLE,
         { { 0.186700, 0.186700, 0.186700 }, { 0.000000, 0.000000, 0.000000 },
             { { 420.000031, 654.000183, -299.999023 },
                 { 420.000031, 654.000183, 0.000000 },
                 { 420.000031, 600.000061, -299.999023 } } } },
-    
+
     /** Patch 167 **/
     { MODEL_RECTANGLE,
         { { 0.186700, 0.186700, 0.186700 }, { 0.000000, 0.000000, 0.000000 },
             { { 420.000031, 654.000183, 0.000000 },
                 { -420.000031, 654.000183, 0.000000 },
                 { 420.000031, 600.000061, 0.000000 } } } },
-    
+
     /** Patch 168 **/
     { MODEL_RECTANGLE,
         { { 0.186700, 0.186700, 0.186700 }, { 0.000000, 0.000000, 0.000000 },
             { { -420.000031, 654.000183, 0.000000 },
                 { -420.000031, 654.000183, -299.999023 },
                 { -420.000031, 600.000061, 0.000000 } } } },
-    
+
     /** Patch 169 **/
     { MODEL_RECTANGLE,
         { { 0.000000, 0.000000, 0.000000 }, { 120.000000, 120.000000, 120.000000 },
             { { -264.000092, 628.000122, -150.002991 },
                 { -264.000092, 628.000122, -190.001038 },
                 { -215.999710, 628.000122, -150.002991 } } } },
-    
+
     /** Patch 170 **/
     { MODEL_RECTANGLE,
         { { 0.000000, 0.000000, 0.000000 }, { 60.000000, 60.000000, 60.000000 },
             { { -264.000092, 631.333496, -190.001038 },
                 { -264.000092, 631.333496, -150.002991 },
                 { -215.999710, 631.333496, -190.001038 } } } },
-    
+
     /** Patch 171 **/
     { MODEL_RECTANGLE,
         { { 0.000000, 0.000000, 0.000000 }, { 120.000000, 120.000000, 120.000000 },
             { { -24.000200, 628.000122, -150.002991 },
                 { -24.000200, 628.000122, -190.001038 },
                 { 24.000200, 628.000122, -150.002991 } } } },
-    
+
     /** Patch 172 **/
     { MODEL_RECTANGLE,
         { { 0.000000, 0.000000, 0.000000 }, { 60.000000, 60.000000, 60.000000 },
             { { -24.000200, 631.333496, -190.001038 },
                 { -24.000200, 631.333496, -150.002991 },
                 { 24.000200, 631.333496, -190.001038 } } } },
-    
+
     /** Patch 173 **/
     { MODEL_RECTANGLE,
         { { 0.000000, 0.000000, 0.000000 }, { 120.000000, 120.000000, 120.000000 },
             { { 215.999710, 628.000122, -150.002991 },
                 { 215.999710, 628.000122, -190.001038 },
                 { 264.000092, 628.000122, -150.002991 } } } },
-    
+
     /** Patch 174 **/
     { MODEL_RECTANGLE,
         { { 0.000000, 0.000000, 0.000000 }, { 60.000000, 60.000000, 60.000000 },
             { { 215.999710, 631.333496, -190.001038 },
                 { 215.999710, 631.333496, -150.002991 },
                 { 264.000092, 631.333496, -190.001038 } } } },
-    
-    
-    
-    
+
+
+
+
     { MODEL_NULL } } ;
 
 
 
 
-ModelDataBase largeroom_model[] = 
+ModelDataBase largeroom_model[] =
 {
-    
+
     /** Patch 0 **/
     { MODEL_RECTANGLE,
         { { 0.615686, 0.737255, 0.870588 }, { 0.000000, 0.000000, 0.000000 },
             { { 847.000000, -800.002014, 0.000000 },
                 { 840.000061, -800.002014, 0.000000 },
                 { 847.000000, -793.001953, 0.000000 } } } },
-    
+
     /** Patch 1 **/
     { MODEL_RECTANGLE,
         { { 0.615686, 0.737255, 0.870588 }, { 0.000000, 0.000000, 0.000000 },
             { { -847.000000, -800.002014, -1701.000000 },
                 { 847.000000, -800.002014, -1701.000000 },
                 { -847.000000, 800.002014, -1701.000000 } } } },
-    
+
     /** Patch 2 **/
     { MODEL_RECTANGLE,
         { { 0.615686, 0.737255, 0.870588 }, { 0.000000, 0.000000, 0.000000 },
             { { 847.000000, -800.002014, -1701.000000 },
                 { 847.000000, -800.002014, 0.000000 },
                 { 847.000000, 800.002014, -1701.000000 } } } },
-    
+
     /** Patch 3 **/
     { MODEL_RECTANGLE,
         { { 0.615686, 0.737255, 0.870588 }, { 0.000000, 0.000000, 0.000000 },
             { { -847.000000, -800.002014, 0.000000 },
                 { -847.000000, -800.002014, -1701.000000 },
                 { -847.000000, 800.002014, 0.000000 } } } },
-    
+
     /** Patch 4 **/
     { MODEL_RECTANGLE,
         { { 0.603921, 0.603921, 0.603921 }, { 0.000000, 0.000000, 0.000000 },
             { { 847.000000, 800.002014, 0.000000 },
                 { -847.000000, 800.002014, 0.000000 },
                 { 847.000000, 800.002014, -1701.000000 } } } },
-    
+
     /** Patch 5 **/
     { MODEL_RECTANGLE,
         { { 0.501961, 0.501961, 0.501961 }, { 0.000000, 0.000000, 0.000000 },
             { { 847.000000, -800.002014, -1701.000000 },
                 { -847.000000, -800.002014, -1701.000000 },
                 { 847.000000, -800.002014, 0.000000 } } } },
-    
+
     /** Patch 6 **/
     { MODEL_RECTANGLE,
         { { 0.576470, 0.521569, 0.521568 }, { 0.000000, 0.000000, 0.000000 },
             { { -269.149994, -216.666794, -1701.000000 },
                 { 165.895096, -216.666794, -1701.000000 },
                 { -269.149994, 281.666687, -1701.000000 } } } },
-    
+
     /** Patch 7 **/
     { MODEL_RECTANGLE,
         { { 0.098034, 0.086275, 0.074510 }, { 0.000000, 0.000000, 0.000000 },
             { { -840.000061, -159.999695, -414.019897 },
                 { -840.000061, -159.999695, -1104.214966 },
                 { -840.000061, 298.332977, -414.019897 } } } },
-    
+
     /** Patch 8 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -84.000000, -350.000000, -1699.999023 },
                 { -840.000061, -350.000000, -859.998962 },
                 { -84.000000, -299.999695, -1699.999023 } } } },
-    
+
     /** Patch 9 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -840.000061, -350.000000, -859.998962 },
                 { -84.000000, -350.000000, -1699.999023 },
                 { -336.000000, -350.000000, -544.999695 } } } },
-    
+
     /** Patch 10 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -336.000000, -299.999695, -544.999695 },
                 { 420.000031, -299.999695, -1384.999023 },
                 { -840.000061, -299.999695, -859.998962 } } } },
-    
+
     /** Patch 11 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -336.000000, -350.000000, -544.999695 },
                 { 420.000031, -350.000000, -1384.999023 },
                 { -336.000000, -299.999695, -544.999695 } } } },
-    
+
     /** Patch 12 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 420.000031, -350.000000, -1384.999023 },
                 { -84.000000, -350.000000, -1699.999023 },
                 { 420.000031, -299.999695, -1384.999023 } } } },
-    
+
     /** Patch 13 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -840.000061, -350.000000, -859.998962 },
                 { -336.000000, -350.000000, -544.999695 },
                 { -840.000061, -299.999695, -859.998962 } } } },
-    
+
     /** Patch 14 **/
     { MODEL_RECTANGLE,
         { { 0.682353, 0.247059, 0.011765 }, { 0.000000, 0.000000, 0.000000 },
             { { -306.000092, -800.002014, -619.999817 },
                 { -786.001953, -800.002014, -920.003052 },
                 { -306.000092, -350.000000, -619.999817 } } } },
-    
+
     /** Patch 15 **/
     { MODEL_RECTANGLE,
         { { 0.682353, 0.247059, 0.011765 }, { 0.000000, 0.000000, 0.000000 },
             { { -341.999695, -800.002014, -579.999695 },
                 { -306.000092, -800.002014, -619.999817 },
                 { -341.999695, -350.000000, -579.999695 } } } },
-    
+
     /** Patch 16 **/
     { MODEL_RECTANGLE,
         { { 0.682353, 0.247059, 0.011765 }, { 0.000000, 0.000000, 0.000000 },
             { { -786.001953, -800.002014, -920.003052 },
                 { -822.002930, -800.002014, -879.998047 },
                 { -786.001953, -350.000000, -920.003052 } } } },
-    
+
     /** Patch 17 **/
     { MODEL_RECTANGLE,
         { { 0.682353, 0.247059, 0.011765 }, { 0.000000, 0.000000, 0.000000 },
             { { -822.002930, -800.002014, -879.998047 },
                 { -341.999695, -800.002014, -579.999695 },
                 { -822.002930, -350.000000, -879.998047 } } } },
-    
+
     /** Patch 18 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 113.999901, -533.332825, -1045.001953 },
                 { 420.000031, -533.332825, -1384.999023 },
                 { 113.999901, -500.000214, -1045.001953 } } } },
-    
+
     /** Patch 19 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 420.000031, -533.332825, -1384.999023 },
                 { -84.000000, -533.332825, -1699.999023 },
                 { 420.000031, -500.000214, -1384.999023 } } } },
-    
+
     /** Patch 20 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 113.999901, -500.000214, -1045.001953 },
                 { 420.000031, -500.000214, -1384.999023 },
                 { -390.000092, -500.000214, -1360.001953 } } } },
-    
+
     /** Patch 21 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -390.000092, -533.332825, -1360.001953 },
                 { -84.000000, -533.332825, -1699.999023 },
                 { 113.999901, -533.332825, -1045.001953 } } } },
-    
+
     /** Patch 22 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -84.000000, -533.332825, -1699.999023 },
                 { -390.000092, -533.332825, -1360.001953 },
                 { -84.000000, -500.000214, -1699.999023 } } } },
-    
+
     /** Patch 23 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -390.000092, -533.332825, -1360.001953 },
                 { 113.999901, -533.332825, -1045.001953 },
                 { -390.000092, -500.000214, -1360.001953 } } } },
-    
+
     /** Patch 24 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 113.999901, -700.000000, -1045.001953 },
                 { 420.000031, -700.000000, -1384.999023 },
                 { 113.999901, -666.666687, -1045.001953 } } } },
-    
+
     /** Patch 25 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 420.000031, -700.000000, -1384.999023 },
                 { -84.000000, -700.000000, -1699.999023 },
                 { 420.000031, -666.666687, -1384.999023 } } } },
-    
+
     /** Patch 26 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 113.999901, -666.666687, -1045.001953 },
                 { 420.000031, -666.666687, -1384.999023 },
                 { -390.000092, -666.666687, -1360.001953 } } } },
-    
+
     /** Patch 27 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -390.000092, -700.000000, -1360.001953 },
                 { -84.000000, -700.000000, -1699.999023 },
                 { 113.999901, -700.000000, -1045.001953 } } } },
-    
+
     /** Patch 28 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -84.000000, -700.000000, -1699.999023 },
                 { -390.000092, -700.000000, -1360.001953 },
                 { -84.000000, -666.666687, -1699.999023 } } } },
-    
+
     /** Patch 29 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -390.000092, -700.000000, -1360.001953 },
                 { 113.999901, -700.000000, -1045.001953 },
                 { -390.000092, -666.666687, -1360.001953 } } } },
-    
+
     /** Patch 30 **/
     { MODEL_RECTANGLE,
         { { 0.682353, 0.247059, 0.011765 }, { 0.000000, 0.000000, 0.000000 },
             { { -138.000107, -500.000214, -1640.001953 },
                 { 341.999695, -500.000214, -1340.002930 },
                 { -138.000107, -350.000000, -1640.001953 } } } },
-    
+
     /** Patch 31 **/
     { MODEL_RECTANGLE,
         { { 0.682353, 0.247059, 0.011765 }, { 0.000000, 0.000000, 0.000000 },
             { { 341.999695, -500.000214, -1340.002930 },
                 { 378.000000, -500.000214, -1380.000977 },
                 { 341.999695, -350.000000, -1340.002930 } } } },
-    
+
     /** Patch 32 **/
     { MODEL_RECTANGLE,
         { { 0.682353, 0.247059, 0.011765 }, { 0.000000, 0.000000, 0.000000 },
             { { 378.000000, -500.000214, -1380.000977 },
                 { -101.999802, -500.000214, -1680.000122 },
                 { 378.000000, -350.000000, -1380.000977 } } } },
-    
+
     /** Patch 33 **/
     { MODEL_RECTANGLE,
         { { 0.682353, 0.247059, 0.011765 }, { 0.000000, 0.000000, 0.000000 },
             { { -101.999802, -500.000214, -1680.000122 },
                 { -138.000107, -500.000214, -1640.001953 },
                 { -101.999802, -350.000000, -1680.000122 } } } },
-    
+
     /** Patch 34 **/
     { MODEL_RECTANGLE,
         { { 0.682353, 0.247059, 0.011765 }, { 0.000000, 0.000000, 0.000000 },
             { { -138.000107, -666.666687, -1640.001953 },
                 { 341.999695, -666.666687, -1340.002930 },
                 { -138.000107, -533.332825, -1640.001953 } } } },
-    
+
     /** Patch 35 **/
     { MODEL_RECTANGLE,
         { { 0.682353, 0.247059, 0.011765 }, { 0.000000, 0.000000, 0.000000 },
             { { 341.999695, -666.666687, -1340.002930 },
                 { 378.000000, -666.666687, -1380.000977 },
                 { 341.999695, -533.332825, -1340.002930 } } } },
-    
+
     /** Patch 36 **/
     { MODEL_RECTANGLE,
         { { 0.682353, 0.247059, 0.011765 }, { 0.000000, 0.000000, 0.000000 },
             { { 378.000000, -666.666687, -1380.000977 },
                 { -101.999802, -666.666687, -1680.000122 },
                 { 378.000000, -533.332825, -1380.000977 } } } },
-    
+
     /** Patch 37 **/
     { MODEL_RECTANGLE,
         { { 0.682353, 0.247059, 0.011765 }, { 0.000000, 0.000000, 0.000000 },
             { { -101.999802, -666.666687, -1680.000122 },
                 { -138.000107, -666.666687, -1640.001953 },
                 { -101.999802, -533.332825, -1680.000122 } } } },
-    
+
     /** Patch 38 **/
     { MODEL_RECTANGLE,
         { { 0.682353, 0.247059, 0.011765 }, { 0.000000, 0.000000, 0.000000 },
             { { -138.000107, -800.002014, -1640.001953 },
                 { 341.999695, -800.002014, -1340.002930 },
                 { -138.000107, -700.000000, -1640.001953 } } } },
-    
+
     /** Patch 39 **/
     { MODEL_RECTANGLE,
         { { 0.682353, 0.247059, 0.011765 }, { 0.000000, 0.000000, 0.000000 },
             { { 341.999695, -800.002014, -1340.002930 },
                 { 378.000000, -800.002014, -1380.000977 },
                 { 341.999695, -700.000000, -1340.002930 } } } },
-    
+
     /** Patch 40 **/
     { MODEL_RECTANGLE,
         { { 0.682353, 0.247059, 0.011765 }, { 0.000000, 0.000000, 0.000000 },
             { { 378.000000, -800.002014, -1380.000977 },
                 { -101.999802, -800.002014, -1680.000122 },
                 { 378.000000, -700.000000, -1380.000977 } } } },
-    
+
     /** Patch 41 **/
     { MODEL_RECTANGLE,
         { { 0.682353, 0.247059, 0.011765 }, { 0.000000, 0.000000, 0.000000 },
             { { -101.999802, -800.002014, -1680.000122 },
                 { -138.000107, -800.002014, -1640.001953 },
                 { -101.999802, -700.000000, -1680.000122 } } } },
-    
+
     /** Patch 42 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { 108.000198, -500.000214, -1080.002075 },
                 { 120.000298, -500.000214, -1093.337036 },
                 { 108.000198, -350.000000, -1080.002075 } } } },
-    
+
     /** Patch 43 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { 104.000397, -500.000214, -1103.333008 },
                 { 91.999603, -500.000214, -1089.998047 },
                 { 104.000397, -350.000000, -1103.333008 } } } },
-    
+
     /** Patch 44 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { 120.000298, -500.000214, -1093.337036 },
                 { 104.000397, -500.000214, -1103.333008 },
                 { 120.000298, -350.000000, -1093.337036 } } } },
-    
+
     /** Patch 45 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { 91.999603, -500.000214, -1089.998047 },
                 { 108.000198, -500.000214, -1080.002075 },
                 { 91.999603, -350.000000, -1089.998047 } } } },
-    
+
     /** Patch 46 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { 108.000198, -666.666687, -1080.002075 },
                 { 120.000298, -666.666687, -1093.337036 },
                 { 108.000198, -533.332825, -1080.002075 } } } },
-    
+
     /** Patch 47 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { 104.000397, -666.666687, -1103.333008 },
                 { 91.999603, -666.666687, -1089.998047 },
                 { 104.000397, -533.332825, -1103.333008 } } } },
-    
+
     /** Patch 48 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { 120.000298, -666.666687, -1093.337036 },
                 { 104.000397, -666.666687, -1103.333008 },
                 { 120.000298, -533.332825, -1093.337036 } } } },
-    
+
     /** Patch 49 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { 91.999603, -666.666687, -1089.998047 },
                 { 108.000198, -666.666687, -1080.002075 },
                 { 91.999603, -533.332825, -1089.998047 } } } },
-    
+
     /** Patch 50 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -308.000000, -500.000214, -1340.002930 },
                 { -295.999207, -500.000214, -1353.331055 },
                 { -308.000000, -350.000000, -1340.002930 } } } },
-    
+
     /** Patch 51 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -295.999207, -500.000214, -1353.331055 },
                 { -311.999786, -500.000214, -1363.333984 },
                 { -295.999207, -350.000000, -1353.331055 } } } },
-    
+
     /** Patch 52 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -311.999786, -500.000214, -1363.333984 },
                 { -323.999908, -500.000214, -1349.999023 },
                 { -311.999786, -350.000000, -1363.333984 } } } },
-    
+
     /** Patch 53 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -323.999908, -500.000214, -1349.999023 },
                 { -308.000000, -500.000214, -1340.002930 },
                 { -323.999908, -350.000000, -1349.999023 } } } },
-    
+
     /** Patch 54 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -308.000000, -666.666687, -1340.002930 },
                 { -295.999207, -666.666687, -1353.331055 },
                 { -308.000000, -533.332825, -1340.002930 } } } },
-    
+
     /** Patch 55 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -295.999207, -666.666687, -1353.331055 },
                 { -311.999786, -666.666687, -1363.333984 },
                 { -295.999207, -533.332825, -1353.331055 } } } },
-    
+
     /** Patch 56 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -311.999786, -666.666687, -1363.333984 },
                 { -323.999908, -666.666687, -1349.999023 },
                 { -311.999786, -533.332825, -1363.333984 } } } },
-    
+
     /** Patch 57 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -323.999908, -666.666687, -1349.999023 },
                 { -308.000000, -666.666687, -1340.002930 },
                 { -323.999908, -533.332825, -1349.999023 } } } },
-    
+
     /** Patch 58 **/
     { MODEL_RECTANGLE,
         { { 0.183806, 0.551419, 0.919032 }, { 0.000000, 0.000000, 0.000000 },
             { { 433.708832, -566.666809, -844.088013 },
                 { 298.470917, -566.666809, -602.406677 },
                 { 424.914001, -534.328918, -847.503967 } } } },
-    
+
     /** Patch 59 **/
     { MODEL_RECTANGLE,
         { { 0.183806, 0.551419, 0.919032 }, { 0.000000, 0.000000, 0.000000 },
             { { 298.470917, -566.666809, -602.406677 },
                 { 509.488007, -518.146973, -520.407959 },
                 { 289.676117, -534.328918, -605.824768 } } } },
-    
+
     /** Patch 60 **/
     { MODEL_RECTANGLE,
         { { 0.183806, 0.551419, 0.919032 }, { 0.000000, 0.000000, 0.000000 },
             { { 644.725891, -518.146973, -762.090027 },
                 { 433.708832, -566.666809, -844.088013 },
                 { 635.931091, -485.809113, -765.505981 } } } },
-    
+
     /** Patch 61 **/
     { MODEL_RECTANGLE,
         { { 0.183806, 0.551419, 0.919032 }, { 0.000000, 0.000000, 0.000000 },
             { { 433.708832, -566.666809, -844.088013 },
                 { 644.725891, -518.146973, -762.090027 },
                 { 298.470917, -566.666809, -602.406677 } } } },
-    
+
     /** Patch 62 **/
     { MODEL_RECTANGLE,
         { { 0.183806, 0.551419, 0.919032 }, { 0.000000, 0.000000, 0.000000 },
             { { 509.488007, -518.146973, -520.407959 },
                 { 644.725891, -518.146973, -762.090027 },
                 { 500.693207, -485.809113, -523.825378 } } } },
-    
+
     /** Patch 63 **/
     { MODEL_RECTANGLE,
         { { 0.183806, 0.551419, 0.919032 }, { 0.000000, 0.000000, 0.000000 },
             { { 289.676117, -534.328918, -605.824768 },
                 { 500.693207, -485.809113, -523.825378 },
                 { 424.914001, -534.328918, -847.503967 } } } },
-    
+
     /** Patch 64 **/
     { MODEL_RECTANGLE,
         { { 0.183806, 0.551419, 0.919032 }, { 0.000000, 0.000000, 0.000000 },
             { { 188.395203, -633.333435, -957.802979 },
                 { 356.457520, -695.767822, -892.500000 },
                 { 36.252300, -633.333435, -685.912537 } } } },
-    
+
     /** Patch 65 **/
     { MODEL_RECTANGLE,
         { { 0.183806, 0.551419, 0.919032 }, { 0.000000, 0.000000, 0.000000 },
             { { 36.252300, -633.333435, -685.912537 },
                 { 204.315292, -695.767822, -620.605286 },
                 { 49.833000, -602.427002, -680.635193 } } } },
-    
+
     /** Patch 66 **/
     { MODEL_RECTANGLE,
         { { 0.183806, 0.551419, 0.919032 }, { 0.000000, 0.000000, 0.000000 },
             { { 356.457520, -695.767822, -892.500000 },
                 { 188.395203, -633.333435, -957.802979 },
                 { 370.038208, -664.861389, -887.221985 } } } },
-    
+
     /** Patch 67 **/
     { MODEL_RECTANGLE,
         { { 0.183806, 0.551419, 0.919032 }, { 0.000000, 0.000000, 0.000000 },
             { { 204.315292, -695.767822, -620.605286 },
                 { 356.457520, -695.767822, -892.500000 },
                 { 217.895294, -664.861389, -615.328003 } } } },
-    
+
     /** Patch 68 **/
     { MODEL_RECTANGLE,
         { { 0.183806, 0.551419, 0.919032 }, { 0.000000, 0.000000, 0.000000 },
             { { 188.395203, -633.333435, -957.802979 },
                 { 36.252300, -633.333435, -685.912537 },
                 { 201.975204, -602.427002, -952.524963 } } } },
-    
+
     /** Patch 69 **/
     { MODEL_RECTANGLE,
         { { 0.183806, 0.551419, 0.919032 }, { 0.000000, 0.000000, 0.000000 },
             { { 49.833000, -602.427002, -680.635193 },
                 { 217.895294, -664.861389, -615.328003 },
                 { 201.975204, -602.427002, -952.524963 } } } },
-    
+
     /** Patch 70 **/
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { 650.722107, -800.002014, -689.105164 },
                 { 580.434387, -800.002014, -563.493713 },
                 { 533.348206, -541.608887, -785.043030 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { 416.794708, -541.608887, -576.753113 },
                 { 533.348206, -541.608887, -785.043030 },
                 { 580.434387, -800.002014, -563.493713 } } } },
-    
+
     /** Patch 71 **/
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { 650.722107, -800.002014, -689.105164 },
                 { 533.348206, -541.608887, -785.043030 },
                 { 689.917908, -800.002014, -670.970276 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { 568.779419, -533.325073, -769.986023 },
                 { 689.917908, -800.002014, -670.970276 },
                 { 533.348206, -541.608887, -785.043030 } } } },
-    
+
     /** Patch 72 **/
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { 416.794708, -541.608887, -576.753113 },
                 { 580.434387, -800.002014, -563.493713 },
                 { 453.411713, -533.325073, -563.813599 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { 622.298584, -800.002014, -550.129272 },
                 { 453.411713, -533.325073, -563.813599 },
                 { 580.434387, -800.002014, -563.493713 } } } },
-    
+
     /** Patch 73 **/
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { 622.298584, -800.002014, -550.129272 },
                 { 689.917908, -800.002014, -670.970276 },
                 { 453.411713, -533.325073, -563.813599 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { 568.779419, -533.325073, -769.986023 },
                 { 453.411713, -533.325073, -563.813599 },
                 { 689.917908, -800.002014, -670.970276 } } } },
-    
+
     /** Patch 74 **/
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { 67.053001, -800.002014, -725.025024 },
                 { 172.239197, -800.002014, -913.003052 },
                 { 147.604797, -670.852722, -665.175659 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { 279.033295, -670.852722, -900.052979 },
                 { 147.604797, -670.852722, -665.175659 },
                 { 172.239197, -800.002014, -913.003052 } } } },
-    
+
     /** Patch 75 **/
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { 279.033295, -670.852722, -900.052979 },
                 { 172.239197, -800.002014, -913.003052 },
                 { 244.124313, -658.100830, -912.344971 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { 126.785400, -800.002014, -926.576050 },
                 { 244.124313, -658.100830, -912.344971 },
                 { 172.239197, -800.002014, -913.003052 } } } },
-    
+
     /** Patch 76 **/
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { 67.053001, -800.002014, -725.025024 },
                 { 147.604797, -670.852722, -665.175659 },
                 { 25.356800, -800.002014, -745.317932 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { 113.862701, -658.100830, -679.557190 },
                 { 25.356800, -800.002014, -745.317932 },
                 { 147.604797, -670.852722, -665.175659 } } } },
-    
+
     /** Patch 77 **/
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { 126.785400, -800.002014, -926.576050 },
                 { 25.356800, -800.002014, -745.317932 },
                 { 244.124313, -658.100830, -912.344971 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { 113.862701, -658.100830, -679.557190 },
                 { 244.124313, -658.100830, -912.344971 },
                 { 25.356800, -800.002014, -745.317932 } } } },
-    
+
     /** Patch 78 **/
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { 185.036591, -766.667969, -883.266968 },
                 { 102.610901, -766.667969, -735.966003 },
                 { 623.555115, -766.667969, -679.991882 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { 571.348389, -766.667969, -586.693787 },
                 { 623.555115, -766.667969, -679.991882 },
                 { 102.610901, -766.667969, -735.966003 } } } },
-    
+
     /** Patch 79 **/
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { 641.077515, -800.002014, -671.869080 },
                 { 161.664307, -800.002014, -894.102966 },
                 { 623.555115, -766.667969, -679.991882 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { 185.036591, -766.667969, -883.266968 },
                 { 623.555115, -766.667969, -679.991882 },
                 { 161.664307, -800.002014, -894.102966 } } } },
-    
+
     /** Patch 80 **/
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { 77.628601, -800.002014, -743.924988 },
                 { 590.078308, -800.002014, -580.729065 },
                 { 102.610901, -766.667969, -735.966003 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { 571.348389, -766.667969, -586.693787 },
                 { 102.610901, -766.667969, -735.966003 },
                 { 590.078308, -800.002014, -580.729065 } } } },
-    
+
     /** Patch 81 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -360.000183, -66.666603, -1699.999023 },
                 { -840.000061, -66.666603, -1699.999023 },
                 { -360.000183, -66.666603, -1400.000000 } } } },
-    
+
     /** Patch 82 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -479.999817, -233.333084, -1699.999023 },
                 { -840.000061, -233.333084, -1699.999023 },
                 { -479.999817, -233.333084, -1299.997925 } } } },
-    
+
     /** Patch 83 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -479.999817, -266.666412, -1299.997925 },
                 { -840.000061, -266.666412, -1299.997925 },
                 { -479.999817, -266.666412, -1699.999023 } } } },
-    
+
     /** Patch 84 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -479.999817, -266.666412, -1699.999023 },
                 { -840.000061, -266.666412, -1699.999023 },
                 { -479.999817, -233.333084, -1699.999023 } } } },
-    
+
     /** Patch 85 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -840.000061, -266.666412, -1699.999023 },
                 { -840.000061, -266.666412, -1299.997925 },
                 { -840.000061, -233.333084, -1699.999023 } } } },
-    
+
     /** Patch 86 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -840.000061, -266.666412, -1299.997925 },
                 { -479.999817, -266.666412, -1299.997925 },
                 { -840.000061, -233.333084, -1299.997925 } } } },
-    
+
     /** Patch 87 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -479.999817, -266.666412, -1299.997925 },
                 { -479.999817, -266.666412, -1699.999023 },
                 { -479.999817, -233.333084, -1299.997925 } } } },
-    
+
     /** Patch 88 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -800.002014, -800.002014, -1699.999023 },
                 { -840.000061, -800.002014, -1699.999023 },
                 { -800.002014, -266.666412, -1699.999023 } } } },
-    
+
     /** Patch 89 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -840.000061, -800.002014, -1699.999023 },
                 { -840.000061, -800.002014, -1666.665039 },
                 { -840.000061, -266.666412, -1699.999023 } } } },
-    
+
     /** Patch 90 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -840.000061, -800.002014, -1666.665039 },
                 { -800.002014, -800.002014, -1666.665039 },
                 { -840.000061, -266.666412, -1666.665039 } } } },
-    
+
     /** Patch 91 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -800.002014, -800.002014, -1666.665039 },
                 { -800.002014, -800.002014, -1699.999023 },
                 { -800.002014, -266.666412, -1666.665039 } } } },
-    
+
     /** Patch 92 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -360.000183, -99.999901, -1400.000000 },
                 { -840.000061, -99.999901, -1400.000000 },
                 { -360.000183, -99.999901, -1699.999023 } } } },
-    
+
     /** Patch 93 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -360.000183, -99.999901, -1699.999023 },
                 { -840.000061, -99.999901, -1699.999023 },
                 { -360.000183, -66.666603, -1699.999023 } } } },
-    
+
     /** Patch 94 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -840.000061, -99.999901, -1699.999023 },
                 { -840.000061, -99.999901, -1400.000000 },
                 { -840.000061, -66.666603, -1699.999023 } } } },
-    
+
     /** Patch 95 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -840.000061, -99.999901, -1400.000000 },
                 { -360.000183, -99.999901, -1400.000000 },
                 { -840.000061, -66.666603, -1400.000000 } } } },
-    
+
     /** Patch 96 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -360.000183, -99.999901, -1400.000000 },
                 { -360.000183, -99.999901, -1699.999023 },
                 { -360.000183, -66.666603, -1400.000000 } } } },
-    
+
     /** Patch 97 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -800.002014, -233.333084, -1699.999023 },
                 { -840.000061, -233.333084, -1699.999023 },
                 { -800.002014, -99.999901, -1699.999023 } } } },
-    
+
     /** Patch 98 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -840.000061, -233.333084, -1699.999023 },
                 { -840.000061, -233.333084, -1666.665039 },
                 { -840.000061, -99.999901, -1699.999023 } } } },
-    
+
     /** Patch 99 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -840.000061, -233.333084, -1666.665039 },
                 { -800.002014, -233.333084, -1666.665039 },
                 { -840.000061, -99.999901, -1666.665039 } } } },
-    
+
     /** Patch 100 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -800.002014, -233.333084, -1666.665039 },
                 { -800.002014, -233.333084, -1699.999023 },
                 { -800.002014, -99.999901, -1666.665039 } } } },
-    
+
     /** Patch 101 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -800.002014, 400.000305, -1699.999023 },
                 { -840.000061, 400.000305, -1699.999023 },
                 { -800.002014, 400.000305, -1666.665039 } } } },
-    
+
     /** Patch 102 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -479.999817, 99.999901, -1699.999023 },
                 { -840.000061, 99.999901, -1699.999023 },
                 { -479.999817, 99.999901, -1299.997925 } } } },
-    
+
     /** Patch 103 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -479.999817, 66.666603, -1299.997925 },
                 { -840.000061, 66.666603, -1299.997925 },
                 { -479.999817, 66.666603, -1699.999023 } } } },
-    
+
     /** Patch 104 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -479.999817, 66.666603, -1699.999023 },
                 { -840.000061, 66.666603, -1699.999023 },
                 { -479.999817, 99.999901, -1699.999023 } } } },
-    
+
     /** Patch 105 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -840.000061, 66.666603, -1699.999023 },
                 { -840.000061, 66.666603, -1299.997925 },
                 { -840.000061, 99.999901, -1699.999023 } } } },
-    
+
     /** Patch 106 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -840.000061, 66.666603, -1299.997925 },
                 { -479.999817, 66.666603, -1299.997925 },
                 { -840.000061, 99.999901, -1299.997925 } } } },
-    
+
     /** Patch 107 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -479.999817, 66.666603, -1299.997925 },
                 { -479.999817, 66.666603, -1699.999023 },
                 { -479.999817, 99.999901, -1299.997925 } } } },
-    
+
     /** Patch 108 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -800.002014, -66.666603, -1699.999023 },
                 { -840.000061, -66.666603, -1699.999023 },
                 { -800.002014, 66.666603, -1699.999023 } } } },
-    
+
     /** Patch 109 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -840.000061, -66.666603, -1699.999023 },
                 { -840.000061, -66.666603, -1666.665039 },
                 { -840.000061, 66.666603, -1699.999023 } } } },
-    
+
     /** Patch 110 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -840.000061, -66.666603, -1666.665039 },
                 { -800.002014, -66.666603, -1666.665039 },
                 { -840.000061, 66.666603, -1666.665039 } } } },
-    
+
     /** Patch 111 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -800.002014, -66.666603, -1666.665039 },
                 { -800.002014, -66.666603, -1699.999023 },
                 { -800.002014, 66.666603, -1666.665039 } } } },
-    
+
     /** Patch 112 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -360.000183, 233.333084, -1400.000000 },
                 { -360.000183, 233.333084, -1699.999023 },
                 { -360.000183, 266.666412, -1400.000000 } } } },
-    
+
     /** Patch 113 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -360.000183, 266.666412, -1699.999023 },
                 { -840.000061, 266.666412, -1699.999023 },
                 { -360.000183, 266.666412, -1400.000000 } } } },
-    
+
     /** Patch 114 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -360.000183, 233.333084, -1400.000000 },
                 { -840.000061, 233.333084, -1400.000000 },
                 { -360.000183, 233.333084, -1699.999023 } } } },
-    
+
     /** Patch 115 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -360.000183, 233.333084, -1699.999023 },
                 { -840.000061, 233.333084, -1699.999023 },
                 { -360.000183, 266.666412, -1699.999023 } } } },
-    
+
     /** Patch 116 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -840.000061, 233.333084, -1699.999023 },
                 { -840.000061, 233.333084, -1400.000000 },
                 { -840.000061, 266.666412, -1699.999023 } } } },
-    
+
     /** Patch 117 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -840.000061, 233.333084, -1400.000000 },
                 { -360.000183, 233.333084, -1400.000000 },
                 { -840.000061, 266.666412, -1400.000000 } } } },
-    
+
     /** Patch 118 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -800.002014, 99.999901, -1699.999023 },
                 { -840.000061, 99.999901, -1699.999023 },
                 { -800.002014, 233.333084, -1699.999023 } } } },
-    
+
     /** Patch 119 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -840.000061, 99.999901, -1699.999023 },
                 { -840.000061, 99.999901, -1666.665039 },
                 { -840.000061, 233.333084, -1699.999023 } } } },
-    
+
     /** Patch 120 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -840.000061, 99.999901, -1666.665039 },
                 { -800.002014, 99.999901, -1666.665039 },
                 { -840.000061, 233.333084, -1666.665039 } } } },
-    
+
     /** Patch 121 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -800.002014, 99.999901, -1666.665039 },
                 { -800.002014, 99.999901, -1699.999023 },
                 { -800.002014, 233.333084, -1666.665039 } } } },
-    
+
     /** Patch 122 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -800.002014, 266.666412, -1699.999023 },
                 { -840.000061, 266.666412, -1699.999023 },
                 { -800.002014, 400.000305, -1699.999023 } } } },
-    
+
     /** Patch 123 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -840.000061, 266.666412, -1699.999023 },
                 { -840.000061, 266.666412, -1666.665039 },
                 { -840.000061, 400.000305, -1699.999023 } } } },
-    
+
     /** Patch 124 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -840.000061, 266.666412, -1666.665039 },
                 { -800.002014, 266.666412, -1666.665039 },
                 { -840.000061, 400.000305, -1666.665039 } } } },
-    
+
     /** Patch 125 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -800.002014, 266.666412, -1666.665039 },
                 { -800.002014, 266.666412, -1699.999023 },
                 { -800.002014, 400.000305, -1666.665039 } } } },
-    
+
     /** Patch 126 **/
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 392.043396, 243.630798, -1051.567993 },
                 { 242.694885, 183.257202, -1015.875000 },
                 { 510.173309, 243.630798, -708.260010 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 398.162109, 198.350601, -681.492676 },
                 { 510.173309, 243.630798, -708.260010 },
                 { 242.694885, 183.257202, -1015.875000 } } } },
-    
+
     /** Patch 127 **/
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 396.395996, 235.538788, -1052.604004 },
                 { 512.350281, 239.584793, -708.778015 },
                 { 247.047501, 175.165207, -1016.917969 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 400.338379, 194.304596, -682.012085 },
                 { 247.047501, 175.165207, -1016.917969 },
                 { 512.350281, 239.584793, -708.778015 } } } },
-    
+
     /** Patch 128 **/
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 356.604492, 243.630798, -1154.558960 },
                 { 238.473892, 243.630798, -1497.867065 },
                 { 207.255997, 183.257202, -1118.873047 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 126.462692, 198.350601, -1471.098877 },
                 { 207.255997, 183.257202, -1118.873047 },
                 { 238.473892, 243.630798, -1497.867065 } } } },
-    
+
     /** Patch 129 **/
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 360.957123, 235.538788, -1155.595093 },
                 { 211.608612, 175.165207, -1119.908936 },
                 { 240.650208, 239.584793, -1498.384888 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 128.639008, 194.304596, -1471.616943 },
                 { 240.650208, 239.584793, -1498.384888 },
                 { 211.608612, 175.165207, -1119.908936 } } } },
-    
+
     /** Patch 130 **/
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 312.337189, 53.784500, -1032.520996 },
                 { 461.685730, 114.158798, -1068.207031 },
                 { 467.804382, 68.877899, -698.133789 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 579.816284, 114.158798, -724.899048 },
                 { 467.804382, 68.877899, -698.133789 },
                 { 461.685730, 114.158798, -1068.207031 } } } },
-    
+
     /** Patch 131 **/
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 308.116211, 114.158798, -1514.505981 },
                 { 426.246765, 114.158798, -1171.197998 },
                 { 196.104996, 68.877899, -1487.744995 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 276.898285, 53.784500, -1135.511963 },
                 { 196.104996, 68.877899, -1487.744995 },
                 { 426.246765, 114.158798, -1171.197998 } } } },
-    
+
     /** Patch 132 **/
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 765.387024, 266.184113, -1215.088013 },
                 { 777.203064, 266.184113, -1180.753052 },
                 { 426.246765, 114.158798, -1171.197998 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 461.685730, 114.158798, -1068.207031 },
                 { 426.246765, 114.158798, -1171.197998 },
                 { 777.203064, 266.184113, -1180.753052 } } } },
-    
+
     /** Patch 133 **/
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 777.203064, 266.184113, -1180.753052 },
                 { 759.794006, 298.552094, -1176.594971 },
                 { 461.685730, 114.158798, -1068.207031 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 426.864197, 178.894806, -1059.884033 },
                 { 461.685730, 114.158798, -1068.207031 },
                 { 759.794006, 298.552094, -1176.594971 } } } },
-    
+
     /** Patch 134 **/
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 759.794006, 298.552094, -1176.594971 },
                 { 747.977966, 298.552094, -1210.922974 },
                 { 426.864197, 178.894806, -1059.884033 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 391.425293, 178.894806, -1162.881958 },
                 { 426.864197, 178.894806, -1059.884033 },
                 { 747.977966, 298.552094, -1210.922974 } } } },
-    
+
     /** Patch 135 **/
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 747.977966, 298.552094, -1210.922974 },
                 { 765.387024, 266.184113, -1215.088013 },
                 { 391.425293, 178.894806, -1162.881958 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 426.246765, 114.158798, -1171.197998 },
                 { 391.425293, 178.894806, -1162.881958 },
                 { 765.387024, 266.184113, -1215.088013 } } } },
-    
+
     /** Patch 136 **/
     { MODEL_RECTANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 765.387024, 266.184113, -1215.088013 },
                 { 747.977966, 298.552094, -1210.922974 },
                 { 777.203064, 266.184113, -1180.753052 } } } },
-    
+
     /** Patch 137 **/
     { MODEL_RECTANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 426.246765, 114.158798, -1171.197998 },
                 { 276.898285, 53.784500, -1135.511963 },
                 { 391.425293, 178.894806, -1162.881958 } } } },
-    
+
     /** Patch 138 **/
     { MODEL_RECTANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 312.337189, 53.784500, -1032.520996 },
                 { 461.685730, 114.158798, -1068.207031 },
                 { 277.516418, 118.520500, -1024.197998 } } } },
-    
+
     /** Patch 139 **/
     { MODEL_RECTANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 391.425293, 178.894806, -1162.881958 },
                 { 242.076797, 118.520500, -1127.188965 },
                 { 426.864197, 178.894806, -1059.884033 } } } },
-    
+
     /** Patch 140 **/
     { MODEL_RECTANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 461.685730, 114.158798, -1068.207031 },
                 { 312.337189, 53.784500, -1032.520996 },
                 { 426.246765, 114.158798, -1171.197998 } } } },
-    
+
     /** Patch 141 **/
     { MODEL_RECTANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 242.669006, 54.875099, -1090.179932 },
                 { 254.482208, 54.875099, -1055.844971 },
                 { 225.257904, 87.243103, -1086.021973 } } } },
-    
+
     /** Patch 142 **/
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 242.076797, 118.520500, -1127.188965 },
                 { 225.257904, 87.243103, -1086.021973 },
                 { 277.516418, 118.520500, -1024.197998 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 237.071091, 87.243103, -1051.687012 },
                 { 277.516418, 118.520500, -1024.197998 },
                 { 225.257904, 87.243103, -1086.021973 } } } },
-    
+
     /** Patch 143 **/
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 242.669006, 54.875099, -1090.179932 },
                 { 276.898285, 53.784500, -1135.511963 },
                 { 254.482208, 54.875099, -1055.844971 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 312.337189, 53.784500, -1032.520996 },
                 { 254.482208, 54.875099, -1055.844971 },
                 { 276.898285, 53.784500, -1135.511963 } } } },
-    
+
     /** Patch 144 **/
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 242.076797, 118.520500, -1127.188965 },
                 { 276.898285, 53.784500, -1135.511963 },
                 { 225.257904, 87.243103, -1086.021973 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 242.669006, 54.875099, -1090.179932 },
                 { 225.257904, 87.243103, -1086.021973 },
                 { 276.898285, 53.784500, -1135.511963 } } } },
-    
+
     /** Patch 145 **/
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 312.337189, 53.784500, -1032.520996 },
                 { 277.516418, 118.520500, -1024.197998 },
                 { 254.482208, 54.875099, -1055.844971 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 237.071091, 87.243103, -1051.687012 },
                 { 254.482208, 54.875099, -1055.844971 },
                 { 277.516418, 118.520500, -1024.197998 } } } },
-    
+
     /** Patch 146 **/
     { MODEL_RECTANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 356.604492, 243.630798, -1154.558960 },
                 { 207.255997, 183.257202, -1118.873047 },
                 { 392.043396, 243.630798, -1051.567993 } } } },
-    
+
     /** Patch 147 **/
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 752.408997, 298.552094, -1198.050049 },
                 { 675.556702, 272.411285, -1179.688965 },
                 { 717.583984, 363.288818, -1189.727051 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 680.249512, 348.194702, -1180.808960 },
                 { 717.583984, 363.288818, -1189.727051 },
                 { 675.556702, 272.411285, -1179.688965 } } } },
-    
+
     /** Patch 148 **/
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 678.510010, 272.411285, -1171.106934 },
                 { 755.362976, 298.552094, -1189.468018 },
                 { 683.202820, 348.194702, -1172.227051 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 720.538025, 363.288818, -1181.145020 },
                 { 683.202820, 348.194702, -1172.227051 },
                 { 755.362976, 298.552094, -1189.468018 } } } },
-    
+
     /** Patch 149 **/
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 758.855957, 278.322113, -1213.526978 },
                 { 681.231567, 248.135315, -1204.265991 },
                 { 723.421997, 278.322113, -1316.518066 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 686.083313, 263.228699, -1307.593018 },
                 { 723.421997, 278.322113, -1316.518066 },
                 { 681.231567, 248.135315, -1204.265991 } } } },
-    
+
     /** Patch 150 **/
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 676.879028, 256.227295, -1203.223022 },
                 { 754.509033, 286.414093, -1212.484009 },
                 { 681.730652, 271.320679, -1306.557007 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 719.068054, 286.414093, -1315.474976 },
                 { 681.730652, 271.320679, -1306.557007 },
                 { 754.509033, 286.414093, -1212.484009 } } } },
-    
+
     /** Patch 151 **/
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 766.317993, 286.414093, -1178.156006 },
                 { 694.598816, 256.227295, -1151.730957 },
                 { 801.759033, 286.414093, -1075.164917 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 764.421021, 271.320679, -1066.239990 },
                 { 801.759033, 286.414093, -1075.164917 },
                 { 694.598816, 256.227295, -1151.730957 } } } },
-    
+
     /** Patch 152 **/
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 698.951416, 248.135315, -1152.767090 },
                 { 770.671997, 278.322113, -1179.192017 },
                 { 768.775024, 263.228699, -1067.283081 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 806.112976, 278.322113, -1076.201050 },
                 { 768.775024, 263.228699, -1067.283081 },
                 { 770.671997, 278.322113, -1179.192017 } } } },
-    
+
     /** Patch 153 **/
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 577.639282, 118.204796, -724.380981 },
                 { 457.333099, 122.250793, -1067.164062 },
                 { 465.628113, 72.923897, -697.613708 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 307.984589, 61.876499, -1031.477905 },
                 { 465.628113, 72.923897, -697.613708 },
                 { 457.333099, 122.250793, -1067.164062 } } } },
-    
+
     /** Patch 154 **/
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 272.545715, 61.876499, -1134.468994 },
                 { 421.894196, 122.250793, -1170.161987 },
                 { 193.928696, 72.923897, -1487.219971 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.941176, 0.125490, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 305.939880, 118.204796, -1513.987915 },
                 { 193.928696, 72.923897, -1487.219971 },
                 { 421.894196, 122.250793, -1170.161987 } } } },
-    
+
     /** Patch 155 **/
     { MODEL_RECTANGLE,
         { { 1.000000, 1.000000, 1.000000 }, { 400.000000, 400.000000, 400.000000 },
             { { -229.925507, 290.945190, -1623.173950 },
                 { -297.808014, 290.945190, -1566.606934 },
                 { -258.613617, 218.439896, -1647.078979 } } } },
-    
+
     /** Patch 156 **/
     { MODEL_TRIANGLE,
         { { 0.373419, 0.373419, 0.373419 }, { 0.000000, 0.000000, 0.000000 },
             { { -329.024506, 295.358704, -1620.905884 },
                 { -343.368195, 259.105713, -1632.854980 },
                 { -297.808014, 290.945190, -1566.606934 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.373419, 0.373419, 0.373419 }, { 0.000000, 0.000000, 0.000000 },
             { { -326.496094, 218.439896, -1590.512085 },
                 { -297.808014, 290.945190, -1566.606934 },
                 { -343.368195, 259.105713, -1632.854980 } } } },
-    
+
     /** Patch 157 **/
     { MODEL_TRIANGLE,
         { { 0.373419, 0.373419, 0.373419 }, { 0.000000, 0.000000, 0.000000 },
             { { -343.368195, 259.105713, -1632.854980 },
                 { -309.427307, 259.105713, -1661.141968 },
                 { -326.496094, 218.439896, -1590.512085 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.373419, 0.373419, 0.373419 }, { 0.000000, 0.000000, 0.000000 },
             { { -258.613617, 218.439896, -1647.078979 },
                 { -326.496094, 218.439896, -1590.512085 },
                 { -309.427307, 259.105713, -1661.141968 } } } },
-    
+
     /** Patch 158 **/
     { MODEL_TRIANGLE,
         { { 0.373419, 0.373419, 0.373419 }, { 0.000000, 0.000000, 0.000000 },
             { { -309.427307, 259.105713, -1661.141968 },
                 { -295.082886, 295.358704, -1649.185913 },
                 { -258.613617, 218.439896, -1647.078979 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.373419, 0.373419, 0.373419 }, { 0.000000, 0.000000, 0.000000 },
             { { -229.925507, 290.945190, -1623.173950 },
                 { -258.613617, 218.439896, -1647.078979 },
                 { -295.082886, 295.358704, -1649.185913 } } } },
-    
+
     /** Patch 159 **/
     { MODEL_TRIANGLE,
         { { 0.373419, 0.373419, 0.373419 }, { 0.000000, 0.000000, 0.000000 },
             { { -295.082886, 295.358704, -1649.185913 },
                 { -329.024506, 295.358704, -1620.905884 },
                 { -229.925507, 290.945190, -1623.173950 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.373419, 0.373419, 0.373419 }, { 0.000000, 0.000000, 0.000000 },
             { { -297.808014, 290.945190, -1566.606934 },
                 { -229.925507, 290.945190, -1623.173950 },
                 { -329.024506, 295.358704, -1620.905884 } } } },
-    
+
     /** Patch 160 **/
     { MODEL_RECTANGLE,
         { { 1.000000, 1.000000, 1.000000 }, { 400.000000, 400.000000, 400.000000 },
             { { -651.277222, 370.474304, -1217.432983 },
                 { -691.848511, 370.474304, -1144.927002 },
                 { -694.779419, 301.192505, -1234.338013 } } } },
-    
+
     /** Patch 161 **/
     { MODEL_TRIANGLE,
         { { 0.373419, 0.373419, 0.373419 }, { 0.000000, 0.000000, 0.000000 },
             { { -742.811951, 379.820679, -1186.801025 },
                 { -764.567993, 345.179810, -1195.250000 },
                 { -691.848511, 370.474304, -1144.927002 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.373419, 0.373419, 0.373419 }, { 0.000000, 0.000000, 0.000000 },
             { { -735.350037, 301.192505, -1161.832031 },
                 { -691.848511, 370.474304, -1144.927002 },
                 { -764.567993, 345.179810, -1195.250000 } } } },
-    
+
     /** Patch 162 **/
     { MODEL_TRIANGLE,
         { { 0.373419, 0.373419, 0.373419 }, { 0.000000, 0.000000, 0.000000 },
             { { -764.567993, 345.179810, -1195.250000 },
                 { -744.281982, 345.179810, -1231.502930 },
                 { -735.350037, 301.192505, -1161.832031 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.373419, 0.373419, 0.373419 }, { 0.000000, 0.000000, 0.000000 },
             { { -694.779419, 301.192505, -1234.338013 },
                 { -735.350037, 301.192505, -1161.832031 },
                 { -744.281982, 345.179810, -1231.502930 } } } },
-    
+
     /** Patch 163 **/
     { MODEL_TRIANGLE,
         { { 0.373419, 0.373419, 0.373419 }, { 0.000000, 0.000000, 0.000000 },
             { { -744.281982, 345.179810, -1231.502930 },
                 { -722.525940, 379.820679, -1223.046997 },
                 { -694.779419, 301.192505, -1234.338013 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.373419, 0.373419, 0.373419 }, { 0.000000, 0.000000, 0.000000 },
             { { -651.277222, 370.474304, -1217.432983 },
                 { -694.779419, 301.192505, -1234.338013 },
                 { -722.525940, 379.820679, -1223.046997 } } } },
-    
+
     /** Patch 164 **/
     { MODEL_TRIANGLE,
         { { 0.373419, 0.373419, 0.373419 }, { 0.000000, 0.000000, 0.000000 },
             { { -722.525940, 379.820679, -1223.046997 },
                 { -742.811951, 379.820679, -1186.801025 },
                 { -651.277222, 370.474304, -1217.432983 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.373419, 0.373419, 0.373419 }, { 0.000000, 0.000000, 0.000000 },
             { { -691.848511, 370.474304, -1144.927002 },
                 { -651.277222, 370.474304, -1217.432983 },
                 { -742.811951, 379.820679, -1186.801025 } } } },
-    
+
     /** Patch 165 **/
     { MODEL_RECTANGLE,
         { { 0.186700, 0.186700, 0.186700 }, { 0.000000, 0.000000, 0.000000 },
             { { -420.000031, 654.000183, -999.999023 },
                 { 420.000031, 654.000183, -999.999023 },
                 { -420.000031, 600.000061, -999.999023 } } } },
-    
+
     /** Patch 166 **/
     { MODEL_RECTANGLE,
         { { 0.186700, 0.186700, 0.186700 }, { 0.000000, 0.000000, 0.000000 },
             { { 420.000031, 654.000183, -999.999023 },
                 { 420.000031, 654.000183, -700.000000 },
                 { 420.000031, 600.000061, -999.999023 } } } },
-    
+
     /** Patch 167 **/
     { MODEL_RECTANGLE,
         { { 0.186700, 0.186700, 0.186700 }, { 0.000000, 0.000000, 0.000000 },
             { { 420.000031, 654.000183, -700.000000 },
                 { -420.000031, 654.000183, -700.000000 },
                 { 420.000031, 600.000061, -700.000000 } } } },
-    
+
     /** Patch 168 **/
     { MODEL_RECTANGLE,
         { { 0.186700, 0.186700, 0.186700 }, { 0.000000, 0.000000, 0.000000 },
             { { -420.000031, 654.000183, -700.000000 },
                 { -420.000031, 654.000183, -999.999023 },
                 { -420.000031, 600.000061, -700.000000 } } } },
-    
+
     /** Patch 169 **/
     { MODEL_RECTANGLE,
         { { 0.000000, 0.000000, 0.000000 }, { 120.000000, 120.000000, 120.000000 },
             { { -264.000092, 628.000122, -850.002991 },
                 { -264.000092, 628.000122, -890.001038 },
                 { -215.999710, 628.000122, -850.002991 } } } },
-    
+
     /** Patch 170 **/
     { MODEL_RECTANGLE,
         { { 0.000000, 0.000000, 0.000000 }, { 60.000000, 60.000000, 60.000000 },
             { { -264.000092, 631.333496, -890.001038 },
                 { -264.000092, 631.333496, -850.002991 },
                 { -215.999710, 631.333496, -890.001038 } } } },
-    
+
     /** Patch 171 **/
     { MODEL_RECTANGLE,
         { { 0.000000, 0.000000, 0.000000 }, { 120.000000, 120.000000, 120.000000 },
             { { -24.000200, 628.000122, -850.002991 },
                 { -24.000200, 628.000122, -890.001038 },
                 { 24.000200, 628.000122, -850.002991 } } } },
-    
+
     /** Patch 172 **/
     { MODEL_RECTANGLE,
         { { 0.000000, 0.000000, 0.000000 }, { 60.000000, 60.000000, 60.000000 },
             { { -24.000200, 631.333496, -890.001038 },
                 { -24.000200, 631.333496, -850.002991 },
                 { 24.000200, 631.333496, -890.001038 } } } },
-    
+
     /** Patch 173 **/
     { MODEL_RECTANGLE,
         { { 0.000000, 0.000000, 0.000000 }, { 120.000000, 120.000000, 120.000000 },
             { { 215.999710, 628.000122, -850.002991 },
                 { 215.999710, 628.000122, -890.001038 },
                 { 264.000092, 628.000122, -850.002991 } } } },
-    
+
     /** Patch 174 **/
     { MODEL_RECTANGLE,
         { { 0.000000, 0.000000, 0.000000 }, { 60.000000, 60.000000, 60.000000 },
             { { 215.999710, 631.333496, -890.001038 },
                 { 215.999710, 631.333496, -850.002991 },
                 { 264.000092, 631.333496, -890.001038 } } } },
-    
+
     /** Patch 0 **/
     { MODEL_RECTANGLE,
         { { 0.615686, 0.737255, 0.870588 }, { 0.000000, 0.000000, 0.000000 },
             { { 847.000000, -800.002014, 1701.000000 },
                 { -847.000000, -800.002014, 1701.000000 },
                 { 847.000000, 800.002014, 1701.000000 } } } },
-    
+
     /** Patch 1 **/
     { MODEL_RECTANGLE,
         { { 0.615686, 0.737255, 0.870588 }, { 0.000000, 0.000000, 0.000000 },
             { { -847.000000, -800.002014, 1701.000000 },
                 { -847.000000, -800.002014, 0.000000 },
                 { -847.000000, 800.002014, 1701.000000 } } } },
-    
+
     /** Patch 2 **/
     { MODEL_RECTANGLE,
         { { 0.615686, 0.737255, 0.870588 }, { 0.000000, 0.000000, 0.000000 },
             { { 847.000000, -800.002014, 0.000000 },
                 { 847.000000, -800.002014, 1701.000000 },
                 { 847.000000, 800.002014, 0.000000 } } } },
-    
+
     /** Patch 3 **/
     { MODEL_RECTANGLE,
         { { 0.603921, 0.603921, 0.603921 }, { 0.000000, 0.000000, 0.000000 },
             { { -847.000000, 800.002014, 0.000000 },
                 { 847.000000, 800.002014, 0.000000 },
                 { -847.000000, 800.002014, 1701.000000 } } } },
-    
+
     /** Patch 4 **/
     { MODEL_RECTANGLE,
         { { 0.501961, 0.501961, 0.501961 }, { 0.000000, 0.000000, 0.000000 },
             { { -847.000000, -800.002014, 1701.000000 },
                 { 847.000000, -800.002014, 1701.000000 },
                 { -847.000000, -800.002014, 0.000000 } } } },
-    
+
     /** Patch 5 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 84.000000, -350.000000, 1699.999023 },
                 { 840.000061, -350.000000, 859.998962 },
                 { 84.000000, -299.999695, 1699.999023 } } } },
-    
+
     /** Patch 6 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 840.000061, -350.000000, 859.998962 },
                 { 84.000000, -350.000000, 1699.999023 },
                 { 336.000000, -350.000000, 544.999695 } } } },
-    
+
     /** Patch 7 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 336.000000, -299.999695, 544.999695 },
                 { -420.000031, -299.999695, 1384.999023 },
                 { 840.000061, -299.999695, 859.998962 } } } },
-    
+
     /** Patch 8 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 336.000000, -350.000000, 544.999695 },
                 { -420.000031, -350.000000, 1384.999023 },
                 { 336.000000, -299.999695, 544.999695 } } } },
-    
+
     /** Patch 9 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -420.000031, -350.000000, 1384.999023 },
                 { 84.000000, -350.000000, 1699.999023 },
                 { -420.000031, -299.999695, 1384.999023 } } } },
-    
+
     /** Patch 10 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 840.000061, -350.000000, 859.998962 },
                 { 336.000000, -350.000000, 544.999695 },
                 { 840.000061, -299.999695, 859.998962 } } } },
-    
+
     /** Patch 11 **/
     { MODEL_RECTANGLE,
         { { 0.682353, 0.247059, 0.011765 }, { 0.000000, 0.000000, 0.000000 },
             { { 306.000092, -800.002014, 619.999817 },
                 { 786.001953, -800.002014, 920.003052 },
                 { 306.000092, -350.000000, 619.999817 } } } },
-    
+
     /** Patch 12 **/
     { MODEL_RECTANGLE,
         { { 0.682353, 0.247059, 0.011765 }, { 0.000000, 0.000000, 0.000000 },
             { { 341.999695, -800.002014, 579.999695 },
                 { 306.000092, -800.002014, 619.999817 },
                 { 341.999695, -350.000000, 579.999695 } } } },
-    
+
     /** Patch 13 **/
     { MODEL_RECTANGLE,
         { { 0.682353, 0.247059, 0.011765 }, { 0.000000, 0.000000, 0.000000 },
             { { 786.001953, -800.002014, 920.003052 },
                 { 822.002930, -800.002014, 879.998047 },
                 { 786.001953, -350.000000, 920.003052 } } } },
-    
+
     /** Patch 14 **/
     { MODEL_RECTANGLE,
         { { 0.682353, 0.247059, 0.011765 }, { 0.000000, 0.000000, 0.000000 },
             { { 822.002930, -800.002014, 879.998047 },
                 { 341.999695, -800.002014, 579.999695 },
                 { 822.002930, -350.000000, 879.998047 } } } },
-    
+
     /** Patch 15 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -113.999901, -533.332825, 1045.001953 },
                 { -420.000031, -533.332825, 1384.999023 },
                 { -113.999901, -500.000214, 1045.001953 } } } },
-    
+
     /** Patch 16 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -420.000031, -533.332825, 1384.999023 },
                 { 84.000000, -533.332825, 1699.999023 },
                 { -420.000031, -500.000214, 1384.999023 } } } },
-    
+
     /** Patch 17 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -113.999901, -500.000214, 1045.001953 },
                 { -420.000031, -500.000214, 1384.999023 },
                 { 390.000092, -500.000214, 1360.001953 } } } },
-    
+
     /** Patch 18 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 390.000092, -533.332825, 1360.001953 },
                 { 84.000000, -533.332825, 1699.999023 },
                 { -113.999901, -533.332825, 1045.001953 } } } },
-    
+
     /** Patch 19 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 84.000000, -533.332825, 1699.999023 },
                 { 390.000092, -533.332825, 1360.001953 },
                 { 84.000000, -500.000214, 1699.999023 } } } },
-    
+
     /** Patch 20 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 390.000092, -533.332825, 1360.001953 },
                 { -113.999901, -533.332825, 1045.001953 },
                 { 390.000092, -500.000214, 1360.001953 } } } },
-    
+
     /** Patch 21 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -113.999901, -700.000000, 1045.001953 },
                 { -420.000031, -700.000000, 1384.999023 },
                 { -113.999901, -666.666687, 1045.001953 } } } },
-    
+
     /** Patch 22 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -420.000031, -700.000000, 1384.999023 },
                 { 84.000000, -700.000000, 1699.999023 },
                 { -420.000031, -666.666687, 1384.999023 } } } },
-    
+
     /** Patch 23 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { -113.999901, -666.666687, 1045.001953 },
                 { -420.000031, -666.666687, 1384.999023 },
                 { 390.000092, -666.666687, 1360.001953 } } } },
-    
+
     /** Patch 24 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 390.000092, -700.000000, 1360.001953 },
                 { 84.000000, -700.000000, 1699.999023 },
                 { -113.999901, -700.000000, 1045.001953 } } } },
-    
+
     /** Patch 25 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 84.000000, -700.000000, 1699.999023 },
                 { 390.000092, -700.000000, 1360.001953 },
                 { 84.000000, -666.666687, 1699.999023 } } } },
-    
+
     /** Patch 26 **/
     { MODEL_RECTANGLE,
         { { 0.464516, 0.076674, 0.000000 }, { 0.000000, 0.000000, 0.000000 },
             { { 390.000092, -700.000000, 1360.001953 },
                 { -113.999901, -700.000000, 1045.001953 },
                 { 390.000092, -666.666687, 1360.001953 } } } },
-    
+
     /** Patch 27 **/
     { MODEL_RECTANGLE,
         { { 0.682353, 0.247059, 0.011765 }, { 0.000000, 0.000000, 0.000000 },
             { { 138.000107, -500.000214, 1640.001953 },
                 { -341.999695, -500.000214, 1340.002930 },
                 { 138.000107, -350.000000, 1640.001953 } } } },
-    
+
     /** Patch 28 **/
     { MODEL_RECTANGLE,
         { { 0.682353, 0.247059, 0.011765 }, { 0.000000, 0.000000, 0.000000 },
             { { -341.999695, -500.000214, 1340.002930 },
                 { -378.000000, -500.000214, 1380.000977 },
                 { -341.999695, -350.000000, 1340.002930 } } } },
-    
+
     /** Patch 29 **/
     { MODEL_RECTANGLE,
         { { 0.682353, 0.247059, 0.011765 }, { 0.000000, 0.000000, 0.000000 },
             { { -378.000000, -500.000214, 1380.000977 },
                 { 101.999802, -500.000214, 1680.000122 },
                 { -378.000000, -350.000000, 1380.000977 } } } },
-    
+
     /** Patch 30 **/
     { MODEL_RECTANGLE,
         { { 0.682353, 0.247059, 0.011765 }, { 0.000000, 0.000000, 0.000000 },
             { { 101.999802, -500.000214, 1680.000122 },
                 { 138.000107, -500.000214, 1640.001953 },
                 { 101.999802, -350.000000, 1680.000122 } } } },
-    
+
     /** Patch 31 **/
     { MODEL_RECTANGLE,
         { { 0.682353, 0.247059, 0.011765 }, { 0.000000, 0.000000, 0.000000 },
             { { 138.000107, -666.666687, 1640.001953 },
                 { -341.999695, -666.666687, 1340.002930 },
                 { 138.000107, -533.332825, 1640.001953 } } } },
-    
+
     /** Patch 32 **/
     { MODEL_RECTANGLE,
         { { 0.682353, 0.247059, 0.011765 }, { 0.000000, 0.000000, 0.000000 },
             { { -341.999695, -666.666687, 1340.002930 },
                 { -378.000000, -666.666687, 1380.000977 },
                 { -341.999695, -533.332825, 1340.002930 } } } },
-    
+
     /** Patch 33 **/
     { MODEL_RECTANGLE,
         { { 0.682353, 0.247059, 0.011765 }, { 0.000000, 0.000000, 0.000000 },
             { { -378.000000, -666.666687, 1380.000977 },
                 { 101.999802, -666.666687, 1680.000122 },
                 { -378.000000, -533.332825, 1380.000977 } } } },
-    
+
     /** Patch 34 **/
     { MODEL_RECTANGLE,
         { { 0.682353, 0.247059, 0.011765 }, { 0.000000, 0.000000, 0.000000 },
             { { 101.999802, -666.666687, 1680.000122 },
                 { 138.000107, -666.666687, 1640.001953 },
                 { 101.999802, -533.332825, 1680.000122 } } } },
-    
+
     /** Patch 35 **/
     { MODEL_RECTANGLE,
         { { 0.682353, 0.247059, 0.011765 }, { 0.000000, 0.000000, 0.000000 },
             { { 138.000107, -800.002014, 1640.001953 },
                 { -341.999695, -800.002014, 1340.002930 },
                 { 138.000107, -700.000000, 1640.001953 } } } },
-    
+
     /** Patch 36 **/
     { MODEL_RECTANGLE,
         { { 0.682353, 0.247059, 0.011765 }, { 0.000000, 0.000000, 0.000000 },
             { { -341.999695, -800.002014, 1340.002930 },
                 { -378.000000, -800.002014, 1380.000977 },
                 { -341.999695, -700.000000, 1340.002930 } } } },
-    
+
     /** Patch 37 **/
     { MODEL_RECTANGLE,
         { { 0.682353, 0.247059, 0.011765 }, { 0.000000, 0.000000, 0.000000 },
             { { -378.000000, -800.002014, 1380.000977 },
                 { 101.999802, -800.002014, 1680.000122 },
                 { -378.000000, -700.000000, 1380.000977 } } } },
-    
+
     /** Patch 38 **/
     { MODEL_RECTANGLE,
         { { 0.682353, 0.247059, 0.011765 }, { 0.000000, 0.000000, 0.000000 },
             { { 101.999802, -800.002014, 1680.000122 },
                 { 138.000107, -800.002014, 1640.001953 },
                 { 101.999802, -700.000000, 1680.000122 } } } },
-    
+
     /** Patch 39 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -108.000198, -500.000214, 1080.002075 },
                 { -120.000298, -500.000214, 1093.337036 },
                 { -108.000198, -350.000000, 1080.002075 } } } },
-    
+
     /** Patch 40 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -104.000397, -500.000214, 1103.333008 },
                 { -91.999603, -500.000214, 1089.998047 },
                 { -104.000397, -350.000000, 1103.333008 } } } },
-    
+
     /** Patch 41 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -120.000298, -500.000214, 1093.337036 },
                 { -104.000397, -500.000214, 1103.333008 },
                 { -120.000298, -350.000000, 1093.337036 } } } },
-    
+
     /** Patch 42 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -91.999603, -500.000214, 1089.998047 },
                 { -108.000198, -500.000214, 1080.002075 },
                 { -91.999603, -350.000000, 1089.998047 } } } },
-    
+
     /** Patch 43 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -108.000198, -666.666687, 1080.002075 },
                 { -120.000298, -666.666687, 1093.337036 },
                 { -108.000198, -533.332825, 1080.002075 } } } },
-    
+
     /** Patch 44 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -104.000397, -666.666687, 1103.333008 },
                 { -91.999603, -666.666687, 1089.998047 },
                 { -104.000397, -533.332825, 1103.333008 } } } },
-    
+
     /** Patch 45 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -120.000298, -666.666687, 1093.337036 },
                 { -104.000397, -666.666687, 1103.333008 },
                 { -120.000298, -533.332825, 1093.337036 } } } },
-    
+
     /** Patch 46 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { -91.999603, -666.666687, 1089.998047 },
                 { -108.000198, -666.666687, 1080.002075 },
                 { -91.999603, -533.332825, 1089.998047 } } } },
-    
+
     /** Patch 47 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { 308.000000, -500.000214, 1340.002930 },
                 { 295.999207, -500.000214, 1353.331055 },
                 { 308.000000, -350.000000, 1340.002930 } } } },
-    
+
     /** Patch 48 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { 295.999207, -500.000214, 1353.331055 },
                 { 311.999786, -500.000214, 1363.333984 },
                 { 295.999207, -350.000000, 1353.331055 } } } },
-    
+
     /** Patch 49 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { 311.999786, -500.000214, 1363.333984 },
                 { 323.999908, -500.000214, 1349.999023 },
                 { 311.999786, -350.000000, 1363.333984 } } } },
-    
+
     /** Patch 50 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { 323.999908, -500.000214, 1349.999023 },
                 { 308.000000, -500.000214, 1340.002930 },
                 { 323.999908, -350.000000, 1349.999023 } } } },
-    
+
     /** Patch 51 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { 308.000000, -666.666687, 1340.002930 },
                 { 295.999207, -666.666687, 1353.331055 },
                 { 308.000000, -533.332825, 1340.002930 } } } },
-    
+
     /** Patch 52 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { 295.999207, -666.666687, 1353.331055 },
                 { 311.999786, -666.666687, 1363.333984 },
                 { 295.999207, -533.332825, 1353.331055 } } } },
-    
+
     /** Patch 53 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { 311.999786, -666.666687, 1363.333984 },
                 { 323.999908, -666.666687, 1349.999023 },
                 { 311.999786, -533.332825, 1363.333984 } } } },
-    
+
     /** Patch 54 **/
     { MODEL_RECTANGLE,
         { { 0.200000, 0.200000, 0.200000 }, { 0.000000, 0.000000, 0.000000 },
             { { 323.999908, -666.666687, 1349.999023 },
                 { 308.000000, -666.666687, 1340.002930 },
                 { 323.999908, -533.332825, 1349.999023 } } } },
-    
+
     /** Patch 55 **/
     { MODEL_RECTANGLE,
         { { 0.183806, 0.551419, 0.919032 }, { 0.000000, 0.000000, 0.000000 },
             { { -433.708832, -566.666809, 844.088013 },
                 { -298.470917, -566.666809, 602.406677 },
                 { -424.914001, -534.328918, 847.503967 } } } },
-    
+
     /** Patch 56 **/
     { MODEL_RECTANGLE,
         { { 0.183806, 0.551419, 0.919032 }, { 0.000000, 0.000000, 0.000000 },
             { { -298.470917, -566.666809, 602.406677 },
                 { -509.488007, -518.146973, 520.407959 },
                 { -289.676117, -534.328918, 605.824768 } } } },
-    
+
     /** Patch 57 **/
     { MODEL_RECTANGLE,
         { { 0.183806, 0.551419, 0.919032 }, { 0.000000, 0.000000, 0.000000 },
             { { -644.725891, -518.146973, 762.090027 },
                 { -433.708832, -566.666809, 844.088013 },
                 { -635.931091, -485.809113, 765.505981 } } } },
-    
+
     /** Patch 58 **/
     { MODEL_RECTANGLE,
         { { 0.183806, 0.551419, 0.919032 }, { 0.000000, 0.000000, 0.000000 },
             { { -433.708832, -566.666809, 844.088013 },
                 { -644.725891, -518.146973, 762.090027 },
                 { -298.470917, -566.666809, 602.406677 } } } },
-    
+
     /** Patch 59 **/
     { MODEL_RECTANGLE,
         { { 0.183806, 0.551419, 0.919032 }, { 0.000000, 0.000000, 0.000000 },
             { { -509.488007, -518.146973, 520.407959 },
                 { -644.725891, -518.146973, 762.090027 },
                 { -500.693207, -485.809113, 523.825378 } } } },
-    
+
     /** Patch 60 **/
     { MODEL_RECTANGLE,
         { { 0.183806, 0.551419, 0.919032 }, { 0.000000, 0.000000, 0.000000 },
             { { -289.676117, -534.328918, 605.824768 },
                 { -500.693207, -485.809113, 523.825378 },
                 { -424.914001, -534.328918, 847.503967 } } } },
-    
+
     /** Patch 61 **/
     { MODEL_RECTANGLE,
         { { 0.183806, 0.551419, 0.919032 }, { 0.000000, 0.000000, 0.000000 },
             { { -188.395203, -633.333435, 957.802979 },
                 { -356.457520, -695.767822, 892.500000 },
                 { -36.252300, -633.333435, 685.912537 } } } },
-    
+
     /** Patch 62 **/
     { MODEL_RECTANGLE,
         { { 0.183806, 0.551419, 0.919032 }, { 0.000000, 0.000000, 0.000000 },
             { { -36.252300, -633.333435, 685.912537 },
                 { -204.315292, -695.767822, 620.605286 },
                 { -49.833000, -602.427002, 680.635193 } } } },
-    
+
     /** Patch 63 **/
     { MODEL_RECTANGLE,
         { { 0.183806, 0.551419, 0.919032 }, { 0.000000, 0.000000, 0.000000 },
             { { -356.457520, -695.767822, 892.500000 },
                 { -188.395203, -633.333435, 957.802979 },
                 { -370.038208, -664.861389, 887.221985 } } } },
-    
+
     /** Patch 64 **/
     { MODEL_RECTANGLE,
         { { 0.183806, 0.551419, 0.919032 }, { 0.000000, 0.000000, 0.000000 },
             { { -204.315292, -695.767822, 620.605286 },
                 { -356.457520, -695.767822, 892.500000 },
                 { -217.895294, -664.861389, 615.328003 } } } },
-    
+
     /** Patch 65 **/
     { MODEL_RECTANGLE,
         { { 0.183806, 0.551419, 0.919032 }, { 0.000000, 0.000000, 0.000000 },
             { { -188.395203, -633.333435, 957.802979 },
                 { -36.252300, -633.333435, 685.912537 },
                 { -201.975204, -602.427002, 952.524963 } } } },
-    
+
     /** Patch 66 **/
     { MODEL_RECTANGLE,
         { { 0.183806, 0.551419, 0.919032 }, { 0.000000, 0.000000, 0.000000 },
             { { -49.833000, -602.427002, 680.635193 },
                 { -217.895294, -664.861389, 615.328003 },
                 { -201.975204, -602.427002, 952.524963 } } } },
-    
+
     /** Patch 67 **/
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { -650.722107, -800.002014, 689.105164 },
                 { -580.434387, -800.002014, 563.493713 },
                 { -533.348206, -541.608887, 785.043030 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { -416.794708, -541.608887, 576.753113 },
                 { -533.348206, -541.608887, 785.043030 },
                 { -580.434387, -800.002014, 563.493713 } } } },
-    
+
     /** Patch 68 **/
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { -650.722107, -800.002014, 689.105164 },
                 { -533.348206, -541.608887, 785.043030 },
                 { -689.917908, -800.002014, 670.970276 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { -568.779419, -533.325073, 769.986023 },
                 { -689.917908, -800.002014, 670.970276 },
                 { -533.348206, -541.608887, 785.043030 } } } },
-    
+
     /** Patch 69 **/
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { -416.794708, -541.608887, 576.753113 },
                 { -580.434387, -800.002014, 563.493713 },
                 { -453.411713, -533.325073, 563.813599 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { -622.298584, -800.002014, 550.129272 },
                 { -453.411713, -533.325073, 563.813599 },
                 { -580.434387, -800.002014, 563.493713 } } } },
-    
+
     /** Patch 70 **/
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { -622.298584, -800.002014, 550.129272 },
                 { -689.917908, -800.002014, 670.970276 },
                 { -453.411713, -533.325073, 563.813599 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { -568.779419, -533.325073, 769.986023 },
                 { -453.411713, -533.325073, 563.813599 },
                 { -689.917908, -800.002014, 670.970276 } } } },
-    
+
     /** Patch 71 **/
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { -67.053001, -800.002014, 725.025024 },
                 { -172.239197, -800.002014, 913.003052 },
                 { -147.604797, -670.852722, 665.175659 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { -279.033295, -670.852722, 900.052979 },
                 { -147.604797, -670.852722, 665.175659 },
                 { -172.239197, -800.002014, 913.003052 } } } },
-    
+
     /** Patch 72 **/
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { -279.033295, -670.852722, 900.052979 },
                 { -172.239197, -800.002014, 913.003052 },
                 { -244.124313, -658.100830, 912.344971 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { -126.785400, -800.002014, 926.576050 },
                 { -244.124313, -658.100830, 912.344971 },
                 { -172.239197, -800.002014, 913.003052 } } } },
-    
+
     /** Patch 73 **/
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { -67.053001, -800.002014, 725.025024 },
                 { -147.604797, -670.852722, 665.175659 },
                 { -25.356800, -800.002014, 745.317932 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { -113.862701, -658.100830, 679.557190 },
                 { -25.356800, -800.002014, 745.317932 },
                 { -147.604797, -670.852722, 665.175659 } } } },
-    
+
     /** Patch 74 **/
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { -126.785400, -800.002014, 926.576050 },
                 { -25.356800, -800.002014, 745.317932 },
                 { -244.124313, -658.100830, 912.344971 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { -113.862701, -658.100830, 679.557190 },
                 { -244.124313, -658.100830, 912.344971 },
                 { -25.356800, -800.002014, 745.317932 } } } },
-    
+
     /** Patch 75 **/
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { -185.036591, -766.667969, 883.266968 },
                 { -102.610901, -766.667969, 735.966003 },
                 { -623.555115, -766.667969, 679.991882 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { -571.348389, -766.667969, 586.693787 },
                 { -623.555115, -766.667969, 679.991882 },
                 { -102.610901, -766.667969, 735.966003 } } } },
-    
+
     /** Patch 76 **/
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { -641.077515, -800.002014, 671.869080 },
                 { -161.664307, -800.002014, 894.102966 },
                 { -623.555115, -766.667969, 679.991882 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { -185.036591, -766.667969, 883.266968 },
                 { -623.555115, -766.667969, 679.991882 },
                 { -161.664307, -800.002014, 894.102966 } } } },
-    
+
     /** Patch 77 **/
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { -77.628601, -800.002014, 743.924988 },
                 { -590.078308, -800.002014, 580.729065 },
                 { -102.610901, -766.667969, 735.966003 } } } },
-    
+
     { MODEL_TRIANGLE,
         { { 0.506699, 0.690953, 0.552763 }, { 0.000000, 0.000000, 0.000000 },
             { { -571.348389, -766.667969, 586.693787 },
                 { -102.610901, -766.667969, 735.966003 },
                 { -590.078308, -800.002014, 580.729065 } } } },
-    
-    
-    
-    
+
+
+
+
     { MODEL_NULL } } ;
 
diff -Naur splash2/codes/apps/radiosity/smallobj.C splash2-modified/codes/apps/radiosity/smallobj.C
--- splash2/codes/apps/radiosity/smallobj.C	1994-10-18 13:37:23.000000000 -0400
+++ splash2-modified/codes/apps/radiosity/smallobj.C	2007-03-20 00:40:53.000000000 -0400
@@ -20,26 +20,26 @@
  *
  *
  *************************************************************************/
-  
+
 #include <stdio.h>
-  
+
 EXTERN_ENV;
-  
+
 include(radiosity.h)
 
 struct {
-    char pad1[PAGE_SIZE];	 	/* padding to avoid false-sharing 
-        and allow page-placement */	
-    int          n_local_free_elemvertex    ;
+    char pad1[PAGE_SIZE];	 	/* padding to avoid false-sharing
+        and allow page-placement */
+    long          n_local_free_elemvertex    ;
     ElemVertex  *local_free_elemvertex      ;
-    int    n_local_free_edge    ;
+    long    n_local_free_edge    ;
     Edge  *local_free_edge      ;
-    int lock_alloc_counter  ;
-    char pad2[PAGE_SIZE];	 	/* padding to avoid false-sharing 
-        and allow page-placement */	
+    long lock_alloc_counter  ;
+    char pad2[PAGE_SIZE];	 	/* padding to avoid false-sharing
+        and allow page-placement */
 } sobj_struct[MAX_PROCESSORS];
 
-  
+
 /***************************************************************************
 ****************************************************************************
 *
@@ -53,20 +53,18 @@
  *    vector_length()
  *
  *    Comute length of a vector represented by Vertex
- *    length = | v | 
+ *    length = | v |
  *
  ****************************************************************************/
-  
-  float vector_length( v )
-  
-  Vertex *v ;
+
+float vector_length(Vertex *v)
 {
     double t0, t1, t2 ;
-    
+
     t0 = v->x * v->x ;
     t1 = v->y * v->y ;
     t2 = v->z * v->z ;
-    
+
     return( sqrt( t0 + t1 + t2 ) ) ;
 }
 
@@ -76,20 +74,18 @@
 *    distance()
   *
   *    Comute distance of two points.
-  *    dist = | P1 - P2 | 
+  *    dist = | P1 - P2 |
   *
   ****************************************************************************/
-  
-  float distance( p1, p2 )
-  
-  Vertex *p1, *p2 ;
+
+float distance(Vertex *p1, Vertex *p2)
 {
     Vertex v12 ;
-    
+
     v12.x = p2->x - p1->x ;
     v12.y = p2->y - p1->y ;
     v12.z = p2->z - p1->z ;
-    
+
     return( vector_length( &v12 ) ) ;
 }
 
@@ -101,21 +97,19 @@
   *    v1 <- normalized( v2 )
   *
   ****************************************************************************/
-  
-  float normalize_vector( v1, v2 )
-  
-  Vertex *v1, *v2 ;
+
+float normalize_vector(Vertex *v1, Vertex *v2)
 {
     float t0 ;
     float length ;
-    
+
     length = vector_length( v2 ) ;
     t0 = (float)1.0 / length ;
-    
+
     v1->x = v2->x * t0 ;
     v1->y = v2->y * t0 ;
     v1->z = v2->z * t0 ;
-    
+
     return( length ) ;
 }
 
@@ -127,17 +121,15 @@
   *          (v1.v2) <- inner_product( v1, v2 )
   *
   ***************************************************************************/
-  
-  float inner_product( v1, v2 )
-  
-  Vertex *v1, *v2 ;
+
+float inner_product(Vertex *v1, Vertex *v2)
 {
     float ip ;
-    
+
     ip  = v1->x * v2->x ;
     ip += v1->y * v2->y ;
     ip += v1->z * v2->z ;
-    
+
     return( ip ) ;
 }
 
@@ -149,10 +141,8 @@
   *          Vc = V1 X V2
   *
   ***************************************************************************/
-  
-  void cross_product( vc, v1, v2 )
-  
-  Vertex *vc, *v1, *v2 ;
+
+void cross_product(Vertex *vc, Vertex *v1, Vertex *v2)
 {
     vc->x = v1->y * v2->z  -  v1->z * v2->y ;
     vc->y = v1->z * v2->x  -  v1->x * v2->z ;
@@ -167,22 +157,20 @@
   *          Vc = (P2-P1) X (P3-P1) /  |(P2-P1) X (P3-P1)|
   *
   ***************************************************************************/
-  
-  float plane_normal( vc, p1, p2, p3 )
-  
-  Vertex *vc, *p1, *p2, *p3 ;
+
+float plane_normal(Vertex *vc, Vertex *p1, Vertex *p2, Vertex *p3)
 {
     Vertex v1, v2 ;
-    
+
     /* Compute vectors */
     v1.x = p2->x - p1->x ;
     v1.y = p2->y - p1->y ;
     v1.z = p2->z - p1->z ;
-    
+
     v2.x = p3->x - p1->x ;
     v2.y = p3->y - p1->y ;
     v2.z = p3->z - p1->z ;
-    
+
     /* Compute cross product and normalize */
     cross_product( vc, &v1, &v2 ) ;
     return( normalize_vector( vc, vc ) ) ;
@@ -197,14 +185,11 @@
   *          P = (P1 + P2 + P3) / 3
   *
   ***************************************************************************/
-  
-  void center_point( p1, p2, p3, pc )
-  
-  Vertex *p1, *p2, *p3 ;		/* 3 vertices of a triangle */
-  Vertex *pc ;			/* Center point (RETURNED) */
+
+void center_point(Vertex *p1, Vertex *p2, Vertex *p3, Vertex *pc)
 {
     /* Compute mid point of the element */
-    
+
     pc->x = (p1->x + p2->x + p3->x) * (float)(1.0/3.0) ;
     pc->y = (p1->y + p2->y + p3->y) * (float)(1.0/3.0) ;
     pc->z = (p1->z + p2->z + p3->z) * (float)(1.0/3.0) ;
@@ -219,26 +204,22 @@
   *          P = (P1 + P2 + P3) / 3
   *
   ***************************************************************************/
-  
-  void four_center_points( p1, p2, p3, pc, pc1, pc2, pc3 )
-  
-  Vertex *p1, *p2, *p3 ;		/* 3 vertices of a triangle */
-  Vertex *pc ;			/* Center point (RETURNED) */
-  Vertex *pc1, *pc2, *pc3 ;		/* Center points (RETURNED) */
+
+void four_center_points(Vertex *p1, Vertex *p2, Vertex *p3, Vertex *pc, Vertex *pc1, Vertex *pc2, Vertex *pc3)
 {
     /* Compute mid point of the element */
     pc->x  = (p1->x + p2->x + p3->x) * (float)(1.0/3.0) ;
     pc->y  = (p1->y + p2->y + p3->y) * (float)(1.0/3.0) ;
     pc->z  = (p1->z + p2->z + p3->z) * (float)(1.0/3.0) ;
-    
+
     pc1->x = (p1->x * 4 + p2->x + p3->x) * (float)(1.0/6.0) ;
     pc1->y = (p1->y * 4 + p2->y + p3->y) * (float)(1.0/6.0) ;
     pc1->z = (p1->z * 4 + p2->z + p3->z) * (float)(1.0/6.0) ;
-    
+
     pc2->x = (p1->x + p2->x * 4 + p3->x) * (float)(1.0/6.0) ;
     pc2->y = (p1->y + p2->y * 4 + p3->y) * (float)(1.0/6.0) ;
     pc2->z = (p1->z + p2->z * 4 + p3->z) * (float)(1.0/6.0) ;
-    
+
     pc3->x = (p1->x + p2->x + p3->x * 4) * (float)(1.0/6.0) ;
     pc3->y = (p1->y + p2->y + p3->y * 4) * (float)(1.0/6.0) ;
     pc3->z = (p1->z + p2->z + p3->z * 4) * (float)(1.0/6.0) ;
@@ -252,11 +233,8 @@
   *    Print point information.
   *
   ****************************************************************************/
-  
-  void print_point( point, process_id )
-  
-  Vertex *point ;
-  unsigned process_id;
+
+void print_point(Vertex *point)
 {
     printf( "\tP(%.2f, %.2f, %.2f)\n", point->x, point->y, point->z ) ;
 }
@@ -278,11 +256,8 @@
   *    Print RGB information.
   *
   ****************************************************************************/
-  
-  void print_rgb( rgb, process_id )
-  
-  Rgb *rgb ;
-  unsigned process_id;
+
+void print_rgb(Rgb *rgb)
 {
     printf( "\tRGB(%.2f, %.2f, %.2f)\n", rgb->r, rgb->g, rgb->b ) ;
 }
@@ -305,16 +280,13 @@
 *
 ****************************************************************************/
 
-ElemVertex *create_elemvertex( p, process_id )
-  
-  Vertex *p ;
-  unsigned process_id;
+ElemVertex *create_elemvertex(Vertex *p, long process_id)
 {
     ElemVertex *ev_new ;
-    
+
     ev_new = get_elemvertex(process_id) ;
     ev_new->p = *p ;
-    
+
     return( ev_new ) ;
 }
 
@@ -329,10 +301,10 @@
 
 
 
-ElemVertex *get_elemvertex(process_id)
+ElemVertex *get_elemvertex(long process_id)
 {
     ElemVertex *ev ;
-    
+
     if( sobj_struct[process_id].n_local_free_elemvertex == 0 )
         {
             LOCK(global->free_elemvertex_lock);
@@ -349,17 +321,17 @@
             global->free_elemvertex += N_ELEMVERTEX_ALLOCATE ;
             UNLOCK(global->free_elemvertex_lock);
         }
-    
+
     ev = sobj_struct[process_id].local_free_elemvertex++ ;
     sobj_struct[process_id].n_local_free_elemvertex-- ;
-    
-    
+
+
     /* Initialize contents */
     ev->col.r  = 0.0 ;
     ev->col.g  = 0.0 ;
     ev->col.b  = 0.0 ;
     ev->weight = 0.0 ;
-    
+
     return( ev ) ;
 }
 
@@ -372,22 +344,21 @@
   *    This routine must be called in single process state.
   *
   ****************************************************************************/
-  
-  
-  void init_elemvertex(process_id)
-  unsigned process_id;
+
+
+void init_elemvertex(long process_id)
 {
-    int ev_cnt ;
-    
+    long ev_cnt ;
+
     /* Initialize global free list */
     LOCKINIT(global->free_elemvertex_lock);
     global->free_elemvertex = 0 ;
-    
+
     /* Allocate locks */
     for( ev_cnt = 0 ; ev_cnt < MAX_ELEMVERTICES ; ev_cnt++ )
         global->elemvertex_buf[ ev_cnt ].ev_lock
             = get_sharedlock( SHARED_LOCK_SEGANY, process_id ) ;
-    
+
     /* Initialize local free list */
     sobj_struct[process_id].n_local_free_elemvertex    = 0 ;
     sobj_struct[process_id].local_free_elemvertex      = 0 ;
@@ -405,29 +376,23 @@
 
 
 /***************************************************************************
-*
-*    foreach_leaf_edge()
-  *
-  *    For each leaf edges of the binary edge tree, apply the specified
-  *    function. Edges are traversed from A to B (i.e., from Pa of the root
-                                                  *    to the Pb of the root) if 'reverse' is 0. Otherwise, it is traversed
-                                                  *    from B to A.
-                                                  *
-                                                  ****************************************************************************/
-  
-  void foreach_leaf_edge( edge, reverse, func, arg1, arg2, process_id )
-  
-  Edge *edge ;		/* Root edge */
-  int reverse ;		/* Reverse traversal  */
-  void (*func)() ;		/* Function applied at the leaves */
-  int arg1, arg2 ;		/* Arguments */
-  unsigned process_id;
+ *
+ *    foreach_leaf_edge()
+ *
+ *    For each leaf edges of the binary edge tree, apply the specified
+ *    function. Edges are traversed from A to B (i.e., from Pa of the root
+ *    to the Pb of the root) if 'reverse' is 0. Otherwise, it is traversed
+ *    from B to A.
+ *
+ ****************************************************************************/
+
+void foreach_leaf_edge(Edge *edge, long reverse, void (*func)(), long arg1, long arg2, long process_id)
 {
     Edge *first, *second ;
-    
+
     if( edge == 0 )
         return ;
-    
+
     if( (edge->ea == 0) && (edge->eb == 0) )
         func( edge, reverse, arg1, arg2, process_id ) ;
     else
@@ -457,13 +422,11 @@
   *    Given two ElemVertices V1 and V2, create a new edge (V1,V2)
   *
   ****************************************************************************/
-  
-  Edge *create_edge( v1, v2, process_id )
-  
-  ElemVertex *v1, *v2 ;
+
+Edge *create_edge(ElemVertex *v1, ElemVertex *v2, long process_id)
 {
     Edge *enew ;
-    
+
     enew = get_edge(process_id) ;
     enew->pa = v1 ;
     enew->pb = v2 ;
@@ -478,49 +441,45 @@
   *    Create child edges. If they already exist, do nothing.
   *
   ****************************************************************************/
-  
-  void subdivide_edge( e, a_ratio, process_id )
-  
-  Edge *e ;		     /* Parent edge */
-  float a_ratio ;	     /* ratio*Pa + (1-ratio)*Pb */
-  unsigned process_id;
+
+void subdivide_edge(Edge *e, float a_ratio, long process_id)
 {
     Edge *enew, *e_am ;
     ElemVertex *ev_middle ;
     float b_ratio ;
-    
+
     /* Lock the element before checking the value */
     LOCK(e->edge_lock->lock);
-    
+
     /* Check if the element already has children */
     if( ! _LEAF_EDGE(e) )
         {
             UNLOCK(e->edge_lock->lock);
             return ;
         }
-    
+
     /* Create the subdivision point */
     b_ratio = (float)1.0 - a_ratio ;
     ev_middle = get_elemvertex(process_id) ;
     ev_middle->p.x = a_ratio * e->pa->p.x + b_ratio * e->pb->p.x ;
     ev_middle->p.y = a_ratio * e->pa->p.y + b_ratio * e->pb->p.y ;
     ev_middle->p.z = a_ratio * e->pa->p.z + b_ratio * e->pb->p.z ;
-    
+
     /* (1) Create edge(A-middle) */
     enew = get_edge(process_id) ;
     e_am = enew ;
     enew->pa = e->pa ;
     enew->pb = ev_middle ;
-    
+
     /* (2) Create edge(middle-B) */
     enew = get_edge(process_id) ;
     enew->pa = ev_middle ;
     enew->pb = e->pb ;
     e->eb = enew ;
-    
+
     /* Finally, set e->ea */
     e->ea = e_am ;
-    
+
     /* Unlock the element */
     UNLOCK(e->edge_lock->lock);
 }
@@ -536,11 +495,10 @@
 
 
 
-Edge *get_edge(process_id)
-  unsigned process_id;
+Edge *get_edge(long process_id)
 {
     Edge *edge ;
-    
+
     if( sobj_struct[process_id].n_local_free_edge == 0 )
         {
             LOCK(global->free_edge_lock);
@@ -556,17 +514,17 @@
             global->free_edge += N_EDGE_ALLOCATE ;
             UNLOCK(global->free_edge_lock);
         }
-    
+
     edge = sobj_struct[process_id].local_free_edge++ ;
     sobj_struct[process_id].n_local_free_edge-- ;
-    
-    
+
+
     /* Initialize contents */
     edge->pa = 0 ;
     edge->pb = 0 ;
     edge->ea = 0 ;
     edge->eb = 0 ;
-    
+
     return( edge ) ;
 }
 
@@ -579,22 +537,21 @@
   *    This routine must be called in single process state.
   *
   ****************************************************************************/
-  
-  
-  void init_edge(process_id)
-  unsigned process_id;
+
+
+void init_edge(long process_id)
 {
-    int edge_cnt ;
-    
+    long edge_cnt ;
+
     /* Initialize global free list */
     LOCKINIT(global->free_edge_lock);
     global->free_edge = 0 ;
-    
+
     /* Allocate locks */
     for( edge_cnt = 0 ; edge_cnt < MAX_EDGES ; edge_cnt++ )
         global->edge_buf[ edge_cnt ].edge_lock
             = get_sharedlock( SHARED_LOCK_SEG0, process_id ) ;
-    
+
     /* Initialize local free list */
     sobj_struct[process_id].n_local_free_edge    = 0 ;
     sobj_struct[process_id].local_free_edge      = 0 ;
@@ -620,18 +577,17 @@
   *    Initialize shared lock.
   *
   ****************************************************************************/
-  
-  
-  void init_sharedlock(process_id)
-  unsigned process_id;
+
+
+void init_sharedlock(long process_id)
 {
-    int i ;
-    
+    long i ;
+
     for( i = 0 ; i < MAX_SHARED_LOCK ; i++ )
         {
             LOCKINIT(global->sh_lock[i].lock);
         }
-    
+
     sobj_struct[process_id].lock_alloc_counter = 0 ;
 }
 
@@ -645,15 +601,12 @@
   *    is specified, the lock is picked up from arbitrary segment.
   *
   ****************************************************************************/
-  
-  Shared_Lock *get_sharedlock( segment, process_id )
-  
-  int segment ;
-  unsigned process_id;
+
+Shared_Lock *get_sharedlock(long segment, long process_id)
 {
     Shared_Lock *pshl ;
-    int effective_lock_ctr ;
-    
+    long effective_lock_ctr ;
+
     /* Compute effective lock allocation counter value */
     switch( segment )
         {
@@ -667,16 +620,16 @@
         default:
             effective_lock_ctr = sobj_struct[process_id].lock_alloc_counter ;
         }
-    
-    
+
+
     /* Get pointer to the lock */
     pshl = &global->sh_lock[ effective_lock_ctr ] ;
-    
+
     /* Update the lock counter */
     sobj_struct[process_id].lock_alloc_counter++ ;
     if( sobj_struct[process_id].lock_alloc_counter >= MAX_SHARED_LOCK )
         sobj_struct[process_id].lock_alloc_counter = 0 ;
-    
+
     return( pshl ) ;
 }
 
diff -Naur splash2/codes/apps/radiosity/structs.H splash2-modified/codes/apps/radiosity/structs.H
--- splash2/codes/apps/radiosity/structs.H	1969-12-31 19:00:00.000000000 -0500
+++ splash2-modified/codes/apps/radiosity/structs.H	2007-03-16 23:34:40.000000000 -0400
@@ -0,0 +1,34 @@
+#ifndef _STRUCTS_H
+#define _STRUCTS_H
+
+/************************************************************************
+*
+*     Vertex    -  3D coordinate
+*
+*************************************************************************/
+
+typedef struct {
+	float x, y, z ;
+} Vertex;
+
+/************************************************************************
+*
+*     Color (R,G,B)
+*
+*************************************************************************/
+
+typedef struct {
+	float r, g, b ;
+} Rgb;
+
+/************************************************************************
+*
+*     Ray       -  3D coordinate
+*
+*************************************************************************/
+
+typedef struct {
+	float x, y, z;
+} Ray;
+
+#endif
diff -Naur splash2/codes/apps/radiosity/task.H splash2-modified/codes/apps/radiosity/task.H
--- splash2/codes/apps/radiosity/task.H	1994-10-18 13:37:23.000000000 -0400
+++ splash2-modified/codes/apps/radiosity/task.H	2007-03-17 14:13:06.000000000 -0400
@@ -25,8 +25,8 @@
 *
 *************************************************************************/
 
-#define PAGE_SIZE 4096   /* page size of system, used for padding to 
-allow page placement of some logically 
+#define PAGE_SIZE 4096   /* page size of system, used for padding to
+allow page placement of some logically
 per-process data structures */
 
 /*** Task types ***/
@@ -54,7 +54,7 @@
 
 /* Decompose modeling object into patches (B-reps) */
 typedef struct {
-    int   type ;		     /* Object type */
+    long   type ;		     /* Object type */
     Model *model ;		     /* Object to be decomposed */
 } Modeling_Task ;
 
@@ -70,12 +70,12 @@
 typedef struct {
     Element *e1, *e2 ;	     /* Interacting elements */
     float   visibility ;           /* Visibility of parent */
-    int level ;		     /* Path length from the root element */
+    long level ;		     /* Path length from the root element */
 } Refinement_Task ;
 
 
 typedef struct {
-    int  ray_type ;
+    long  ray_type ;
     Element *e ;		     /* The element we are interested in */
 } Ray_Task ;
 
@@ -83,7 +83,7 @@
 typedef struct {
     Element *e ;		     /* The element we are interested in */
     Interaction *inter ;	     /* Top of interactions */
-    int   n_inter ;		     /* Number of interactions */
+    long   n_inter ;		     /* Number of interactions */
     void  (*k)() ;		     /* Continuation */
 } Visibility_Task ;
 
@@ -94,8 +94,8 @@
 
 typedef struct {
     Element *e ;
-    int level ;
-    int mode ;
+    long level ;
+    long mode ;
 } RadAvg_Task ;
 
 
@@ -108,7 +108,7 @@
 
 
 typedef struct _task {
-    int task_type ;
+    long task_type ;
     struct _task *next ;
     union {
         Modeling_Task   model ;
@@ -122,43 +122,48 @@
 
 
 typedef struct {
-    char pad1[PAGE_SIZE];	 	/* padding to avoid false-sharing 
-    and allow page-placement */	
+    char pad1[PAGE_SIZE];	 	/* padding to avoid false-sharing
+    and allow page-placement */
     LOCKDEC(q_lock)
     Task  *top, *tail ;
-    int   n_tasks ;
+    long   n_tasks ;
     LOCKDEC(f_lock)
-    int   n_free ;
+    long   n_free ;
     Task  *free ;
-    char pad2[PAGE_SIZE];	 	/* padding to avoid false-sharing 
-    and allow page-placement */	
+    char pad2[PAGE_SIZE];	 	/* padding to avoid false-sharing
+    and allow page-placement */
 } Task_Queue ;
 
 
 #define TASK_APPEND (0)
 #define TASK_INSERT (1)
 
-
-extern Task *get_task() ;
-extern void free_task() ;
-extern void enqueue_task() ;
-extern Task *dequeue_task(), *dequeue_neighbor_task() ;
 #define taskq_length(q)   (q->n_tasks)
 #define taskq_top(q)      (q->top)
-extern void print_task(), print_taskq() ;
-extern int assign_taskq() ;
-extern void init_taskq() ;
 #define taskq_too_long(q)  ((q)->n_tasks > n_tasks_per_queue)
 
-extern void process_tasks() ;
-extern void create_modeling_task(), create_bsp_task() ;
-extern void create_ff_refine_task() ;
-extern void create_ray_task(), create_radavg_task() ;
-extern void create_visibility_tasks() ;
-extern void enqueue_ray_task() ;
-extern void enqueue_radavg_task() ;
-extern int  check_task_counter() ;
-
+/*
+ * taskman.C
+ */
+void process_tasks(long process_id);
+long _process_task_wait_loop(void);
+void create_modeling_task(Model *model, long type, long process_id);
+void create_bsp_task(Patch *patch, Patch *parent, long process_id);
+void create_ff_refine_task(Element *e1, Element *e2, long level, long process_id);
+void create_ray_task(Element *e, long process_id);
+void enqueue_ray_task(long qid, Element *e, long mode, long process_id);
+void create_visibility_tasks(Element *e, void (*k)(), long process_id);
+void create_radavg_task(Element *e, long mode, long process_id);
+void enqueue_radavg_task(long qid, Element *e, long mode, long process_id);
+void enqueue_task(long qid, Task *task, long mode);
+Task *dequeue_task(long qid, long max_visit, long process_id);
+Task *get_task(long process_id);
+void free_task(Task *task, long process_id);
+void init_taskq(long process_id);
+long check_task_counter(void);
+long assign_taskq(long process_id);
+void print_task(Task *task);
+void print_taskq(Task_Queue *tq);
 
 #endif
 
diff -Naur splash2/codes/apps/radiosity/taskman.C splash2-modified/codes/apps/radiosity/taskman.C
--- splash2/codes/apps/radiosity/taskman.C	1994-10-18 13:37:23.000000000 -0400
+++ splash2-modified/codes/apps/radiosity/taskman.C	2007-03-17 13:29:02.000000000 -0400
@@ -32,13 +32,13 @@
 
 
 struct {
-    char pad1[PAGE_SIZE];	 	/* padding to avoid false-sharing 
-                                   and allow page-placement */	
-    int n_local_free_task ;
+    char pad1[PAGE_SIZE];	 	/* padding to avoid false-sharing
+                                   and allow page-placement */
+    long n_local_free_task ;
     Task *local_free_task ;
-    int crnt_taskq_id ;
-    char pad2[PAGE_SIZE];	 	/* padding to avoid false-sharing 
-                                   and allow page-placement */	
+    long crnt_taskq_id ;
+    char pad2[PAGE_SIZE];	 	/* padding to avoid false-sharing
+                                   and allow page-placement */
 }  task_struct[MAX_PROCESSORS];
 
 /***************************************************************************
@@ -60,13 +60,12 @@
 #define QUEUES_VISITED (n_taskqueues)
 #define DEQUEUE_TASK(q,v,p) (dequeue_task((q),(v),p))
 
-void process_tasks(process_id)
-  unsigned process_id;
+void process_tasks(long process_id)
 {
     Task *t ;
-    
+
     t = DEQUEUE_TASK( taskqueue_id[process_id], QUEUES_VISITED, process_id ) ;
-    
+
  retry_entry:
     while( t )
         {
@@ -82,7 +81,7 @@
                     ff_refine_elements( t->task.ref.e1, t->task.ref.e2, 0, process_id ) ;
                     break ;
                 case TASK_RAY:
-                    process_rays( t->task.ray.e, process_id, process_id ) ;
+                    process_rays( t->task.ray.e, process_id ) ;
                     break ;
                 case TASK_VISIBILITY:
                     visibility_task( t->task.vis.e, t->task.vis.inter,
@@ -94,38 +93,38 @@
                 default:
                     fprintf( stderr, "Panic:process_tasks:Illegal task type\n" );
                 }
-            
+
             /* Free the task */
             free_task( t, process_id ) ;
-            
+
             /* Get next task */
             t = DEQUEUE_TASK( taskqueue_id[process_id], QUEUES_VISITED, process_id ) ;
         }
-    
-    
+
+
     /* Barrier. While waiting for other processors to finish, poll the task
        queues and resume processing if there is any task */
-    
+
     LOCK(global->pbar_lock);
     /* Reset the barrier counter if not initialized */
     if( global->pbar_count >= n_processors )
         global->pbar_count = 0 ;
-    
+
     /* Increment the counter */
     global->pbar_count++ ;
     UNLOCK(global->pbar_lock);
-    
+
     /* barrier spin-wait loop */
     while( global->pbar_count < n_processors )
         {
             /* Wait for a while and then retry dequeue */
-            if( _process_task_wait_loop(process_id) )
+            if( _process_task_wait_loop() )
                 break ;
-            
+
             /* Waited for a while but other processors are still running.
                Poll the task queue again */
             t = DEQUEUE_TASK( taskqueue_id[process_id], QUEUES_VISITED, process_id ) ;
-            if( t ) 
+            if( t )
                 {
                     /* Task found. Exit the barrier and work on it */
                     LOCK(global->pbar_lock);
@@ -133,28 +132,26 @@
                     UNLOCK(global->pbar_lock);
                     goto retry_entry ;
                 }
-            
+
         }
-    
+
     BARRIER(global->barrier, n_processors);
 }
 
 
-int _process_task_wait_loop(process_id)
-  unsigned process_id;
+long _process_task_wait_loop()
 {
-    int  i ;
-    int finished = 0 ;
-    
+    long  i ;
+    long finished = 0 ;
+
     /* Wait for a while and then retry */
     for( i = 0 ; i < 1000 && ! finished ; i++ )
         {
-            if(    (i & 0xff) == 0
-               && (volatile)global->pbar_count >= n_processors )
-                
+            if(    ((i & 0xff) == 0) && ((volatile long)global->pbar_count >= n_processors) )
+
                 finished = 1 ;
         }
-    
+
     return( finished ) ;
 }
 
@@ -172,45 +169,29 @@
  ****************************************************************************/
 
 
-void create_modeling_task( model, type, process_id )
-  
-  Model *model ;
-  int   type ;
-  unsigned process_id;
+void create_modeling_task(Model *model, long type, long process_id)
 {
     /* Implemented this way (routine just calls another routine)
        for historical reasons */
-    
+
     process_model( model, type, process_id ) ;
     return ;
 }
 
 
-void create_bsp_task( patch, parent, process_id )
-  
-  Patch *patch ;
-  Patch *parent ;
-  unsigned process_id;
+void create_bsp_task(Patch *patch, Patch *parent, long process_id)
 {
-    Task *t ;
-    
-    /* Implemented this way (routine just calls another routine)
-       for historical reasons */
-    
+    /* Implemented this way (routine just calls another routine) for historical reasons */
     define_patch( patch, parent, process_id ) ;
     return ;
 }
 
 
 
-void create_ff_refine_task( e1, e2, level, process_id)
-  unsigned process_id;
-  
-  Element *e1, *e2 ;
-  int level ;
+void create_ff_refine_task(Element *e1, Element *e2, long level, long process_id)
 {
     Task *t ;
-    
+
     /* Check existing parallelism */
     if( taskq_too_long(&global->task_queue[ taskqueue_id[process_id] ]) )
         {
@@ -218,28 +199,23 @@
             ff_refine_elements( e1, e2, level, process_id ) ;
             return ;
         }
-    
+
     /* Create a task */
     t = get_task(process_id) ;
     t->task_type = TASK_FF_REFINEMENT ;
     t->task.ref.e1              = e1 ;
     t->task.ref.e2              = e2 ;
     t->task.ref.level           = level ;
-    
+
     /* Put in the queue */
-    enqueue_task( taskqueue_id[process_id], t, TASK_INSERT, process_id ) ;
+    enqueue_task( taskqueue_id[process_id], t, TASK_INSERT ) ;
 }
 
 
 
 
-void create_ray_task( e, process_id )
-  
-  Element *e ;
-  unsigned process_id;
+void create_ray_task(Element *e, long process_id)
 {
-    void enqueue_ray_task() ;
-    
     /* Check existing parallelism */
     if(   ((e->n_interactions + e->n_vis_undef_inter)
            < N_inter_parallel_bf_refine)
@@ -250,50 +226,41 @@
             process_rays( e, process_id ) ;
             return ;
         }
-    
+
     /* Put in the queue */
     enqueue_ray_task( taskqueue_id[process_id], e, TASK_INSERT, process_id ) ;
 }
 
 
-void enqueue_ray_task( qid, e, mode, process_id )
-  
-  int qid ;
-  Element *e ;
-  int mode ;
-  unsigned process_id;
+void enqueue_ray_task(long qid, Element *e, long mode, long process_id)
 {
     Task *t ;
-    
+
     /* Create task object */
     t = get_task(process_id) ;
     t->task_type = TASK_RAY ;
     t->task.ray.e     = e ;
-    
+
     /* Put in the queue */
-    enqueue_task( qid, t, mode, process_id ) ;
+    enqueue_task( qid, t, mode ) ;
 }
 
 
-void create_visibility_tasks( e, k, process_id )
-  
-  Element *e ;
-  void (*k)() ;
-  unsigned process_id;
+void create_visibility_tasks(Element *e, void (*k)(), long process_id)
 {
-    int n_tasks ;
-    int remainder ;			     /* Residue of MOD(total_undefs)*/
-    int i_cnt ;
+    long n_tasks ;
+    long remainder ;			     /* Residue of MOD(total_undefs)*/
+    long i_cnt ;
     Interaction *top, *tail ;
     Task *t ;
-    int total_undefs = 0 ;
-    int tasks_created = 0 ;
-    
+    long total_undefs = 0 ;
+    long tasks_created = 0 ;
+
     /* Check number of hard problems */
     for( top = e->vis_undef_inter ; top ; top = top->next )
         if( top->visibility == VISIBILITY_UNDEF )
             total_undefs++ ;
-    
+
     if( total_undefs == 0 )
         {
             /* No process needs to be created. Call the continuation
@@ -301,7 +268,7 @@
             (*k)( e, process_id ) ;
             return ;
         }
-    
+
     /* Check existing parallelism */
     if(   (total_undefs < N_visibility_per_task)
        || taskq_too_long(&global->task_queue[ taskqueue_id[process_id] ]) )
@@ -310,10 +277,10 @@
                Solve it immediately. */
             visibility_task( e, e->vis_undef_inter,
                             e->n_vis_undef_inter, k, process_id ) ;
-            
+
             return ;
         }
-    
+
     /* Create multiple tasks. Hard problems (i.e. where visibility comp is
        really necessary) are divided into 'n_tasks' groups by residue
        number division (or Bresenham's DDA) */
@@ -321,7 +288,7 @@
        modified while other tasks are being created. So, any information
        that is necessary in the for-loop must be read from the element
        and saved locally */
-    
+
     n_tasks = (total_undefs + N_visibility_per_task - 1)
         / N_visibility_per_task ;
     remainder = 0 ;
@@ -329,22 +296,22 @@
     for( top = e->vis_undef_inter, tail = top ; tail ; tail = tail->next )
         {
             i_cnt++ ;
-            
+
             if( tail->visibility != VISIBILITY_UNDEF )
                 continue ;
-            
+
             remainder += n_tasks ;
-            
+
             if( remainder >= total_undefs )
                 {
                     /* Create a task */
-                    
+
                     /* For the last task, append following (easy) interactions
                        if there is any */
                     tasks_created++ ;
                     if( tasks_created >= n_tasks )
                         for( ; tail->next ; tail = tail->next, i_cnt++ ) ;
-                    
+
                     /* Set task descriptor */
                     t = get_task(process_id) ;
                     t->task_type = TASK_VISIBILITY ;
@@ -352,10 +319,10 @@
                     t->task.vis.inter   = top ;
                     t->task.vis.n_inter = i_cnt ;
                     t->task.vis.k       = k ;
-                    
+
                     /* Enqueue */
-                    enqueue_task( taskqueue_id[process_id], t, TASK_INSERT, process_id ) ;
-                    
+                    enqueue_task( taskqueue_id[process_id], t, TASK_INSERT ) ;
+
                     /* Update pointer and the residue variable */
                     top = tail->next ;
                     remainder -= total_undefs ;
@@ -367,14 +334,8 @@
 
 
 
-void create_radavg_task( e, mode, process_id )
-  
-  Element *e ;
-  int mode ;
-  unsigned process_id;
+void create_radavg_task(Element *e, long mode, long process_id)
 {
-    void enqueue_radavg_task() ;
-    
     /* Check existing parallelism */
     if(   (e->n_interactions < N_inter_parallel_bf_refine)
        || taskq_too_long(&global->task_queue[ taskqueue_id[process_id] ]) )
@@ -384,29 +345,24 @@
             radiosity_averaging( e, mode, process_id ) ;
             return ;
         }
-    
+
     /* Put in the queue */
     enqueue_radavg_task( taskqueue_id[process_id], e, mode, process_id ) ;
 }
 
 
-void enqueue_radavg_task( qid, e, mode, process_id )
-  
-  int qid ;
-  Element *e ;
-  int mode ;
-  unsigned process_id;
+void enqueue_radavg_task(long qid, Element *e, long mode, long process_id)
 {
     Task *t ;
-    
+
     /* Create task object */
     t = get_task(process_id) ;
     t->task_type = TASK_RAD_AVERAGE ;
     t->task.rad.e     = e ;
     t->task.rad.mode  = mode ;
-    
+
     /* Put in the queue */
-    enqueue_task( qid, t, TASK_INSERT, process_id ) ;
+    enqueue_task( qid, t, TASK_INSERT ) ;
 }
 
 
@@ -418,20 +374,16 @@
  *
  ****************************************************************************/
 
-void enqueue_task( qid, task, mode, process_id )
-  
-  int  qid ;
-  Task *task ;
-  int  mode ;
+void enqueue_task(long qid, Task *task, long  mode)
 {
     Task_Queue *tq ;
-    
-    
+
+
     tq = &global->task_queue[ qid ] ;
-    
+
     /* Lock the task queue */
     LOCK(tq->q_lock);
-    
+
     if( tq->tail == 0 )
         {
             /* The first task in the queue */
@@ -455,7 +407,7 @@
                     tq->n_tasks++ ;
                 }
         }
-    
+
     /* Unlock the task queue */
     UNLOCK(tq->q_lock);
 }
@@ -463,36 +415,33 @@
 
 
 
-Task *dequeue_task( qid, max_visit, process_id )
+Task *dequeue_task(long qid, long max_visit, long process_id)
   /*
-   *    Attempts to dequeue first from the specified queue (qid), but if no 
+   *    Attempts to dequeue first from the specified queue (qid), but if no
    *	 task is found the routine searches max_visit other queues and returns
    *    a task. If a task is taken from another queue, the task is taken from
    *    the tail of the queue (usually, larger amount of work is involved than
    *    the task at the top of the queue and more locality can be exploited
    *  	 within the stolen task).
    */
-  int qid ;
-  int max_visit ;
-  unsigned process_id;
 {
     Task_Queue *tq ;
     Task *t = 0 ;
     Task *prev ;
-    int visit_count = 0 ;
-    int sign = -1 ;		      /* The first retry will go backward */
-    int offset ;
-    
+    long visit_count = 0 ;
+    long sign = -1 ;		      /* The first retry will go backward */
+    long offset ;
+
     /* Check number of queues to be visited */
     if( max_visit > n_taskqueues )
         max_visit = n_taskqueues ;
-    
+
     /* Get next task */
     while( visit_count < max_visit )
         {
             /* Select a task queue */
             tq = &global->task_queue[ qid ] ;
-            
+
             /* Check the length (test-test&set) */
             if( tq->n_tasks > 0 )
                 {
@@ -513,7 +462,7 @@
                                     /* Get tail */
                                     for( prev = 0, t = tq->top ; t->next ;
                                         prev = t, t = t->next ) ;
-                                    
+
                                     if( prev == 0 )
                                         tq->top = 0 ;
                                     else
@@ -526,21 +475,21 @@
                     UNLOCK(tq->q_lock);
                     break ;
                 }
-            
+
             /* Update visit count */
             visit_count++ ;
-            
+
             /* Compute next taskqueue ID */
             offset = (sign > 0)? visit_count : -visit_count ;
             sign = -sign ;
-            
+
             qid += offset ;
             if( qid < 0 )
                 qid += n_taskqueues ;
             else if( qid >= n_taskqueues )
                 qid -= n_taskqueues ;
         }
-    
+
     return( t ) ;
 }
 
@@ -553,25 +502,24 @@
  ****************************************************************************/
 
 
-Task *get_task(process_id)
-  unsigned process_id;
+Task *get_task(long process_id)
 {
     Task *p ;
     Task_Queue *tq ;
-    int i ;
-    int q_id ;
-    int retry_count = 0 ;
-    
+    long i ;
+    long q_id ;
+    long retry_count = 0 ;
+
     /* First, check local task queue */
     if( task_struct[process_id].local_free_task == 0 )
         {
             /* If empty, allocate task objects from the shared list */
             q_id = taskqueue_id[process_id] ;
-            
+
             while( task_struct[process_id].local_free_task == 0 )
                 {
                     tq = &global->task_queue[ q_id ] ;
-                    
+
                     if( tq->n_free > 0 )
                         {
                             LOCK(tq->f_lock);
@@ -581,7 +529,7 @@
                                     for( i = 1, p = tq->free ;
                                         (i < N_ALLOCATE_LOCAL_TASK) && p->next ;
                                         i++, p = p->next ) ;
-                                    
+
                                     task_struct[process_id].local_free_task = tq->free ;
                                     task_struct[process_id].n_local_free_task = i ;
                                     tq->free = p->next ;
@@ -592,68 +540,65 @@
                                 }
                             UNLOCK(tq->f_lock);
                         }
-                    
+
                     /* Try next task queue */
                     if( ++q_id >= n_taskqueues )
                         q_id = 0 ;
-                    
+
                     /* Check retry count */
                     if( ++retry_count > MAX_TASKGET_RETRY )
                         {
-                            fprintf( stderr, "Panic(P%d):No free task\n",
+                            fprintf( stderr, "Panic(P%ld):No free task\n",
                                     process_id ) ;
-                            fprintf( stderr, "  Local %d\n", task_struct[process_id].n_local_free_task ) ;
-                            fprintf( stderr, "  Q0 free %d\n",
+                            fprintf( stderr, "  Local %ld\n", task_struct[process_id].n_local_free_task ) ;
+                            fprintf( stderr, "  Q0 free %ld\n",
                                     global->task_queue[0].n_free ) ;
-                            fprintf( stderr, "  Q0 task %d\n",
+                            fprintf( stderr, "  Q0 task %ld\n",
                                     global->task_queue[0].n_tasks ) ;
                             exit(1) ;
                         }
                 }
         }
-    
-    
+
+
     /* Delete from the queue */
     p = task_struct[process_id].local_free_task ;
     task_struct[process_id].local_free_task = p->next ;
     task_struct[process_id].n_local_free_task-- ;
-    
+
     /* Clear pointer just in case.. */
     p->next = 0 ;
-    
-    
+
+
     return( p ) ;
 }
 
 
 
-void free_task( task, process_id )
-  
-  Task *task ;
-  unsigned process_id;
+void free_task(Task *task, long process_id)
 {
     Task_Queue *tq ;
     Task *p, *top ;
-    int i ;
-    
+    long i ;
+
     /* Insert to the local queue */
     task->next = task_struct[process_id].local_free_task ;
     task_struct[process_id].local_free_task = task ;
     task_struct[process_id].n_local_free_task++ ;
-    
+
     /* If local list is too long, export some tasks */
     if( task_struct[process_id].n_local_free_task >= (N_ALLOCATE_LOCAL_TASK * 2) )
         {
             tq = &global->task_queue[ taskqueue_id[process_id] ] ;
-            
+
             for( i = 1, p = task_struct[process_id].local_free_task ;
                 i < N_ALLOCATE_LOCAL_TASK ;   i++, p = p->next ) ;
-            
+
             /* Update local list */
             top = task_struct[process_id].local_free_task ;
             task_struct[process_id].local_free_task = p->next ;
             task_struct[process_id].n_local_free_task -= i ;
-            
+
             /* Insert in the shared list */
             LOCK(tq->f_lock);
             p->next = tq->free ;
@@ -675,21 +620,20 @@
  ****************************************************************************/
 
 
-void init_taskq(process_id)
-  unsigned process_id;
+void init_taskq(long process_id)
 {
-    int i ;
-    int qid ;
-    int task_index = 0 ;
-    int task_per_queue ;
-    int n_tasks ;
-    
+    long i ;
+    long qid ;
+    long task_index = 0 ;
+    long task_per_queue ;
+    long n_tasks ;
+
     /* Reset task assignment index */
     task_struct[process_id].crnt_taskq_id = 0 ;
-    
+
     /* Initialize task queues */
     task_per_queue = (MAX_TASKS + n_taskqueues - 1) / n_taskqueues ;
-    
+
     for( qid = 0 ; qid < n_taskqueues ; qid++ )
         {
             /* Initialize free list */
@@ -697,27 +641,27 @@
                 n_tasks = MAX_TASKS - task_index ;
             else
                 n_tasks = task_per_queue ;
-            
+
             for( i = task_index ; i < task_index + n_tasks - 1 ; i++ )
                 global->task_buf[i].next = &global->task_buf[i+1] ;
             global->task_buf[ i ].next = 0 ;
-            
+
             global->task_queue[ qid ].free = &global->task_buf[ task_index ] ;
             global->task_queue[ qid ].n_free = n_tasks ;
-            
+
             /* Initialize task queue */
             global->task_queue[ qid ].top     = 0 ;
             global->task_queue[ qid ].tail    = 0 ;
             global->task_queue[ qid ].n_tasks = 0 ;
-            
+
             /* Initialize locks */
             LOCKINIT(global->task_queue[ qid ].q_lock);
             LOCKINIT(global->task_queue[ qid ].f_lock);
-            
+
             /* Update index for next queue */
             task_index += n_tasks ;
         }
-    
+
     /* Initialize local free lists */
     task_struct[process_id].n_local_free_task      = 0 ;
     task_struct[process_id].local_free_task        = 0 ;
@@ -733,24 +677,23 @@
  *
  ****************************************************************************/
 
-int check_task_counter(process_id)
-  unsigned process_id;
+long check_task_counter()
 {
-    int flag = 0 ;
-    
-    
+    long flag = 0 ;
+
+
     LOCK(global->task_counter_lock);
-    
+
     if( global->task_counter == 0 )
         /* First processor */
         flag = 1 ;
-    
+
     global->task_counter++ ;
     if( global->task_counter >= n_processors )
         global->task_counter = 0 ;
-    
+
     UNLOCK(global->task_counter_lock);
-    
+
     return( flag ) ;
 }
 
@@ -764,16 +707,15 @@
  *
  ****************************************************************************/
 
-int assign_taskq(process_id)
-  unsigned process_id;
+long assign_taskq(long process_id)
 {
-    int qid ;
-    
+    long qid ;
+
     qid = task_struct[process_id].crnt_taskq_id++ ;
-    
+
     if( task_struct[process_id].crnt_taskq_id >= n_taskqueues )
         task_struct[process_id].crnt_taskq_id = 0 ;
-    
+
     return( qid ) ;
 }
 
@@ -787,17 +729,14 @@
  *
  ****************************************************************************/
 
-void print_task( task, process_id )
-  
-  Task *task ;
-  unsigned process_id;
+void print_task(Task *task)
 {
     if( task == 0 )
         {
             printf( "Task (NULL)\n" ) ;
             return ;
         }
-    
+
     switch( task->task_type )
         {
         case TASK_MODELING:
@@ -810,33 +749,30 @@
             printf( "Task (FF Refinement)\n" ) ;
             break ;
         case TASK_RAY:
-            printf( "Task (Ray)  (patch ID %d)\n",
+            printf( "Task (Ray)  (patch ID %ld)\n",
                    task->task.ray.e->patch->seq_no ) ;
             break ;
         case TASK_VISIBILITY:
-            printf( "Task (Visibility)  (patch ID %d)\n",
+            printf( "Task (Visibility)  (patch ID %ld)\n",
                    task->task.vis.e->patch->seq_no ) ;
             break ;
         case TASK_RAD_AVERAGE:
             printf( "Task (RadAvg)\n" ) ;
             break ;
         default:
-            fprintf( stderr, "Task(Illegal task type %d)\n", task->task_type );
+            fprintf( stderr, "Task(Illegal task type %ld)\n", task->task_type );
         }
 }
 
 
-void print_taskq( tq, process_id )
-  
-  Task_Queue *tq ;
-  unsigned process_id;
+void print_taskq(Task_Queue *tq)
 {
     Task *t ;
-    
-    printf( "TaskQ: %d tasks in the queue\n", taskq_length(tq) ) ;
+
+    printf( "TaskQ: %ld tasks in the queue\n", taskq_length(tq) ) ;
     for( t = taskq_top(tq) ; t ; t = t->next )
         {
             printf( "  " ) ;
-            print_task( t, process_id ) ;
+            print_task( t ) ;
         }
 }
diff -Naur splash2/codes/apps/radiosity/visible.C splash2-modified/codes/apps/radiosity/visible.C
--- splash2/codes/apps/radiosity/visible.C	1994-10-18 13:37:24.000000000 -0400
+++ splash2-modified/codes/apps/radiosity/visible.C	2007-03-17 13:20:03.000000000 -0400
@@ -35,28 +35,24 @@
 
 #define FABS(x)  (((x) < 0)?-(x):(x))
 
-typedef struct {
-    float x, y, z;
-} Ray;
-
 
 float rand_ray1[VISI_RAYS_MAX][2], rand_ray2[VISI_RAYS_MAX][2] ;
 
 struct v_struct {
-    char pad1[PAGE_SIZE];	 	/* padding to avoid false-sharing 
-                                   and allow page-placement */	
+    char pad1[PAGE_SIZE];	 	/* padding to avoid false-sharing
+                                   and allow page-placement */
     Patch *v_src_patch, *v_dest_patch ;
     Vertex v_src_p1,   v_dest_p1 ;
     Vertex v_src_v12,  v_src_v13 ;
     Vertex v_dest_v12, v_dest_v13 ;
-    
-    int bsp_nodes_visited, total_bsp_nodes_visited ;
+
+    long bsp_nodes_visited, total_bsp_nodes_visited ;
     Ray ray_pool[VISI_POOL_NO];
     Vertex point_pool[VISI_POOL_NO];
-    int pool_dst_hits;	/* Number of rays that hit the destination  */
+    long pool_dst_hits;	/* Number of rays that hit the destination  */
     Patch *patch_cache[PATCH_CACHE_SIZE] ;
-    char pad2[PAGE_SIZE];	 	/* padding to avoid false-sharing 
-                                   and allow page-placement */	
+    char pad2[PAGE_SIZE];	 	/* padding to avoid false-sharing
+                                   and allow page-placement */
 } vis_struct[MAX_PROCESSORS];
 
 
@@ -75,16 +71,13 @@
  *       (3) Current scheme selects pairs of the small triangles in a static
  *           manner. The pairs are chosen such that rays are equally
  *           distributed.
- *	
+ *
  *************************************************************/
 
-void init_visibility_module(process_id)
-  unsigned process_id;
+void init_visibility_module(long process_id)
 {
-    void init_patch_cache() ;
-    
 #define TTICK (1.0/12.0)
-    
+
     /* Three corner triangles. P(i) -- Q(i) */
     rand_ray1[0][0] = TTICK ;      rand_ray1[0][1] = TTICK ;
     rand_ray1[1][0] = TTICK ;      rand_ray1[1][1] = TTICK * 10 ;
@@ -92,7 +85,7 @@
     rand_ray2[0][0] = TTICK ;      rand_ray2[0][1] = TTICK ;
     rand_ray2[1][0] = TTICK ;      rand_ray2[1][1] = TTICK * 10 ;
     rand_ray2[2][0] = TTICK * 10 ; rand_ray2[2][1] = TTICK ;
-    
+
     /* Three triangles adjacent to the corners. RotLeft P(i)--> Q(i+1) */
     rand_ray1[3][0] = TTICK * 2 ;  rand_ray1[3][1] = TTICK * 2 ;
     rand_ray1[4][0] = TTICK * 2 ;  rand_ray1[4][1] = TTICK * 8 ;
@@ -100,7 +93,7 @@
     rand_ray2[4][0] = TTICK * 2 ;  rand_ray2[4][1] = TTICK * 2 ;
     rand_ray2[5][0] = TTICK * 2 ;  rand_ray2[5][1] = TTICK * 8 ;
     rand_ray2[3][0] = TTICK * 8 ;  rand_ray2[3][1] = TTICK * 2 ;
-    
+
     /* Three triangles adjacent to the center. RotRight P(i)--> Q(i-1) */
     rand_ray1[6][0] = TTICK * 2 ;  rand_ray1[6][1] = TTICK * 5 ;
     rand_ray1[7][0] = TTICK * 5 ;  rand_ray1[7][1] = TTICK * 5 ;
@@ -108,11 +101,11 @@
     rand_ray2[8][0] = TTICK * 2 ;  rand_ray2[8][1] = TTICK * 5 ;
     rand_ray2[6][0] = TTICK * 5 ;  rand_ray2[6][1] = TTICK * 5 ;
     rand_ray2[7][0] = TTICK * 5 ;  rand_ray2[7][1] = TTICK * 2 ;
-    
+
     /* Center triangle. Straight P(i) --> Q(i) */
     rand_ray1[9][0] = TTICK * 4 ;  rand_ray1[9][1] = TTICK * 4 ;
     rand_ray2[9][0] = TTICK * 4 ;  rand_ray2[9][1] = TTICK * 4 ;
-    
+
     /* Along the pelimeter. RotRight P(i)--> Q(i-1) */
     rand_ray1[10][0] = TTICK * 1 ;  rand_ray1[10][1] = TTICK * 7 ;
     rand_ray1[11][0] = TTICK * 5 ;  rand_ray1[11][1] = TTICK * 4 ;
@@ -120,7 +113,7 @@
     rand_ray2[12][0] = TTICK * 1 ;  rand_ray2[12][1] = TTICK * 7 ;
     rand_ray2[10][0] = TTICK * 5 ;  rand_ray2[10][1] = TTICK * 4 ;
     rand_ray2[11][0] = TTICK * 4 ;  rand_ray2[11][1] = TTICK * 1 ;
-    
+
     /* Along the pelimeter. RotLeft P(i)--> Q(i+1) */
     rand_ray1[13][0] = TTICK * 1 ;  rand_ray1[13][1] = TTICK * 4 ;
     rand_ray1[14][0] = TTICK * 4 ;  rand_ray1[14][1] = TTICK * 7 ;
@@ -128,7 +121,7 @@
     rand_ray2[14][0] = TTICK * 1 ;  rand_ray2[14][1] = TTICK * 4 ;
     rand_ray2[15][0] = TTICK * 4 ;  rand_ray2[15][1] = TTICK * 7 ;
     rand_ray2[13][0] = TTICK * 7 ;  rand_ray2[13][1] = TTICK * 1 ;
-    
+
     /* Initialize patch cache */
     init_patch_cache(process_id) ;
 }
@@ -141,41 +134,36 @@
  *	Place: main loop.
  *
  *	Storage: must keep in the invidiual processor.
- *	
+ *
  *************************************************************/
 
-void get_test_rays( p_src, v, no, process_id )
-  
-  Vertex *p_src;
-  Ray *v;
-  int no;
-  unsigned process_id;
+void get_test_rays(Vertex *p_src, Ray *v, long no, long process_id)
 {
-    int g_index, i ;
+    long g_index, i ;
     Vertex p_dst ;
     float fv1, fv2 ;
-    
+
     if( no > VISI_RAYS_MAX )
         no = VISI_RAYS_MAX ;
-    
+
     for (i = 0, g_index = 0 ; i < no; i++, g_index++) {
-        
+
         fv1 = rand_ray1[ g_index ][0] ;
         fv2 = rand_ray1[ g_index ][1] ;
         p_src->x = vis_struct[process_id].v_src_p1.x + vis_struct[process_id].v_src_v12.x * fv1 + vis_struct[process_id].v_src_v13.x * fv2 ;
         p_src->y = vis_struct[process_id].v_src_p1.y + vis_struct[process_id].v_src_v12.y * fv1 + vis_struct[process_id].v_src_v13.y * fv2 ;
         p_src->z = vis_struct[process_id].v_src_p1.z + vis_struct[process_id].v_src_v12.z * fv1 + vis_struct[process_id].v_src_v13.z * fv2 ;
-        
+
         fv1 = rand_ray2[ g_index ][0] ;
         fv2 = rand_ray2[ g_index ][1] ;
         p_dst.x = vis_struct[process_id].v_dest_p1.x + vis_struct[process_id].v_dest_v12.x * fv1 + vis_struct[process_id].v_dest_v13.x * fv2 ;
         p_dst.y = vis_struct[process_id].v_dest_p1.y + vis_struct[process_id].v_dest_v12.y * fv1 + vis_struct[process_id].v_dest_v13.y * fv2 ;
         p_dst.z = vis_struct[process_id].v_dest_p1.z + vis_struct[process_id].v_dest_v12.z * fv1 + vis_struct[process_id].v_dest_v13.z * fv2 ;
-        
+
         v->x = p_dst.x - p_src->x;
         v->y = p_dst.y - p_src->y;
         v->z = p_dst.z - p_src->z;
-        
+
         p_src++;
         v++;
     }
@@ -184,42 +172,36 @@
 
 /************************************************************************
  *
- *	int v_intersect(): check if the ray intersects with the polygon.
+ *	long v_intersect(): check if the ray intersects with the polygon.
  *
  *************************************************************************/
 
 
-int v_intersect( patch, p, ray, t, process_id )
-  
-  Patch *patch;
-  Vertex *p;
-  Ray *ray;
-  float t ;
-  unsigned process_id;
+long v_intersect(Patch *patch, Vertex *p, Ray *ray, float t)
 {
     float px, py, pz;
     float nx, ny, nz;
     float rx, ry, rz;
     float x, y, x1, x2, x3, y1, y2, y3;
     float a, b, c;
-    int nc, sh, nsh;
-    
+    long nc, sh, nsh;
+
     nx = patch->plane_equ.n.x;
     ny = patch->plane_equ.n.y;
     nz = patch->plane_equ.n.z;
-    
+
     rx = ray->x;
     ry = ray->y;
     rz = ray->z;
-    
+
     px = p->x;
     py = p->y;
     pz = p->z;
-    
-    
+
+
     a = FABS(nx); b = FABS(ny); c = FABS(nz);
-    
-    if (a > b) 
+
+    if (a > b)
         if (a > c) {
             x  = py + t * ry; y = pz + t * rz;
             x1 = patch->p1.y; y1 = patch->p1.z;
@@ -242,24 +224,24 @@
         x2 = patch->p2.x; y2 = patch->p2.y;
         x3 = patch->p3.x; y3 = patch->p3.y;
     }
-    
-    
+
+
     x1 -= x; y1 -= y;
     x2 -= x; y2 -= y;
     x3 -= x; y3 -= y;
-    
+
     nc = 0;
-    
+
     if (y1 >= 0.0)
         sh = 1;
     else
         sh = -1;
-    
+
     if (y2 >= 0.0)
         nsh = 1;
-    else 
+    else
         nsh = -1;
-    
+
     if (sh != nsh) {
         if ((x1 >= 0.0) && (x2 >= 0.0))
             nc++;
@@ -268,12 +250,12 @@
                 nc++;
         sh = nsh;
     }
-    
+
     if (y3 >= 0.0)
         nsh = 1;
-    else 
+    else
         nsh = -1;
-    
+
     if (sh != nsh) {
         if ((x2 >= 0.0) && (x3 >= 0.0))
             nc++;
@@ -282,12 +264,12 @@
                 nc++;
         sh = nsh;
     }
-    
+
     if (y1 >= 0.0)
         nsh = 1;
-    else 
+    else
         nsh = -1;
-    
+
     if (sh != nsh) {
         if ((x3 >= 0.0) && (x1 >= 0.0))
             nc++;
@@ -296,13 +278,13 @@
                 nc++;
         sh = nsh;
     }
-    
-    if ((nc % 2) == 0) 
+
+    if ((nc % 2) == 0)
         return(0);
     else {
         return(1);
     }
-    
+
 }
 
 
@@ -340,74 +322,61 @@
  *****************************************************************************/
 
 
-int traverse_bsp( src_node, p, ray, r_min, r_max, process_id )
-  
-  Patch *src_node ;
-  Vertex *p ;
-  Ray *ray ;
-  float r_min, r_max ;
-  unsigned process_id;
+long traverse_bsp(Patch *src_node, Vertex *p, Ray *ray, float r_min, float r_max, long process_id)
 {
-    float t ;
+    float t = 0.0 ;
     Patch *parent, *visited_child ;
-    int traverse_subtree() ;
-    int test_intersection() ;
-    int advice ;
-    
-    
+    long advice ;
+
+
     /* (1) Check patch cache */
     if( check_patch_cache( p, ray, r_min, r_max, process_id ) )
         return( 1 ) ;
-    
+
     /* (2) Check S+(src_node) */
     if( traverse_subtree( src_node->bsp_positive, p, ray, r_min, r_max, process_id ) )
         return( 1 ) ;
-    
+
     /* (3) Continue in-order traversal till root is encountered */
     for( parent = src_node->bsp_parent, visited_child = src_node ;
         parent ;
         visited_child = parent, parent = parent->bsp_parent )
         {
             /* Check intersection at this node */
-            advice = intersection_type( parent, p, ray, &t, r_min, r_max, process_id ) ;
-            if( (advice != POSITIVE_SUBTREE_ONLY) &&
-               (advice != NEGATIVE_SUBTREE_ONLY) )
+            advice = intersection_type( parent, p, ray, &t, r_min, r_max ) ;
+            if( (advice != POSITIVE_SUBTREE_ONLY) && (advice != NEGATIVE_SUBTREE_ONLY) )
                 {
                     if( test_intersection( parent, p, ray, t, process_id ) )
                         return( 1 ) ;
-                    
+
                     r_min = t - VIS_RANGE_MARGIN ;
                 }
-            
+
             /* Traverse unvisited subtree of the node */
-            if(   (parent->bsp_positive == visited_child)
-               && (advice != POSITIVE_SUBTREE_ONLY) )
+            if(   (parent->bsp_positive == visited_child) && (advice != POSITIVE_SUBTREE_ONLY) )
                 {
-                    if( traverse_subtree( parent->bsp_negative, p, ray,
-                                         r_min, r_max, process_id ) )
+                    if( traverse_subtree( parent->bsp_negative, p, ray, r_min, r_max, process_id ) )
                         return( 1 ) ;
                 }
-            else if( (parent->bsp_positive != visited_child)
-                    && (advice != NEGATIVE_SUBTREE_ONLY) )
+            else if( (parent->bsp_positive != visited_child) && (advice != NEGATIVE_SUBTREE_ONLY) )
                 {
-                    if( traverse_subtree( parent->bsp_positive, p, ray,
-                                         r_min, r_max, process_id ) )
+                    if( traverse_subtree( parent->bsp_positive, p, ray, r_min, r_max, process_id ) )
                         return( 1 ) ;
                 }
         }
-    
+
     return( 0 ) ;
 }
 
 
 
 
-int traverse_subtree( node, p, ray, r_min, r_max, process_id )
+long traverse_subtree(Patch *node, Vertex *p, Ray *ray, float r_min, float r_max, long process_id)
   /*
    *    To minimize the length of the traversal of the BSP tree, a pruning
    *    algorithm is incorporated.
-   *    One possibility (not used in this version) is to prune one of the 
-   *	 subtrees if the node in question intersects the ray outside of the 
+   *    One possibility (not used in this version) is to prune one of the
+   *	 subtrees if the node in question intersects the ray outside of the
    *	 range defined by the source and the destination patches.
    *    Another possibility (used here) is more aggressive pruning. Like the above
    *    method, the intersection point is checked against the range to prune the
@@ -415,27 +384,22 @@
    *    the range itself is recursively subdivided so that the minimum range is
    *    applied the possibility of pruning maximized.
    */
-  Patch *node ;
-  Vertex *p ;
-  Ray *ray ;
-  float r_min, r_max ;
-  unsigned process_id;
 {
     float t ;
-    int advice ;
-    
-    
+    long advice ;
+
+
     if( node == 0 )
         return( 0 ) ;
-    
-    advice = intersection_type( node, p, ray, &t, r_min, r_max, process_id ) ;
+
+    advice = intersection_type( node, p, ray, &t, r_min, r_max ) ;
     if( advice == POSITIVE_SIDE_FIRST )
         {
             /* The ray is approaching from the positive side of the patch */
             if( traverse_subtree( node->bsp_positive, p, ray,
                                  r_min, t + VIS_RANGE_MARGIN, process_id ) )
                 return( 1 ) ;
-            
+
             if( test_intersection( node, p, ray, t, process_id ) )
                 return( 1 ) ;
             return( traverse_subtree( node->bsp_negative, p, ray,
@@ -449,11 +413,11 @@
                 return( 1 ) ;
             if( test_intersection( node, p, ray, t, process_id ) )
                 return( 1 ) ;
-            
+
             return( traverse_subtree( node->bsp_positive, p, ray,
                                      t - VIS_RANGE_MARGIN, r_max, process_id ) ) ;
         }
-    
+
     else if( advice == POSITIVE_SUBTREE_ONLY )
         return( traverse_subtree( node->bsp_positive, p, ray,
                                  r_min, r_max, process_id ) ) ;
@@ -486,45 +450,38 @@
  *
  ***************************************************************************/
 
-int intersection_type( patch, p, ray, tval, range_min, range_max, process_id )
-  
-  Patch  *patch ;
-  Vertex *p ;
-  Ray    *ray ;
-  float  *tval ;
-  float  range_min, range_max ;
-  unsigned process_id;
+long intersection_type(Patch  *patch, Vertex *p, Ray *ray, float *tval, float range_min, float range_max)
 {
     float r_dot_n ;
     float dist ;
     float t ;
     float nx, ny, nz ;
-    
+
 #if PATCH_ASSIGNMENT == PATCH_ASSIGNMENT_COSTBASED
     vis_struct[process_id].bsp_nodes_visited++ ;
 #endif
-    
+
     /* (R.N) */
     nx = patch->plane_equ.n.x ;
     ny = patch->plane_equ.n.y ;
     nz = patch->plane_equ.n.z ;
-    
+
     r_dot_n = nx * ray->x + ny * ray->y + nz * ray->z ;
     dist = patch->plane_equ.c  +  p->x * nx  +  p->y * ny  +  p->z * nz ;
-    
+
     if( (-(float)F_ZERO < r_dot_n) && (r_dot_n < (float)F_ZERO) )
         {
             if( dist > (float)F_COPLANAR )
                 return( POSITIVE_SUBTREE_ONLY ) ;
             else if( dist < -F_COPLANAR )
                 return( NEGATIVE_SUBTREE_ONLY ) ;
-            
+
             return( ON_THE_PLANE ) ;
         }
-    
+
     t = -dist / r_dot_n ;
     *tval = t ;
-    
+
     if( t < range_min )
         {
             if( r_dot_n >= 0 )
@@ -555,35 +512,27 @@
  *
  *************************************************************/
 
-int test_intersection( patch, p, ray, tval, process_id )
-  
-  Patch  *patch ;
-  Vertex *p ;
-  Ray    *ray ;
-  float  tval ;
-  unsigned process_id;
+long test_intersection(Patch *patch, Vertex *p, Ray *ray, float tval, long process_id)
 {
-    void update_patch_cache() ;
-    
     /* Rays always hit the destination. Note that (R.Ndest) is already
        checked by visibility() */
-    
+
     if( patch == vis_struct[process_id].v_dest_patch )
         {
             vis_struct[process_id].pool_dst_hits++ ;
             return( 1 ) ;
         }
-    
+
     if( patch_tested( patch, process_id ) )
         return( 0 ) ;
-    
-    if( v_intersect( patch, p, ray, tval, process_id ) )
+
+    if( v_intersect( patch, p, ray, tval ) )
         {
             /* Store it in the patch-cache */
             update_patch_cache( patch, process_id ) ;
             return( 1 ) ;
         }
-    
+
     return( 0 ) ;
 }
 
@@ -600,8 +549,8 @@
  *    To exploit visibility coherency, a patch cache is used.
  *    Before traversing the BSP tree, the cache contents are tested to see
  *    if they intercept the ray in question. The size of the patch cache is
- *    defined by PATCH_CACHE_SIZE (in patch.H). Since the first two 
- *    entries of the cache 
+ *    defined by PATCH_CACHE_SIZE (in patch.H). Since the first two
+ *    entries of the cache
  *    usually cover about 95% of the cache hits, increasing the cache size
  *    does not help much. Nevertheless, the program is written so that
  *    increasing cache size does not result in additional ray-intersection
@@ -609,52 +558,42 @@
  *
  *************************************************************/
 
-void update_patch_cache( patch, process_id )
-  
-  Patch *patch ;
-  unsigned process_id;
+void update_patch_cache(Patch *patch, long process_id)
 {
-    int i ;
-    
+    long i ;
+
     /* Shift current contents */
     for( i = PATCH_CACHE_SIZE-1 ; i > 0  ; i-- )
         vis_struct[process_id].patch_cache[i] = vis_struct[process_id].patch_cache[i-1] ;
-    
+
     /* Store the new patch data */
     vis_struct[process_id].patch_cache[0] = patch ;
 }
 
 
 
-int check_patch_cache( p, ray, r_min, r_max, process_id )
-  
-  Vertex *p ;
-  Ray    *ray ;
-  float  r_min, r_max ;
-  unsigned process_id;
+long check_patch_cache(Vertex *p, Ray *ray, float r_min, float r_max, long process_id)
 {
-    int i ;
+    long i ;
     float t ;
     Patch *temp ;
-    int advice ;
-    
+    long advice ;
+
     for( i = 0 ; i < PATCH_CACHE_SIZE ; i++ )
         {
             if(   (vis_struct[process_id].patch_cache[i] == 0)
                || (vis_struct[process_id].patch_cache[i] == vis_struct[process_id].v_dest_patch)
                || (vis_struct[process_id].patch_cache[i] == vis_struct[process_id].v_src_patch) )
                 continue ;
-            
-            advice = intersection_type( vis_struct[process_id].patch_cache[i],  p, ray, &t,
-                                       r_min, r_max, process_id ) ;
-            
+
+            advice = intersection_type( vis_struct[process_id].patch_cache[i],  p, ray, &t, r_min, r_max ) ;
+
             /* If no intersection, then skip */
             if(   (advice == POSITIVE_SUBTREE_ONLY)
                || (advice == NEGATIVE_SUBTREE_ONLY) )
                 continue ;
-            
-            if(   (advice == ON_THE_PLANE)
-               || v_intersect( vis_struct[process_id].patch_cache[i], p, ray, t, process_id ) )
+
+            if(   (advice == ON_THE_PLANE) || v_intersect( vis_struct[process_id].patch_cache[i], p, ray, t ) )
                 {
                     /* Change priority */
                     if( i > 0 )
@@ -663,39 +602,36 @@
                             vis_struct[process_id].patch_cache[ i-1 ] = vis_struct[process_id].patch_cache[ i ] ;
                             vis_struct[process_id].patch_cache[ i ] = temp ;
                         }
-                    
+
                     return( 1 ) ;
                 }
         }
-    
-    
+
+
     return( 0 ) ;
 }
 
 
 
-void init_patch_cache(process_id)
+void init_patch_cache(long process_id)
 {
-    int i ;
-    
+    long i ;
+
     for( i = 0 ; i < PATCH_CACHE_SIZE ; i++ )
         vis_struct[process_id].patch_cache[ i ] = 0 ;
 }
 
 
-int patch_tested( p, process_id )
-  
-  Patch *p ;
-  unsigned process_id;
+long patch_tested(Patch *p, long process_id)
 {
-    int i ;
-    
+    long i ;
+
     for( i = 0 ; i < PATCH_CACHE_SIZE ; i++ )
         {
             if( p == vis_struct[process_id].patch_cache[i] )
                 return( 1 ) ;
         }
-    
+
     return( 0 ) ;
 }
 
@@ -707,20 +643,16 @@
  *************************************************************/
 
 
-float visibility( e1, e2, n_rays, process_id )
-  
-  Element *e1, *e2;
-  int n_rays ;
-  unsigned process_id;
+float visibility(Element *e1, Element *e2, long n_rays, long process_id)
 {
     float range_max, range_min ;
-    int i;
+    long i;
     Ray *r;
-    int ray_reject ;
-    
+    long ray_reject ;
+
     vis_struct[process_id].v_src_patch  = e1->patch;
     vis_struct[process_id].v_dest_patch = e2->patch;
-    
+
     vis_struct[process_id].v_src_p1 = e1->ev1->p ;
     vis_struct[process_id].v_src_v12.x = e1->ev2->p.x - vis_struct[process_id].v_src_p1.x ;
     vis_struct[process_id].v_src_v12.y = e1->ev2->p.y - vis_struct[process_id].v_src_p1.y ;
@@ -728,7 +660,7 @@
     vis_struct[process_id].v_src_v13.x = e1->ev3->p.x - vis_struct[process_id].v_src_p1.x ;
     vis_struct[process_id].v_src_v13.y = e1->ev3->p.y - vis_struct[process_id].v_src_p1.y ;
     vis_struct[process_id].v_src_v13.z = e1->ev3->p.z - vis_struct[process_id].v_src_p1.z ;
-    
+
     vis_struct[process_id].v_dest_p1 = e2->ev1->p ;
     vis_struct[process_id].v_dest_v12.x = e2->ev2->p.x - vis_struct[process_id].v_dest_p1.x ;
     vis_struct[process_id].v_dest_v12.y = e2->ev2->p.y - vis_struct[process_id].v_dest_p1.y ;
@@ -736,37 +668,37 @@
     vis_struct[process_id].v_dest_v13.x = e2->ev3->p.x - vis_struct[process_id].v_dest_p1.x ;
     vis_struct[process_id].v_dest_v13.y = e2->ev3->p.y - vis_struct[process_id].v_dest_p1.y ;
     vis_struct[process_id].v_dest_v13.z = e2->ev3->p.z - vis_struct[process_id].v_dest_p1.z ;
-    
+
     get_test_rays( vis_struct[process_id].point_pool, vis_struct[process_id].ray_pool, n_rays, process_id ) ;
-    
+
     range_min = -VIS_RANGE_MARGIN ;
     range_max =  1.0 + VIS_RANGE_MARGIN ;
-    
+
     vis_struct[process_id].pool_dst_hits = 0 ;
     ray_reject = 0 ;
     for ( i = 0 ; i < n_rays ; i++ )
         {
             r = &(vis_struct[process_id].ray_pool[i]);
-            
-            if (  (inner_product( r, &(vis_struct[process_id].v_src_patch)->plane_equ.n ) <= 0.0 )
-                ||(inner_product( r, &(vis_struct[process_id].v_dest_patch)->plane_equ.n ) >= 0.0 ) )
+
+            if (  (inner_product( (Vertex *)r, &(vis_struct[process_id].v_src_patch)->plane_equ.n ) <= 0.0 )
+                ||(inner_product( (Vertex *)r, &(vis_struct[process_id].v_dest_patch)->plane_equ.n ) >= 0.0 ) )
                 {
                     ray_reject++ ;
                     continue ;
                 }
-            
+
             traverse_bsp( vis_struct[process_id].v_src_patch, &vis_struct[process_id].point_pool[i], r, range_min, range_max, process_id ) ;
         }
-    
+
     if (ray_reject == n_rays) {
         /* All rays have been trivially rejected. This can occur
            if no rays are shot between visible portion of the elements.
            Return partial visibility (1/No-of-rays). */
-        
+
         /* Return partially visible result */
         vis_struct[process_id].pool_dst_hits = 1 ;
     }
-    
+
     return( (float)vis_struct[process_id].pool_dst_hits / (float)n_rays ) ;
 }
 
@@ -780,25 +712,19 @@
  *
  ******************************************************************/
 
-void compute_visibility_values( elem, inter, n_inter, process_id )
-  
-  Element *elem ;                /* Element that the list belongs to */
-  Interaction *inter ;	   /* Interaction list */
-  int n_inter ;		   /* Number of interactions whose visibility
-                          value is computed */
-  unsigned process_id;
+void compute_visibility_values(Element *elem, Interaction *inter, long n_inter, long process_id)
 {
     for( ; n_inter > 0 ; inter = inter->next, n_inter-- )
         {
             if( inter->visibility != VISIBILITY_UNDEF )
                 continue ;
-            
+
             vis_struct[process_id].bsp_nodes_visited = 0 ;
-            
+
             inter->visibility
                 = visibility( elem, inter->destination,
                              N_VISIBILITY_TEST_RAYS, process_id ) ;
-            
+
             vis_struct[process_id].total_bsp_nodes_visited += vis_struct[process_id].bsp_nodes_visited ;
         }
 }
@@ -813,37 +739,30 @@
  *
  ******************************************************************/
 
-void visibility_task( elem, inter, n_inter, k, process_id )
-  
-  Element *elem ;                /* Element that the list belongs to */
-  Interaction *inter ;	   /* Interaction list */
-  int n_inter ;		   /* Number of interactions whose visibility
-                          value is computed */
-  void (*k)() ;		   /* Continuation */
-  unsigned process_id;
+void visibility_task(Element *elem, Interaction *inter, long n_inter, void (*k)(), long process_id)
 {
 #if PATCH_ASSIGNMENT == PATCH_ASSIGNMENT_COSTBASED
     Patch_Cost *pc ;
 #endif
-    int new_vis_undef_count ;
-    
+    long new_vis_undef_count ;
+
     /* Compute visibility */
     vis_struct[process_id].total_bsp_nodes_visited = 0 ;
     compute_visibility_values( elem, inter, n_inter, process_id ) ;
-    
+
     /* Change visibility undef count */
     LOCK(elem->elem_lock->lock);
     elem->n_vis_undef_inter -= n_inter ;
     new_vis_undef_count = elem->n_vis_undef_inter ;
     UNLOCK(elem->elem_lock->lock);
-    
+
 #if PATCH_ASSIGNMENT == PATCH_ASSIGNMENT_COSTBASED
     pc = &global->patch_cost[ elem->patch->seq_no ] ;
     LOCK(pc->cost_lock->lock);
     pc->n_bsp_node += vis_struct[process_id].total_bsp_nodes_visited ;
     UNLOCK(pc->cost_lock->lock);
 #endif
-    
+
     /* Call continuation if this is the last task finished. */
     if( new_vis_undef_count == 0 )
         k( elem, process_id ) ;
diff -Naur splash2/codes/apps/raytrace/bbox.C splash2-modified/codes/apps/raytrace/bbox.C
--- splash2/codes/apps/raytrace/bbox.C	1994-10-14 17:25:59.000000000 -0400
+++ splash2-modified/codes/apps/raytrace/bbox.C	2007-03-18 01:17:33.000000000 -0400
@@ -45,10 +45,7 @@
  *	Nothing.
  */
 
-VOID	InquireBoundBoxValues(pbb, minx, miny, minz, maxx, maxy, maxz)
-BBOX	*pbb;
-REAL	*minx, *miny, *minz;
-REAL	*maxx, *maxy, *maxz;
+VOID	InquireBoundBoxValues(BBOX *pbb, REAL *minx, REAL *miny, REAL *minz, REAL *maxx, REAL *maxy, REAL *maxz)
 	{
 	*minx = pbb->dnear[0];
 	*miny = pbb->dnear[1];
@@ -73,9 +70,7 @@
  *	Nothing.
  */
 
-VOID	NormalizeBoundBox(pbb, mat)
-BBOX	*pbb;
-MATRIX	mat;
+VOID	NormalizeBoundBox(BBOX *pbb, MATRIX mat)
 	{
 	POINT	tmp;
 
diff -Naur splash2/codes/apps/raytrace/cr.C splash2-modified/codes/apps/raytrace/cr.C
--- splash2/codes/apps/raytrace/cr.C	1994-10-14 17:26:00.000000000 -0400
+++ splash2-modified/codes/apps/raytrace/cr.C	2007-03-18 01:16:17.000000000 -0400
@@ -34,9 +34,9 @@
 
 GRID	*gridlist = NULL;
 
-/* 
+/*
 	Note: gridlist doesn't need to be an array since it is only used when
-	building HUG, which is done before child process creation 
+	building HUG, which is done before child process creation
 */
 
 
@@ -151,13 +151,9 @@
  *
  */
 
-GRID	*init_world_grid(v, pepa, num_pe)
-VOXEL	*v;
-ELEMENT **pepa;
-INT	num_pe;
+GRID	*init_world_grid(VOXEL	*v, ELEMENT **pepa, INT	num_pe)
 	{
 	UINT	*ec;
-	UINT	*pc;
 	BBOX	wbox;
 	GRID	*g;
 	VOXEL	**ht;
@@ -220,9 +216,7 @@
  *
  */
 
-VOXEL	*init_world_voxel(pepa, numelements)
-ELEMENT **pepa;
-INT	numelements;
+VOXEL	*init_world_voxel(ELEMENT **pepa, INT	numelements)
 	{
 	VOXEL	*v;
 
@@ -254,9 +248,7 @@
  *	Nothing.
  */
 
-VOID	mark_empty(index1D, g)
-INT	index1D;
-GRID	*g;
+VOID	mark_empty(INT	index1D, GRID	*g)
 	{
 	INT	i, r;
 	UINT	w;
@@ -284,9 +276,7 @@
  *	Nothing.
  */
 
-VOID	mark_nonempty(index1D, g)
-INT	index1D;
-GRID	*g;
+VOID	mark_nonempty(INT index1D, GRID *g)
 	{
 	INT	i, r;
 	UINT	w;
@@ -314,9 +304,7 @@
  *	Nothing.
  */
 
-VOID	insert_in_hashtable(v, g)
-VOXEL	*v;
-GRID	*g;
+VOID	insert_in_hashtable(VOXEL *v, GRID *g)
 	{
 	INT	i, r;
 	VOXEL	*vht;
@@ -346,11 +334,7 @@
  *	bounding box.
  */
 
-ELEMENT **prims_in_box2(pepa, n_in, b, n)
-ELEMENT **pepa;
-INT	n_in;
-BBOX	b;
-INT	*n;
+ELEMENT **prims_in_box2(ELEMENT **pepa, INT n_in, BBOX b, INT *n)
 	{
 	INT	ovlap, i, j, k;
 	ELEMENT *pe;
@@ -371,7 +355,7 @@
 		npepa = ObjectMalloc(OT_PEPARRAY, n_in);
 	else
 		{
-		npepa == NULL;
+		npepa = NULL;
 		*n = 0;
 		return (npepa);
 		}
@@ -449,11 +433,9 @@
  *
  */
 
-BTNODE	*init_bintree(ng)
-GRID	*ng;
+BTNODE	*init_bintree(GRID *ng)
 	{
 	BTNODE	*btn;
-	ELEMENT **pepa;
 
 	btn = ObjectMalloc(OT_BINTREE, 1);
 
@@ -503,9 +485,7 @@
  *
  */
 
-VOID	subdiv_bintree(btn, g)
-BTNODE	*btn;
-GRID	*g;
+VOID	subdiv_bintree(BTNODE *btn, GRID *g)
 	{
 	BTNODE	*btn1, *btn2;
 	INT	 n1, n2, imax, dmax;
@@ -600,7 +580,7 @@
 
 		btn2->pe    = prims_in_box2(btn->pe, btn->nprims, b2, &(btn2->nprims));
 		btn2->totalPrimsAllocated = btn->nprims;
-		
+
 		}
 
 	if (btn1->n[0] == 1 && btn1->n[1] == 1 && btn1->n[2] == 1)
@@ -630,9 +610,7 @@
  *	Nothing.
  */
 
-VOID	create_bintree(root , g)
-BTNODE	*root;
-GRID	*g;
+VOID	create_bintree(BTNODE *root, GRID *g)
 	{
 	BTNODE	*btn;
 
@@ -675,13 +653,8 @@
  *
  */
 
-ELEMENT **bintree_lookup(root, i, j, k, g, n)
-BTNODE	*root;
-INT	i, j, k;
-GRID	*g;
-INT	*n;
+ELEMENT **bintree_lookup(BTNODE	*root, INT i, INT j, INT k, GRID *g, INT *n)
 	{
-	INT	l,x;
 	INT	ijk[3];
 	INT	child;
 	INT	idiv;
@@ -776,8 +749,7 @@
  *	Nothing.
  */
 
-VOID	deleteBinTree(binTree)
-BTNODE	*binTree;
+VOID	deleteBinTree(BTNODE *binTree)
 	{
 	BTNODE *left, *right;
 
@@ -821,20 +793,15 @@
  *	A pointer to the grid.
  */
 
-GRID	*create_grid(v, g, num_prims)
-VOXEL	*v;
-GRID	*g;
-INT	num_prims;
+GRID	*create_grid(VOXEL *v, GRID *g, INT num_prims)
 	{
 	INT	n;
 	INT	i, j, k, r;
 	INT	nprims;
 	INT	index1D;
 	UINT	*ec;
-	UINT	*pc;
-	R64	nec, unsgn, ncells;
+	R64	ncells;
 	GRID	*ng, *nng;	/* New grid. */
-	BBOX	b;
 	VOXEL	*nv;
 	VOXEL	**ht;
 	BTNODE	*bintree;
diff -Naur splash2/codes/apps/raytrace/env.C splash2-modified/codes/apps/raytrace/env.C
--- splash2/codes/apps/raytrace/env.C	1994-10-14 17:26:00.000000000 -0400
+++ splash2-modified/codes/apps/raytrace/env.C	2007-03-21 16:47:55.000000000 -0400
@@ -27,6 +27,7 @@
 
 #include <stdio.h>
 #include <math.h>
+#include <string.h>
 #include "rt.h"
 
 
@@ -420,8 +421,7 @@
  *	TRUE if color is within range, FALSE otherwise.
  */
 
-BOOL	VerifyColorRange(c)
-COLOR	c;
+BOOL	VerifyColorRange(COLOR c)
 	{
 	if (c[0] < 0.0 || c[0] > 1.0  ||
 	    c[1] < 0.0 || c[1] > 1.0  ||
@@ -448,8 +448,7 @@
  *	Nothing.
  */
 
-VOID	TransformLights(m)
-MATRIX	m;
+VOID	TransformLights(MATRIX m)
 	{
 	INT	i;
 	LIGHT	*lp;
@@ -477,9 +476,7 @@
  *	Nothing.
  */
 
-VOID	ViewRotate(M, x, y, z)
-MATRIX	M;
-REAL	x, y, z;
+VOID	ViewRotate(MATRIX M, REAL x, REAL y, REAL z)
 	{
 	REAL	r, rx;
 
@@ -560,8 +557,7 @@
  *	Nothing.
  */
 
-VOID	TransformViewRay(tray)
-POINT	tray;
+VOID	TransformViewRay(POINT tray)
 	{
 	VecMatMult(tray, View.vtransInv, tray);
 	}
@@ -580,11 +576,8 @@
  *	Nothing.
  */
 
-VOID	NormalizeEnv(normMat)
-MATRIX	normMat;
+VOID	NormalizeEnv(MATRIX normMat)
 	{
-	POINT	tmp;
-
 	View.eye[3] = 1.0;
 	VecMatMult(View.eye, normMat, View.eye);
 
@@ -608,8 +601,7 @@
  *	The corresponding opcode.
  */
 
-CHAR	LookupCommand(s)
-CHAR	*s;
+CHAR	LookupCommand(CHAR *s)
 	{
 	INT	i;
 
@@ -635,8 +627,7 @@
  *	Nothing.
  */
 
-VOID	ReadEnvFile(EnvFileName)
-CHAR	*EnvFileName;
+VOID	ReadEnvFile(CHAR *EnvFileName)
 	{
 	INT	i, j;				/* Indices.		     */
 	INT	stat;				/* Input var status counter. */
@@ -755,7 +746,7 @@
 			/* Recursion level. */
 			case OP_MAXLEVEL:
 				stat = fscanf(pf, "%ld", &(Display.maxlevel));
-				printf("maxlevel of ray recursion = %d\n",Display.maxlevel);	
+				printf("maxlevel of ray recursion = %ld\n",Display.maxlevel);
 				fflush(stdout);
 				if (stat != 1)
 					{
diff -Naur splash2/codes/apps/raytrace/fbuf.C splash2-modified/codes/apps/raytrace/fbuf.C
--- splash2/codes/apps/raytrace/fbuf.C	1994-10-14 17:26:00.000000000 -0400
+++ splash2-modified/codes/apps/raytrace/fbuf.C	2007-03-18 01:22:02.000000000 -0400
@@ -44,9 +44,9 @@
 	}
 	image[MAX_X];
 
-/*	
+/*
 	image does not have  have to be made an array for tango-lite
-	since it is only used in RunLengthEncode, which is only 
+	since it is only used in RunLengthEncode, which is only
 	called by CloseFrameBuffer, which is only called after
 	all children have terminated
 */
@@ -67,10 +67,7 @@
  *	Nothing.
  */
 
-VOID	RunLengthEncode(pf, fb, xsize)
-FILE	*pf;
-PIXEL	*fb;
-INT	xsize;
+VOID	RunLengthEncode(FILE *pf, PIXEL *fb, INT xsize)
 	{
 	INT	x;			/* Original buffer entry address.    */
 	INT	rl;			/* Runlength buffer entry address.   */
@@ -159,10 +156,7 @@
  *	Nothing.
  */
 
-VOID	AddPixelColor(c, x, y)
-COLOR	c;
-INT	x;
-INT	y;
+VOID	AddPixelColor(COLOR c, INT x, INT y)
 	{
 	INT	addr;			/* Index into framebuffer.	     */
 	PIXEL	*fb;			/* Ptr to framebuffer.		     */
@@ -189,8 +183,7 @@
  *	Nothing.
  */
 
-VOID	CloseFrameBuffer(PicFileName)
-CHAR	*PicFileName;
+VOID	CloseFrameBuffer(CHAR *PicFileName)
 	{
 	INT	x;
 	INT	y;
diff -Naur splash2/codes/apps/raytrace/geo.C splash2-modified/codes/apps/raytrace/geo.C
--- splash2/codes/apps/raytrace/geo.C	1994-10-14 17:26:00.000000000 -0400
+++ splash2-modified/codes/apps/raytrace/geo.C	2007-03-18 01:23:36.000000000 -0400
@@ -30,6 +30,7 @@
 #include <stdio.h>
 #include <fcntl.h>
 #include <math.h>
+#include <string.h>
 #include "rt.h"
 
 
@@ -105,8 +106,7 @@
  *
  */
 
-ELEMENT **MakeElementArray(totalElements)
-INT	*totalElements;
+ELEMENT **MakeElementArray(INT *totalElements)
 	{
 	INT	 i;
 	OBJECT	*po;				/* Ptr to object.	     */
@@ -150,8 +150,7 @@
  *	Nothing.
  */
 
-VOID	PrintGeo(po)
-OBJECT	*po;
+VOID	PrintGeo(OBJECT *po)
 	{
 	while (po)
 		{
@@ -186,10 +185,7 @@
  *	Nothing.
  */
 
-VOID	NormalizeGeo(po, model, modelInvT)
-OBJECT	*po;
-MATRIX	model;
-MATRIX	modelInvT;
+VOID	NormalizeGeo(OBJECT *po, MATRIX model, MATRIX modelInvT)
 	{
 	REAL	norm_minx;			/* Normalize min values.     */
 	REAL	norm_miny;
@@ -278,8 +274,7 @@
  *	Nothing.
  */
 
-VOID	ReadGeoFile(GeoFileName)
-CHAR	*GeoFileName;
+VOID	ReadGeoFile(CHAR *GeoFileName)
 	{
 	INT		i;
 	INT		dummy;
@@ -293,7 +288,6 @@
 	MATRIX		model;			/* Model matrix.	     */
 	MATRIX		modelInv;		/* Model matrix inverse.     */
 	MATRIX		modelInvT;		/* Model matrix inv transpose*/
-	OBJECT		*po;			/* Ptr to object.	     */
 	OBJECT		*prev;			/* Ptr to previous object.   */
 	OBJECT		*curr;			/* Ptr to current object.    */
 	ELEMENT 	*pe;			/* Ptr to the element list.  */
diff -Naur splash2/codes/apps/raytrace/huprn.C splash2-modified/codes/apps/raytrace/huprn.C
--- splash2/codes/apps/raytrace/huprn.C	1994-10-14 17:26:00.000000000 -0400
+++ splash2-modified/codes/apps/raytrace/huprn.C	2007-03-18 01:25:45.000000000 -0400
@@ -29,15 +29,14 @@
 #include <math.h>
 #include "rt.h"
 
-VOID	prn_voxel(v)
-VOXEL	*v;
+VOID	prn_voxel(VOXEL *v)
 	{
 	ELEMENT *pe, **pepa;
 	GRID	*g;
 	INT	i;
 
 	fprintf(stderr, "    Print Voxel  id = %ld \n", v->id);
-	fprintf(stderr, "        celltype %ld \n", v->celltype);
+	fprintf(stderr, "        celltype %d \n", v->celltype);
 
 	if (v->celltype == GSM_VOXEL)
 		{
@@ -66,12 +65,10 @@
 
 
 
-VOID	prn_grid(g)
-GRID	*g;
+VOID	prn_grid(GRID *g)
 	{
 	INT	i;
 	INT	n;
-	INT	cnt;
 	GRID	*ng;
 	VOXEL	*v;
 
@@ -112,8 +109,7 @@
 
 
 
-VOID	prn_ray(r)
-RAY	*r;
+VOID	prn_ray(RAY *r)
 	{
 	RAYINFO *ri;
 	GRID	*g;
@@ -143,8 +139,7 @@
 
 
 
-VOID	prn_PrimElem(p)
-ELEMENT *p;
+VOID	prn_PrimElem(ELEMENT *p)
 	{
 	BBOX	b;
 
@@ -154,7 +149,7 @@
 		exit(-1);
 		}
 
-	fprintf(stderr, "PrimElem: index %ld  ptr %lu, PrimObj index %ld ptr %lu \n",
+	fprintf(stderr, "PrimElem: index %ld  ptr %p, PrimObj index %ld ptr %p \n",
 		p->index, p,  p->parent->index,   p->parent);
 
 	b = p->bv;
@@ -165,8 +160,7 @@
 
 
 
-VOID	prn_bintree_node(b)
-BTNODE	*b;
+VOID	prn_bintree_node(BTNODE *b)
 	{
 	INT	i;
 
@@ -193,8 +187,7 @@
 
 
 
-VOID	prn_bintree_leaves(root)
-BTNODE	*root;
+VOID	prn_bintree_leaves(BTNODE *root)
 	{
 	BTNODE	*b;
 
@@ -209,9 +202,7 @@
 	}
 
 
-VOID	prn_pepa_prim_list(pepa, nprims)
-ELEMENT **pepa;
-INT	nprims;
+VOID	prn_pepa_prim_list(ELEMENT **pepa, INT nprims)
 	{
 	INT	i;
 
diff -Naur splash2/codes/apps/raytrace/husetup.C splash2-modified/codes/apps/raytrace/husetup.C
--- splash2/codes/apps/raytrace/husetup.C	1994-10-14 17:26:00.000000000 -0400
+++ splash2-modified/codes/apps/raytrace/husetup.C	2007-03-18 01:28:06.000000000 -0400
@@ -68,18 +68,10 @@
 
 VOID	BuildHierarchy_Uniform()
 	{
-	INT	i;
-	INT	num;
 	INT	num_pe;
-	INT	status;
-	REAL	den;
 	GRID	*g;
-	GRID	*gr;
 	GRID	*ng;
-	GRID	testgrid;
 	VOXEL	*v;
-	RAY	r;
-	RAYINFO *rinfo;
 	ELEMENT **pepa;
 
 	init_masks();
@@ -116,12 +108,7 @@
  *
  */
 
-VOID	IntersectHuniformPrimlist(intersectPrim, hit, v, r, pid)
-INT *intersectPrim;
-IRECORD *hit;
-VOXEL *v;
-RAY	*r;
-INT	pid;
+VOID	IntersectHuniformPrimlist(INT *intersectPrim, IRECORD *hit, VOXEL *v, RAY *r, INT pid)
 	{
 	ELEMENT **pptr; 		/* Primitive element list ptr.	     */
 	OBJECT	*peParent;		/* Ptr to parent object.	     */
@@ -169,11 +156,7 @@
  *
  */
 
-REAL	HuniformShadowIntersect(r, lightlength, pe, pid)
-RAY	*r;
-REAL	lightlength;
-ELEMENT *pe;
-INT	pid;
+REAL	HuniformShadowIntersect(RAY *r, REAL lightlength, ELEMENT *pe, INT pid)
 	{
 	INT	status;
 	INT	hitcode,i;
@@ -242,10 +225,7 @@
  *
  */
 
-BOOL	TraverseHierarchyUniform(r, hit, pid)
-RAY	*r;
-IRECORD *hit;
-INT	pid;
+BOOL	TraverseHierarchyUniform(RAY *r, IRECORD *hit, INT pid)
 	{
 	INT	status;
 	INT	intersectPrim;
diff -Naur splash2/codes/apps/raytrace/hutv.C splash2-modified/codes/apps/raytrace/hutv.C
--- splash2/codes/apps/raytrace/hutv.C	1994-10-14 17:26:00.000000000 -0400
+++ splash2-modified/codes/apps/raytrace/hutv.C	2007-03-18 01:59:07.000000000 -0400
@@ -71,10 +71,9 @@
  *	Nothing, yet.
  */
 
-INT	send_ray(r, v)
-RAY	*r;
-VOXEL	*v;
+INT	send_ray(RAY *r, VOXEL *v)
 	{
+		return(0);
 	}
 
 
@@ -99,9 +98,7 @@
  *
  */
 
-VOXEL	*lookup_hashtable(indx, g)
-INT	indx;
-GRID	*g;
+VOXEL	*lookup_hashtable(INT indx, GRID *g)
 	{
 	INT	i;
 	VOXEL	*v;
@@ -142,9 +139,7 @@
  *
  */
 
-INT	lookup_emptycells(indx, g)
-INT	indx;
-GRID	*g;
+INT	lookup_emptycells(INT indx, GRID *g)
 	{
 	INT	i, w, r, num_bits;
 	UINT	p, b;
@@ -179,8 +174,7 @@
  *	Nothing.
  */
 
-VOID	pop_up_a_grid(r)
-RAY	*r;
+VOID	pop_up_a_grid(RAY *r)
 	{
 	RAYINFO *old_ri;
 
@@ -200,7 +194,7 @@
  * SYNOPSIS
  *	VOID	push_down_grid(r, v)
  *	RAY	*r;
- *	VOXEL	*v;			/* Voxel containing the new grid.
+ *	VOXEL	*v;			Voxel containing the new grid.
  *
  * DESCRIPTION
  *	push_down_grid creates rayinfo for the new grid being entered and puts
@@ -210,9 +204,7 @@
  *	Nothing.
  */
 
-VOID	push_down_grid(r, v)
-RAY	*r;
-VOXEL	*v;
+VOID	push_down_grid(RAY *r, VOXEL *v)
 	{
 	INT	n;		       /* # cells per axis in new grid.      */
 	INT	small;
@@ -263,7 +255,7 @@
 	wc[2] = ti*r->D[2] + r->P[2];
 
 
-	new_ri->index3D[0] = (int)((wc[0] - new_g->min[0]) / new_g->cellsize[0]);
+	new_ri->index3D[0] = (INT)((wc[0] - new_g->min[0]) / new_g->cellsize[0]);
 
 	if (new_ri->index3D[0] < 0)
 		new_ri->index3D[0] = 0;
@@ -272,7 +264,7 @@
 		new_ri->index3D[0] = n - 1;
 
 
-	new_ri->index3D[1] = (int)((wc[1] - new_g->min[1]) / new_g->cellsize[1]);
+	new_ri->index3D[1] = (INT)((wc[1] - new_g->min[1]) / new_g->cellsize[1]);
 
 	if (new_ri->index3D[1] < 0)
 		new_ri->index3D[1] = 0;
@@ -281,7 +273,7 @@
 		new_ri->index3D[1] = n - 1;
 
 
-	new_ri->index3D[2] = (int)((wc[2] - new_g->min[2]) / new_g->cellsize[2]);
+	new_ri->index3D[2] = (INT)((wc[2] - new_g->min[2]) / new_g->cellsize[2]);
 
 	if (new_ri->index3D[2] < 0)
 		new_ri->index3D[2] = 0;
@@ -478,20 +470,23 @@
 					}
 
 				new_ri->d[i] = th;
-				if (t_in < tl)			/* max min   */
+//				if (t_in < tl)			/* max min   */
+				if (t_in - tl < 0.0)
 					{
 					t_in = tl;
 					i_in = il;
 					}
 
-				if (t_out > th) 		/* min max   */
+//				if (t_out > th) 		/* min max   */
+				if (t_out - th > 0.0)
 					{
 					t_out = th;
 					i_out = ih;
 					}
 				}
 
-			if ((t_in > t_out) || (t_out < 0.0))
+//			if ((t_in > t_out) || (t_out < 0.0))
+			if ((t_in - t_out > 0.0) || (t_out < 0.0))
 				{
 				fprintf(stderr, "push_down_grid: Ray origin not in voxel \n");
 				exit(-1);
@@ -533,8 +528,7 @@
  *	Nothing.
  */
 
-INT	step_grid(r)
-RAY	*r;
+INT	step_grid(RAY *r)
 	{
 	INT	n;			/* # cells per axis in grid.	     */
 	INT	small;			/* Index of closest cell boundary.   */
@@ -601,12 +595,10 @@
  *
  */
 
-INT	next_voxel(r)
-RAY	*r;
+INT	next_voxel(RAY *r)
 	{
 	INT	indx;
 	GRID	*gr;
-	VOXEL	*v;
 	RAYINFO *rinfo;
 
 	while ((indx = step_grid(r)) == -1)
@@ -656,8 +648,7 @@
  *	A pointer to the next nonempty voxel.
  */
 
-VOXEL	*next_nonempty_voxel(r)
-RAY	*r;
+VOXEL	*next_nonempty_voxel(RAY *r)
 	{
 	INT	indx;
 	VOXEL	*v;
@@ -727,13 +718,9 @@
  *	Nothing.
  */
 
-VOXEL	*next_nonempty_leaf(r , step, status)
-RAY	*r;
-INT	step;
-INT	*status;
+VOXEL	*next_nonempty_leaf(RAY *r, INT step, INT *status)
 	{
 	INT	indx;
-	GRID	*ng;
 	VOXEL	*v;
 	RAYINFO *rinfo;
 
@@ -819,9 +806,7 @@
  *	returned, otherwise NULL is returned.
  */
 
-VOXEL	*init_ray(r, g)
-RAY	*r;
-GRID	*g;
+VOXEL	*init_ray(RAY *r, GRID *g)
 	{
 	INT	status;
 	INT	indx, grid_id;
diff -Naur splash2/codes/apps/raytrace/isect.C splash2-modified/codes/apps/raytrace/isect.C
--- splash2/codes/apps/raytrace/isect.C	1994-10-14 17:26:04.000000000 -0400
+++ splash2-modified/codes/apps/raytrace/isect.C	2007-03-18 01:32:54.000000000 -0400
@@ -45,9 +45,7 @@
  *	TRUE if ray intersects an object, FALSE otherwise.
  */
 
-BOOL	Intersect(pr, hit)
-RAY	*pr;
-IRECORD *hit;
+BOOL	Intersect(RAY *pr, IRECORD *hit)
 	{
 	OBJECT	*po;				/* Ptr to the object.	     */
 	IRECORD newhit; 			/* New intersection.	     */
@@ -90,10 +88,7 @@
  *	1.0 -> Fully visible.
  */
 
-REAL	ShadowIntersect(pr, lightdist, pe)
-RAY	*pr;
-REAL	lightdist;
-ELEMENT *pe;
+REAL	ShadowIntersect(RAY *pr, REAL lightdist, ELEMENT *pe)
 	{
 	REAL	trans;				/* Transparency factor.      */
 	OBJECT	*po;				/* Ptr to the object.	     */
diff -Naur splash2/codes/apps/raytrace/main.C splash2-modified/codes/apps/raytrace/main.C
--- splash2/codes/apps/raytrace/main.C	1994-11-01 15:33:21.000000000 -0500
+++ splash2-modified/codes/apps/raytrace/main.C	2007-03-21 18:23:22.000000000 -0400
@@ -182,17 +182,17 @@
 	INT	pid;			/* Our internal process id number.   */
 	UINT	begin;
 	UINT	end;
-	UINT	lapsed;
-
 
 	LOCK(gm->pidlock)
 	pid = gm->pid++;
 	UNLOCK(gm->pidlock)
 
+	BARINCLUDE(gm->start);
+
 	if ((pid == 0) ||  (dostats))
         CLOCK(begin);
 
-	/* POSSIBLE ENHANCEMENT: Here's where one might lock processes down 
+	/* POSSIBLE ENHANCEMENT: Here's where one might lock processes down
 	to processors if need be */
 
 	InitWorkPool(pid);
@@ -207,7 +207,7 @@
 
 	BARRIER(gm->start, gm->nprocs)
 
-	/* POSSIBLE ENHANCEMENT:  Here's where one would RESET STATISTICS 
+	/* POSSIBLE ENHANCEMENT:  Here's where one would RESET STATISTICS
 	and TIMING if one wanted to measure only the parallel part */
 
 	RayTrace(pid);
@@ -241,80 +241,69 @@
  *	1 for any type of failure.
  */
 
-int	main(argc, argv)
-int	argc;
-CHAR	*argv[];
+int	main(int argc, CHAR *argv[])
 	{
 	INT	i;
 	UINT	begin;
 	UINT	end;
 	UINT	lapsed;
-	U16	tmp;
-	CHAR	*pch;
 	MATRIX	vtrans, Vinv;		/*  View transformation and inverse. */
 
 
 	/*
 	 *	First, process command line arguments.
 	 */
+	i = 1;
+	while ((i < argc) && (argv[i][0] == '-')) {
+		switch (argv[i][1]) {
+			case '?':
+			case 'h':
+			case 'H':
+				Usage();
+				exit(1);
+
+			case 'a':
+			case 'A':
+				AntiAlias = TRUE;
+				if (argv[i][2] != '\0') {
+					NumSubRays = atoi(&argv[i][2]);
+				} else {
+					NumSubRays = atoi(&argv[++i][0]);
+				}
+				break;
 
-	while (argc-- > 1 && (*++argv)[0] == '-')
-		for (pch = argv[0] + 1; *pch != '\0'; pch++)
-			switch (*pch)
-				{
-				case '?':
-				case 'h':
-				case 'H':
-					Usage();
-					exit(1);
-
-				case 'a':
-				case 'A':
-					AntiAlias = TRUE;
-					if (*++pch)
-						NumSubRays = atoi(pch);
-
-					*pch = '\0';
-					pch--;
-					break;
-
-				case 'm':
-					if (*++pch)
-						MaxGlobMem = atoi(pch);
-
-					*pch = '\0';
-					pch--;
-					break;
-
-				case 'p':
-					if (*++pch)
-						nprocs = atoi(pch);
-
-					*pch = '\0';
-					pch--;
-					break;
-                    
-                case 's':
-                case 'S': 
-                    dostats = TRUE;
-                    break;
-
-				default:
-					fprintf(stderr, "%s: Invalid option \'%c\'.\n", ProgName, *pch);
-					exit(1);
+			case 'm':
+				if (argv[i][2] != '\0') {
+					MaxGlobMem = atoi(&argv[i][2]);
+				} else {
+					MaxGlobMem = atoi(&argv[++i][0]);
 				}
+				break;
 
+			case 'p':
+				if (argv[i][2] != '\0') {
+					nprocs = atoi(&argv[i][2]);
+				} else {
+					nprocs = atoi(&argv[++i][0]);
+				}
+				break;
 
-	/*
-	 *	If no more command line arguments, the environment file name
-	 *	is missing.  Print a usage message and terminate.
-	 */
+			case 's':
+			case 'S':
+				dostats = TRUE;
+				break;
+
+			default:
+				fprintf(stderr, "%s: Invalid option \'%c\'.\n", ProgName, argv[i][0]);
+				exit(1);
+		}
+		i++;
+	}
 
-	if (!argc)
-		{
+	if (i == argc) {
 		Usage();
 		exit(1);
-		}
+	}
 
 
 	/*
@@ -323,7 +312,7 @@
 
 	if (nprocs < 1 || nprocs > MAX_PROCS)
 		{
-		fprintf(stderr, "%s: Valid range for #processors is [1, %ld].\n", ProgName, MAX_PROCS);
+		fprintf(stderr, "%s: Valid range for #processors is [1, %d].\n", ProgName, MAX_PROCS);
 		exit(1);
 		}
 
@@ -358,13 +347,13 @@
 	gm->pid    = 0;
 	gm->rid    = 1;
 
-	BARINIT(gm->start)
+	BARINIT(gm->start, nprocs)
 	LOCKINIT(gm->pidlock)
 	LOCKINIT(gm->ridlock)
 	LOCKINIT(gm->memlock)
 	ALOCKINIT(gm->wplock, nprocs)
 
-/* POSSIBLE ENHANCEMENT:  Here is where one might distribute the 
+/* POSSIBLE ENHANCEMENT:  Here is where one might distribute the
    raystruct data structure across physically distributed memories as
    desired.  */
 
@@ -380,7 +369,7 @@
 	 */
 
 	Huniform_defaults();
-	ReadEnvFile(*argv);
+	ReadEnvFile(/* *argv*/argv[i]);
 	ReadGeoFile(GeoFileName);
 	OpenFrameBuffer();
 
@@ -416,12 +405,8 @@
 	 */
 
 	CLOCK(begin)
-	for (i = 0; i < gm->nprocs - 1; i++)
-		CREATE(StartRayTrace)
-
-	StartRayTrace();
-
-	WAIT_FOR_END(gm->nprocs - 1)
+	CREATE(StartRayTrace, gm->nprocs);
+	WAIT_FOR_END(gm->nprocs);
 	CLOCK(end)
 
 
@@ -447,12 +432,12 @@
         unsigned totalproctime, maxproctime, minproctime;
 
         printf("\n\n\nPER-PROCESS STATISTICS:\n");
-        
+
         printf("%20s%20s\n","Proc","Time");
         printf("%20s%20s\n\n","","Tracing Rays");
         for (i = 0; i < gm->nprocs; i++)
-            printf("%20d%20d\n",i,gm->partime[i]);
-        
+            printf("%20ld%20ld\n",i,gm->partime[i]);
+
         totalproctime = gm->partime[0];
         minproctime = gm->partime[0];
         maxproctime = gm->partime[0];
diff -Naur splash2/codes/apps/raytrace/makefile splash2-modified/codes/apps/raytrace/makefile
--- splash2/codes/apps/raytrace/makefile	1994-10-14 17:27:15.000000000 -0400
+++ splash2-modified/codes/apps/raytrace/makefile	1969-12-31 19:00:00.000000000 -0500
@@ -1,54 +0,0 @@
-TARGET = RAYTRACE
-
-OBJS = bbox.o cr.o env.o fbuf.o geo.o huprn.o husetup.o hutv.o isect.o \
-	main.o matrix.o memory.o poly.o raystack.o shade.o sph.o trace.o \
-	tri.o workpool.o
-LDFLAGS = -lmpc -lm
-MACROS = ../../null_macros/c.m4.null
-CFLAGS = -cckr -O2 -Olimit 1500
-
-x = *
-
-$(TARGET): $(OBJS)
-	cc $(OBJS) $(CFLAGS) -o $(TARGET) $(LDFLAGS)
-
-
-M4 = -m4 -Uindex -Ulen
-RM = -rm -f
-
-.SUFFIXES:
-.SUFFIXES:      .o .c .C .h .H
-
-.H.h:
-	$(M4) ${MACROS} $*.H > $*.h
-
-.C.c:
-	$(M4) $(MACROS) $*.C > $*.c
-
-.c.o:
-	cc -c $(CFLAGS) $*.c
-
-.C.o:
-	$(M4) $(MACROS) $*.C > $*.c
-	cc -c $(CFLAGS) $*.c
-
-bbox.c: bbox.C rt.h
-cr.c:	cr.C rt.h
-env.c:	env.C rt.h
-fbuf.c: fbuf.C rt.h
-geo.c:	geo.C rt.h
-huprn.c: huprn.C rt.h
-husetup.c: husetup.C rt.h
-hutv.c: hutv.C rt.h
-isect.c: isect.C rt.h
-main.c: main.C rt.h
-matrix.c: matrix.C rt.h
-memory.c: memory.C rt.h
-poly.c: poly.C rt.h
-raystack.c: raystack.C rt.h
-shade.c: shade.C rt.h
-sph.c:	sph.C rt.h
-trace.c: trace.C rt.h
-tri.c:	tri.C rt.h
-workpool.c: workpool.C rt.h
-
diff -Naur splash2/codes/apps/raytrace/Makefile splash2-modified/codes/apps/raytrace/Makefile
--- splash2/codes/apps/raytrace/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ splash2-modified/codes/apps/raytrace/Makefile	2007-03-18 02:00:07.000000000 -0400
@@ -0,0 +1,28 @@
+TARGET = RAYTRACE
+
+OBJS = bbox.o cr.o env.o fbuf.o geo.o huprn.o husetup.o hutv.o isect.o \
+	main.o matrix.o memory.o poly.o raystack.o shade.o sph.o trace.o \
+	tri.o workpool.o
+
+include ../../Makefile.config
+
+bbox.c: bbox.C rt.h
+cr.c:	cr.C rt.h
+env.c:	env.C rt.h
+fbuf.c: fbuf.C rt.h
+geo.c:	geo.C rt.h
+huprn.c: huprn.C rt.h
+husetup.c: husetup.C rt.h
+hutv.c: hutv.C rt.h
+isect.c: isect.C rt.h
+main.c: main.C rt.h
+matrix.c: matrix.C rt.h
+memory.c: memory.C rt.h
+poly.c: poly.C rt.h
+raystack.c: raystack.C rt.h
+shade.c: shade.C rt.h
+sph.c:	sph.C rt.h
+trace.c: trace.C rt.h
+tri.c:	tri.C rt.h
+workpool.c: workpool.C rt.h
+
diff -Naur splash2/codes/apps/raytrace/matrix.C splash2-modified/codes/apps/raytrace/matrix.C
--- splash2/codes/apps/raytrace/matrix.C	1994-10-14 17:26:04.000000000 -0400
+++ splash2-modified/codes/apps/raytrace/matrix.C	2007-03-18 01:37:41.000000000 -0400
@@ -47,8 +47,7 @@
  *	Nothing.
  */
 
-VOID	VecNorm(V)
-POINT	V;
+VOID	VecNorm(POINT V)
 	{
 	REAL	l;
 
@@ -77,10 +76,7 @@
  *	Nothing.
  */
 
-VOID	VecMatMult(Vt, M, V)
-POINT	Vt;
-MATRIX	M;
-POINT	V;
+VOID	VecMatMult(POINT Vt, MATRIX M, POINT V)
 	{
 	INT	i, j;
 	POINT	tvec;
@@ -115,9 +111,7 @@
  *	Nothing.
  */
 
-VOID	PrintMatrix(M, s)
-MATRIX	M;
-CHAR	*s;
+VOID	PrintMatrix(MATRIX M, CHAR *s)
 	{
 	INT	i, j;
 
@@ -148,8 +142,7 @@
  *	Nothing.
  */
 
-VOID	MatrixIdentity(M)
-MATRIX	M;
+VOID	MatrixIdentity(MATRIX M)
 	{
 	INT	i, j;
 
@@ -178,8 +171,7 @@
  *	Nothing.
  */
 
-VOID	MatrixCopy(A, B)
-MATRIX	A, B;
+VOID	MatrixCopy(MATRIX A, MATRIX B)
 	{
 	INT	i, j;
 
@@ -203,9 +195,7 @@
  *	Nothing.
  */
 
-VOID	MatrixTranspose(MT, M)
-MATRIX	MT;
-MATRIX	M;
+VOID	MatrixTranspose(MATRIX MT, MATRIX M)
 	{
 	INT	i, j;
 	MATRIX	tmp;
@@ -231,8 +221,7 @@
  *	Nothing.
  */
 
-VOID	MatrixMult(C, A, B)
-MATRIX	C, A, B;
+VOID	MatrixMult(MATRIX C, MATRIX A, MATRIX B)
 	{
 	INT	i, j, k;
 	MATRIX	T;			/* Temporary matrix.		     */
@@ -269,9 +258,7 @@
  *	Nothing.
  */
 
-VOID	MatrixInverse(Minv, Mat)
-MATRIX	Minv;
-MATRIX	Mat;
+VOID	MatrixInverse(MATRIX Minv, MATRIX Mat)
 	{
 	INT		i, j, k;	/* Indices.			     */
 	GJMATRIX	gjmat;		/* Inverse calculator.		     */
@@ -380,9 +367,7 @@
  *	Nothing.
  */
 
-VOID	Translate(M, dx, dy, dz)
-MATRIX	M;
-REAL	dx, dy, dz;
+VOID	Translate(MATRIX M, REAL dx, REAL dy, REAL dz)
 	{
 	MatrixIdentity(M);
 
@@ -406,9 +391,7 @@
  *	Nothing.
  */
 
-VOID	Scale(M, sx, sy, sz)
-MATRIX	M;
-REAL	sx, sy, sz;
+VOID	Scale(MATRIX M, REAL sx, REAL sy, REAL sz)
 	{
 	MatrixIdentity(M);
 
@@ -433,10 +416,7 @@
  *	Nothing.
  */
 
-VOID	Rotate(axis, M, angle)
-INT	axis;
-MATRIX	M;
-REAL	angle;
+VOID	Rotate(INT axis, MATRIX M, REAL angle)
 	{
 	REAL	cosangle;
 	REAL	sinangle;
diff -Naur splash2/codes/apps/raytrace/memory.C splash2-modified/codes/apps/raytrace/memory.C
--- splash2/codes/apps/raytrace/memory.C	1994-11-13 17:45:17.000000000 -0500
+++ splash2-modified/codes/apps/raytrace/memory.C	2007-03-21 18:25:30.000000000 -0400
@@ -100,13 +100,11 @@
  *	generates an error exit.
  */
 
-VOID	*LocalMalloc(n, msg)
-UINT	n;
-CHAR	*msg;
+VOID	*LocalMalloc(UINT n, CHAR *msg)
 	{
 	VOID	*p;
 
-	p = (VOID *) malloc(n);
+	p = (VOID *) /*malloc*/G_MALLOC(n);
 	if (!p)
 		{
 		printf("%s: %s cannot allocate local memory.\n", ProgName, msg);
@@ -136,8 +134,7 @@
  *	Nothing.
  */
 
-VOID	LocalFree(p)
-VOID	*p;
+VOID	LocalFree(VOID *p)
 	{
 	free(p);
 
@@ -215,12 +212,8 @@
  *	FALSE otherwise.
  */
 
-BOOL	GlobalHeapInit(size)
-UINT	size;
+BOOL	GlobalHeapInit(UINT size)
 	{
-	INT	i;
-	U8	*ptr;
-
 	size	     = ROUND_UP(size);
 	gm->freelist = (NODE huge *)G_MALLOC(size);
 
@@ -236,9 +229,9 @@
 	gm->freelist->free = TRUE;
 	gm->freelist->cksm = CKSM;
 
-/* NOTE TO USERS: Here's where one can allocate the memory segment from 
+/* NOTE TO USERS: Here's where one can allocate the memory segment from
 	begmem to endmem round-robin among memories or however one desires */
-	
+
 	return (TRUE);
 	}
 
@@ -272,9 +265,7 @@
  *	Generates error exit if there is insufficient memory available.
  */
 
-VOID	*GlobalMalloc(size, msg)
-UINT	size;
-CHAR	*msg;
+VOID	*GlobalMalloc(UINT size, CHAR *msg)
 	{
 	NODE	huge   *prev;
 	NODE	huge   *curr;
@@ -375,9 +366,7 @@
  *
  */
 
-VOID	*GlobalCalloc(n, size)
-UINT	n;
-UINT	size;
+VOID	*GlobalCalloc(UINT n, UINT size)
 	{
 	UINT	nbytes;
 	UINT	huge	*p;
@@ -452,9 +441,7 @@
  *	As stated above.
  */
 
-VOID	*GlobalRealloc(p, size)
-VOID	*p;
-UINT	size;
+VOID	*GlobalRealloc(VOID *p, UINT size)
 	{
 	UINT		oldsize;
 	UINT		newsize;
@@ -632,8 +619,7 @@
  *	Nothing.
  */
 
-VOID	GlobalFree(p)
-VOID	*p;
+VOID	GlobalFree(VOID *p)
 	{
 	BOOL		pcom;			/* TRUE if prev can combine. */
 	BOOL		ncom;			/* TRUE if next can combine. */
@@ -699,7 +685,7 @@
 
 		if (curr >= endmem)
 			{
-			fprintf(stdout, "freelist=0x%08lX, curr=0x%08lX, size=0x%08lX, pn=0x%08lX, endmem=0x%08lX\n", gm->freelist, curr, curr->size, pn, endmem);
+			fprintf(stdout, "freelist=0x%p, curr=0x%p, size=0x%lu, pn=0x%p, endmem=0x%p\n", gm->freelist, curr, curr->size, pn, endmem);
 			fprintf(stderr, "GlobalFree: Search for previous block fell off end of memory.\n");
 			exit(1);
 			}
@@ -903,9 +889,7 @@
  *	generates an error exit.
  */
 
-VOID	*ObjectMalloc(ObjectType, count)
-INT	ObjectType;
-INT	count;
+VOID	*ObjectMalloc(INT ObjectType, INT count)
 	{
 	INT	n;
 	VOID	*p;
@@ -980,7 +964,7 @@
 			break;
 
 		default:
-			printf("ObjectMalloc: Unknown object type: %d\n", ObjectType);
+			printf("ObjectMalloc: Unknown object type: %ld\n", ObjectType);
 			exit(-1);
 		}
 
@@ -1007,10 +991,7 @@
  *	Nothing.
  */
 
-VOID	ObjectFree(ObjectType, count, p)
-INT	ObjectType;
-INT	count;
-VOID	*p;
+VOID	ObjectFree(INT ObjectType, INT count, VOID *p)
 	{
 	INT	n;
 
@@ -1050,7 +1031,7 @@
 			break;
 
 		default:
-			printf("ObjectFree: Unknown object type: %d\n", ObjectType);
+			printf("ObjectFree: Unknown object type: %ld\n", ObjectType);
 			exit(-1);
 		}
 	}
@@ -1058,8 +1039,7 @@
 
 
 
-RAYINFO *ma_rayinfo(r)
-RAY	*r;
+RAYINFO *ma_rayinfo(RAY *r)
 	{
 	RAYINFO *p;
 
@@ -1084,16 +1064,14 @@
 
 
 
-VOID   free_rayinfo(r)
-RAY    *r;
+VOID   free_rayinfo(RAY *r)
 	{
 	r->ri_indx -= 1;
 	}
 
 
 
-VOID	reset_rayinfo(r)
-RAY	*r;
+VOID	reset_rayinfo(RAY *r)
 	{
 	r->ri_indx = 0;
 	}
@@ -1102,7 +1080,6 @@
 
 VOID	ma_print()
 	{
-	INT	i;
 	INT	mem_total;
 	INT	maxmem_total;
 
@@ -1115,11 +1092,11 @@
 	fprintf(stdout, "\n****** Hierarchial uniform grid memory allocation summary ******* \n\n");
 	fprintf(stdout, "     < struct >:            < current >   < maximum >    < sizeof > \n");
 	fprintf(stdout, "     <  bytes >:             <  bytes >   <   bytes >    <  bytes > \n\n");
-	fprintf(stdout, "     grid:                %11ld   %11ld   %11d \n", mem_grid,        maxmem_grid,        sizeof(GRID)   );
-	fprintf(stdout, "     hashtable entries:   %11ld   %11ld   %11d \n", mem_hashtable,   maxmem_hashtable,   sizeof(VOXEL**));
-	fprintf(stdout, "     emptycell entries:   %11ld   %11ld   %11d \n", mem_emptycells,  maxmem_emptycells,  sizeof(UINT)   );
-	fprintf(stdout, "     voxel:               %11ld   %11ld   %11d \n", mem_voxel,       maxmem_voxel,       sizeof(VOXEL)  );
-	fprintf(stdout, "     bintree_node:        %11ld   %11ld   %11d \n", mem_bintree,     maxmem_bintree,     sizeof(BTNODE) );
+	fprintf(stdout, "     grid:                %11ld   %11ld   %11ld \n", mem_grid,        maxmem_grid,        sizeof(GRID)   );
+	fprintf(stdout, "     hashtable entries:   %11ld   %11ld   %11ld \n", mem_hashtable,   maxmem_hashtable,   sizeof(VOXEL**));
+	fprintf(stdout, "     emptycell entries:   %11ld   %11ld   %11ld \n", mem_emptycells,  maxmem_emptycells,  sizeof(UINT)   );
+	fprintf(stdout, "     voxel:               %11ld   %11ld   %11ld \n", mem_voxel,       maxmem_voxel,       sizeof(VOXEL)  );
+	fprintf(stdout, "     bintree_node:        %11ld   %11ld   %11ld \n", mem_bintree,     maxmem_bintree,     sizeof(BTNODE) );
 
 	fprintf(stdout, "\n");
 	fprintf(stdout, "     Totals:              %11ld   %11ld      \n\n", mem_total,       maxmem_total);
diff -Naur splash2/codes/apps/raytrace/poly.C splash2-modified/codes/apps/raytrace/poly.C
--- splash2/codes/apps/raytrace/poly.C	1994-10-14 17:26:04.000000000 -0400
+++ splash2-modified/codes/apps/raytrace/poly.C	2007-03-18 01:44:11.000000000 -0400
@@ -30,22 +30,6 @@
 #include "rt.h"
 
 
-/*
- *	Define polygon data structure.
- */
-
-typedef struct poly
-	{
-	INT	nverts; 		/* Number of vertices in polygon.    */
-	VEC3	norm;			/* Face normal. 		     */
-	REAL	d;			/* Plane eqn D. 		     */
-	VEC3	*vptr;			/* Global vertex list pointer.	     */
-	INT	*vindex;		/* Index of vertices.		     */
-	INT	axis_proj;		/* Best axis for projection.	     */
-	}
-	POLY;
-
-
 
 /*
  * NAME
@@ -77,8 +61,7 @@
  *	Nothing.
  */
 
-VOID	PolyPrint(po)
-OBJECT	*po;
+VOID	PolyPrint(OBJECT *po)
 	{
 	INT	i, j;
 	INT	*vindex;		/* Ptr to vertex index. 	     */
@@ -124,9 +107,7 @@
  *	Nothing.
  */
 
-VOID	PolyElementBoundBox(pe, pp)
-ELEMENT *pe;
-POLY	*pp;
+VOID	PolyElementBoundBox(ELEMENT *pe, POLY *pp)
 	{
 	INT	i;			/* Index.			     */
 	INT	*vindex;		/* Vertex index pointer.	     */
@@ -182,8 +163,7 @@
  *	Nothing.
  */
 
-VOID	PolyBoundBox(po)
-OBJECT	*po;
+VOID	PolyBoundBox(OBJECT *po)
 	{
 	INT	i;
 	POLY	*pp;			/* Ptr to polygon data. 	     */
@@ -244,10 +224,7 @@
  *	Nothing.
  */
 
-VOID	PolyNormal(hit, Pi, Ni)
-IRECORD *hit;
-POINT	Pi;
-POINT	Ni;
+VOID	PolyNormal(IRECORD *hit, POINT Pi, POINT Ni)
 	{
 	ELEMENT *pe;
 	POLY	*pp;
@@ -274,9 +251,7 @@
  *	Nothing.
  */
 
-VOID	PolyDataNormalize(po, normMat)
-OBJECT	*po;
-MATRIX	normMat;
+VOID	PolyDataNormalize(OBJECT *po, MATRIX normMat)
 	{
 	INT	i;
 	POINT	coord;
@@ -363,19 +338,14 @@
  *	The number of intersection points.
  */
 
-INT	PolyPeIntersect(pr, pe, hit)
-RAY	*pr;
-ELEMENT *pe;
-IRECORD *hit;
+INT	PolyPeIntersect(RAY *pr, ELEMENT *pe, IRECORD *hit)
 	{
 	INT	i;
 	INT	*vindex;		/* Vertex index pointer.	     */
 	INT	toright;		/* Counter.			     */
 	INT	sh, nsh;		/* Sign holders.		     */
-	REAL	tmp;
 	REAL	Rd_dot_Pn;		/* Polygon normal dot ray direction. */
 	REAL	Ro_dot_Pn;		/* Polygon normal dot ray origin.    */
-	REAL	q1, q2;
 	REAL	tval;			/* Intersection t distance value.    */
 	REAL	x[MAX_VERTS + 1];	/* Projection list.		     */
 	REAL	y[MAX_VERTS + 1];	/* Projection list.		     */
@@ -384,7 +354,6 @@
 	REAL	xint;			/* Intersection value.		     */
 	VEC3	I;			/* Intersection point.		     */
 	VEC3	*vlist, *vpos;		/* Vertex list pointer. 	     */
-	VEC3	*v1, *v2, *v3;		/* Vertex list pointers.	     */
 	POLY	*pp;			/* Ptr to polygon data. 	     */
 
 	pp = (POLY *)pe->data;
@@ -532,10 +501,7 @@
  *	The number of intersections found.
  */
 
-INT	PolyIntersect(pr, po, hit)
-RAY	*pr;
-OBJECT	*po;
-IRECORD *hit;
+INT	PolyIntersect(RAY *pr, OBJECT *po, IRECORD *hit)
 	{
 	INT	i;
 	INT	nhits;			/* # hits in polyhedra. 	     */
@@ -588,14 +554,10 @@
  *	Nothing.
  */
 
-VOID	PolyTransform(po, xtrans, xinvT)
-OBJECT	*po;
-MATRIX	xtrans;
-MATRIX	xinvT;
+VOID	PolyTransform(OBJECT *po, MATRIX xtrans, MATRIX xinvT)
 	{
-	INT	i, j;			/* Indices.			     */
+	INT	i;			/* Indices.			     */
 	INT	numelems;		/* # of elements.		     */
-	INT	*vindex;		/* Vertex index pointer.	     */
 	VEC3	*vptr, *vp;		/* Vertex list pointers.	     */
 	VEC4	norm, coord;		/* Transform 4 vectors. 	     */
 	POLY	*pp;			/* Ptr to polygon data. 	     */
@@ -694,9 +656,7 @@
  *	Nothing.
  */
 
-VOID	PolyRead(po, pf)
-OBJECT	*po;
-FILE	*pf;
+VOID	PolyRead(OBJECT *po, FILE *pf)
 	{
 	INT	i, j;			/* Indices.			     */
 	INT	instat; 		/* Read status. 		     */
@@ -704,7 +664,6 @@
 	INT	totalverts;		/* Total # of vertices in poly mesh. */
 	CHAR	normstr[5];		/* Face/vertex normal flag string.   */
 	BOOL	pnormals;		/* Face normals present?	     */
-	BOOL	vnormals;		/* Vertex normals present?	     */
 	VEC3	pnorm;			/* Polygon normal accumulator.	     */
 	VEC3	*vlist, *vptr, *vp;	/* Ptr to vertex list.		     */
 	VEC3	*vptmp, *vptmp2;	/* Ptr to vertex list.		     */
diff -Naur splash2/codes/apps/raytrace/raystack.C splash2-modified/codes/apps/raytrace/raystack.C
--- splash2/codes/apps/raytrace/raystack.C	1994-10-19 17:38:03.000000000 -0400
+++ splash2-modified/codes/apps/raytrace/raystack.C	2007-03-18 01:58:39.000000000 -0400
@@ -43,14 +43,14 @@
 
 struct r_struct {
 INT 	pad1[PAGE_SIZE];		/* This pad is inserted to avoid
-					   false-sharing due to artifacts 
+					   false-sharing due to artifacts
 					   of not having a private space
 					   in the sproc model */
 RAY	*Stack; 			/* Ptr to ray tree stack.	     */
 INT	StackTop;			/* Top of ray tree stack.	     */
 INT	StackSize;			/* Maximum size of ray tree stack.   */
 INT 	pad2[PAGE_SIZE];		/* This pad is inserted to avoid
-					   false-sharing due to artifacts 
+					   false-sharing due to artifacts
 					   of not having a private space
 					   in the sproc model */
 
@@ -70,9 +70,7 @@
  *	Nothing.
  */
 
-VOID	CopyRayMsg(rdst, rsrc)
-RAY	*rdst;
-RAY	*rsrc;
+VOID	CopyRayMsg(RAY *rdst, RAY *rsrc)
 	{
 	rdst->id = rsrc->id;
 	rdst->x  = rsrc->x;
@@ -106,12 +104,8 @@
  *	Nothing.
  */
 
-VOID	InitRayTreeStack(TreeDepth, pid)
-INT	TreeDepth;
-INT	pid;
+VOID	InitRayTreeStack(INT TreeDepth, INT pid)
 	{
-	unsigned int powint();
-
 	raystruct[pid].StackSize   = powint(2, TreeDepth) - 1;
 	raystruct[pid].StackSize  += NumSubRays;
 	raystruct[pid].Stack	    = LocalMalloc(raystruct[pid].StackSize*sizeof(RAY), "raystack.c");
@@ -119,11 +113,10 @@
 	}
 
 
-unsigned int powint(i,j)
-  int i,j;
+unsigned long powint(long i, long j)
   {
-  int k;
-  int temp = 1;
+  long k;
+  long temp = 1;
 
   for (k = 0; k < j; k++)
       temp = temp*i;
@@ -144,9 +137,7 @@
  *	Nothing.
  */
 
-VOID	PushRayTreeStack(rmsg, pid)
-RAY	*rmsg;
-INT	pid;
+VOID	PushRayTreeStack(RAY *rmsg, INT pid)
 	{
 	raystruct[pid].StackTop++;
 
@@ -174,9 +165,7 @@
  *	Either empty or popped status code.
  */
 
-INT	PopRayTreeStack(rmsg, pid)
-RAY	*rmsg;
-INT	pid;
+INT	PopRayTreeStack(RAY *rmsg, INT pid)
 	{
 	if (raystruct[pid].StackTop < 0)
 		return (RTS_EMPTY);
diff -Naur splash2/codes/apps/raytrace/rltotiff/makefile splash2-modified/codes/apps/raytrace/rltotiff/makefile
--- splash2/codes/apps/raytrace/rltotiff/makefile	1994-10-14 17:26:04.000000000 -0400
+++ splash2-modified/codes/apps/raytrace/rltotiff/makefile	1969-12-31 19:00:00.000000000 -0500
@@ -1,23 +0,0 @@
-TARGET = rltotiff
-
-TIFF_LIBDIR = ./libtiff
-TIFF_INCDIR = ./libtiff
-OBJS = rltotiff.o tiff_rgba_io.o
-LDFLAGS = -L$(TIFF_LIBDIR) -lc_s -ltiff
-CFLAGS = -I$(TIFF_INCDIR)
-
-x = *
-
-$(TARGET): $(OBJS)
-	cc $(OBJS) $(CFLAGS) -o $(TARGET) $(LDFLAGS)
-
-
-M4 = -m4 -Uindex -Ulen
-RM = -rm -f
-
-.SUFFIXES:
-.SUFFIXES:      .o .c
-
-.c.o:
-	cc -c $(CFLAGS) $*.c
-
diff -Naur splash2/codes/apps/raytrace/rltotiff/Makefile splash2-modified/codes/apps/raytrace/rltotiff/Makefile
--- splash2/codes/apps/raytrace/rltotiff/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ splash2-modified/codes/apps/raytrace/rltotiff/Makefile	2007-03-18 02:42:31.000000000 -0400
@@ -0,0 +1,9 @@
+TARGET = rltotiff
+OBJS   = rltotiff.o tiff_rgba_io.o
+
+include ../../../Makefile.config
+
+LDFLAGS := $(LDFLAGS) -ltiff
+
+clean:
+	rm -rf $(OBJS) $(TARGET)
diff -Naur splash2/codes/apps/raytrace/rltotiff/rltotiff.c splash2-modified/codes/apps/raytrace/rltotiff/rltotiff.c
--- splash2/codes/apps/raytrace/rltotiff/rltotiff.c	1994-10-14 17:26:04.000000000 -0400
+++ splash2-modified/codes/apps/raytrace/rltotiff/rltotiff.c	2007-03-18 02:56:24.000000000 -0400
@@ -1,4 +1,4 @@
-/*************************************************************************/
+/************************************************************************/
 /*                                                                       */
 /*  Copyright (c) 1994 Stanford University                               */
 /*                                                                       */
@@ -23,14 +23,14 @@
 typedef short SHORT;
 typedef long LONG;
 typedef char CHAR;
-typedef int INT;
+typedef long INT;
 typedef float REAL;
 typedef void VOID;
 typedef unsigned short USHORT;
 typedef unsigned char BYTE;
 typedef unsigned char BOOL;
 typedef unsigned char UCHAR;
-typedef unsigned int UINT;
+typedef unsigned long UINT;
 typedef unsigned long ULONG;
 
 #define FALSE 0
@@ -133,16 +133,15 @@
 TGAPIX	tp;				/* TGA pixel buffer.		     */
 
 
-static int *gbRGBA;
-static int gbWidth;
-static int gbHeight;
-static int gbUseCurrentDim;
+static long *gbRGBA;
+static long gbWidth;
+static long gbHeight;
 
 VOID	ProcessSpachFile(FILE	*pf, CHAR	*pchFileName);
 void configRGBABuf(void);
 void SetPixel24(INT i, INT j,  BYTE r,  BYTE g, BYTE b);
 
-main(int argc, char **argv)
+int main(int argc, char **argv)
 {
     FILE *fp;
     char *spachfile, *tiffile;
@@ -155,7 +154,7 @@
     tiffile = argv[2];
 
     fp = fopen(spachfile, "rb");
-    
+
     if (!fp) {
 	fprintf(stderr, "spachtotiff: could not open file %s\n", spachfile);
 	exit(1);
@@ -163,6 +162,7 @@
 
     ProcessSpachFile(fp, spachfile);
     tiff_save_rgba(tiffile, gbRGBA, gbWidth, gbHeight);
+    return(0);
 }
 
 
@@ -170,7 +170,7 @@
 void
 configRGBABuf()
 {
-    gbRGBA = (int *)malloc(gbWidth*gbHeight*sizeof(int));
+    gbRGBA = (long *)malloc(gbWidth*gbHeight*sizeof(long));
 }
 
 
@@ -181,7 +181,7 @@
     if (i+j*gbWidth >= gbWidth*gbHeight)
 	fprintf(stderr, "Bug!\n");
 
-    gbRGBA[i+(gbHeight-j-1)*gbWidth] = 
+    gbRGBA[i+(gbHeight-j-1)*gbWidth] =
 	((UINT)r)*256*256 + ((UINT)g)*256 + ((UINT)b);
 }
 
@@ -205,8 +205,7 @@
 	INT	j;
 	INT	k;
 	INT	count;
-	UINT	ui, ui2, ui_low, ui_high;
-	UINT    c1, c2, c3, c4, c5, c6;
+	UINT	ui;
 	LONG	lPixCnt;
 
 	ui	 = getc(pf);
@@ -225,7 +224,7 @@
 	lPixCnt  = (ULONG)iCntResX*(ULONG)iCntResY;
 
 	configRGBABuf();
-	
+
 
 	if (fCenter)
 		{
@@ -252,7 +251,7 @@
 				}
 
 			if (fDebug)
-				printf("%d\t%d\t0x%02X\t0x%02X\t0x%02X\t0x%02X\n",
+				printf("%ld\t%ld\t0x%02X\t0x%02X\t0x%02X\t0x%02X\n",
 					i, j, sp.count, sp.r, sp.g, sp.b);
 
 			SetPixel24(i, j, sp.r, sp.g, sp.b);
diff -Naur splash2/codes/apps/raytrace/rltotiff/tiff_rgba_io.c splash2-modified/codes/apps/raytrace/rltotiff/tiff_rgba_io.c
--- splash2/codes/apps/raytrace/rltotiff/tiff_rgba_io.c	1994-10-14 17:26:04.000000000 -0400
+++ splash2-modified/codes/apps/raytrace/rltotiff/tiff_rgba_io.c	2007-03-18 02:51:57.000000000 -0400
@@ -23,12 +23,18 @@
 #endif
 
 #include <stdio.h>
-#include <tiffioP.h>
+#include <stdlib.h>
+#include <tiffio.h>
 #include "tiff_rgba_io.h"
 
 #define	streq(a,b)	(strcmp(a,b) == 0)
 
-#define BYTESWAP 
+#define BYTESWAP
+
+typedef unsigned char  u_char;
+typedef unsigned long  u_long;
+typedef unsigned short ushort;
+typedef unsigned short u_short;
 
 static u_char	rbuf[2048];
 static u_char	gbuf[2048];
@@ -36,23 +42,22 @@
 static u_char	abuf[2048];
 static u_char	*scanline = NULL;
 
-static int	rowsperstrip = -1;
-static int	compression = COMPRESSION_LZW;
-static int	config = PLANARCONFIG_CONTIG;
-static int	orientation = ORIENTATION_BOTLEFT;
+static long	rowsperstrip = -1;
+static long	compression = COMPRESSION_LZW;
+static long	config = PLANARCONFIG_CONTIG;
+static long	orientation = ORIENTATION_BOTLEFT;
 
 #define	MIN(a,b)	((a)<(b)?(a):(b))
 #define	ABS(x)		((x)<0?-(x):(x))
 
 
-int
-tiff_save_rgba(char *name, int *pixels, int width, int height)
+long
+tiff_save_rgba(char *name, long *pixels, long width, long height)
 {
 	TIFF *tif;
-	int xsize, ysize;
-	int xorg, yorg;
-	int y, i;
-	int *pos;
+	long xsize, ysize;
+	long y;
+	long *pos;
 
 	xsize = width;
 	ysize = height;
@@ -83,7 +88,7 @@
 #ifdef BYTESWAP
 		register char *sp = (char *) pos;
 		register char *tp = (char *) scanline;
-		register int x;
+		register long x;
 
 		for (x = 0; x < xsize; x++) {
 		    tp[3] = sp[0];
@@ -103,7 +108,7 @@
 	    else if (config == PLANARCONFIG_SEPARATE) {
 
 		register char *pp = (char *) pos;
-		register int x;
+		register long x;
 
 		for (x = 0; x < xsize; x++) {
 		    rbuf[x] = pp[0];
@@ -117,22 +122,22 @@
 		    TIFFWriteScanline(tif, bbuf, y, 2) < 0 ||
 		    TIFFWriteScanline(tif, abuf, y, 3) < 0)
 			break;
-	    } 
+	    }
 	}
     (void) TIFFClose(tif);
     return 1;
 }
 
 
-int
-tiff_load_rgba(char *file, int **pixels, int *width, int *height)
+long
+tiff_load_rgba(char *file, long **pixels, long *width, long *height)
 {
 	TIFF *tif;
-	u_short config, bitspersample, samplesperpixel;
+	u_short bitspersample, samplesperpixel;
 	u_long xsize, ysize;
-	register int x, y, rowbytes;
+	register long x, y, rowbytes;
 	u_char *buf;
-        int temp;
+        long temp;
 	ushort orient;
         register char *tp ;
         register char *sp ;
@@ -175,7 +180,7 @@
 
 	*width = xsize;
 	*height = ysize;
-	*pixels = (int *) malloc(ysize*xsize*sizeof(int));
+	*pixels = (long *) malloc(ysize*xsize*sizeof(long));
 
 
         switch (samplesperpixel) {
@@ -184,7 +189,7 @@
 		if (orient != ORIENTATION_BOTLEFT)
 		    tp += 4 * (*height-1) * *width;
 		buf = (u_char *) malloc(rowbytes);
-		
+
 		for (y = 0; y < ysize; y++) {
 		    if (TIFFReadScanline(tif, buf, y, 0) < 0)
 			break;
@@ -221,7 +226,7 @@
 		    sp = (char *) &temp;
 
 		    for (x = 0; x < xsize; x++) {
-			temp = *((int *)tp);
+			temp = *((long *)tp);
 			tp[3] = sp[0];
 			tp[2] = sp[1];
 			tp[1] = sp[2];
diff -Naur splash2/codes/apps/raytrace/rltotiff/tiff_rgba_io.h splash2-modified/codes/apps/raytrace/rltotiff/tiff_rgba_io.h
--- splash2/codes/apps/raytrace/rltotiff/tiff_rgba_io.h	1994-10-14 17:26:04.000000000 -0400
+++ splash2-modified/codes/apps/raytrace/rltotiff/tiff_rgba_io.h	2007-03-18 02:54:50.000000000 -0400
@@ -37,16 +37,16 @@
 *
 *  Arguments:
 *    char *filename - name of TIFF image target file
-*    int *pixels - 32-bit r,g,b,a image
-*    int width - image width
-*    int height - image height
+*    long *pixels - 32-bit r,g,b,a image
+*    long width - image width
+*    long height - image height
 *
 *  Description:
 *    Stores the pixels into the given file name as a TIFF file.
 *
 ******/
 
-int tiff_save_rgba(char *, int *, int, int);
+long tiff_save_rgba(char *, long *, long, long);
 
 
 
@@ -56,16 +56,16 @@
 *
 *  Arguments:
 *    char *filename - name of TIFF image target file
-*    int **pixels - 32-bit r,g,b,a image
-*    int *width - image width
-*    int *height - image height
+*    long **pixels - 32-bit r,g,b,a image
+*    long *width - image width
+*    long *height - image height
 *
 *  Description:
 *    Loads the pixels from the named TIFF file.
 *
 ******/
 
-int tiff_load_rgba(char *, int **, int*, int*);
+long tiff_load_rgba(char *, long **, long *, long *);
 
 
 #ifdef __cplusplus
diff -Naur splash2/codes/apps/raytrace/rt.H splash2-modified/codes/apps/raytrace/rt.H
--- splash2/codes/apps/raytrace/rt.H	1994-10-14 17:26:04.000000000 -0400
+++ splash2-modified/codes/apps/raytrace/rt.H	2007-03-21 16:38:44.000000000 -0400
@@ -39,6 +39,8 @@
 EXTERN_ENV
 #endif
 
+#define M_PI_2	1.57079632679489661923
+
 /*
  *	Define general constants.
  */
@@ -58,33 +60,37 @@
 
 #define MAX_X		1280		/* Max # pixels along x-axis.	     */
 #define MAX_Y		1024		/* Max # pixels along y-axis.	     */
-#define MAX_PROCS	128		/* Max # of processors. 	     */
+#define MAX_PROCS	4096		/* Max # of processors. 	     */
 #define MAX_VERTS	100		/* Max # of vertices in a polygon.   */
 #define MAX_LIGHTS	20		/* Max # of lights in a scene.	     */
 #define MAX_AA_ROW	9		/* Max antialias super sample is 9x9 */
 #define MAX_AA_COL	9
 
-#define INT_PAD_SIZE	256		/* padding size for 32-bit 
-	   quantities to avoid false-sharing. Pads are inserted in two 
+#define INT_PAD_SIZE	256		/* padding size for 32-bit
+	   quantities to avoid false-sharing. Pads are inserted in two
 	   situations: (i) when variables are really private to a processor
 	   but are declared in a shared array owing to the lack of a private
 	   space in the sproc lightweight threads model, and (ii) when
 	   there are simple situations of "control" variables that are written
 	   by only one processor but read by several, and declared in a
-	   shared array indexed by process id, e.g. wpstat and workpool 
+	   shared array indexed by process id, e.g. wpstat and workpool
 	   declared in this file */
 
 #define MAX_SUBDIV_LEVEL 3		/* Max HUG subdivision level.	     */
 #define MAX_RAYINFO	(MAX_SUBDIV_LEVEL + 1)
 
-#define NAME_LEN	30
+#define NAME_LEN	32
 #define ISECT_MAX	2
 
 
 #define RAYEPS		1e-07		/* Roundoff error tolerance.	     */
 #define HUGE_REAL	1e+32		/* A number we consider infinity.    */
+#if 0
 #define PI		3.141592654
 #define PI_over_2	1.570796327
+#else
+#define PI_over_2	M_PI_2
+#endif
 #define PIINV		0.318309886
 #define TWOPIINV	0.159154943
 #define LOG_CONV	3.321928094	/* Log base 2 of 10 (for base conv). */
@@ -182,9 +188,11 @@
  *	Define general macros.
  */
 
-#define Min(A, B)		( (A) < (B) ? (A) :  (B) )
+//#define Min(A, B)		( (A) < (B) ? (A) :  (B) )
+#define Min(A, B)		( (A) - (B) < 0.0 ? (A) :  (B) )
 
-#define Max(A, B)		( (A) > (B) ? (A) :  (B) )
+//#define Max(A, B)		( (A) > (B) ? (A) :  (B) )
+#define Max(A, B)		( (A) - (B) > 0.0 ? (A) :  (B) )
 
 #define ABS(A)			( (A) > 0.0 ? (A) : -(A) )
 
@@ -350,12 +358,13 @@
 typedef struct voxel
 	{
 	INT		id;		/* id = index1D 		     */
+	INT		numelements;	/* Number of elements in voxel.      */
+	struct voxel	*next;		/* Hashtable bucket list.	     */
 	CHAR		*cell;		/* Ptr to grid or ptr to ElemPtr list*/
 	CHAR		celltype;	/* 0 => local voxel, 1 => local grid */
 					/* 2 => GSM voxel, 3 => GSM grid     */
 					/* 4 => remote voxel, 5 =>remote grid*/
-	INT		numelements;	/* Number of elements in voxel.      */
-	struct voxel	*next;		/* Hashtable bucket list.	     */
+	CHAR		dummy[sizeof(INT) - 1];
 	}
 	VOXEL;
 
@@ -429,9 +438,9 @@
 typedef struct element
 	{
 	INT		index;
-	BBOX		bv;		/* Element bounding volume.	     */
 	struct object	*parent;	/* Ptr back to parent object.	     */
 	CHAR		*data;		/* Pointer to data info.	     */
+	BBOX		bv;		/* Element bounding volume.	     */
 	}
 	ELEMENT;
 
@@ -570,11 +579,12 @@
 	VEC3		P;			/* Position (origin).	     */
 	VEC3		D;			/* Direction.		     */
 	INT		level;			/* Level of ray in ray tree. */
-	R32		weight; 		/* Ray weight.		     */
-	INT		indx_inc3D[3];		/* Incl sign of ray direction*/
 	RAYINFO 	*ri;			/* Grid dependent ray info.  */
 	INT		ri_indx;
+	INT		indx_inc3D[3];		/* Incl sign of ray direction*/
 	RAYINFO 	rinfo[MAX_RAYINFO + 1];
+	R32		weight; 		/* Ray weight.		     */
+	R32		dummy;
 	}
 	RAY;
 
@@ -635,11 +645,11 @@
 	OBJECT	*modelroot;		/* Root of model list.		     */
 	GRID	*world_level_grid;	/* Zero level grid pointer.	     */
 	NODE	huge *freelist; 	/* Ptr to global free memory heap.   */
-	INT	wpstat[MAX_PROCS][INT_PAD_SIZE]; /* Shared work pool 
+	INT	wpstat[MAX_PROCS][INT_PAD_SIZE]; /* Shared work pool
 					   status hints.  Padded to avoid
 					   false-sharing */
-	WPJOB	*workpool[MAX_PROCS][INT_PAD_SIZE]; /* Ptr to heads of 
-					   shared work pools.  Padded to 
+	WPJOB	*workpool[MAX_PROCS][INT_PAD_SIZE]; /* Ptr to heads of
+					   shared work pools.  Padded to
 					   avoid false-sharing */
 
 	BARDEC(start)			/* Barrier for startup sync.	     */
@@ -655,6 +665,52 @@
 
 
 /*
+ *      Define polygon data structure.
+ */
+
+typedef struct poly
+        {
+        INT     nverts;                 /* Number of vertices in polygon. */
+        VEC3    norm;                   /* Face normal. */
+        REAL    d;                      /* Plane eqn D. */
+        VEC3    *vptr;                  /* Global vertex list pointer. */
+        INT     *vindex;                /* Index of vertices. */
+        INT     axis_proj;              /* Best axis for projection. */
+        }
+        POLY;
+
+
+
+/*
+ *      Define sphere data structure.
+ */
+
+typedef struct  sphere
+        {
+        POINT   center;                 /* Center of sphere. */
+        REAL    rad;                    /* Radius of sphere. */
+        REAL    rad2;                   /* Radius squared of sphere. */
+        }
+        SPHERE;
+
+
+
+typedef struct  tri
+        {
+        VEC3    norm;                   /* Face normal. */
+        REAL    d;                      /* Plane equation D. */
+        VEC3    *vptr;                  /* Global vertex list pointer. */
+        VEC3    *nptr;                  /* Global normal list pointer. */
+        INT     vindex[3];              /* Index of vertices. */
+        INT     indx;                   /* Normal component max flag. */
+        BOOL    norminterp;             /* Do normal interpolation? */
+        BOOL    vorder;                 /* Vertex order orientation. */
+        }
+        TRI;
+
+
+
+/*
  *	Define flags and associated types.
  */
 
@@ -715,172 +771,179 @@
  *	Function prototypes.
  */
 
-extern	void InquireBoundBoxValues(struct bbox *pbb,double *minx,double *miny,double *minz,double *maxx,double *maxy,double *maxz);
-extern	void NormalizeBoundBox(struct bbox *pbb,double (*mat)[4]);
-
-extern	void prn_gridlist(void );
-extern	void prn_ds_stats(void );
-extern	void init_masks(void );
-extern	struct grid *init_world_grid(struct voxel *v,ELEMENT **pepa,long num_pe);
-extern	struct voxel *init_world_voxel(ELEMENT **pepa, INT numelements);
-extern	void mark_empty(long index1D,struct grid *g);
-extern	void mark_nonempty(long index1D,struct grid *g);
-extern	void insert_in_hashtable(struct voxel *v,struct grid *g);
-extern	struct element * *prims_in_box2(struct element * *pepa,long n_in,struct bbox b,long *n);
-extern	struct btnode *init_bintree(struct grid *ng);
-extern	void subdiv_bintree(struct btnode *btn,struct grid *g);
-extern	void create_bintree(struct btnode *root,struct grid *g);
-extern	ELEMENT **bintree_lookup(struct btnode *root,long i,long j,long k,struct grid *g,long *n);
-extern	struct grid *create_grid(struct voxel *v,struct grid *g,long num_prims);
-
-extern	void PrintEnv(void );
-extern	void InitEnv(void );
-extern	void InitLights(void );
-extern	void InitDisplay(void );
-extern	unsigned long VerifyColorRange(double *c);
-extern	void TransformLights(double (*m)[4]);
-extern	void ViewRotate(double (*M)[4],double x,double y,double z);
-extern	void CreateViewMatrix(void );
-extern	void TransformViewRay(double *tray);
-extern	void NormalizeEnv(double (*normMat)[4]);
-extern	char LookupCommand(char *s);
-extern	void ReadEnvFile(char *EnvFileName);
-
-extern	void RunLengthEncode(struct _iobuf *pf,struct pixel *fb,long xsize);
-extern	void OpenFrameBuffer(void);
-extern	void AddPixelColor(double *c,long x,long y);
-extern	void CloseFrameBuffer(char *PicFileName);
-
-extern	ELEMENT **MakeElementArray(long *totalElements);
-extern	void PrintGeo(struct object *head);
-extern	void NormalizeGeo(struct object *po, double (*model)[4],double (*modelInvT)[4]);
-extern	void ReadGeoFile(char *mname);
-
-extern	void prn_voxel(struct voxel *v);
-extern	void prn_grid(struct grid *g);
-extern	void prn_ray(struct ray *r);
-extern	void prn_PrimElem(struct element *p);
-extern	void prn_bintree_node(struct btnode *b);
-extern	void prn_bintree_leaves(struct btnode *root);
-extern	void prn_pepa_prim_list(struct element * *pepa,long nprims);
-
-extern	void Huniform_defaults(void );
-extern	void BuildHierarchy_Uniform(void );
-extern	void IntersectHuniformPrimlist(long *intersectPrim,struct irecord *hit,VOXEL *v,struct ray *r,long pid);
-extern	double HuniformShadowIntersect(struct ray *r,double lightlength,struct element *pe,long pid);
-extern	unsigned long TraverseHierarchyUniform(struct ray *r,struct irecord *hit,long pid);
-
-extern	void prn_tv_stats(void );
-extern	long send_ray(struct ray *r,struct voxel *v);
-extern	struct voxel *lookup_hashtable(long indx,struct grid *g);
-extern	long lookup_emptycells(long indx,struct grid *g);
-extern	void pop_up_a_grid(struct ray *r);
-extern	void push_down_grid(struct ray *r,struct voxel *v);
-extern	long step_grid(struct ray *r);
-extern	long next_voxel(struct ray *r);
-extern	struct voxel *next_nonempty_voxel(struct ray *r);
-extern	struct voxel *next_nonempty_leaf(struct ray *r,long step,long *status);
-extern	struct voxel *init_ray(struct ray *r,struct grid *g);
-
-extern	unsigned long Intersect(struct ray *pr,struct irecord *hit);
-extern	double ShadowIntersect(struct ray *pr,double lightdist,struct element *pe);
-
-extern	void Usage(void );
-extern	void PrintStatistics(void );
-extern	void StartRayTrace(void );
-extern	int main(int argc,char * *argv);
-
-extern	void VecNorm(double *V);
-extern	void VecMatMult(double *Vt,double (*M)[4],double *V);
-extern	void PrintMatrix(double (*M)[4],char *s);
-extern	void MatrixIdentity(double (*M)[4]);
-extern	void MatrixCopy(double (*A)[4],double (*B)[4]);
-extern	void MatrixTranspose(double (*MT)[4],double (*M)[4]);
-extern	void MatrixMult(double (*C)[4],double (*A)[4],double (*B)[4]);
-extern	void MatrixInverse(double (*Minv)[4],double (*Mat)[4]);
-extern	void Translate(double (*M)[4],double dx,double dy,double dz);
-extern	void Scale(double (*M)[4],double sx,double sy,double sz);
-extern	void Rotate(long axis,double (*M)[4],double angle);
-
-extern	VOID	*LocalMalloc(UINT, CHAR *);
-extern	VOID	LocalFree(VOID *);
-extern	VOID	GlobalHeapWalk(VOID);
-extern	BOOL	GlobalHeapInit(UINT);
-extern	VOID	*GlobalMalloc(UINT, CHAR *);
-extern	VOID	*GlobalCalloc(UINT, UINT);
-extern	VOID	*GlobalRealloc(VOID *, UINT);
-extern	VOID	GlobalFree(VOID *);
-extern	UINT	GlobalMemAvail(VOID);
-extern	UINT	GlobalMemMax(VOID);
-extern	VOID	*ObjectMalloc(INT, INT);
-extern	VOID	ObjectFree(INT, INT, VOID *);
-
-extern	struct rayinfo *ma_rayinfo(struct ray *r);
-extern	void free_rayinfo(struct ray *r);
-extern	void reset_rayinfo(struct ray *r);
-extern	void ma_print(void );
-
-/*
- *	Define polygon function prototypes.
- */
-
-extern	char *PolyName(void );
-extern	void PolyPrint(struct object *po);
-extern	void PolyElementBoundBox(struct element *pe,struct poly *pp);
-extern	void PolyBoundBox(struct object *po);
-extern	void PolyNormal(struct irecord *hit,double *Pi,double *Ni);
-extern	void PolyDataNormalize(struct object *po,double (*normMat)[4]);
-extern	long PolyPeIntersect(struct ray *pr,struct element *pe,struct irecord *hit);
-extern	long PolyIntersect(struct ray *pr,struct object *po,struct irecord *hit);
-extern	void PolyTransform(struct object *po,double (*xtrans)[4],double (*xinvT)[4]);
-extern	void PolyRead(struct object *po,struct _iobuf *pf);
-
-extern	void CopyRayMsg(struct ray *rdst,struct ray *rsrc);
-extern	void InitRayTreeStack(long TreeDepth, int pid);
-extern	void PushRayTreeStack(struct ray *rmsg, int pid);
-extern	long PopRayTreeStack(struct ray *rmsg, int pid);
-
-extern	void SpecularDirection(double *R,double *N,double *I);
-extern	unsigned long TransmissionDirection(double *T,double *N,double *I,double kn);
-extern	void Shade(double *iP,double *N,struct ray *ray,struct irecord *hit,long pid);
-
-/*
- *	Define sphere function prototypes.
- */
-
-extern	char *SphName(void );
-extern	void SphPrint(struct object *po);
-extern	void SphElementBoundBox(struct element *pe,struct sphere *ps);
-extern	void SphBoundBox(struct object *po);
-extern	void SphNormal(struct irecord *hit,double *Pi,double *Ni);
-extern	void SphDataNormalize(struct object *po,double (*normMat)[4]);
-extern	long SphPeIntersect(struct ray *pr,struct element *pe,struct irecord *hit);
-extern	long SphIntersect(struct ray *pr,struct object *po,struct irecord *hit);
-extern	void SphTransform(struct object *po,double (*xtrans)[4],double (*xinvT)[4]);
-extern	void SphRead(struct object *po,struct _iobuf *pf);
-
-extern	unsigned long GetRayJobFromBundle(struct rayjob *job,long *x,long *y);
-extern	void ConvertPrimRayJobToRayMsg(struct ray *ray,double x,double y);
-extern	void RayTrace(long pid);
-
-/*
- *	Define triangle function prototypes.
- */
-
-extern	char *TriName(void );
-extern	void TriPrint(struct object *po);
-extern	void TriElementBoundBox(struct element *pe,struct tri *pt);
-extern	void TriBoundBox(struct object *po);
-extern	void TriNormal(struct irecord *hit,double *Pi,double *Ni);
-extern	void TriDataNormalize(struct object *po,double (*normMat)[4]);
-extern	long TriPeIntersect(struct ray *pr,struct element *pe,struct irecord *hit);
-extern	long TriIntersect(struct ray *pr,struct object *po,struct irecord *hit);
-extern	void TriTransform(struct object *po,double (*xtrans)[4],double (*xinvT)[4]);
-extern	void TriRead(struct object *po,struct _iobuf *pf);
-
-extern	void InitWorkPool(long pid);
-extern	void PrintWorkPool(long pid);
-extern	void PutJob(long xs,long ys,long xe,long ye,long xbe,long ybe,long pid);
-extern	long GetJob(struct rayjob *job,long pid);
-extern	long GetJobs(struct rayjob *job,long pid);
-
+/* bbox.c */
+void InquireBoundBoxValues(BBOX *pbb, REAL *minx, REAL *miny, REAL *minz, REAL *maxx, REAL *maxy, REAL *maxz);
+void NormalizeBoundBox(BBOX *pbb, MATRIX mat);
+
+/* cr.c */
+void prn_gridlist(void);
+void prn_ds_stats(void);
+void init_masks(void);
+GRID *init_world_grid(VOXEL *v, ELEMENT **pepa, INT num_pe);
+VOXEL *init_world_voxel(ELEMENT **pepa, INT numelements);
+void mark_empty(INT index1D, GRID *g);
+void mark_nonempty(INT index1D, GRID *g);
+void insert_in_hashtable(VOXEL *v, GRID *g);
+ELEMENT **prims_in_box2(ELEMENT **pepa, INT n_in, BBOX b, INT *n);
+BTNODE *init_bintree(GRID *ng);
+void subdiv_bintree(BTNODE *btn, GRID *g);
+void create_bintree(BTNODE *root, GRID *g);
+ELEMENT **bintree_lookup(BTNODE *root, INT i, INT j, INT k, GRID *g, INT *n);
+void deleteBinTree(BTNODE *binTree);
+GRID *create_grid(VOXEL *v, GRID *g, INT num_prims);
+
+/* env.c */
+void PrintEnv(void);
+void InitEnv(void);
+void InitLights(void);
+void InitDisplay(void);
+BOOL VerifyColorRange(COLOR c);
+void TransformLights(MATRIX m);
+void ViewRotate(MATRIX M, REAL x, REAL y, REAL z);
+void CreateViewMatrix(void);
+void TransformViewRay(POINT tray);
+void NormalizeEnv(MATRIX normMat);
+CHAR LookupCommand(CHAR *s);
+void ReadEnvFile(CHAR *EnvFileName);
+
+/* fbuf.c */
+void RunLengthEncode(FILE *pf, PIXEL *fb, INT xsize);
+void OpenFrameBuffer(void);
+void AddPixelColor(COLOR c, INT x, INT y);
+void CloseFrameBuffer(CHAR *PicFileName);
+
+/* geo.c */
+ELEMENT **MakeElementArray(INT *totalElements);
+void PrintGeo(OBJECT *po);
+void NormalizeGeo(OBJECT *po, MATRIX model, MATRIX modelInvT);
+void ReadGeoFile(CHAR *GeoFileName);
+
+/* huprn.c */
+void prn_voxel(VOXEL *v);
+void prn_grid(GRID *g);
+void prn_ray(RAY *r);
+void prn_PrimElem(ELEMENT *p);
+void prn_bintree_node(BTNODE *b);
+void prn_bintree_leaves(BTNODE *root);
+void prn_pepa_prim_list(ELEMENT **pepa, INT nprims);
+
+/* husetup.c */
+void Huniform_defaults(void);
+void BuildHierarchy_Uniform(void);
+void IntersectHuniformPrimlist(INT *intersectPrim, IRECORD *hit, VOXEL *v, RAY *r, INT pid);
+REAL HuniformShadowIntersect(RAY *r, REAL lightlength, ELEMENT *pe, INT pid);
+BOOL TraverseHierarchyUniform(RAY *r, IRECORD *hit, INT pid);
+
+/* hutv.c */
+void prn_tv_stats(void);
+INT send_ray(RAY *r, VOXEL *v);
+VOXEL *lookup_hashtable(INT indx, GRID *g);
+INT lookup_emptycells(INT indx, GRID *g);
+void pop_up_a_grid(RAY *r);
+void push_down_grid(RAY *r, VOXEL *v);
+INT step_grid(RAY *r);
+INT next_voxel(RAY *r);
+VOXEL *next_nonempty_voxel(RAY *r);
+VOXEL *next_nonempty_leaf(RAY *r, INT step, INT *status);
+VOXEL *init_ray(RAY *r, GRID *g);
+
+/* isect.c */
+BOOL Intersect(RAY *pr, IRECORD *hit);
+REAL ShadowIntersect(RAY *pr, REAL lightdist, ELEMENT *pe);
+
+/* main.c */
+void Usage(void);
+void PrintStatistics(void);
+void StartRayTrace(void);
+
+/* matrix.c */
+void VecNorm(POINT V);
+void VecMatMult(POINT Vt, MATRIX M, POINT V);
+void PrintMatrix(MATRIX M, CHAR *s);
+void MatrixIdentity(MATRIX M);
+void MatrixCopy(MATRIX A, MATRIX B);
+void MatrixTranspose(MATRIX MT, MATRIX M);
+void MatrixMult(MATRIX C, MATRIX A, MATRIX B);
+void MatrixInverse(MATRIX Minv, MATRIX Mat);
+void Translate(MATRIX M, REAL dx, REAL dy, REAL dz);
+void Scale(MATRIX M, REAL sx, REAL sy, REAL sz);
+void Rotate(INT axis, MATRIX M, REAL angle);
+
+/* memory.c */
+void *LocalMalloc(UINT n, CHAR *msg);
+void LocalFree(void *p);
+void GlobalHeapWalk(void);
+BOOL GlobalHeapInit(UINT size);
+void *GlobalMalloc(UINT size, CHAR *msg);
+void *GlobalCalloc(UINT n, UINT size);
+void *GlobalRealloc(void *p, UINT size);
+void GlobalFree(void *p);
+UINT GlobalMemAvl(void);
+UINT GlobalMemMax(void);
+void *ObjectMalloc(INT ObjectType, INT count);
+void ObjectFree(INT ObjectType, INT count, void *p);
+RAYINFO *ma_rayinfo(RAY *r);
+void free_rayinfo(RAY *r);
+void reset_rayinfo(RAY *r);
+void ma_print(void);
+
+/* poly.c */
+CHAR *PolyName(void);
+void PolyPrint(OBJECT *po);
+void PolyElementBoundBox(ELEMENT *pe, POLY *pp);
+void PolyBoundBox(OBJECT *po);
+void PolyNormal(IRECORD *hit, POINT Pi, POINT Ni);
+void PolyDataNormalize(OBJECT *po, MATRIX normMat);
+INT PolyPeIntersect(RAY *pr, ELEMENT *pe, IRECORD *hit);
+INT PolyIntersect(RAY *pr, OBJECT *po, IRECORD *hit);
+void PolyTransform(OBJECT *po, MATRIX xtrans, MATRIX xinvT);
+void PolyRead(OBJECT *po, FILE *pf);
+
+/* raystack.c */
+void CopyRayMsg(RAY *rdst, RAY *rsrc);
+void InitRayTreeStack(INT TreeDepth, INT pid);
+unsigned long powint(long i, long j);
+void PushRayTreeStack(RAY *rmsg, INT pid);
+INT PopRayTreeStack(RAY *rmsg, INT pid);
+
+/* shade.c */
+void SpecularDirection(POINT R, POINT N, POINT I);
+BOOL TransmissionDirection(POINT T, POINT N, POINT I, REAL kn);
+void Shade(VEC3 iP, VEC3 N, RAY *ray, IRECORD *hit, INT pid);
+
+/* sph.c */
+CHAR *SphName(void);
+void SphPrint(OBJECT *po);
+void SphElementBoundBox(ELEMENT *pe, SPHERE *ps);
+void SphBoundBox(OBJECT *po);
+void SphNormal(IRECORD *hit, POINT Pi, POINT Ni);
+void SphDataNormalize(OBJECT *po, MATRIX normMat);
+INT SphPeIntersect(RAY *pr, ELEMENT *pe, IRECORD *hit);
+INT SphIntersect(RAY *pr, OBJECT *po, IRECORD *hit);
+void SphTransform(OBJECT *po, MATRIX xtrans, MATRIX xinvT);
+void SphRead(OBJECT *po, FILE *pf);
+
+/* trace.c */
+REAL frand(void);
+BOOL GetRayJobFromBundle(RAYJOB *job, INT *x, INT *y);
+void ConvertPrimRayJobToRayMsg(RAY *ray, REAL x, REAL y);
+void RayTrace(INT pid);
+
+/* tri.c */
+CHAR *TriName(void);
+void TriPrint(OBJECT *po);
+void TriElementBoundBox(ELEMENT *pe, TRI *pt);
+void TriBoundBox(OBJECT *po);
+void TriNormal(IRECORD *hit, POINT Pi, POINT Ni);
+void TriDataNormalize(OBJECT *po, MATRIX normMat);
+INT TriPeIntersect(RAY *pr, ELEMENT *pe, IRECORD *hit);
+INT TriIntersect(RAY *pr, OBJECT *po, IRECORD *hit);
+void TriTransform(OBJECT *po, MATRIX xtrans, MATRIX xinvT);
+void TriRead(OBJECT *po, FILE *pf);
+
+/* workpool.c */
+void PutJob(INT xs, INT ys, INT xe, INT ye, INT xbe, INT ybe, INT pid);
+INT GetJob(RAYJOB *job, INT pid);
+INT GetJobs(RAYJOB *job, INT pid);
+void PrintWorkPool(INT pid);
+void InitWorkPool(INT pid);
diff -Naur splash2/codes/apps/raytrace/shade.C splash2-modified/codes/apps/raytrace/shade.C
--- splash2/codes/apps/raytrace/shade.C	1994-10-14 17:26:06.000000000 -0400
+++ splash2-modified/codes/apps/raytrace/shade.C	2007-03-18 01:47:49.000000000 -0400
@@ -48,10 +48,7 @@
  *	Nothing.
  */
 
-VOID	SpecularDirection(R, N, I)
-POINT	R;
-POINT	N;
-POINT	I;
+VOID	SpecularDirection(POINT R, POINT N, POINT I)
 	{
 	REAL	I_dot_N;		/* I*N				     */
 	POINT	N2;			/* 2N				     */
@@ -87,11 +84,7 @@
  *	TRUE if the ray was transmitted, FALSE if the ray was blocked.
  */
 
-BOOL	TransmissionDirection(T, N, I, kn)
-POINT	T;
-POINT	N;
-POINT	I;
-REAL	kn;
+BOOL	TransmissionDirection(POINT T, POINT N, POINT I, REAL kn)
 	{
 	POINT	vprime; 		/* Parameters in calculation.	     */
 	POINT	vplusn;
@@ -146,12 +139,7 @@
  *	Nothing.
  */
 
-VOID	Shade(iP, N, ray, hit, pid)
-VEC3	iP;
-VEC3	N;
-RAY	*ray;
-IRECORD *hit;
-INT	pid;
+VOID	Shade(VEC3 iP, VEC3 N, RAY *ray, IRECORD *hit, INT pid)
 	{
 	VEC3	Lvec;			/* Light vector.		     */
 	VEC3	Hvec;			/* Highlight vector.		     */
@@ -166,7 +154,7 @@
 	REAL	spec;			/* Highlight variable.		     */
 	OBJECT	*po;			/* Ptr to object.		     */
 	SURF	*s;			/* Surface pointer.		     */
-	INT	i, j;			/* Index variables.		     */
+	INT	i;			/* Index variables.		     */
 	REAL	lightlen;		/* Length of light vector.	     */
 	REAL	shadtrans;		/* Shadow transmission. 	     */
 	LIGHT	*lptr;			/* Light pointer.		     */
diff -Naur splash2/codes/apps/raytrace/sph.C splash2-modified/codes/apps/raytrace/sph.C
--- splash2/codes/apps/raytrace/sph.C	1994-10-14 17:26:06.000000000 -0400
+++ splash2-modified/codes/apps/raytrace/sph.C	2007-03-18 01:50:36.000000000 -0400
@@ -32,20 +32,6 @@
 
 
 /*
- *	Define sphere data structure.
- */
-
-typedef struct	sphere
-	{
-	POINT	center; 		/* Center of sphere.		     */
-	REAL	rad;			/* Radius of sphere.		     */
-	REAL	rad2;			/* Radius squared of sphere.	     */
-	}
-	SPHERE;
-
-
-
-/*
  * NAME
  *	SphName - return the object name
  *
@@ -75,8 +61,7 @@
  *	Nothing.
  */
 
-VOID	SphPrint(po)
-OBJECT	*po;
+VOID	SphPrint(OBJECT *po)
 	{
 	INT	i;
 	SPHERE	*ps;			/* Ptr to sphere data.		     */
@@ -109,9 +94,7 @@
  *	Nothing.
  */
 
-VOID	SphElementBoundBox(pe, ps)
-ELEMENT *pe;
-SPHERE	*ps;
+VOID	SphElementBoundBox(ELEMENT *pe, SPHERE *ps)
 	{
 	BBOX	*pbb;			/* Ptr to bounding box. 	     */
 
@@ -140,8 +123,7 @@
  *	Nothing.
  */
 
-VOID	SphBoundBox(po)
-OBJECT	*po;
+VOID	SphBoundBox(OBJECT *po)
 	{
 	INT	i;
 	SPHERE	*ps;			/* Ptr to sphere data.		     */
@@ -202,10 +184,7 @@
  *	Nothing.
  */
 
-VOID	SphNormal(hit, Pi, Ni)
-IRECORD *hit;
-POINT	Pi;
-POINT	Ni;
+VOID	SphNormal(IRECORD *hit, POINT Pi, POINT Ni)
 	{
 	ELEMENT *pe;
 	SPHERE	*ps;			/* Ptr to sphere data.		     */
@@ -236,9 +215,7 @@
  *	Nothing.
  */
 
-VOID	SphDataNormalize(po, normMat)
-OBJECT	*po;
-MATRIX	normMat;
+VOID	SphDataNormalize(OBJECT *po, MATRIX normMat)
 	{
 	INT	i;
 	SPHERE	*ps;			/* Ptr to sphere data.		     */
@@ -309,10 +286,7 @@
  *	The number of intersection points.
  */
 
-INT	SphPeIntersect(pr, pe, hit)
-RAY	*pr;
-ELEMENT *pe;
-IRECORD *hit;
+INT	SphPeIntersect(RAY *pr, ELEMENT *pe, IRECORD *hit)
 	{
 	INT	nhits;				/* Number of hits.	     */
 	REAL	b, disc, t1, t2, vsq;		/* Formula variables.	     */
@@ -371,10 +345,7 @@
  *	The number of intersections found.
  */
 
-INT	SphIntersect(pr, po, hit)
-RAY	*pr;
-OBJECT	*po;
-IRECORD *hit;
+INT	SphIntersect(RAY *pr, OBJECT *po, IRECORD *hit)
 	{
 	INT	i;
 	INT	nhits;			/* # hits in sphere.		     */
@@ -418,10 +389,7 @@
  *	Nothing.
  */
 
-VOID	SphTransform(po, xtrans, xinvT)
-OBJECT	*po;
-MATRIX	xtrans;
-MATRIX	xinvT;
+VOID	SphTransform(OBJECT *po, MATRIX xtrans, MATRIX xinvT)
 	{
 	INT	i;
 	INT	numelems;		/* Number of object elements.	  */
@@ -488,9 +456,7 @@
  *	Nothing.
  */
 
-VOID	SphRead(po, pf)
-OBJECT	*po;
-FILE	*pf;
+VOID	SphRead(OBJECT *po, FILE *pf)
 	{
 	INT	i;
 	INT	instat; 		/* Input counter		     */
diff -Naur splash2/codes/apps/raytrace/trace.C splash2-modified/codes/apps/raytrace/trace.C
--- splash2/codes/apps/raytrace/trace.C	1994-10-14 17:26:06.000000000 -0400
+++ splash2-modified/codes/apps/raytrace/trace.C	2007-03-18 01:52:13.000000000 -0400
@@ -75,9 +75,7 @@
  *	See above.
  */
 
-BOOL	GetRayJobFromBundle(job, x, y)
-RAYJOB	*job;
-INT	*x, *y;
+BOOL	GetRayJobFromBundle(RAYJOB *job, INT *x, INT *y)
 	{
 	*x = job->xcurr;			/* Set pixel address first.  */
 	*y = job->ycurr;
@@ -125,9 +123,7 @@
  *	Nothing.
  */
 
-VOID	ConvertPrimRayJobToRayMsg(ray, x, y)
-RAY	*ray;
-REAL	x, y;
+VOID	ConvertPrimRayJobToRayMsg(RAY *ray, REAL x, REAL y)
 	{
 	VEC4	dir;
 	VEC4	origin;
@@ -220,10 +216,9 @@
  *	Nothing.
  */
 
-VOID	RayTrace(pid)
-INT	pid;
+VOID	RayTrace(INT pid)
 	{
-	INT	i, j;
+	INT	j;
 	INT	x, y;			/* Pixel address.		     */
 	REAL	xx, yy;
 	VEC3	N;			/* Normal at intersection.	     */
diff -Naur splash2/codes/apps/raytrace/tri.C splash2-modified/codes/apps/raytrace/tri.C
--- splash2/codes/apps/raytrace/tri.C	1994-10-14 17:26:06.000000000 -0400
+++ splash2-modified/codes/apps/raytrace/tri.C	2007-03-18 01:55:21.000000000 -0400
@@ -43,25 +43,6 @@
 
 
 /*
- *	Define triangle data structure.
- */
-
-typedef struct	tri
-	{
-	VEC3	norm;			/* Face normal. 		     */
-	REAL	d;			/* Plane equation D.		     */
-	VEC3	*vptr;			/* Global vertex list pointer.	     */
-	VEC3	*nptr;			/* Global normal list pointer.	     */
-	INT	vindex[3];		/* Index of vertices.		     */
-	INT	indx;			/* Normal component max flag.	     */
-	BOOL	norminterp;		/* Do normal interpolation?	     */
-	BOOL	vorder; 		/* Vertex order orientation.	     */
-	}
-	TRI;
-
-
-
-/*
  * NAME
  *	TriName - return the object name
  *
@@ -91,8 +72,7 @@
  *	Nothing.
  */
 
-VOID	TriPrint(po)
-OBJECT	*po;
+VOID	TriPrint(OBJECT *po)
 	{
 	INT	i, j;
 	INT	*vindex;		/* Ptr to vertex index. 	     */
@@ -138,9 +118,7 @@
  *	Nothing.
  */
 
-VOID	TriElementBoundBox(pe, pt)
-ELEMENT *pe;
-TRI	*pt;
+VOID	TriElementBoundBox(ELEMENT *pe, TRI *pt)
 	{
 	INT	i;			/* Index.			     */
 	INT	*vindex;		/* Vertex index pointer.	     */
@@ -196,8 +174,7 @@
  *	Nothing.
  */
 
-VOID	TriBoundBox(po)
-OBJECT	*po;
+VOID	TriBoundBox(OBJECT *po)
 	{
 	INT	i;
 	TRI	*pt;			/* Ptr to triangle data.	     */
@@ -258,10 +235,7 @@
  *	Nothing.
  */
 
-VOID	TriNormal(hit, Pi, Ni)
-IRECORD *hit;
-POINT	Pi;
-POINT	Ni;
+VOID	TriNormal(IRECORD *hit, POINT Pi, POINT Ni)
 	{
 	ELEMENT *pe;
 	TRI	*pt;			/* Ptr to triangle data.	     */
@@ -335,9 +309,7 @@
  *	Nothing.
  */
 
-VOID	TriDataNormalize(po, normMat)
-OBJECT	*po;
-MATRIX	 normMat;
+VOID	TriDataNormalize(OBJECT *po, MATRIX normMat)
 	{
 	INT	i;
 	POINT	coord;
@@ -418,12 +390,8 @@
  *	The number of intersection points.
  */
 
-INT	TriPeIntersect(pr, pe, hit)
-RAY	*pr;
-ELEMENT *pe;
-IRECORD *hit;
+INT	TriPeIntersect(RAY *pr, ELEMENT *pe, IRECORD *hit)
 	{
-	INT	i;
 	REAL	Rd_dot_Pn;		/* Polygon normal dot ray direction. */
 	REAL	Ro_dot_Pn;		/* Polygon normal dot ray origin.    */
 	REAL	q1, q2;
@@ -555,10 +523,7 @@
  *	The number of intersections found.
  */
 
-INT	TriIntersect(pr, po, hit)
-RAY	*pr;
-OBJECT	*po;
-IRECORD *hit;
+INT	TriIntersect(RAY *pr, OBJECT *po, IRECORD *hit)
 	{
 	INT	i;
 	INT	nhits;			/* # hits in polyhedra. 	     */
@@ -608,12 +573,9 @@
  *	Nothing.
  */
 
-VOID	TriTransform(po, xtrans, xinvT)
-OBJECT	*po;
-MATRIX	xtrans;
-MATRIX	xinvT;
+VOID	TriTransform(OBJECT *po, MATRIX xtrans, MATRIX xinvT)
 	{
-	INT	i, j;			/* Indices.			     */
+	INT	i;			/* Indices.			     */
 	INT	numelems;		/* # of elements.		     */
 	INT	*vindex;		/* Vertex index pointer.	     */
 	VEC3	*vptr, *vp;		/* Vertex list pointers.	     */
@@ -753,11 +715,9 @@
  *	Nothing.
  */
 
-VOID	TriRead(po, pf)
-OBJECT	*po;
-FILE	*pf;
+VOID	TriRead(OBJECT *po, FILE *pf)
 	{
-	INT	i, j;			/* Indices.			     */
+	INT	i;			/* Indices.			     */
 	INT	instat; 		/* Read status. 		     */
 	INT	totalverts;		/* Total # of vertices in tri mesh.  */
 	CHAR	normstr[5];		/* Face/vertex normal flag string.   */
diff -Naur splash2/codes/apps/raytrace/workpool.C splash2-modified/codes/apps/raytrace/workpool.C
--- splash2/codes/apps/raytrace/workpool.C	1994-10-14 17:26:06.000000000 -0400
+++ splash2-modified/codes/apps/raytrace/workpool.C	2007-03-18 01:57:39.000000000 -0400
@@ -64,11 +64,7 @@
  *	Nothing.
  */
 
-VOID	PutJob(xs, ys, xe, ye, xbe, ybe, pid)
-INT	xs,  ys;
-INT	xe,  ye;
-INT	xbe, ybe;
-INT	pid;
+VOID	PutJob(INT xs, INT ys, INT xe, INT ye, INT xbe, INT ybe, INT pid)
 	{
 	INT	i, j;
 	INT	xb_addr, yb_addr;		/* Bundle pixel address.     */
@@ -149,9 +145,7 @@
  *	Work pool status code.
  */
 
-INT	GetJob(job, pid)
-RAYJOB	*job;
-INT	pid;
+INT	GetJob(RAYJOB *job, INT pid)
 	{
 	WPJOB	*wpentry;			/* Work pool entry.	     */
 
@@ -198,9 +192,7 @@
  *	Workpool status.
  */
 
-INT	GetJobs(job, pid)
-RAYJOB	*job;
-INT	pid;
+INT	GetJobs(RAYJOB *job, INT pid)
 	{
 	INT	i;
 
@@ -250,8 +242,7 @@
  *	Nothing.
  */
 
-VOID	PrintWorkPool(pid)
-INT	pid;
+VOID	PrintWorkPool(INT pid)
 	{
 	WPJOB	*j;
 
@@ -278,8 +269,7 @@
  *	Nothing.
  */
 
-VOID	InitWorkPool(pid)
-INT	pid;
+VOID	InitWorkPool(INT pid)
 	{
 	INT	i;
 	INT	x, y;
diff -Naur splash2/codes/apps/volrend/adaptive.C splash2-modified/codes/apps/volrend/adaptive.C
--- splash2/codes/apps/volrend/adaptive.C	1994-10-14 01:01:12.000000000 -0400
+++ splash2-modified/codes/apps/volrend/adaptive.C	2007-03-19 23:42:45.000000000 -0400
@@ -16,8 +16,8 @@
 
 /*************************************************************************
 *                                                                        *
-*     adaptive.c:  Render dataset via raytracing. 					  	 *
-*															             *
+*     adaptive.c:  Render dataset via raytracing.                        *
+*                                                                        *
 *************************************************************************/
 
 #include "incl.h"
@@ -29,10 +29,10 @@
 				/*   [2][0] is dx(object)/dz(image)          */
 float invinvjacobian[NM][NM];	/*   [i][j] = 1.0 / invjacobian[i][j]        */
                                 /* For gathering statistics:                 */
-int num_rays_traced;            /*   number of calls to Trace_Ray            */
-int num_traced_rays_hit_volume; /*   number of traced rays that hit volume   */
-int num_samples_trilirped;      /*   number of samples trilirped             */
-int itest;
+long num_rays_traced;            /*   number of calls to Trace_Ray            */
+long num_traced_rays_hit_volume; /*   number of traced rays that hit volume   */
+long num_samples_trilirped;      /*   number of samples trilirped             */
+long itest;
 
 #define	RAY_TRACED	((MAX_PIXEL+1)/2)	/* Ray traced at this pixel  */
 #define START_RAY       1
@@ -42,15 +42,11 @@
 
 #include "anl.h"
 
-Ray_Trace(int my_node)
+void Ray_Trace(long my_node)
 {
-  int outx,outy,outz;
-  int i,j;
-  unsigned int starttime,stoptime,exectime,exectime1;
-  int pid;
-  char cmd[FILENAME_STRING_SIZE];
+  long i,j;
+  long starttime,stoptime,exectime,exectime1;
 
-  
   /* Assumptions made by ray tracer:                                   */
   /*   o Frustrum clipping is performed.                               */
   /*     All viewing frustums will be handled correctly.               */
@@ -58,7 +54,7 @@
   /*     If downsizing was specified, some input voxels will be        */
   /*     unsampled, but upsizing may be specified and will be          */
   /*     handled correctly.                                            */
-  
+
   /* Compute inverse Jacobian matrix from                              */
   /* coordinates of output map unit voxel in object space,             */
   /* then make a copy of object space d{x,y,z} per image space dz,     */
@@ -107,7 +103,7 @@
     BARRIER(Global->TimeBarrier,num_nodes);
 
     mclock(stoptime,starttime,&exectime);
-    
+
     /* If adaptively ray tracing and highest sampling size is greater    */
     /* than lowest size for volume data if polygon list exists or        */
     /* display pixel size if it does not, recursively interpolate to     */
@@ -126,6 +122,7 @@
 
       mclock(stoptime,starttime,&exectime1);
     }
+
   }
   else {
 
@@ -151,7 +148,7 @@
   }
 
     LOCK(Global->CountLock);
-    printf("%3d\t%3d\t%6u\t%6u\t%6d\t%6d\t%8d\n",my_node,frame,exectime,
+    printf("%3ld\t%3ld\t%6ld\t%6ld\t%6ld\t%6ld\t%8ld\n",my_node,frame,exectime,
 	   exectime1,num_rays_traced,num_traced_rays_hit_volume,
 	   num_samples_trilirped);
 
@@ -161,12 +158,12 @@
 }
 
 
-Ray_Trace_Adaptively(int my_node)
+void Ray_Trace_Adaptively(long my_node)
 {
-  int i,outx,outy,yindex,xindex;
+  long outx,outy,yindex,xindex;
 
-  int num_xqueue,num_yqueue,num_queue,lnum_xblocks,lnum_yblocks,lnum_blocks;
-  int xstart,xstop,ystart,ystop,local_node,work;
+  long num_xqueue,num_yqueue,num_queue,lnum_xblocks,lnum_yblocks,lnum_blocks;
+  long xstart,xstop,ystart,ystop,local_node,work;
 
   itest = 0;
 
@@ -198,7 +195,7 @@
 	   outy+=highest_sampling_boxlen) {
 	for (outx=xindex; outx<xindex+block_xlen && outx<xstop;
 	     outx+=highest_sampling_boxlen) {
-	  
+
 	  /* Trace rays within square box of highest sampling size     */
 	  /* whose lower-left corner is current image space location.  */
 	  Ray_Trace_Adaptive_Box(outx,outy,highest_sampling_boxlen);
@@ -223,17 +220,16 @@
 }
 
 
-Ray_Trace_Adaptive_Box(outx, outy, boxlen)
-     int outx, outy, boxlen;
+void Ray_Trace_Adaptive_Box(long outx, long outy, long boxlen)
 {
-  int i,j;
-  int half_boxlen;
-  int min_volume_color,max_volume_color;
+  long i,j;
+  long half_boxlen;
+  long min_volume_color,max_volume_color;
   float foutx,fouty;
-  volatile int imask;
-  
+  volatile long imask;
+
   PIXEL *pixel_address;
-  
+
   /* Trace rays from all four corners of the box into the map,         */
   /* being careful not to exceed the boundaries of the output image,   */
   /* and using a flag array to avoid retracing any rays.               */
@@ -278,7 +274,7 @@
 
 /*reschedule processes here if rescheduling only at synch points on simulator*/
 
-	Trace_Ray(outx+j,outy+i,foutx,fouty,pixel_address);
+	Trace_Ray(foutx,fouty,pixel_address);
 
 /*reschedule processes here if rescheduling only at synch points on simulator*/
 
@@ -316,7 +312,7 @@
   /* being careful not to exceed the boundaries of the output image.   */
   /* Use of geometry-only color difference suppressed in accordance    */
   /* with hybrid.trf as published in IEEE CG&A, March, 1990.           */
-  if (boxlen > lowest_volume_boxlen && 
+  if (boxlen > lowest_volume_boxlen &&
       max_volume_color - min_volume_color >=
       volume_color_difference) {
     half_boxlen = boxlen >> 1;
@@ -329,14 +325,14 @@
 }
 
 
-Ray_Trace_Non_Adaptively(int my_node)
+void Ray_Trace_Non_Adaptively(long my_node)
 {
-  int i,outx,outy,xindex,yindex;
+  long outx,outy,xindex,yindex;
   float foutx,fouty;
   PIXEL *pixel_address;
 
-  int num_xqueue,num_yqueue,num_queue,lnum_xblocks,lnum_yblocks,lnum_blocks;
-  int xstart,xstop,ystart,ystop,local_node,work;
+  long num_xqueue,num_yqueue,num_queue,lnum_xblocks,lnum_yblocks,lnum_blocks;
+  long xstart,xstop,ystart,ystop,local_node,work;
 
   num_xqueue = ROUNDUP((float)image_len[X]/(float)image_section[X]);
   num_yqueue = ROUNDUP((float)image_len[Y]/(float)image_section[Y]);
@@ -359,13 +355,13 @@
       yindex = ystart + (work/lnum_xblocks)*block_ylen;
       for (outy=yindex; outy<yindex+block_ylen && outy<ystop; outy++) {
 	for (outx=xindex; outx<xindex+block_xlen && outx<xstop; outx++) {
-	  
+
 	  /* Trace ray from specified image space location into map.   */
 	  /* Stochastic sampling is as described in adaptive code.     */
 	  foutx = (float)(outx);
 	  fouty = (float)(outy);
 	  pixel_address = IMAGE_ADDRESS(outy,outx);
-	  Trace_Ray(outx,outy,foutx,fouty,pixel_address);
+	  Trace_Ray(foutx,fouty,pixel_address);
 	}
       }
       ALOCK(Global->QLock,local_node);
@@ -385,9 +381,9 @@
 }
 
 
-Ray_Trace_Fast_Non_Adaptively(int my_node)
+void Ray_Trace_Fast_Non_Adaptively(long my_node)
 {
-  int i,outx,outy,xindex,yindex;
+  long i,outx,outy,xindex,yindex;
   float foutx,fouty;
   PIXEL *pixel_address;
 
@@ -399,14 +395,14 @@
          outy<image_len[Y]; outy+=lowest_volume_boxlen) {
       for (outx=xindex; outx<xindex+block_xlen &&
            outx<image_len[X]; outx+=lowest_volume_boxlen) {
-      
+
 	/* Trace ray from specified image space location into map.   */
 	/* Stochastic sampling is as described in adaptive code.     */
 	MASK_IMAGE(outy,outx) += RAY_TRACED;
 	foutx = (float)(outx);
 	fouty = (float)(outy);
 	pixel_address = IMAGE_ADDRESS(outy,outx);
-	Trace_Ray(outx,outy,foutx,fouty,pixel_address);
+	Trace_Ray(foutx,fouty,pixel_address);
 	num_rays_traced++;
       }
     }
@@ -414,10 +410,10 @@
 }
 
 
-Interpolate_Recursively(int my_node)
+void Interpolate_Recursively(long my_node)
 {
-  int i,outx,outy,xindex,yindex;
-  
+  long i,outx,outy,xindex,yindex;
+
   for (i=0; i<num_blocks; i+=num_nodes) {
     yindex = ((my_node+i)/num_xblocks)*block_ylen;
     xindex = ((my_node+i)%num_xblocks)*block_xlen;
@@ -436,18 +432,17 @@
 }
 
 
-Interpolate_Recursive_Box(outx, outy, boxlen)
-     int outx, outy, boxlen;
+void Interpolate_Recursive_Box(long outx, long outy, long boxlen)
 {
-  int i,j;
-  int half_boxlen;
-  int corner_color[2][2],color;
-  int outx_plus_boxlen,outy_plus_boxlen;
-  
+  long i,j;
+  long half_boxlen;
+  long corner_color[2][2],color;
+  long outx_plus_boxlen,outy_plus_boxlen;
+
   float one_over_boxlen;
   float xalpha,yalpha;
   float one_minus_xalpha,one_minus_yalpha;
-  
+
   /* Fill in the four pixels at the midpoints of the sides and at      */
   /* the center of the box by bilirping between the four corners,      */
   /* being careful not to exceed the boundaries of the output image,   */
@@ -500,11 +495,3 @@
     }
   }
 }
-
-
-
-
-
-
-
-
diff -Naur splash2/codes/apps/volrend/anl.H splash2-modified/codes/apps/volrend/anl.H
--- splash2/codes/apps/volrend/anl.H	1994-10-14 01:01:12.000000000 -0400
+++ splash2-modified/codes/apps/volrend/anl.H	2007-03-18 23:41:09.000000000 -0400
@@ -24,8 +24,8 @@
 #define PAD 256
 
 struct GlobalMemory {
-  volatile int Index,Counter;
-  volatile int Queue[MAX_NUMPROC+1][PAD];
+  volatile long Index,Counter;
+  volatile long Queue[MAX_NUMPROC+1][PAD];
   BARDEC(SlaveBarrier)
   BARDEC(TimeBarrier)
   LOCKDEC(IndexLock)
diff -Naur splash2/codes/apps/volrend/const.H splash2-modified/codes/apps/volrend/const.H
--- splash2/codes/apps/volrend/const.H	1994-10-14 01:01:12.000000000 -0400
+++ splash2-modified/codes/apps/volrend/const.H	2007-03-19 20:37:47.000000000 -0400
@@ -16,7 +16,7 @@
 
 /************************************************************************
 *                                                                       *
-*     constants.h:  constants needed for rendering system 				*
+*     constants.h:  constants needed for rendering system 		*
 *                                                                       *
 ************************************************************************/
 
@@ -30,10 +30,10 @@
 #define PIXELS_PER_BLOCK_DIM   4
 #define ZSCALE                 1
 #ifdef DIM
-#define ROTATE_STEPS          4
+#define ROTATE_STEPS          8
 #define STEP_SIZE             3
 #else
-#define ROTATE_STEPS           4
+#define ROTATE_STEPS           8
 #define STEP_SIZE              3
 #endif
 #define ROOT                   0
@@ -92,7 +92,7 @@
 #define MAX_OUTLEN	4096	/*   size of any output map or space         */
 #define SMALL          0.00001  /* Don't use {SMALL,BIG} in single precision */
 #define BIG            9999.999 /* expressions alongside {big,small} numbers */
-#define MAX_INT    4294967295   /* 2^32-1 is the maximum integer             */
+/*#define MAX_INT    4294967295*/   /* 2^32-1 is the maximum integer             */
 
                                 /* Definition of global constants assumed    */
 #define INSET           1               /*   inset assumes gradient          */
diff -Naur splash2/codes/apps/volrend/file.C splash2-modified/codes/apps/volrend/file.C
--- splash2/codes/apps/volrend/file.C	1994-10-14 01:01:12.000000000 -0400
+++ splash2-modified/codes/apps/volrend/file.C	2007-03-19 22:58:38.000000000 -0400
@@ -16,6 +16,7 @@
 
 /********** storing/loading of large arrays to/from files **********/
 
+#include <fcntl.h>
 #include "incl.h"
 
 #define	PMODE	0644		/* RW for owner, R for group, R for others */
@@ -23,8 +24,7 @@
 
 EXTERN_ENV
 
-Create_File(filename)
-     char filename[];
+int Create_File(char filename[])
 {
   int fd;
   if ((fd = creat(filename,PMODE)) == -1) {
@@ -34,8 +34,7 @@
 }
 
 
-Open_File(filename)
-     char filename[];
+int Open_File(char filename[])
 {
   int fd;
   if ((fd = open(filename,RWMODE)) == -1) {
@@ -45,10 +44,7 @@
 }
 
 
-Write_Bytes(fd,array,length)
-     int fd;
-     unsigned char array[];
-     long length;
+void Write_Bytes(int fd, unsigned char array[], long length)
 {
   long n_written;
   long more_written;
@@ -68,13 +64,8 @@
 }
 
 
-Write_Shorts(fd,array,length)
-     int fd;
-     unsigned char array[];
-     long length;
+void Write_Shorts(int fd, unsigned char array[], long length)
 {
-  int i;
-  unsigned char byte;
   long n_written;
   long more_written;
 #ifdef FLIP
@@ -107,13 +98,8 @@
 }
 
 
-Write_Longs(fd,array,length)
-     int fd;
-     unsigned char array[];
-     long length;
+void Write_Longs(int fd, unsigned char array[], long length)
 {
-  int i;
-  unsigned char byte;
   long n_written;
   long more_written;
 #ifdef FLIP
@@ -152,10 +138,7 @@
 }
 
 
-Read_Bytes(fd,array,length)
-     int fd;
-     unsigned char array[];
-     long length;
+void Read_Bytes(int fd, unsigned char array[], long length)
 {
   long n_read;
   long more_read;
@@ -175,13 +158,8 @@
 }
 
 
-Read_Shorts(fd,array,length)
-     int fd;
-     unsigned char array[];
-     long length;
+void Read_Shorts(int fd, unsigned char array[], long length)
 {
-  int i;
-  unsigned char byte;
   long n_read;
   long more_read;
   n_read = read(fd,array,MIN(length,32766));
@@ -207,13 +185,8 @@
 }
 
 
-Read_Longs(fd,array,length)
-     int fd;
-     unsigned char array[];
-     long length;
+void Read_Longs(int fd, unsigned char array[], long length)
 {
-  int i;
-  unsigned char byte;
   long n_read;
   long more_read;
   n_read = read(fd,array,MIN(length,32766));
@@ -242,8 +215,7 @@
 }
 
 
-Close_File(fd)
-     int fd;
+void Close_File(int fd)
 {
   if (close(fd) == -1) {
     Error("    Can't close file %d\n",fd);
diff -Naur splash2/codes/apps/volrend/global.H splash2-modified/codes/apps/volrend/global.H
--- splash2/codes/apps/volrend/global.H	1994-10-14 01:01:13.000000000 -0400
+++ splash2-modified/codes/apps/volrend/global.H	2007-03-22 00:07:35.000000000 -0400
@@ -21,12 +21,12 @@
 ************************************************************************/
 
 
-extern int image_section[NI];
-extern int voxel_section[NM];
+extern long image_section[NI];
+extern long voxel_section[NM];
 
 extern PIXEL *image,*image_block,*mask_image_block;
-extern int num_nodes,frame;
-extern int block_xlen,block_ylen,num_blocks,num_xblocks,num_yblocks;
+extern long num_nodes,frame;
+extern long block_xlen,block_ylen,num_blocks,num_xblocks,num_yblocks;
 extern struct GlobalMemory *Global;
 extern PIXEL *shd_address;
 extern BOOLEAN *sbit_address;
@@ -35,13 +35,13 @@
                                 /* Option globals                            */
 extern BOOLEAN adaptive;        /* YES for adaptive ray tracing, NO if not   */
                                 /* Shading parameters of reflective surface: */
-extern float density_opacity[MAX_DENSITY+1];	
+extern float density_opacity[MAX_DENSITY+1];
                                 /*   opacity as function of density          */
 extern float magnitude_opacity[MAX_MAGNITUDE+1];
                                 /*  opacity as function of magnitude         */
-extern int density_epsilon;	/*   minimum (density*map_divisor)           */
+extern long density_epsilon;	/*   minimum (density*map_divisor)           */
 				/*     (>= MIN_DENSITY)                      */
-extern int magnitude_epsilon;	/*   minimum (magnitude*grd_divisor)**2      */
+extern long magnitude_epsilon;	/*   minimum (magnitude*grd_divisor)**2      */
 				/*     (> MIN_MAGNITUDE)                     */
 extern PIXEL background;	/*   color of background                     */
 extern float light[NM];		/*   normalized vector from object to light  */
@@ -58,41 +58,41 @@
 				/*      all voxels for generation of mipmap) */
 extern float opacity_cutoff;	/*   cutoff opacity                          */
 				/*     (<= MAX_OPACITY)                      */
-extern int highest_sampling_boxlen;
+extern long highest_sampling_boxlen;
                                 /*   highest boxlen for adaptive sampling    */
 				/*     (>= 1)                                */
-extern int lowest_volume_boxlen;/*   lowest boxlen for volume data           */
+extern long lowest_volume_boxlen;/*   lowest boxlen for volume data           */
 				/*     (>= 1)                                */
-extern int volume_color_difference;
+extern long volume_color_difference;
                         	/*   minimum color diff for volume data      */
 				/*     (>= MIN_PIXEL)                        */
 extern float angle[NM];         /*  initial viewing angle                    */
-extern int pyr_highest_level;	/*   highest level of pyramid to look at     */
+extern long pyr_highest_level;	/*   highest level of pyramid to look at     */
 				/*     (<= MAX_PYRLEVEL)                     */
-extern int pyr_lowest_level;	/*   lowest level of pyramid to look at      */
+extern long pyr_lowest_level;	/*   lowest level of pyramid to look at      */
 				/*     (>= 0)                                */
 
                                 /* Pre_View Globals                          */
-extern short frust_len; 	/* Size of clipping frustum                  */
+extern long frust_len; 	/* Size of clipping frustum                  */
 				/*   (mins will be 0 in this program,        */
 				/*    {x,y}len will be <= IK{X,Y}SIZE)       */
 extern float depth_cueing[MAX_OUTLEN];
                          	/* Pre-computed table of depth cueing        */
-extern int image_zlen;	       	/* number of samples along viewing ray       */
+extern long image_zlen;	       	/* number of samples along viewing ray       */
 extern float in_max[NM];        /* Pre-computed clipping aids                */
-extern int opc_xlen,opc_xylen;
-extern int norm_xlen,norm_xylen;
+extern long opc_xlen,opc_xylen;
+extern long norm_xlen,norm_xylen;
 
 extern VOXEL *vox_address;
-extern short vox_len[NM];
+extern long vox_len[NM];
 extern long vox_length;
-extern int vox_xlen,vox_xylen;
+extern long vox_xlen,vox_xylen;
 
 
                                 /* View Globals                              */
 extern float transformation_matrix[4][4];
                                 /* current transformation matrix             */
-extern float out_invvertex[2][2][2][NM]; 
+extern float out_invvertex[2][2][2][NM];
                                 /* Image and object space centers            */
                                 /*   of outer voxels in output map           */
 extern float uout_invvertex[2][2][2][NM];
@@ -114,20 +114,20 @@
 
                                 /* Density map globals                       */
 extern short map_len[NM];	/* Size of this density map                  */
-extern long map_length;		/* Total number of densities in map          */
+extern int map_length;		/* Total number of densities in map          */
 				/*   (= product of lens)                     */
 extern DENSITY *map_address;	/* Pointer to map                            */
 
                                 /* Normal and gradient magnitude map globals */
 extern short norm_len[NM];	/* Size of this normal map                   */
-extern long norm_length;	/* Total number of normals in map            */
+extern int norm_length;	/* Total number of normals in map            */
 				/*   (= NM * product of lens)                */
 extern NORMAL *norm_address;	/* Pointer to normal map                     */
 extern float nmag_epsilon;
 
                                 /* Opacity map globals                       */
 extern short opc_len[NM];	/* Size of this opacity map                  */
-extern long opc_length;		/* Total number of opacities in map          */
+extern int opc_length;		/* Total number of opacities in map          */
 				/*   (= product of lens)                     */
 extern OPACITY *opc_address;	/* Pointer to opacity map                    */
 
@@ -137,9 +137,9 @@
                         	/* Number of voxels on each level            */
 extern short pyr_voxlen[MAX_PYRLEVEL+1][NM];
                           	/* Size of voxels on each level              */
-extern long pyr_length[MAX_PYRLEVEL+1];
+extern int pyr_length[MAX_PYRLEVEL+1];
                                 /* Total number of bytes on this level       */
-				/* (= (int)((product of lens+7)/8))          */
+				/* (= (long)((product of lens+7)/8))          */
 extern BYTE *pyr_address[MAX_PYRLEVEL+1];
                                 /* Pointer to binary pyramid                 */
 				/*   (only pyr_levels sets of lens, lengths, */
@@ -149,11 +149,107 @@
 extern BYTE *pyr_address2;	/* Pointer to byte containing bit            */
 
                                 /* Image globals                             */
-extern short image_len[NI];     /* Size of image                             */
-extern long image_length;       /* Total number of pixels in map             */
+extern long image_len[NI];      /* Size of image                             */
+extern int image_length;        /* Total number of pixels in map             */
 extern PIXEL *image_address;    /* Pointer to image                          */
-extern short mask_image_len[NI];/* Size of mask image for adaptive ray trace */
+extern long mask_image_len[NI]; /* Size of mask image for adaptive ray trace */
 extern long mask_image_length;  /* Total number of pixels in mask image      */
 extern MPIXEL *mask_image_address;
                                 /* Pointer to image                          */
 
+/* adaptive.c */
+void Ray_Trace(long my_node);
+void Ray_Trace_Adaptively(long my_node);
+void Ray_Trace_Adaptive_Box(long outx, long outy, long boxlen);
+void Ray_Trace_Non_Adaptively(long my_node);
+void Ray_Trace_Fast_Non_Adaptively(long my_node);
+void Interpolate_Recursively(long my_node);
+void Interpolate_Recursive_Box(long outx, long outy, long boxlen);
+
+/* file.c */
+int Create_File(char filename[]);
+int Open_File(char filename[]);
+void Write_Bytes(int fd, unsigned char array[], long length);
+void Write_Shorts(int fd, unsigned char array[], long length);
+void Write_Longs(int fd, unsigned char array[], long length);
+void Read_Bytes(int fd, unsigned char array[], long length);
+void Read_Shorts(int fd, unsigned char array[], long length);
+void Read_Longs(int fd, unsigned char array[], long length);
+void Close_File(int fd);
+
+/* main.c */
+void mclock(long stoptime, long starttime, long *exectime);
+void Frame(void);
+void Render_Loop(void);
+void Error(char string[], .../*char *arg1, char *arg2, char *arg3, char *arg4, char *arg5, char *arg6, char *arg7, char *arg8*/);
+void Allocate_Image(PIXEL **address, long length);
+void Allocate_MImage(MPIXEL **address, long length);
+void Lallocate_Image(PIXEL **address, long length);
+void Store_Image(char filename[]);
+void Allocate_Shading_Table(PIXEL **address1, long length);
+void Init_Decomposition(void);
+long WriteGrayscaleTIFF(char *filename, long width, long height, long scanbytes, unsigned char *data);
+
+/* map.c */
+void Load_Map(char filename[]);
+void Allocate_Map(DENSITY **address, long length);
+void Deallocate_Map(DENSITY **address);
+
+/* normal.c */
+void Compute_Normal(void);
+void Allocate_Normal(NORMAL **address, long length);
+void Normal_Compute(void);
+void Load_Normal(char filename[]);
+void Store_Normal(char filename[]);
+void Deallocate_Normal(NORMAL **address);
+
+/* octree.c */
+void Compute_Octree(void);
+void Compute_Base(void);
+void Or_Neighbors_In_Base(void);
+void Allocate_Pyramid_Level(BYTE **address, long length);
+void Compute_Pyramid_Level(long level);
+void Load_Octree(char filename[]);
+void Store_Octree(char filename[]);
+
+/* opacity.c */
+void Compute_Opacity(void);
+void Allocate_Opacity(OPACITY **address, long length);
+void Opacity_Compute(void);
+void Load_Opacity(char filename[]);
+void Store_Opacity(char filename[]);
+void Deallocate_Opacity(OPACITY **address);
+
+/* option.c */
+void Init_Options(void);
+void Init_Opacity(void);
+void Init_Lighting(void);
+void Init_Parallelization(void);
+
+/* raytrace.c */
+void Trace_Ray(double foutx, double fouty, PIXEL *pixel_address);
+void Pre_Shade(long my_node);
+
+/* render.c */
+void Render(long my_node);
+void Observer_Transform_Light_Vector(void);
+void Compute_Observer_Transformed_Highlight_Vector(void);
+
+/* view.c */
+void Compute_Pre_View(void);
+void Select_View(double delta_angle, long axis);
+void Compute_Input_Dimensions(void);
+void Compute_Input_Unit_Vector(void);
+void Load_Transformation_Matrix(float matrix[4][4]);
+void Transform_Point(double xold, double yold, double zold, float *xnew, float *ynew, float *znew);
+void Inverse_Concatenate_Translation(float matrix[4][4], double xoffset, double yoffset, double zoffset);
+void Inverse_Concatenate_Scaling(float matrix[4][4], double xscale, double yscale, double zscale);
+void Inverse_Concatenate_Rotation(float matrix[4][4], long axis, double angle);
+void Load_Identity_Matrix(float matrix[4][4]);
+void Load_Translation_Matrix(float matrix[4][4], double xoffset, double yoffset, double zoffset);
+void Load_Scaling_Matrix(float matrix[4][4], double xscale, double yscale, double zscale);
+void Load_Rotation_Matrix(float matrix[4][4], long axis, double angle);
+void Concatenate_Transform(float composite_matrix[][4], float transformation_matrix[][4]);
+void Inverse_Concatenate_Transform(float composite_matrix[][4], float transformation_matrix[][4]);
+void Multiply_Matrices(float input_matrix1[][4], float input_matrix2[][4], float output_matrix[][4]);
+void Copy_Matrix(float input_matrix[][4], float output_matrix[][4]);
diff -Naur splash2/codes/apps/volrend/macros.H splash2-modified/codes/apps/volrend/macros.H
--- splash2/codes/apps/volrend/macros.H	1994-10-14 01:01:13.000000000 -0400
+++ splash2-modified/codes/apps/volrend/macros.H	2007-03-18 23:43:31.000000000 -0400
@@ -25,14 +25,14 @@
 #define MAX(X,Y)	((X) > (Y) ? (X) : (Y))
 #define ABS(X)		((X) > 0 ? (X) : -(X))
 #define SIGN(X)		((X) > 0 ? 1 : -1)
-#define NINT(X)		(int)((X)+0.5)				  /* flt X>=0*/
-#define	ROUNDDOWN(X)	(int)(X)				  /* flt X>=0*/
-#define	ROUNDUP(X)	((X) == (int)(X) ? (int)(X) : (int)(X)+1) /* flt X>=0*/
-#define	STEPDOWN(X)	((X) == (int)(X) ? (int)(X)-1 : (int)(X)) /* flt X>=0*/
-#define	STEPUP(X)	((int)(X)+1)				  /* flt X>=0*/
+#define NINT(X)		(long)((X)+0.5)				  /* flt X>=0*/
+#define	ROUNDDOWN(X)	(long)(X)				  /* flt X>=0*/
+#define	ROUNDUP(X)	((X) == (long)(X) ? (long)(X) : (long)(X)+1) /* flt X>=0*/
+#define	STEPDOWN(X)	((X) == (long)(X) ? (long)(X)-1 : (long)(X)) /* flt X>=0*/
+#define	STEPUP(X)	((long)(X)+1)				  /* flt X>=0*/
 #define NLONG(X)	(long)((X)+0.5)				  /* flt X>=0*/
 #define	HALF(X)		((X)>>1)				  /* int X>=0*/
-#define	FRACT(X)	((X)-(int)(X))				  /* flt X>=0*/
+#define	FRACT(X)	((X)-(long)(X))				  /* flt X>=0*/
 
 
 
diff -Naur splash2/codes/apps/volrend/main.C splash2-modified/codes/apps/volrend/main.C
--- splash2/codes/apps/volrend/main.C	1994-10-14 01:21:18.000000000 -0400
+++ splash2-modified/codes/apps/volrend/main.C	2007-03-22 00:29:21.000000000 -0400
@@ -18,17 +18,19 @@
 *                                                                        *
 *     main.c:  Starting point for rendering system.                      *
 *                                                                        *
-      Usage:  VOLREND num_processes input_file [-a] 
+      Usage:  VOLREND num_processes input_file [-a]
 
       where input_file is head for the head data set. i.e. the filename
           without a suffix.
       and the -a option enables adaptive sampling of pixels.
-      
+
 *************************************************************************/
 
 #include "incl.h"
+#include <string.h>
 #include <sys/time.h>
 #include <sys/resource.h>
+#include <limits.h>
 #include "tiffio.h"
 
 #define SH_MEM_AMT 60000000
@@ -39,36 +41,33 @@
 
 struct GlobalMemory *Global;
 
-int image_section[NI];
-int voxel_section[NM];
+long image_section[NI];
+long voxel_section[NM];
 
-int num_nodes,frame;
-int num_blocks,num_xblocks,num_yblocks;
+long num_nodes,frame;
+long num_blocks,num_xblocks,num_yblocks;
 PIXEL *image_address;
 MPIXEL *mask_image_address;
 PIXEL *image_block,*mask_image_block;
 PIXEL *shd_address;
 BOOLEAN *sbit_address;
 long shd_length;
-short image_len[NI], mask_image_len[NI];
-long image_length, mask_image_length;
-char *filename[FILENAME_STRING_SIZE];
-void Render_Loop();
+long image_len[NI], mask_image_len[NI];
+int  image_length;
+long mask_image_length;
+char filename[FILENAME_STRING_SIZE];
 
-mclock(stoptime,starttime,exectime)
-     unsigned int stoptime,starttime,*exectime;
+void mclock(long stoptime, long starttime, long *exectime)
 {
   if (stoptime < starttime)
-    *exectime = ((MAX_INT - starttime) + stoptime)/1000;
+    *exectime = ((ULONG_MAX - starttime) + stoptime)/1000;
   else
     *exectime = (stoptime - starttime)/1000;
 }
 
 
-main(argc, argv)
-     int argc;
-     char *argv[];
-{	
+int main(int argc, char *argv[])
+{
   if ((argc < 3) || (strncmp(argv[1],"-h",strlen("-h")) == 0) || (strncmp(argv[1],"-h",strlen("-H")) == 0)){
     printf("usage:  VOLREND num_processes input_file\n");
     exit(-1);
@@ -76,7 +75,7 @@
 
   MAIN_INITENV(, SH_MEM_AMT);
 
-  num_nodes = atoi(argv[1]);
+  num_nodes = atol(argv[1]);
 
   strcpy(filename,argv[2]);
 
@@ -91,31 +90,33 @@
 
   Frame();
 
+/*  if (num_nodes > 1)
+    WAIT_FOR_END(num_nodes-1);*/
   if (num_nodes > 1)
-    WAIT_FOR_END(num_nodes-1);
+    WAIT_FOR_END(num_nodes);
   MAIN_END;
-}	
+}
 
 
-Frame()
+void Frame()
 {
-  unsigned int starttime,stoptime,exectime,i;
+  long starttime,stoptime,exectime,i;
 
   Init_Options();
-  
-  printf("*****Entering init_decomposition with num_nodes = %d\n",num_nodes);
+
+  printf("*****Entering init_decomposition with num_nodes = %ld\n",num_nodes);
   fflush(stdout);
 
   Init_Decomposition();
 
-  printf("*****Exited init_decomposition with num_nodes = %d\n",num_nodes);
+  printf("*****Exited init_decomposition with num_nodes = %ld\n",num_nodes);
   fflush(stdout);
 
-  
+
 
   Global = (struct GlobalMemory *)NU_MALLOC(sizeof(struct GlobalMemory),0);
-  BARINIT(Global->SlaveBarrier);
-  BARINIT(Global->TimeBarrier);
+  BARINIT(Global->SlaveBarrier, num_nodes);
+  BARINIT(Global->TimeBarrier, num_nodes);
   LOCKINIT(Global->IndexLock);
   LOCKINIT(Global->CountLock);
   ALOCKINIT(Global->QLock,MAX_NUMPROC+1);
@@ -126,7 +127,7 @@
   Load_Map(filename);
   CLOCK(stoptime);
   mclock(stoptime,starttime,&exectime);
-  printf("wall clock execution time to load map:  %u ms\n", exectime);
+  printf("wall clock execution time to load map:  %lu ms\n", exectime);
 #endif
 
   CLOCK(starttime);
@@ -140,7 +141,7 @@
 #endif
   CLOCK(stoptime);
   mclock(stoptime,starttime,&exectime);
-  printf("wall clock execution time to compute normal:  %u ms\n", exectime);
+  printf("wall clock execution time to compute normal:  %lu ms\n", exectime);
 
   CLOCK(starttime);
 #ifndef RENDER_ONLY
@@ -153,11 +154,11 @@
 #endif
   CLOCK(stoptime);
   mclock(stoptime,starttime,&exectime);
-  printf("wall clock execution time to compute opacity:  %u ms\n", exectime);
+  printf("wall clock execution time to compute opacity:  %lu ms\n", exectime);
 
   Compute_Pre_View();
   shd_length = LOOKUP_SIZE;
-  Allocate_Shading_Table(&shd_address,&sbit_address,shd_length);
+  Allocate_Shading_Table(&shd_address,shd_length);
   /* allocate space for image */
   image_len[X] = frust_len;
   image_len[Y] = frust_len;
@@ -190,13 +191,14 @@
 #endif
   CLOCK(stoptime);
   mclock(stoptime,starttime,&exectime);
-  printf("wall clock execution time to compute octree:  %u ms\n", exectime);
+  printf("wall clock execution time to compute octree:  %lu ms\n", exectime);
 
 #ifdef PREPROCESS
   return;
 #endif
 
   if (adaptive) {
+    printf("1.\n");
     for (i=0; i<NI; i++) {
       mask_image_len[i] = image_len[i];
     }
@@ -206,6 +208,7 @@
       mask_image_block = (PIXEL *)mask_image_address;
     else
       Lallocate_Image(&mask_image_block, block_xlen*block_ylen);
+    printf("2.\n");
   }
 
 #ifndef RENDER_ONLY
@@ -217,35 +220,32 @@
   printf("\nRendering...\n");
   printf("node\tframe\ttime\titime\trays\thrays\tsamples trilirped\n");
 
-  for (i=1; i<num_nodes; i++) CREATE(Render_Loop)
-
-  Render_Loop();
+  CREATE(Render_Loop, num_nodes);
 }
 
 
 void Render_Loop()
 {
-  int step,i,dim,pid;
+  long step,i;
   PIXEL *local_image_address;
   MPIXEL *local_mask_image_address;
-  PIXEL *local_shd_address;
-  char outfile[FILENAME_STRING_SIZE],cmd[FILENAME_STRING_SIZE];
-  int image_partition,mask_image_partition,shd_table_partition;
+  char outfile[FILENAME_STRING_SIZE];
+  long image_partition,mask_image_partition;
   float inv_num_nodes;
-  int my_node;
-  int zz;
-  int zzz;
-  PIXEL *p;
+  long my_node;
 
   LOCK(Global->IndexLock);
   my_node = Global->Index++;
   UNLOCK(Global->IndexLock);
   my_node = my_node%num_nodes;
 
-/*  POSSIBLE ENHANCEMENT:  Here's where one might bind the process to a 
-    processor, if one wanted to. 
+  BARINCLUDE(Global->TimeBarrier);
+  BARINCLUDE(Global->SlaveBarrier);
+
+/*  POSSIBLE ENHANCEMENT:  Here's where one might bind the process to a
+    processor, if one wanted to.
 */
-    
+
   inv_num_nodes = 1.0/(float)num_nodes;
   image_partition = ROUNDUP(image_length*inv_num_nodes);
   mask_image_partition = ROUNDUP(mask_image_length*inv_num_nodes);
@@ -256,7 +256,7 @@
 
     for (step=0; step<ROTATE_STEPS; step++) { /* do rotation sequence */
 
-/*  POSSIBLE ENHANCEMENT:  Here is where one might reset statistics, if 
+/*  POSSIBLE ENHANCEMENT:  Here is where one might reset statistics, if
     		one wanted to.
 */
 
@@ -271,18 +271,18 @@
       if (my_node == num_nodes-1) {
 	for (i=image_partition*my_node; i<image_length; i++)
 	  *local_image_address++ = background;
-	if (adaptive) 
+	if (adaptive)
 	  for (i=mask_image_partition*my_node; i<mask_image_length; i++)
 	    *local_mask_image_address++ = NULL_PIXEL;
       }
       else {
 	for (i=0; i<image_partition; i++)
 	  *local_image_address++ = background;
-	if (adaptive) 
+	if (adaptive)
 	  for (i=0; i<mask_image_partition; i++)
 	    *local_mask_image_address++ = NULL_PIXEL;
       }
-      
+
       if (my_node == ROOT) {
 #ifdef DIM
 	Select_View((float)STEP_SIZE, dim);
@@ -302,24 +302,24 @@
       if (my_node == ROOT) {
 	if (ROTATE_STEPS > 1) {
 #ifdef DIM
-	  sprintf(outfile, "%s_%d",filename, 1000+dim*ROTATE_STEPS+step);
+	  sprintf(outfile, "%s_%ld",filename, 1000+dim*ROTATE_STEPS+step);
 #else
-	  sprintf(outfile, "%s_%d.tiff",filename, 1000+step);
+	  sprintf(outfile, "%s_%ld.tiff",filename, 1000+step);
 #endif
-/*	  Store_Image(outfile); 
+/*	  Store_Image(outfile);
           p = image_address;
           for (zz = 0;zz < image_length;zz++) {
-            tiff_image[zz] = (int) ((*p)*256*256*256 + (*p)*256*256 +
+            tiff_image[zz] = (long) ((*p)*256*256*256 + (*p)*256*256 +
 				    (*p)*256 + (*p));
 	    p++;
           }
 tiff_save_rgba(outfile,tiff_image,image_len[X],image_len[Y]);  */
 WriteGrayscaleTIFF(outfile, image_len[X],image_len[Y],image_len[X], image_address);
 	} else {
-/*	  Store_Image(filename);  
+/*	  Store_Image(filename);
 	  p = image_address;
           for (zz = 0;zz < image_length;zz++) {
-            tiff_image[zz] = (int) ((*p)*256*256*256 + (*p)*256*256 +
+            tiff_image[zz] = (long) ((*p)*256*256*256 + (*p)*256*256 +
 				    (*p)*256 + (*p));
 	    p++;
           }
@@ -334,51 +334,61 @@
 #endif
 }
 
-
-Error(string,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8)
-     char string[], *arg1, *arg2, *arg3, *arg4, *arg5, *arg6, *arg7, *arg8;
+#if 0
+void Error(char string[], char *arg1, char *arg2, char *arg3, char *arg4, char *arg5, char *arg6, char *arg7, char *arg8)
 {
   fprintf(stderr,string,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
   exit(1);
 }
+#else
+void Error(char string[], ...)
+{
+	va_list	ap;
+	char	*arg1 = NULL, *arg2 = NULL, *arg3 = NULL, *arg4 = NULL, *arg5 = NULL, *arg6 = NULL, *arg7 = NULL, *arg8 = NULL;
 
+	va_start(ap, string);
+	arg1 = va_arg(ap, char *);
+	arg1 = va_arg(ap, char *);
+	arg1 = va_arg(ap, char *);
+	arg1 = va_arg(ap, char *);
+	arg1 = va_arg(ap, char *);
+	arg1 = va_arg(ap, char *);
+	arg1 = va_arg(ap, char *);
+	arg1 = va_arg(ap, char *);
+	va_end(ap);
+	fprintf(stderr,string,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
+	exit(1);
+}
+#endif
 
-Allocate_Image(address, length)
-     PIXEL **address;
-     long length;
+void Allocate_Image(PIXEL **address, long length)
 {
-  unsigned int i,j,size,type_per_page,count,block;
-  unsigned int p,numbytes;
+  long i;
 
-  printf("    Allocating image of %ld bytes...\n",
-	 length*sizeof(PIXEL));
+  printf("    Allocating image of %ld bytes...\n", length*sizeof(PIXEL));
 
   *address = (PIXEL *)NU_MALLOC(length*sizeof(PIXEL),0);
 
   if (*address == NULL)
-    Error("    No space available for image.\n");
+	  Error("    No space available for image.\n", NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
 
   for (i=0; i<length; i++) *(*address+i) = 0;
 
 }
 
 
-Allocate_MImage(address, length)
-     MPIXEL **address;
-     long length;
+void Allocate_MImage(MPIXEL **address, long length)
 {
-  unsigned int i,j,size,type_per_page,count,block;
-  unsigned int p,numbytes;
+  long i;
 
-  printf("    Allocating image of %ld bytes...\n",
-	 length*sizeof(MPIXEL));
+  printf("    Allocating image of %ld bytes...\n", length*sizeof(MPIXEL));
 
   *address = (MPIXEL *)NU_MALLOC(length*sizeof(MPIXEL),0);
 
   if (*address == NULL)
     Error("    No space available for image.\n");
 
-/*  POSSIBLE ENHANCEMENT:  Here's where one might distribute the 
+/*  POSSIBLE ENHANCEMENT:  Here's where one might distribute the
     opacity map among physical memories if one wanted to.
 */
 
@@ -387,16 +397,9 @@
 }
 
 
-Lallocate_Image(address, length)
-     PIXEL **address;
-     long length;
-{
-  char *calloc();
-  int i;
-  unsigned int p,numbytes;
-
-  printf("    Allocating image of %ld bytes...\n",
-	 length*sizeof(PIXEL));
+void Lallocate_Image(PIXEL **address, long length)
+{
+  printf("    Allocating image of %ld bytes...\n", length*sizeof(PIXEL));
   *address = (PIXEL *)calloc(length,sizeof(PIXEL));
   if (*address == NULL)
     Error("    No space available for image.\n");
@@ -404,11 +407,10 @@
 }
 
 
-Store_Image(filename)
-     char filename[];
+void Store_Image(char filename[])
 {
   char local_filename[FILENAME_STRING_SIZE];
-  int fd;
+  long fd;
   short pix_version;
   short local_image_len[NI+1]; /* dimension larger than NI for backwards     */
                                /* compatibility of .pix file with no color   */
@@ -421,23 +423,20 @@
   strcpy(local_filename,filename);
   strcat(local_filename,".pix");
   fd = Create_File(local_filename);
-  Write_Shorts(fd,&pix_version,(long)sizeof(pix_version));
-  
-  Write_Shorts(fd,local_image_len,(long)sizeof(local_image_len));
-  Write_Longs(fd,&image_length,(long)sizeof(image_length));
-  
+  Write_Shorts(fd,(unsigned char *)&pix_version,(long)sizeof(pix_version));
+
+  Write_Shorts(fd,(unsigned char *)local_image_len,(long)sizeof(local_image_len));
+  Write_Longs(fd,(unsigned char *)&image_length,(long)sizeof(image_length));
+
   Write_Bytes(fd,image_address,(long)(image_length*sizeof(PIXEL)));
   Close_File(fd);
 }
 
 
-Allocate_Shading_Table(address1,address2,length)
-     PIXEL **address1,**address2;
-     long length;
-{
-  unsigned int i,size,type_per_page;
-  unsigned int p,numbytes;
-  
+void Allocate_Shading_Table(PIXEL **address1, long length)
+{
+  long i;
+
   printf("    Allocating shade lookup table of %ld bytes...\n",
 	 length*sizeof(PIXEL));
 
@@ -449,7 +448,7 @@
   if (*address1 == NULL)
     Error("    No space available for table.\n");
 
-/*  POSSIBLE ENHANCEMENT:  Here's where one might distribute the 
+/*  POSSIBLE ENHANCEMENT:  Here's where one might distribute the
     shading table among physical memories if one wanted to.
 */
 
@@ -458,11 +457,11 @@
 }
 
 
-Init_Decomposition()
+void Init_Decomposition()
 {
-  int factors[MAX_NUMPROC];
+  long factors[MAX_NUMPROC];
   double processors,newfactor;
-  int i,sq,cu,maxcu,count;
+  long i,sq,cu,maxcu,count;
 
   /* figure out what to divide dimensions of image and volume by to */
   /* partition data and computation to processors                   */
@@ -476,8 +475,8 @@
   else {
     count = 1;
     processors = (double)num_nodes;
-    sq = (int)sqrt(processors);
-    cu = (int)pow(processors,1.0/3.0);
+    sq = (long)sqrt(processors);
+    cu = (long)pow(processors,1.0/3.0);
     factors[0] = 1;
 
     for (i=2; i<sq; i++) {
@@ -493,7 +492,7 @@
     image_section[X] = factors[count];
     image_section[Y] = num_nodes/factors[count];
 
-    sq = (int)sqrt(newfactor);
+    sq = (long)sqrt(newfactor);
     count = 1;
 
     for (i=2; i<sq; i++) {
@@ -503,7 +502,7 @@
     count--;
     voxel_section[X] = MIN(factors[count],maxcu);
     voxel_section[Y] = MAX(factors[count],maxcu);
-    voxel_section[Z] = (int)newfactor/factors[count];
+    voxel_section[Z] = (long)newfactor/factors[count];
   }
 }
 
@@ -517,23 +516,18 @@
  * Return value is 1 for success, 0 for failure.
  */
 
-int
-WriteGrayscaleTIFF(filename, width, height, scanbytes, data)
-char *filename;         /* file to write to */
-int width, height;      /* size of image */
-int scanbytes;          /* length of each scanline in bytes */
-unsigned char *data;    /* image data */
+long WriteGrayscaleTIFF(char *filename, long width, long height, long scanbytes, unsigned char *data)
 {
-    unsigned long y;
+    long y;
     double factor;
-    int c;
-    unsigned short cmap[256];           /* output color map */
+    long c;
+    unsigned long cmap[256];           /* output color map */
     TIFF *outimage;                     /* TIFF image handle */
 
     /* create a grayscale ramp for the output color map */
     factor = (double)((1 << 16) - 1) / (double)((1 << 8) - 1);
     for (c = 0; c < 256; c++)
-        cmap[c] = (int)(c * factor);
+        cmap[c] = (long)(c * factor);
 
     /* open and initialize output file */
     if ((outimage = TIFFOpen(filename, "w")) == NULL)
@@ -561,6 +555,3 @@
     TIFFClose(outimage);
     return(1);
 }
-
-
-    
diff -Naur splash2/codes/apps/volrend/makefile splash2-modified/codes/apps/volrend/makefile
--- splash2/codes/apps/volrend/makefile	1994-10-14 01:22:14.000000000 -0400
+++ splash2-modified/codes/apps/volrend/makefile	1969-12-31 19:00:00.000000000 -0500
@@ -1,42 +0,0 @@
-TARGET = VOLREND
-OBJS = main.o file.o option.o map.o normal.o opacity.o octree.o view.o \
-       render.o adaptive.o raytrace.o
-CFLAGS = -O2 -Olimit 1500 -DFLIP -DPRESHD $(CDEBUG) -Ilibtiff
-CCOPTS = -S -I -I$(SIMDIR) -I$(IDIR) -I/usr/include -DAUG $(CFLAGS)
-LDFLAGS = -O2 -lm -Ilibtiff -Llibtiff -ltiff
-MACROS = ../../null_macros/c.m4.null
-
-x = *
-
-$(TARGET): $(OBJS)
-	cc $(OBJS) $(CFLAGS) -o $(TARGET) $(LDFLAGS)
-
-.SUFFIXES:
-.SUFFIXES:	.o .c .C .h .H
-
-.H.h:	
-	m4 ${MACROS} $*.H > $*.h
-
-.C.c:	
-	m4 $(MACROS) $*.C > $*.c
-
-.c.o:	
-	cc -c $(CFLAGS) $*.c
-
-.C.o:	
-	m4 $(MACROS) $*.C > $*.c
-	cc -c $(CFLAGS) $*.c
-
-main.c:	main.C incl.h anl.h
-file.c:	file.C incl.h
-option.c: option.C incl.h
-map.c: map.C incl.h
-normal.c: normal.C incl.h anl.h address.h
-opacity.c: opacity.C incl.h anl.h
-octree.c: octree.C incl.h anl.h
-view.c:	view.C incl.h
-render.c: render.C incl.h
-adaptive.c: adaptive.C incl.h anl.h
-raytrace.c: raytrace.C incl.h address.h
-
-incl.h:	user_options.h const.h my_types.h global.h macros.h address.h
diff -Naur splash2/codes/apps/volrend/Makefile splash2-modified/codes/apps/volrend/Makefile
--- splash2/codes/apps/volrend/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ splash2-modified/codes/apps/volrend/Makefile	2007-03-21 21:27:05.000000000 -0400
@@ -0,0 +1,21 @@
+TARGET = VOLREND
+OBJS = adaptive.o file.o main.o map.o normal.o octree.o opacity.o option.o raytrace.o render.o view.o
+
+include ../../Makefile.config
+
+CFLAGS := $(CFLAGS) -I./libtiff
+LDFLAGS := -L./libtiff $(LDFLAGS) -ltiff
+
+main.c:	main.C incl.h anl.h
+file.c:	file.C incl.h
+option.c: option.C incl.h
+map.c: map.C incl.h
+normal.c: normal.C incl.h anl.h address.h
+opacity.c: opacity.C incl.h anl.h
+octree.c: octree.C incl.h anl.h
+view.c:	view.C incl.h
+render.c: render.C incl.h
+adaptive.c: adaptive.C incl.h anl.h
+raytrace.c: raytrace.C incl.h address.h
+
+incl.h:	user_options.h const.h my_types.h global.h macros.h address.h
diff -Naur splash2/codes/apps/volrend/map.C splash2-modified/codes/apps/volrend/map.C
--- splash2/codes/apps/volrend/map.C	1994-10-14 01:01:13.000000000 -0400
+++ splash2-modified/codes/apps/volrend/map.C	2007-03-21 23:16:50.000000000 -0400
@@ -20,6 +20,7 @@
 *                                                                             *
 ******************************************************************************/
 
+#include <string.h>
 #include "incl.h"
 
 /* The following declarations show the layout of the .den file.              */
@@ -45,7 +46,7 @@
 short map_warps;		/* Number of warps since extraction          */
 				/*   (0 = none)                              */
 
-long map_length;		/* Total number of densities in map          */
+int map_length;		/* Total number of densities in map          */
 				/*   (= product of lens)                     */
 DENSITY *map_address;		/* Pointer to map                            */
 
@@ -54,7 +55,7 @@
 EXTERN_ENV
 
 
-Load_Map(filename)
+void Load_Map(filename)
      char filename[];
 {
   char local_filename[FILENAME_STRING_SIZE];
@@ -63,40 +64,39 @@
   strcpy(local_filename,filename);
   strcat(local_filename,".den");
   fd = Open_File(local_filename);
-  
-  Read_Shorts(fd,&map_version, (long)sizeof(map_version));
-  if (map_version != MAP_CUR_VERSION) 
+
+  Read_Shorts(fd,(unsigned char *)&map_version, (long)sizeof(map_version));
+  if (map_version != MAP_CUR_VERSION)
     Error("    Can't load version %d file\n",map_version);
-  
-  Read_Shorts(fd,orig_min,(long)sizeof(orig_min));
-  Read_Shorts(fd,orig_max,(long)sizeof(orig_max));
-  Read_Shorts(fd,orig_len,(long)sizeof(orig_len));
-  
-  Read_Shorts(fd,extr_min,(long)sizeof(extr_min));
-  Read_Shorts(fd,extr_max,(long)sizeof(extr_max));
-  Read_Shorts(fd,extr_len,(long)sizeof(extr_len));
-  
-  Read_Shorts(fd,map_min,(long)sizeof(map_min));
-  Read_Shorts(fd,map_max,(long)sizeof(map_max));
-  Read_Shorts(fd,map_len,(long)sizeof(map_len));
-  
-  Read_Shorts(fd,&map_warps,(long)sizeof(map_warps));
-  Read_Longs(fd,&map_length,(long)sizeof(map_length));
-  
+
+  Read_Shorts(fd,(unsigned char *)orig_min,(long)sizeof(orig_min));
+  Read_Shorts(fd,(unsigned char *)orig_max,(long)sizeof(orig_max));
+  Read_Shorts(fd,(unsigned char *)orig_len,(long)sizeof(orig_len));
+
+  Read_Shorts(fd,(unsigned char *)extr_min,(long)sizeof(extr_min));
+  Read_Shorts(fd,(unsigned char *)extr_max,(long)sizeof(extr_max));
+  Read_Shorts(fd,(unsigned char *)extr_len,(long)sizeof(extr_len));
+
+  Read_Shorts(fd,(unsigned char *)map_min,(long)sizeof(map_min));
+  Read_Shorts(fd,(unsigned char *)map_max,(long)sizeof(map_max));
+  Read_Shorts(fd,(unsigned char *)map_len,(long)sizeof(map_len));
+
+  Read_Shorts(fd,(unsigned char *)&map_warps,(long)sizeof(map_warps));
+  Read_Longs(fd,(unsigned char *)&map_length,(long)sizeof(map_length));
+
   Allocate_Map(&map_address,map_length);
-  
+
   printf("    Loading map from .den file...\n");
-  Read_Bytes(fd,map_address,(long)(map_length*sizeof(DENSITY)));
+  Read_Bytes(fd,(unsigned char *)map_address,(long)(map_length*sizeof(DENSITY)));
   Close_File(fd);
 }
 
 
-Allocate_Map(address, length)
+void Allocate_Map(address, length)
      DENSITY **address;
      long length;
 {
-  int i;
-  unsigned int p,numbytes;
+  long i;
 
   printf("    Allocating density map of %ld bytes...\n",
 	 length*sizeof(DENSITY));
@@ -111,7 +111,7 @@
 }
 
 
-Deallocate_Map(address)
+void Deallocate_Map(address)
 DENSITY **address;
 {
   printf("    Deallocating density map...\n");
diff -Naur splash2/codes/apps/volrend/my_types.H splash2-modified/codes/apps/volrend/my_types.H
--- splash2/codes/apps/volrend/my_types.H	1994-10-14 01:01:13.000000000 -0400
+++ splash2-modified/codes/apps/volrend/my_types.H	2007-03-19 22:55:00.000000000 -0400
@@ -26,7 +26,7 @@
 typedef unsigned char BYTE;		/*   general purpose byte            */
 typedef signed short NORMAL;            /*   density normal                  */
 typedef unsigned char PIXEL;		/*   pixel or voxel color            */
-typedef unsigned char MPIXEL;	        /*   volatile pixel or voxel color; 
+typedef unsigned char MPIXEL;	        /*   volatile pixel or voxel color;
                                                make volatile on SGIs   */
 typedef unsigned char OPACITY;          /*   voxel opacity                   */
 typedef unsigned short BOOLEAN;		/*   boolean flag                    */
diff -Naur splash2/codes/apps/volrend/normal.C splash2-modified/codes/apps/volrend/normal.C
--- splash2/codes/apps/volrend/normal.C	1994-10-17 21:05:35.000000000 -0400
+++ splash2-modified/codes/apps/volrend/normal.C	2007-03-19 23:03:44.000000000 -0400
@@ -21,6 +21,7 @@
 *                                                                             *
 ******************************************************************************/
 
+#include <string.h>
 #include "incl.h"
 
 /* The following declarations show the layout of the .norm file.             */
@@ -33,22 +34,21 @@
 
 short norm_len[NM];		/* Size of this normal map                   */
 
-long norm_length;		/* Total number of normals in map            */
+int norm_length;		/* Total number of normals in map            */
 				/*   (= NM * product of lens)                */
 NORMAL *norm_address;		/* Pointer to normal map                     */
 
 /* End of layout of .norm file.                                              */
 
 float nmag_epsilon;
-void Normal_Compute();
 
 EXTERN_ENV
 
 #include "anl.h"
 
-Compute_Normal()
+void Compute_Normal()
 {
-  int i;
+  long i;
 
   for (i=0; i<NM; i++) {
     norm_len[i] = map_len[i]-2*INSET;
@@ -70,12 +70,11 @@
 }
 
 
-Allocate_Normal(address, length)
+void Allocate_Normal(address, length)
      NORMAL **address;
      long length;
 {
-  unsigned int i,j,size,type_per_page,count,block;
-  unsigned int p,numbytes;
+  long i;
 
   printf("    Allocating normal map of %ld bytes...\n",
 	 length*sizeof(NORMAL));
@@ -85,7 +84,7 @@
   if (*address == NULL)
     Error("    No space available for map.\n");
 
-/*  POSSIBLE ENHANCEMENT:  Here's where one might distribute the 
+/*  POSSIBLE ENHANCEMENT:  Here's where one might distribute the
     normal map among physical memories if one wanted to.
 */
 
@@ -96,30 +95,30 @@
 
 void Normal_Compute()
 {
-  int inx,iny,inz;	/* Voxel location in object space            */
-  int outx,outy,outz;	/* Loop indices in image space               */
+  long inx,iny,inz;	/* Voxel location in object space            */
+  long outx,outy,outz;	/* Loop indices in image space               */
   NORMAL *local_norm_address;
   double inv_mag_shift,magnitude,norm_lshift,grd_x,grd_y,grd_z;
-  int nmap_partition,zstart,zstop;
-  int xnorm,ynorm,znorm,norm0;
-  int num_xqueue,num_yqueue,num_zqueue,num_queue;
-  int xstart,xstop,ystart,ystop;
-  int my_node;
+  long zstart,zstop;
+  long xnorm,ynorm,znorm,norm0;
+  long num_xqueue,num_yqueue,num_zqueue,num_queue;
+  long xstart,xstop,ystart,ystop;
+  long my_node;
 
   LOCK(Global->IndexLock);
   my_node = Global->Index++;
   UNLOCK(Global->IndexLock);
   my_node = my_node%num_nodes;
 
-/*  POSSIBLE ENHANCEMENT:  Here's where one might bind the process to a 
-    processor, if one wanted to. 
+/*  POSSIBLE ENHANCEMENT:  Here's where one might bind the process to a
+    processor, if one wanted to.
 */
 
   /* use these to save work in loop */
-  norm0 = (int)(NORM_LSHIFT);
+  norm0 = (long)(NORM_LSHIFT);
   norm_lshift = -NORM_LSHIFT;
   nmag_epsilon = magnitude_epsilon;
-  
+
   num_xqueue = ROUNDUP((float)norm_len[X]/(float)voxel_section[X]);
   num_yqueue = ROUNDUP((float)norm_len[Y]/(float)voxel_section[Y]);
   num_zqueue = ROUNDUP((float)norm_len[Z]/(float)voxel_section[Z]);
@@ -143,28 +142,28 @@
   for (outz=zstart; outz<zstop; outz++) {
     for (outy=ystart; outy<ystop; outy++) {
       for (outx=xstart; outx<xstop; outx++) {
-	
+
 	inx = INSET + outx;
 	iny = INSET + outy;
 	inz = INSET + outz;
-	
+
 	/* Compute voxel gradient assuming gradient operator is 1x3     */
-	grd_x = (double)((int)MAP(inz,iny,inx+1) - (int)MAP(inz,iny,inx-1));
-	grd_y = (double)((int)MAP(inz,iny+1,inx) - (int)MAP(inz,iny-1,inx));
-	grd_z = (double)((int)MAP(inz+1,iny,inx) - (int)MAP(inz-1,iny,inx));
+	grd_x = (double)((long)MAP(inz,iny,inx+1) - (long)MAP(inz,iny,inx-1));
+	grd_y = (double)((long)MAP(inz,iny+1,inx) - (long)MAP(inz,iny-1,inx));
+	grd_z = (double)((long)MAP(inz+1,iny,inx) - (long)MAP(inz-1,iny,inx));
 
 	/* Compute (magnitude*grd_divisor)**2 of gradient               */
 	/* Reduce (magnitude*grd_divisor)**2 to magnitude*grd_divisor   */
 	/* Reduce magnitude*grd_divisor to magnitude                    */
-	magnitude = grd_x*grd_x+grd_y*grd_y+grd_z*grd_z; 
+	magnitude = grd_x*grd_x+grd_y*grd_y+grd_z*grd_z;
 
 	local_norm_address = NORM_ADDRESS(outz,outy,outx,X);
 	if (magnitude > SMALL) {
-	  inv_mag_shift = norm_lshift/sqrt(magnitude); 
+	  inv_mag_shift = norm_lshift/sqrt(magnitude);
 	  if (grd_x*inv_mag_shift > 0.0) xnorm = 1;
 	  else xnorm = 0;
-	  ynorm = (int)(grd_y*inv_mag_shift);
-	  znorm = (int)(grd_z*inv_mag_shift);
+	  ynorm = (long)(grd_y*inv_mag_shift);
+	  znorm = (long)(grd_z*inv_mag_shift);
 	  *local_norm_address = TADDR(znorm,ynorm,xnorm);
 	}
 	else {
@@ -180,7 +179,7 @@
 }
 
 
-Load_Normal(filename)
+void Load_Normal(filename)
      char filename[];
 {
   char local_filename[FILENAME_STRING_SIZE];
@@ -188,26 +187,26 @@
 
   strcpy(local_filename,filename);
   strcat(local_filename,".norm");
-  fd = Open_File(local_filename); 
-  
-  Read_Shorts(fd,&norm_version, (long)sizeof(norm_version));
-  if (norm_version != NORM_CUR_VERSION) 
+  fd = Open_File(local_filename);
+
+  Read_Shorts(fd,(unsigned char *)&norm_version, (long)sizeof(norm_version));
+  if (norm_version != NORM_CUR_VERSION)
     Error("    Can't load version %d file\n",norm_version);
-  
-  Read_Shorts(fd,norm_len,(long)sizeof(map_len));
-  
-  Read_Longs(fd,&norm_length,(long)sizeof(norm_length));
-  
+
+  Read_Shorts(fd,(unsigned char *)norm_len,(long)sizeof(map_len));
+
+  Read_Longs(fd,(unsigned char *)&norm_length,(long)sizeof(norm_length));
+
   Allocate_Normal(&norm_address,norm_length);
-  
+
   printf("    Loading normal map from .norm file...\n");
-  Read_Shorts(fd,norm_address,(long)(norm_length*sizeof(NORMAL)));
+  Read_Shorts(fd,(unsigned char *)norm_address,(long)(norm_length*sizeof(NORMAL)));
   fflush(stdout);
   Close_File(fd);
 }
 
 
-Store_Normal(filename)
+void Store_Normal(filename)
 char filename[];
 {
   char local_filename[FILENAME_STRING_SIZE];
@@ -215,24 +214,24 @@
 
   strcpy(local_filename,filename);
   strcat(local_filename,".norm");
-  fd = Create_File(local_filename); 
+  fd = Create_File(local_filename);
 
   norm_version = NORM_CUR_VERSION;
   strcpy(local_filename,filename);
   strcat(local_filename,".norm");
   fd = Create_File(local_filename);
-  Write_Shorts(fd,&norm_version,(long)sizeof(norm_version));
-  
-  Write_Shorts(fd,norm_len,(long)sizeof(norm_len));
-  Write_Longs(fd,&norm_length,(long)sizeof(norm_length));
-  
+  Write_Shorts(fd,(unsigned char *)&norm_version,(long)sizeof(norm_version));
+
+  Write_Shorts(fd,(unsigned char *)norm_len,(long)sizeof(norm_len));
+  Write_Longs(fd,(unsigned char *)&norm_length,(long)sizeof(norm_length));
+
   printf("    Storing normal map into .norm file...\n");
-  Write_Shorts(fd,norm_address,(long)(norm_length*sizeof(NORMAL)));
+  Write_Shorts(fd,(unsigned char *)norm_address,(long)(norm_length*sizeof(NORMAL)));
   Close_File(fd);
 }
 
 
-Deallocate_Normal(address)
+void Deallocate_Normal(address)
 NORMAL **address;
 {
   printf("    Deallocating normal map...\n");
@@ -241,4 +240,3 @@
 
   *address = NULL;
 }
-
diff -Naur splash2/codes/apps/volrend/octree.C splash2-modified/codes/apps/volrend/octree.C
--- splash2/codes/apps/volrend/octree.C	1994-10-17 21:05:57.000000000 -0400
+++ splash2-modified/codes/apps/volrend/octree.C	2007-03-22 01:42:13.000000000 -0400
@@ -20,6 +20,7 @@
 *                                                                             *
 ******************************************************************************/
 
+#include <string.h>
 #include "incl.h"
 
 #define WRITE_PYR(IBIT,ILEVEL,IZ,IY,IX)\
@@ -35,12 +36,12 @@
 short pyr_version;		/* Version of this .pyr file                 */
 
 short pyr_levels;		/* Number of levels in this pyramid          */
-				
+
 short pyr_len[MAX_PYRLEVEL+1][NM];	/* Number of voxels on each level    */
 short pyr_voxlen[MAX_PYRLEVEL+1][NM];	/* Size of voxels on each level      */
 
-long pyr_length[MAX_PYRLEVEL+1];/* Total number of bytes on this level       */
-				/*   (= (int)((product of lens+7)/8))        */
+int pyr_length[MAX_PYRLEVEL+1];/* Total number of bytes on this level       */
+				/*   (= (long)((product of lens+7)/8))        */
 BYTE *pyr_address[MAX_PYRLEVEL+1];/* Pointer to binary pyramid               */
 				/*   (only pyr_levels sets of lens, lengths, */
 				/*    and 3-D arrays are written to file)    */
@@ -64,17 +65,14 @@
      pyr_offset2;		/* Bit offset of bit within byte             */
 BYTE *pyr_address2;		/* Pointer to byte containing bit            */
 
-void Compute_Base();
-void Or_Neighbors_In_Base();
-
 EXTERN_ENV
 
 #include "anl.h"
 
-Compute_Octree()
+void Compute_Octree()
 {
-  int level,max_len;
-  int i;
+  long level,max_len;
+  long i;
   max_len = 0;
   for (i=0; i<NM; i++) {
     max_len = MAX(max_len,opc_len[i]);
@@ -84,7 +82,7 @@
     pyr_levels++;
   printf("    Computing binary pyramid of %d levels...\n",
 	 pyr_levels);
-  
+
   for (i=0; i<NM; i++) {
     pyr_len[0][i] = opc_len[i];
     pyr_voxlen[0][i] = 1;
@@ -146,19 +144,19 @@
 
 void Compute_Base()
 {
-  int outx, outy, outz, i;	
-  int pmap_partition,zstart,zstop;
-  int num_xqueue,num_yqueue,num_zqueue,num_queue;
-  int xstart,xstop,ystart,ystop;
-  int my_node;
+  long outx, outy, outz;
+  long zstart,zstop;
+  long num_xqueue,num_yqueue,num_zqueue,num_queue;
+  long xstart,xstop,ystart,ystop;
+  long my_node;
 
   LOCK(Global->IndexLock);
   my_node = Global->Index++;
   UNLOCK(Global->IndexLock);
   my_node = my_node%num_nodes;
 
-/*  POSSIBLE ENHANCEMENT:  Here's where one might bind the process to a 
-    processor, if one wanted to. 
+/*  POSSIBLE ENHANCEMENT:  Here's where one might bind the process to a
+    processor, if one wanted to.
 */
 
   num_xqueue = ROUNDUP((float)pyr_len[0][X]/(float)voxel_section[X]);
@@ -209,22 +207,21 @@
 
 void Or_Neighbors_In_Base()
 {
-  int outx,outy,outz;	/* Loop indices in image space               */
-  int outx_plus_one,outy_plus_one,outz_plus_one;
-  int i;
+  long outx,outy,outz;	/* Loop indices in image space               */
+  long outx_plus_one,outy_plus_one,outz_plus_one;
   BOOLEAN bit;
-  int pmap_partition,zstart,zstop;
-  int my_node;
+  long pmap_partition,zstart,zstop;
+  long my_node;
 
   LOCK(Global->IndexLock);
   my_node = Global->Index++;
   UNLOCK(Global->IndexLock);
   my_node = my_node%num_nodes;
 
-/*  POSSIBLE ENHANCEMENT:  Here's where one might bind the process to a 
-    processor, if one wanted to. 
+/*  POSSIBLE ENHANCEMENT:  Here's where one might bind the process to a
+    processor, if one wanted to.
 */
-    
+
   /* assumed for now that z direction has enough parallelism */
   pmap_partition = ROUNDUP((double)pyr_len[0][Z]/(double)num_nodes);
   zstart = pmap_partition * my_node;
@@ -246,7 +243,7 @@
       outy_plus_one = MIN(outy+1,pyr_len[0][Y]-1);
       for (outx=0; outx<pyr_len[0][X]; outx++) {
 	outx_plus_one = MIN(outx+1,pyr_len[0][X]-1);
-	
+
 	bit = PYR(0,outz,outy,outx);
 	bit |= PYR(0,outz,outy,outx_plus_one);
 	bit |= PYR(0,outz,outy_plus_one,outx);
@@ -255,7 +252,7 @@
 	bit |= PYR(0,outz_plus_one,outy,outx_plus_one);
 	bit |= PYR(0,outz_plus_one,outy_plus_one,outx);
 	bit |= PYR(0,outz_plus_one,outy_plus_one,outx_plus_one);
-	
+
 	WRITE_PYR(bit,0,outz,outy,outx);
       }
     }
@@ -267,17 +264,16 @@
 */
 
 #ifndef SERIAL_PREPROC
-  BARRIER(Global->SlaveBarrier,num_nodes);	
+  BARRIER(Global->SlaveBarrier,num_nodes);
 #endif
 }
 
 
-Allocate_Pyramid_Level(address, length)
+void Allocate_Pyramid_Level(address, length)
      BYTE **address;
      long length;
 {
-  unsigned int i,j,size,type_per_page,count,block;
-  unsigned int p,numbytes;
+  long i;
 
   printf("      Allocating pyramid level of %ld bytes...\n",
 	 length*sizeof(BYTE));
@@ -291,7 +287,7 @@
   if (*address == NULL)
     Error("    No space available for pyramid level.\n");
 
-/*  POSSIBLE ENHANCEMENT:  Here's where one might distribute the 
+/*  POSSIBLE ENHANCEMENT:  Here's where one might distribute the
     octree among physical memories if one wanted to.
 */
 
@@ -300,16 +296,15 @@
 }
 
 
-Compute_Pyramid_Level(level)
-     int level;
+void Compute_Pyramid_Level(level)
+     long level;
 {
-  int outx,outy,outz;	/* Loop indices in image space               */
-  int i;
-  int inx,iny,inz;
-  int inx_plus_one,iny_plus_one,inz_plus_one;
+  long outx,outy,outz;	/* Loop indices in image space               */
+  long inx,iny,inz;
+  long inx_plus_one,iny_plus_one,inz_plus_one;
   BOOLEAN bit;
-  
-  printf("      Computing pyramid level %d from level %d...\n",
+
+  printf("      Computing pyramid level %ld from level %ld...\n",
 	 level,level-1);
   for (outz=0; outz<pyr_len[level][Z]; outz++) {
     inz = outz<<1;
@@ -320,7 +315,7 @@
       for (outx=0; outx<pyr_len[level][X]; outx++) {
 	inx = outx<<1;
 	inx_plus_one = MIN(inx+1,pyr_len[level-1][X]-1);
-	
+
 	bit = PYR(level-1,inz,iny,inx);
 	bit |= PYR(level-1,inz,iny,inx_plus_one);
 	bit |= PYR(level-1,inz,iny_plus_one,inx);
@@ -329,7 +324,7 @@
 	bit |= PYR(level-1,inz_plus_one,iny,inx_plus_one);
 	bit |= PYR(level-1,inz_plus_one,iny_plus_one,inx);
 	bit |= PYR(level-1,inz_plus_one,iny_plus_one,inx_plus_one);
-	
+
 	WRITE_PYR(bit,level,outz,outy,outx);
       }
     }
@@ -337,63 +332,60 @@
 }
 
 
-Load_Octree(filename)
+void Load_Octree(filename)
      char filename[];
 {
   char local_filename[FILENAME_STRING_SIZE];
-  int fd,level;
+  int fd;
+  long level;
 
   strcpy(local_filename,filename);
   strcat(local_filename,".pyr");
   fd = Open_File(local_filename);
-  
-  Read_Shorts(fd,&pyr_version, (long)sizeof(pyr_version));
-  if (pyr_version != PYR_CUR_VERSION) 
-    Error("    Can't load version %d file\n",pyr_version);
-  
-  Read_Shorts(fd,&pyr_levels,(long)sizeof(pyr_levels));
-  Read_Shorts(fd,pyr_len,(long)(pyr_levels*NM*sizeof(short)));
-  Read_Shorts(fd,pyr_voxlen,(long)(pyr_levels*NM*sizeof(short)));
-  Read_Longs(fd,pyr_length,(long)(pyr_levels*sizeof(long)));
+
+  Read_Shorts(fd,(unsigned char *)&pyr_version, (long)sizeof(pyr_version));
+  if (pyr_version != PYR_CUR_VERSION)
+    Error("    Can't load version %ld file\n",pyr_version);
+
+  Read_Shorts(fd,(unsigned char *)&pyr_levels,(long)sizeof(pyr_levels));
+  Read_Shorts(fd,(unsigned char *)pyr_len,(long)(pyr_levels*NM*sizeof(long)));
+  Read_Shorts(fd,(unsigned char *)pyr_voxlen,(long)(pyr_levels*NM*sizeof(long)));
+  Read_Longs(fd,(unsigned char *)pyr_length,(long)(pyr_levels*sizeof(pyr_length[0])));
 
   printf("    Loading binary pyramid of %d levels...\n",pyr_levels);
   for (level=0; level<pyr_levels; level++) {
     Allocate_Pyramid_Level(&pyr_address[level],pyr_length[level]);
-    printf("      Loading pyramid level %d from .pyr file...\n",level);
-    Read_Bytes(fd,pyr_address[level],(long)(pyr_length[level]*sizeof(BYTE)));
+    printf("      Loading pyramid level %ld from .pyr file...\n",level);
+    Read_Bytes(fd,(unsigned char *)pyr_address[level],(long)(pyr_length[level]*sizeof(BYTE)));
   }
   Close_File(fd);
 }
 
 
-Store_Octree(filename)
+void Store_Octree(filename)
 char filename[];
 {
   char local_filename[FILENAME_STRING_SIZE];
-  int fd,level;
+  int fd;
+  long level;
 
   strcpy(local_filename,filename);
   strcat(local_filename,".pyr");
   fd = Create_File(local_filename);
 
   pyr_version = PYR_CUR_VERSION;
-  Write_Shorts(fd,&pyr_version,(long)sizeof(pyr_version));
+  Write_Shorts(fd,(unsigned char *)&pyr_version,(long)sizeof(pyr_version));
 
-  Write_Shorts(fd,&pyr_levels,(long)sizeof(pyr_levels));
-  Write_Shorts(fd,pyr_len,(long)(pyr_levels*NM*sizeof(short)));
-  Write_Shorts(fd,pyr_voxlen,(long)(pyr_levels*NM*sizeof(short)));
-  Write_Longs(fd,pyr_length,(long)(pyr_levels*sizeof(long)));
+  Write_Shorts(fd,(unsigned char *)&pyr_levels,(long)sizeof(pyr_levels));
+  Write_Shorts(fd,(unsigned char *)pyr_len,(long)(pyr_levels*NM*sizeof(long)));
+  Write_Shorts(fd,(unsigned char *)pyr_voxlen,(long)(pyr_levels*NM*sizeof(long)));
+  Write_Longs(fd,(unsigned char *)pyr_length,(long)(pyr_levels*sizeof(pyr_length[0])));
 
   printf("    Storing binary pyramid of %d levels...\n",pyr_levels);
   for (level=0; level<pyr_levels; level++) {
-    printf("      Storing pyramid level %d into .pyr file...\n",level);
+    printf("      Storing pyramid level %ld into .pyr file...\n",level);
 
-    Write_Bytes(fd,pyr_address[level],(long)(pyr_length[level]*sizeof(BYTE)));
+    Write_Bytes(fd,(unsigned char *)pyr_address[level],(long)(pyr_length[level]*sizeof(BYTE)));
   }
   Close_File(fd);
 }
-
-
-
-
-
diff -Naur splash2/codes/apps/volrend/opacity.C splash2-modified/codes/apps/volrend/opacity.C
--- splash2/codes/apps/volrend/opacity.C	1994-10-17 21:05:42.000000000 -0400
+++ splash2-modified/codes/apps/volrend/opacity.C	2007-03-19 23:06:10.000000000 -0400
@@ -21,6 +21,7 @@
 *                                                                             *
 ******************************************************************************/
 
+#include <string.h>
 #include "incl.h"
 
 /* The following declarations show the layout of the .opc file.              */
@@ -33,21 +34,19 @@
 
 short opc_len[NM];	        /* Size of this opacity map                  */
 
-long opc_length;		/* Total number of opacities in map          */
+int opc_length;		/* Total number of opacities in map          */
 				/*   (= product of lens)                     */
 OPACITY *opc_address;	        /* Pointer to opacity map                    */
 
 /* End of layout of .opc file.                                               */
 
-void Opacity_Compute();
-
 EXTERN_ENV
 
 #include "anl.h"
 
-Compute_Opacity()
+void Compute_Opacity()
 {
-  int i;
+  long i;
 
   /* to allow room for gradient operator plus 1-voxel margin   */
   /* of zeros if shading transition width > 0.  Zero voxels    */
@@ -70,12 +69,11 @@
 }
 
 
-Allocate_Opacity(address, length)
+void Allocate_Opacity(address, length)
      OPACITY **address;
      long length;
 {
-  unsigned int i,j,size,type_per_page,count,block;
-  unsigned int p,numbytes;
+  long i;
 
   printf("    Allocating opacity map of %ld bytes...\n",
 	 length*sizeof(OPACITY));
@@ -85,7 +83,7 @@
   if (*address == NULL)
     Error("    No space available for map.\n");
 
-/*  POSSIBLE ENHANCEMENT:  Here's where one might distribute the 
+/*  POSSIBLE ENHANCEMENT:  Here's where one might distribute the
     opacity map among physical memories if one wanted to.
 */
 
@@ -96,25 +94,25 @@
 
 void Opacity_Compute()
 {
-  int inx,iny,inz;	        /* Voxel location in object space            */
-  int outx,outy,outz;	        /* Loop indices in image space               */
-  int i, density;
+  long inx,iny,inz;	        /* Voxel location in object space            */
+  long outx,outy,outz;	        /* Loop indices in image space               */
+  long density;
   float magnitude;
   float opacity, grd_x,grd_y,grd_z;
-  int omap_partition,zstart,zstop;
-  int num_xqueue,num_yqueue,num_zqueue,num_queue;
-  int xstart,xstop,ystart,ystop;
-  int my_node;
+  long zstart,zstop;
+  long num_xqueue,num_yqueue,num_zqueue,num_queue;
+  long xstart,xstop,ystart,ystop;
+  long my_node;
 
   LOCK(Global->IndexLock);
   my_node = Global->Index++;
   UNLOCK(Global->IndexLock);
   my_node = my_node%num_nodes;
 
-/*  POSSIBLE ENHANCEMENT:  Here's where one might bind the process to a 
-    processor, if one wanted to. 
+/*  POSSIBLE ENHANCEMENT:  Here's where one might bind the process to a
+    processor, if one wanted to.
 */
-    
+
   num_xqueue = ROUNDUP((float)opc_len[X]/(float)voxel_section[X]);
   num_yqueue = ROUNDUP((float)opc_len[Y]/(float)voxel_section[Y]);
   num_zqueue = ROUNDUP((float)opc_len[Z]/(float)voxel_section[Z]);
@@ -138,7 +136,7 @@
   for (outz=zstart; outz<zstop; outz++) {
     for (outy=ystart; outy<ystop; outy++) {
       for (outx=xstart; outx<xstop; outx++) {
-		
+
 	inx = INSET + outx;
 	iny = INSET + outy;
 	inz = INSET + outz;
@@ -146,11 +144,11 @@
 	density = MAP(inz,iny,inx);
 	if (density > density_epsilon) {
 
-	  grd_x = (float)((int)MAP(inz,iny,inx+1) - (int)MAP(inz,iny,inx-1));
-	  grd_y = (float)((int)MAP(inz,iny+1,inx) - (int)MAP(inz,iny-1,inx));
-	  grd_z = (float)((int)MAP(inz+1,iny,inx) - (int)MAP(inz-1,iny,inx));
+	  grd_x = (float)((long)MAP(inz,iny,inx+1) - (long)MAP(inz,iny,inx-1));
+	  grd_y = (float)((long)MAP(inz,iny+1,inx) - (long)MAP(inz,iny-1,inx));
+	  grd_z = (float)((long)MAP(inz+1,iny,inx) - (long)MAP(inz-1,iny,inx));
 	  magnitude = grd_x*grd_x+grd_y*grd_y+grd_z*grd_z;
-  
+
 	  /* If (magnitude*grd_divisor)**2 is small, skip voxel             */
 	  if (magnitude > nmag_epsilon) {
 	    magnitude = .5*sqrt(magnitude);
@@ -159,7 +157,7 @@
 	    /*   functions of local density and gradient magnitude.         */
 	    /*   Detects both front and rear-facing surfaces.               */
 	    opacity = density_opacity[density] *
-	      magnitude_opacity[(int)magnitude];
+	      magnitude_opacity[(long)magnitude];
 	    /* If opacity is small, skip shading and compositing of sample  */
 	    if (opacity > opacity_epsilon)
 	      OPC(outz,outy,outx) = NINT(opacity*MAX_OPC);
@@ -176,7 +174,7 @@
 }
 
 
-Load_Opacity(filename)
+void Load_Opacity(filename)
      char filename[];
 {
   char local_filename[FILENAME_STRING_SIZE];
@@ -185,24 +183,24 @@
   strcpy(local_filename,filename);
   strcat(local_filename,".opc");
   fd = Open_File(local_filename);
-  
-  Read_Shorts(fd,&opc_version, (long)sizeof(opc_version));
-  if (opc_version != OPC_CUR_VERSION) 
+
+  Read_Shorts(fd,(unsigned char *)&opc_version, (long)sizeof(opc_version));
+  if (opc_version != OPC_CUR_VERSION)
     Error("    Can't load version %d file\n",opc_version);
-  
-  Read_Shorts(fd,opc_len,(long)sizeof(map_len));
-  
-  Read_Longs(fd,&opc_length,(long)sizeof(opc_length));
-  
+
+  Read_Shorts(fd,(unsigned char *)opc_len,(long)sizeof(map_len));
+
+  Read_Longs(fd,(unsigned char *)&opc_length,(long)sizeof(opc_length));
+
   Allocate_Opacity(&opc_address,opc_length);
-  
+
   printf("    Loading opacity map from .opc file...\n");
-  Read_Bytes(fd,opc_address,(long)(opc_length*sizeof(OPACITY)));
+  Read_Bytes(fd,(unsigned char *)opc_address,(long)(opc_length*sizeof(OPACITY)));
   Close_File(fd);
 }
 
 
-Store_Opacity(filename)
+void Store_Opacity(filename)
 char filename[];
 {
   char local_filename[FILENAME_STRING_SIZE];
@@ -216,18 +214,18 @@
   strcpy(local_filename,filename);
   strcat(local_filename,".opc");
   fd = Create_File(local_filename);
-  Write_Shorts(fd,&opc_version,(long)sizeof(opc_version));
-  
-  Write_Shorts(fd,opc_len,(long)sizeof(opc_len));
-  Write_Longs(fd,&opc_length,(long)sizeof(opc_length));
-  
+  Write_Shorts(fd,(unsigned char *)&opc_version,(long)sizeof(opc_version));
+
+  Write_Shorts(fd,(unsigned char *)opc_len,(long)sizeof(opc_len));
+  Write_Longs(fd,(unsigned char *)&opc_length,(long)sizeof(opc_length));
+
   printf("    Storing opacity map into .opc file...\n");
-  Write_Bytes(fd,opc_address,(long)(opc_length*sizeof(OPACITY)));
+  Write_Bytes(fd,(unsigned char *)opc_address,(long)(opc_length*sizeof(OPACITY)));
   Close_File(fd);
 }
 
 
-Deallocate_Opacity(address)
+void Deallocate_Opacity(address)
 OPACITY **address;
 {
   printf("    Deallocating opacity map...\n");
diff -Naur splash2/codes/apps/volrend/option.C splash2-modified/codes/apps/volrend/option.C
--- splash2/codes/apps/volrend/option.C	1994-10-14 01:01:13.000000000 -0400
+++ splash2-modified/codes/apps/volrend/option.C	2007-03-18 23:51:16.000000000 -0400
@@ -22,13 +22,13 @@
 
 #include "incl.h"
 
-int block_xlen,block_ylen;
+long block_xlen,block_ylen;
 BOOLEAN adaptive;               /* adaptive ray tracing?                     */
 
 				/* During shading:                           */
-int density_epsilon;	        /*   minimum (density*map_divisor)           */
+long density_epsilon;	        /*   minimum (density*map_divisor)           */
 				/*     (>= MIN_DENSITY)                      */
-int magnitude_epsilon;  	/*   minimum (magnitude*grd_divisor)**2      */
+long magnitude_epsilon;  	/*   minimum (magnitude*grd_divisor)**2      */
 				/*     (> MIN_MAGNITUDE)                     */
 
                                 /* Shading parameters of reflective surface: */
@@ -63,22 +63,22 @@
 				/*     (<= MAX_OPACITY)                      */
 
 				/* During ray tracing:                       */
-int highest_sampling_boxlen;    /*   highest boxlen for adaptive sampling    */
+long highest_sampling_boxlen;    /*   highest boxlen for adaptive sampling    */
 				/*     (>= 1)                                */
-int lowest_volume_boxlen;      	/*   lowest boxlen for volume data           */
+long lowest_volume_boxlen;      	/*   lowest boxlen for volume data           */
 				/*     (>= 1)                                */
-int volume_color_difference;   	/*   minimum color diff for volume data      */
+long volume_color_difference;   	/*   minimum color diff for volume data      */
 				/*     (>= MIN_PIXEL)                        */
-int pyr_highest_level; 		/*   highest level of pyramid to look at     */
+long pyr_highest_level; 		/*   highest level of pyramid to look at     */
 				/*     (<= MAX_PYRLEVEL)                     */
-int pyr_lowest_level;  		/*   lowest level of pyramid to look at      */
+long pyr_lowest_level;  		/*   lowest level of pyramid to look at      */
 				/*     (>= 0)                                */
 float angle[NM];                /* initial viewing angle                     */
 
 
 EXTERN_ENV
 
-Init_Options()
+void Init_Options()
 {
 
   norm_address = NULL;
@@ -94,7 +94,7 @@
   angle[Y] = -36.0;
   angle[Z] = 0.0;
   Init_Parallelization();
-    
+
   opacity_epsilon = 0.0;
   opacity_cutoff = 0.95;
   highest_sampling_boxlen = HBOXLEN; /* this must be less than BLOCK_LEN */
@@ -108,9 +108,9 @@
 }
 
 
-Init_Opacity()
+void Init_Opacity()
 {
-  int i;
+  long i;
   float increment;
 
   density_epsilon = 96;
@@ -136,7 +136,7 @@
 }
 
 
-Init_Lighting()  
+void Init_Lighting()
 {
   float inv_magnitude;
 
@@ -155,14 +155,14 @@
   diffuse_color = 100.0;
   specular_color = 130.0;
   specular_exponent = 10.0;
-  
+
   depth_hither = 1.0;
-  depth_yon = 0.4;	
-  depth_exponent = 1.0;	
+  depth_yon = 0.4;
+  depth_exponent = 1.0;
 }
 
 
-Init_Parallelization()
+void Init_Parallelization()
 {
   block_xlen = BLOCK_LEN;
   block_ylen = BLOCK_LEN;
@@ -180,8 +180,8 @@
 #endif
 
   printf("Gouraud shading from lookup tables used\n");
-  printf("\t%d processes\n",num_nodes);
-  printf("\t%dx%d image block size\n",block_xlen,block_ylen);
+  printf("\t%ld processes\n",num_nodes);
+  printf("\t%ldx%ld image block size\n",block_xlen,block_ylen);
 
   if (adaptive) {
     printf("\tdoing adaptive rendering\n");
diff -Naur splash2/codes/apps/volrend/raytrace.C splash2-modified/codes/apps/volrend/raytrace.C
--- splash2/codes/apps/volrend/raytrace.C	1994-10-14 01:01:13.000000000 -0400
+++ splash2-modified/codes/apps/volrend/raytrace.C	2007-03-19 22:53:21.000000000 -0400
@@ -22,13 +22,13 @@
 
 #include "incl.h"
 
-extern int num_traced_rays_hit_volume;
-extern int num_samples_trilirped;     
-extern int traversal_time,trilirp_time,init_time,composite_time;
+extern long num_traced_rays_hit_volume;
+extern long num_samples_trilirped;
+extern long traversal_time,trilirp_time,init_time,composite_time;
 
 #define VXEL(X,SIGN)		((SIGN) > 0 ? \
-				 (int)((X)+SMALL) : \
-				 (int)((X)-SMALL))
+				 (long)((X)+SMALL) : \
+				 (long)((X)-SMALL))
 
 #define SBIT_ADDRESS(TA)        (sbit_address+(TA))
 #define SHD_ADDRESS(TA)         (shd_address+(TA))
@@ -37,8 +37,7 @@
 
 EXTERN_ENV
 
-Trace_Ray(outx, outy, foutx, fouty, pixel_address)
-     int outx, outy;
+void Trace_Ray(foutx, fouty, pixel_address)
      float foutx, fouty;
      PIXEL *pixel_address;
 {
@@ -54,31 +53,27 @@
                                 /*   in input map encountered by ray         */
                                 /*   (min is first, i.e. closest to eye)     */
                                 /*   (max is last, i.e. farthest from eye)   */
-  int segment_zmin,	        /* Image space loop terminals of segments of */
+  long segment_zmin,	        /* Image space loop terminals of segments of */
   segment_zmax;	                /*   samples between polygon intersections   */
-  int span_zmin,		/* Image space loop terminals of spans of    */
+  long span_zmin,		/* Image space loop terminals of spans of    */
   span_zmax;	        	/*   samples within pyramid boxes            */
   float sample[NM],	        /* Object space coordinates of sample        */
   sample2[NM];	                /*   before and after indenting for trilirp  */
-  int outz;		        /* Image space loop index along ray          */
-  int i,samplex,sampley,samplez;
-  int sample2x,sample2y,sample2z;
-  
+  long outz;		        /* Image space loop index along ray          */
+  long i,samplex,sampley,samplez;
+  long sample2x,sample2y,sample2z;
+
   float box_zmin,box_zmax;
-  int starting_level,level;
+  long starting_level,level;
   float jump[NM],min_jump;
   float voxel[NM],next_voxel[NM];
-  int ivoxel[NM],next_ivoxel[NM];
+  long ivoxel[NM],next_ivoxel[NM];
   BOOLEAN bit;
-  
+
   float xalpha,yalpha,zalpha;
   float one_minus_xalpha,one_minus_yalpha,one_minus_zalpha;
   float weight,wopacity,wopacitysum,wcolorsum;
-  int table_addr,xnorm,ynorm,znorm;
-  float normal[NM],wnormalsum[NM];
-  float inv_magnitude,magnitude;
   float additional_opacity;
-  float dot_product,diffuse,specular;
 
   float color;			/*   color (MIN_PIXEL..MAX_PIXEL)            */
   float opacity;		/*   opacity (0.0..1.0)                      */
@@ -104,7 +99,7 @@
 	invjacobian[Y][i]*fouty;
     ray[1][i] = ray[0][i] + invjacobian[Z][i]*image_zlen;
   }
-  
+
   /* Compute ray space centers of min and max voxels in input map      */
   /* for each coordinate.  If denominator for any coordinate is zero,  */
   /* ray is perpendicular to coordinate axis and that coordinate can   */
@@ -113,7 +108,7 @@
   /* Accumulate to yield ray space centers of first and last           */
   /* voxels in input map encountered by viewing ray, applying          */
   /* frustum and option clipping at the same time.                     */
-  
+
   ray_min = 0.0;
   ray_max = 1.0;
   for (i=0; i<NM; i++) {
@@ -140,10 +135,10 @@
   /* the first and last sample positions along ray fall within the     */
   /* map, taking advantage of the fact that input map mins = 0 and     */
   /* integerization of slightly negative numbers rounds up to zero.    */
-  
+
   segment_zmin = ROUNDUP(image_zlen * ray_min);
   segment_zmax = ROUNDDOWN(image_zlen * ray_max);
-  
+
   /* If loop terminals call for no work to be done, skip ray.          */
   if (segment_zmax < segment_zmin) return;
 
@@ -152,7 +147,7 @@
   /* Unless lowest level to look at is lowest level of pyramid,        */
   /* sample spans may include some non-interesting samples,            */
   /* so binary mask should be used along with pyramid.                 */
-    
+
   /* Start search at start of segment computed above, at the       */
   /* corresponding voxel coordinates, and at lower of selected     */
   /* highest level to look at and highest level present.           */
@@ -165,7 +160,7 @@
   /* real coordinates near integers are rounded to that integer    */
   /* if moving in the positive direction, but to the next lower    */
   /* integer if moving in the negative direction.                  */
-  
+
   box_zmin = (float)segment_zmin;
   voxel[X] = ray[0][X] + invjacobian[Z][X]*box_zmin;
   voxel[Y] = ray[0][Y] + invjacobian[Z][Y]*box_zmin;
@@ -175,25 +170,25 @@
   ivoxel[Z] = VXEL(voxel[Z],invjacobian[Z][Z]);
   starting_level = MIN(pyr_highest_level,pyr_levels-1);
   level = starting_level;
-  
+
   while (1) {
-    
+
     /* Extract bit from pyramid.  Note:  If mipmapping,          */
     /* use of OR'ed pyramid and no trilirp is valid but wasteful,*/
     /* but use of un-OR'ed pyramid and trilirp is invalid.       */
-    
+
     bit = PYR(level,ivoxel[Z]>>level,
 	      ivoxel[Y]>>level,
 	      ivoxel[X]>>level);
     if (bit && level > pyr_lowest_level) {
-      
+
       /* This pyramid box contains something interesting,  */
       /* but we are not at lowest level to be looked at,   */
       /* so stay at current position and drop a level.     */
       level--;
       continue;
     }
-    
+
     /* Compute image space position of far box boundary by       */
     /* computing image space distance from near box boundary     */
     /* to each of the three planes that bound the box in the     */
@@ -239,26 +234,26 @@
       min_jump = MIN(min_jump,jump[Z]);
     }
     box_zmax = box_zmin + min_jump;
-    
+
     if (bit) {
       /* This pyramid box contains something interesting,  */
       /* and we are at lowest level to be looked at, so    */
       /* break out of loop and begin rendering.            */
       break;
     }
-    
+
     /* This pyramid box either contains nothing interesting,     */
     /* or contains something which has now been rendered.        */
     /* If far box boundary is beyond end of segment,             */
     /* skip to end of segment.  Otherwise, set near              */
     /* boundary of next box to far boundary of current box.      */
-    
+
   next_box:
     if (box_zmax >= (float)segment_zmax) {
       goto end_of_segment;
     }
     box_zmin = box_zmax;
-    
+
     /* Compute voxel coordinates of near boundary of next box    */
     next_voxel[X] = voxel[X] + invjacobian[Z][X]*min_jump;
     next_voxel[Y] = voxel[Y] + invjacobian[Z][Y]*min_jump;
@@ -266,7 +261,7 @@
     next_ivoxel[X] = VXEL(next_voxel[X],invjacobian[Z][X]);
     next_ivoxel[Y] = VXEL(next_voxel[Y],invjacobian[Z][Y]);
     next_ivoxel[Z] = VXEL(next_voxel[Z],invjacobian[Z][Z]);
-    
+
     /* If current and next boxes do not have the same parent,    */
     /* time can be saved by popping up to parent of next box,    */
     /* which spans more image space distance than its child.     */
@@ -284,7 +279,7 @@
       else
 	break;
     }
-    
+
     /* Advance voxel coordinates to near boundary of next box    */
     /* and loop for next bit from pyramid.                       */
     voxel[X] = next_voxel[X];
@@ -294,7 +289,7 @@
     ivoxel[Y] = next_ivoxel[Y];
     ivoxel[Z] = next_ivoxel[Z];
   }
-    
+
   /* We have now broken out of loop to begin rendering.            */
   /* Set image space loop terminals of sample span to include      */
   /* either all integer image space positions falling inside or    */
@@ -303,26 +298,26 @@
   /* Use of integer positions insures even spacing of samples,     */
   /* which prevents addition of noise component to image.          */
   span_zmin = ROUNDUP(box_zmin);
-  span_zmax = MIN((int)box_zmax,segment_zmax);
-  
+  span_zmax = MIN((long)box_zmax,segment_zmax);
+
   /* If span contains no samples, skip it.                         */
   if (span_zmax < span_zmin) goto next_box;
-  
+
   /* Compute coordinates of first sample position in span              */
   sample[X] = ray[0][X] + invjacobian[Z][X]*span_zmin;
   sample[Y] = ray[0][Y] + invjacobian[Z][Y]*span_zmin;
   sample[Z] = ray[0][Z] + invjacobian[Z][Z]*span_zmin;
-  
+
   for (outz=span_zmin; outz<=span_zmax; outz++) {
-    
+
     /* If binary octree is zero for all eight neighbors in the    */
     /* base level, if trilirp'ing, or lower neighbor otherwise, skip it.     */
     /* Use of OR'ed mask and no trilirp is valid but wasteful, but use of    */
     /* un-OR'ed mask and trilirp is invalid.                                 */
-    
-    samplex=(int)sample[X];
-    sampley=(int)sample[Y];
-    samplez=(int)sample[Z];
+
+    samplex=(long)sample[X];
+    sampley=(long)sample[Y];
+    samplez=(long)sample[Z];
 
       bit=PYR(0,samplez,sampley,samplex);
       if (!bit) goto end_of_sample;
@@ -333,7 +328,7 @@
     /* If not trilirp'ing and not shadowing, then                */
     /* extract color and opacity of lower neighbor,              */
     /* and pre-multiply color by opacity.                        */
-    
+
     /* Indent object space coordinates of sample position      */
     /* by an amount unlikely to produce visible artifacts if   */
     /* necessary so that they fall strictly inside input map   */
@@ -343,10 +338,10 @@
     sample2[X] = MIN(sample[X],in_max[X]);
     sample2[Y] = MIN(sample[Y],in_max[Y]);
     sample2[Z] = MIN(sample[Z],in_max[Z]);
-    
-    sample2x = (int)sample2[X];
-    sample2y = (int)sample2[Y];
-    sample2z = (int)sample2[Z];
+
+    sample2x = (long)sample2[X];
+    sample2y = (long)sample2[Y];
+    sample2z = (long)sample2[Z];
 
     xalpha = sample2[X]-sample2x++;
     yalpha = sample2[Y]-sample2y;
@@ -358,7 +353,7 @@
     /* note that the code below is optimized for the particular map        */
     /* layout and is not abstracted so that if the map layout changes,     */
     /* so must the code that does the trilinear interpolation below.       */
-    
+
     one_minus_xalpha = 1.0 - xalpha;
     one_minus_yalpha = 1.0 - yalpha;
     one_minus_zalpha = 1.0 - zalpha;
@@ -368,13 +363,13 @@
     color = SHD(*local_norm_address--);
     wcolorsum = color * wopacity;
     wopacitysum = wopacity;
-    
+
     weight = one_minus_xalpha * one_minus_yalpha * one_minus_zalpha;
     wopacity = *local_opc_address * weight;
     color = SHD(*local_norm_address);
     wcolorsum += color * wopacity;
     wopacitysum += wopacity;
-    
+
     weight = xalpha * yalpha * one_minus_zalpha;
     local2_opc_address = local_opc_address+opc_xlen;
     local2_norm_address = local_norm_address+norm_xlen;
@@ -388,7 +383,7 @@
     color = SHD(*local2_norm_address);
     wcolorsum += color * wopacity;
     wopacitysum += wopacity;
-    
+
     weight = xalpha * one_minus_yalpha * zalpha;
     local_opc_address = local_opc_address+opc_xylen;
     local_norm_address = local_norm_address+norm_xylen;
@@ -396,13 +391,13 @@
     color = SHD(*local_norm_address--);
     wcolorsum += color * wopacity;
     wopacitysum += wopacity;
-    
+
     weight = one_minus_xalpha * one_minus_yalpha * zalpha;
     wopacity = *local_opc_address * weight;
     color = SHD(*local_norm_address);
     wcolorsum += color * wopacity;
     wopacitysum += wopacity;
-    
+
     weight = xalpha * yalpha * zalpha;
     local2_opc_address = local_opc_address+opc_xlen;
     local2_norm_address = local_norm_address+norm_xlen;
@@ -410,7 +405,7 @@
     color = SHD(*local2_norm_address--);
     wcolorsum += color * wopacity;
     wopacitysum += wopacity;
-    
+
     weight = one_minus_xalpha * yalpha * zalpha;
     wopacity = *local2_opc_address * weight;
     color = SHD(*local2_norm_address);
@@ -434,17 +429,17 @@
     /* Direction-sensitive initialization of inverse Jacobian    */
     /* insures that compositing will be along image space Z-axis */
     /* and from origin towards +Z axis, i.e. front-to-back.      */
-	
+
     additional_opacity = opacity * (1.0-ray_opacity);
     ray_color += color * (1.0-ray_opacity);
     ray_opacity += additional_opacity;
-    
+
     /* If accumulated opacity of geometry/volume ray is unity,   */
     /* if polygon list exists and adaptively ray tracing,        */
     /* bypass volume data, but continue geometry-only ray until  */
     /* its opacity becomes unity or we run out of intersections. */
     /* If no polygons or not adaptively ray tracing, ray is done.*/
-	
+
     if (ray_opacity > opacity_cutoff) {
       goto end_of_ray;
     }
@@ -476,17 +471,16 @@
 }
 
 
-Pre_Shade(int my_node)
+void Pre_Shade(long my_node)
 {
-  int xnorm,ynorm,znorm,table_addr,norm_lshift,i;
-  int shd_table_partition,zstart,zstop;
+  long xnorm,ynorm,znorm,table_addr,norm_lshift;
+  long shd_table_partition,zstart,zstop;
   float mag,error,inv_num_nodes;
   float normal[NM];
   float dot_product,diffuse,specular,color;
   float dpartial_product1,dpartial_product2;
   float spartial_product1,spartial_product2;
-  BOOLEAN *local_sbit_address;
-  int temp;
+  long temp;
 
   inv_num_nodes = 1.0/(float)num_nodes;
 
@@ -517,7 +511,7 @@
       if (mag > error) {
 	mag = MAX(mag,0.0);
 	normal[X] = sqrt(mag);
-	xnorm = (int)normal[X];
+	xnorm = (long)normal[X];
 	dpartial_product1 = normal[Z] * obslight[Z] + normal[Y] * obslight[Y];
 	dpartial_product2 = normal[X] * obslight[X];
 	spartial_product1 = normal[Z] * obshighlight[Z] +
@@ -532,7 +526,7 @@
 	color = ambient_color + diffuse*diffuse_color +
 	  specular*specular_color;
 	color = NINT(MIN(color,MAX_PIXEL));
-	temp = (int) color;
+	temp = (long) color;
 	SHD(table_addr+1) = (unsigned char) temp;
 	if (normal[X] > 0.0) {
 	  dot_product = dpartial_product1 - dpartial_product2;
@@ -544,12 +538,12 @@
 	    specular*specular_color;
 	  color = NINT(MIN(color,MAX_PIXEL));
 	}
-	temp = (int) color;
+	temp = (long) color;
 	SHD(table_addr) = (unsigned char) temp;
       }
     }
   }
   table_addr = LOOKUP_HSIZE+(norm_lshift*LOOKUP_PREC+2)*2+1;
-  temp = (int) ambient_color;
+  temp = (long) ambient_color;
   SHD(table_addr) = (unsigned char) temp;
 }
diff -Naur splash2/codes/apps/volrend/render.C splash2-modified/codes/apps/volrend/render.C
--- splash2/codes/apps/volrend/render.C	1994-10-14 01:01:13.000000000 -0400
+++ splash2-modified/codes/apps/volrend/render.C	2007-03-18 23:49:40.000000000 -0400
@@ -28,7 +28,7 @@
 
 EXTERN_ENV
 
-Render(int my_node)           /* assumes direction is +Z */
+void Render(long my_node)           /* assumes direction is +Z */
 {
   if (my_node == ROOT) {
   Observer_Transform_Light_Vector();
@@ -38,10 +38,10 @@
 }
 
 
-Observer_Transform_Light_Vector()
+void Observer_Transform_Light_Vector()
 {
   float inv_magnitude;
-  
+
   /* Transform light vector by inverse of viewing matrix               */
   /* to move shading light inversely with ray tracing observer.        */
   /* Matrix should include only scaling and rotation, not translation. */
@@ -52,7 +52,7 @@
   /* light source will appear fixed relative to observer.              */
   Transform_Point(light[X],light[Y],light[Z],
 		  &obslight[X],&obslight[Y],&obslight[Z]);
-  
+
   /* Normalize transformed light vector                                */
   inv_magnitude = 1.0/sqrt(obslight[X]*obslight[X] +
 		   obslight[Y]*obslight[Y] +
@@ -63,7 +63,7 @@
 }
 
 
-Compute_Observer_Transformed_Highlight_Vector()
+void Compute_Observer_Transformed_Highlight_Vector()
 {
   float inv_magnitude;
   float obseye[NM];		/*   observer transformed eye vector         */
@@ -78,7 +78,7 @@
   eye[Y] = 0.0;
   eye[Z] = -1.0;
   Transform_Point(eye[X],eye[Y],eye[Z],&obseye[X],&obseye[Y],&obseye[Z]);
-  
+
   /* Normalize transformed eye vector                                  */
   inv_magnitude = 1.0/sqrt(obseye[X]*obseye[X] +
 		   obseye[Y]*obseye[Y] +
@@ -86,14 +86,14 @@
   obseye[X] = obseye[X] * inv_magnitude;
   obseye[Y] = obseye[Y] * inv_magnitude;
   obseye[Z] = obseye[Z] * inv_magnitude;
-  
+
   /* Compute observer transformed maximum highlight vector             */
   /* as diagonal of rhombus formed by normalized observer transformed  */
   /* light vector and normalized observer transformed eye vector.      */
   obshighlight[X] = obslight[X] + obseye[X];
   obshighlight[Y] = obslight[Y] + obseye[Y];
   obshighlight[Z] = obslight[Z] + obseye[Z];
-  
+
   /* Normalize transformed highlight vector                            */
   inv_magnitude = 1.0/sqrt(obshighlight[X]*obshighlight[X] +
 		   obshighlight[Y]*obshighlight[Y] +
@@ -102,6 +102,3 @@
   obshighlight[Y] = obshighlight[Y] * inv_magnitude * brightness;
   obshighlight[Z] = obshighlight[Z] * inv_magnitude * brightness;
 }
-
-
-
diff -Naur splash2/codes/apps/volrend/user_options.H splash2-modified/codes/apps/volrend/user_options.H
--- splash2/codes/apps/volrend/user_options.H	1994-10-14 01:01:13.000000000 -0400
+++ splash2-modified/codes/apps/volrend/user_options.H	2007-03-19 23:19:56.000000000 -0400
@@ -28,19 +28,19 @@
 #endif
 
 
-/* For doing different parts of the computation differently; 
+/* For doing different parts of the computation differently;
 If RENDER_ONLY is defined, then the program assumes that the .norm, .opc
 and .pyr files already exist and just does rendering, getting its input
-from these files.   If RENDER_ONLY is not defined, then the program will 
-not use these files but start from the .den file itself.  In this case, 
+from these files.   If RENDER_ONLY is not defined, then the program will
+not use these files but start from the .den file itself.  In this case,
 there are two options:  if PREPROCESS is defined, then the program will
 not render, but will create the .norm, .opc and .pyr files from the .den
 file for a future run of the program to render. If PREPROCESS is not
-defined either, then the program will not produce these intermediate 
+defined either, then the program will not produce these intermediate
  files:  It will start from the .den file, create the normal and opacity
-tables etc as internal data structures, and render them directly. 
+tables etc as internal data structures, and render them directly.
 
-The SERIAL_PREPROC option tells whether the preprocessing phases (computing  
+The SERIAL_PREPROC option tells whether the preprocessing phases (computing
 the normal table or .norm file, etc.), should be done serially or in
 parallel, when they are done.
 
@@ -49,7 +49,7 @@
 values.
 */
 
-#if 1
+#if 0
 #define RENDER_ONLY                             /* to just do rendering from */
 #endif                                          /* .norm, .opc and .pyr files*/
 
diff -Naur splash2/codes/apps/volrend/view.C splash2-modified/codes/apps/volrend/view.C
--- splash2/codes/apps/volrend/view.C	1994-10-14 01:01:13.000000000 -0400
+++ splash2-modified/codes/apps/volrend/view.C	2007-03-18 23:56:29.000000000 -0400
@@ -20,7 +20,7 @@
  *                                                                             *
  ******************************************************************************/
 
-#include "incl.h" 
+#include "incl.h"
 
 #define XAXIS		1	/* Positive X-axis points rightwards  */
 #define YAXIS		2	/* Positive Y-axis points upwards     */
@@ -32,16 +32,16 @@
 float uout_invvertex[2][2][2][NM];/* Image and object space vertices         */
 /*   of output map unit voxel              */
 
-short frust_len;		/* Size of clipping frustum                  */
+long frust_len;		/* Size of clipping frustum                  */
 /*   (mins will be 0 in this program,        */
 /*    {x,y}len will be <= IK{X,Y}SIZE)       */
 float out_diag_len[NM];   	/* Per-axis lengths and combined length of   */
 float out_diag_length;	        /*   diagonal of input map in image space    */
 float depth_cueing[MAX_OUTLEN];	/* Pre-computed table of depth cueing        */
-int image_zlen;			/*   number of samples along viewing ray     */
+long image_zlen;			/*   number of samples along viewing ray     */
 float in_max[NM];               /* Pre-computed clipping aids                */
-int opc_xlen,opc_xylen;
-int norm_xlen,norm_xylen;
+long opc_xlen,opc_xylen;
+long norm_xlen,norm_xylen;
 
 float invmatrix[4][4];		/* Inverse of viewing matrix:                */
 /* 4 x 4 viewing transformation matrix       */
@@ -49,11 +49,11 @@
 /*    matrix[][3] = 0, matrix[3][3] = 1)     */
 
 EXTERN_ENV
-    
-    Compute_Pre_View()
-{ 
-    int i, outz;
-    
+
+void Compute_Pre_View()
+{
+    long i, outz;
+
     for (i=0; i<NM; i++)
         out_diag_len[i] = opc_len[i]-1;
     out_diag_length = out_diag_len[X]*out_diag_len[X] +
@@ -62,7 +62,7 @@
     out_diag_length = sqrt(out_diag_length);
     frust_len = NINT(out_diag_length)+1;
     image_zlen = frust_len - 1;
-    
+
     /* Pre-compute table of depth cueing attenuation fractions as        */
     /* exponential falloff from intensity of depth_hither*full at        */
     /* hither (outz=0) to depth_yon*full at yon (frust_len-1).           */
@@ -77,12 +77,12 @@
                 (depth_hither - depth_yon);
         depth_cueing[outz] = MIN(MAX(depth_cueing[outz],0.0),1.0);
     }
-    
+
     /* Pre-compute clipping aids                                         */
     in_max[X] = (float)(opc_len[X]-1)-SMALL-1.0/(float)MAX_PIXEL;
     in_max[Y] = (float)(opc_len[Y]-1)-SMALL-1.0/(float)MAX_PIXEL;
     in_max[Z] = (float)(opc_len[Z]-1)-SMALL-1.0/(float)MAX_PIXEL;
-    
+
     /* Pre-compute subscripting aids                                     */
     opc_xlen = opc_len[X] + 1;
     opc_xylen = opc_len[X] * opc_len[Y] + 1;
@@ -92,13 +92,13 @@
 }
 
 
-Select_View(delta_angle, axis)
+void Select_View(delta_angle, axis)
   float delta_angle;
-  int axis;
-  
+  long axis;
+
 {
     Load_Identity_Matrix(invmatrix);
-    
+
     /* Moves input map from all-positive octant to center of     */
     /* coordinate system so subsequent rotations spin object     */
     /* in place.  Must be first after initialization to work.    */
@@ -106,10 +106,10 @@
                                     (float)(out_diag_len[X])/2.0,
                                     (float)(out_diag_len[Y])/2.0,
                                     (float)(out_diag_len[Z])/2.0);
-    
+
     /* scale dataset size in Z-direction for 256x256x113 dataset */
     Inverse_Concatenate_Scaling(invmatrix,1.0,1.0,1.0/(float)ZSCALE);
-    
+
     /* rotation about axis by angle */
     if (frame != 0)
         angle[axis] = angle[axis] + delta_angle;
@@ -117,7 +117,7 @@
     Inverse_Concatenate_Rotation(invmatrix,YAXIS,-angle[Y]);
     /*  Inverse_Concatenate_Rotation(invmatrix,ZAXIS,-angle[Z]);*/
     Inverse_Concatenate_Rotation(invmatrix,XAXIS,30.0);
-    
+
     /* Moves input map from center of coordinate system back     */
     /* to within all-positive octant such that any rotation      */
     /* (e.g. by using pre-matrix, rotations, and anpost-matrix)  */
@@ -128,7 +128,7 @@
                                     -out_diag_length/2.0,
                                     -out_diag_length/2.0,
                                     -out_diag_length/2.0);
-    
+
     /* Insures that frustum entirely encloses any rotation of    */
     /* map assuming they fall within the all-positive octant     */
     /* (e.g. by using pre-matrix, rotations, and anpost-matrix), */
@@ -138,43 +138,43 @@
 }
 
 
-Compute_Input_Dimensions()
+void Compute_Input_Dimensions()
 {
-    int x,y,z,i;
+    long x,y,z;
     float in_invvertex[2][2][2][NM];	/* Image and object space centers    */
-    
+
     in_invvertex[0][0][0][X] = 0;
     in_invvertex[0][0][0][Y] = 0;
     in_invvertex[0][0][0][Z] = 0;
-    
+
     in_invvertex[0][0][1][X] = frust_len-1;
     in_invvertex[0][0][1][Y] = 0;
     in_invvertex[0][0][1][Z] = 0;
-    
+
     in_invvertex[0][1][0][X] = 0;
     in_invvertex[0][1][0][Y] = frust_len-1;
     in_invvertex[0][1][0][Z] = 0;
-    
+
     in_invvertex[0][1][1][X] = frust_len-1;
     in_invvertex[0][1][1][Y] = frust_len-1;
     in_invvertex[0][1][1][Z] = 0;
-    
+
     in_invvertex[1][0][0][X] = 0;
     in_invvertex[1][0][0][Y] = 0;
     in_invvertex[1][0][0][Z] = frust_len-1;
-    
+
     in_invvertex[1][0][1][X] = frust_len-1;
     in_invvertex[1][0][1][Y] = 0;
     in_invvertex[1][0][1][Z] = frust_len-1;
-    
+
     in_invvertex[1][1][0][X] = 0;
     in_invvertex[1][1][0][Y] = frust_len-1;
     in_invvertex[1][1][0][Z] = frust_len-1;
-    
+
     in_invvertex[1][1][1][X] = frust_len-1;
     in_invvertex[1][1][1][Y] = frust_len-1;
     in_invvertex[1][1][1][Z] = frust_len-1;
-    
+
     for (z=0; z<2; z++) {
         for (y=0; y<2; y++) {
             for (x=0; x<2; x++) {
@@ -190,43 +190,43 @@
 }
 
 
-Compute_Input_Unit_Vector()
+void Compute_Input_Unit_Vector()
 {
-    int x,y,z,i;
-    float uin_invvertex[2][2][2][NM];    
-    
+    long x,y,z;
+    float uin_invvertex[2][2][2][NM];
+
     uin_invvertex[0][0][0][X] = 0;
     uin_invvertex[0][0][0][Y] = 0;
     uin_invvertex[0][0][0][Z] = 0;
-    
+
     uin_invvertex[0][0][1][X] = 1.0;
     uin_invvertex[0][0][1][Y] = 0;
     uin_invvertex[0][0][1][Z] = 0;
-    
+
     uin_invvertex[0][1][0][X] = 0;
     uin_invvertex[0][1][0][Y] = 1.0;
     uin_invvertex[0][1][0][Z] = 0;
-    
+
     uin_invvertex[0][1][1][X] = 1.0;
     uin_invvertex[0][1][1][Y] = 1.0;
     uin_invvertex[0][1][1][Z] = 0;
-    
+
     uin_invvertex[1][0][0][X] = 0;
     uin_invvertex[1][0][0][Y] = 0;
     uin_invvertex[1][0][0][Z] = 1.0;
-    
+
     uin_invvertex[1][0][1][X] = 1.0;
     uin_invvertex[1][0][1][Y] = 0;
     uin_invvertex[1][0][1][Z] = 1.0;
-    
+
     uin_invvertex[1][1][0][X] = 0;
     uin_invvertex[1][1][0][Y] = 1.0;
     uin_invvertex[1][1][0][Z] = 1.0;
-    
+
     uin_invvertex[1][1][1][X] = 1.0;
     uin_invvertex[1][1][1][Y] = 1.0;
     uin_invvertex[1][1][1][Z] = 1.0;
-    
+
     for (z=0; z<2; z++) {
         for (y=0; y<2; y++) {
             for (x=0; x<2; x++) {
@@ -242,14 +242,14 @@
 }
 
 
-Load_Transformation_Matrix(matrix)
+void Load_Transformation_Matrix(matrix)
   float matrix[4][4];
 {
 	Copy_Matrix(matrix,transformation_matrix);
 }
 
 
-Transform_Point(xold,yold,zold,xnew,ynew,znew)
+void Transform_Point(xold,yold,zold,xnew,ynew,znew)
   float xold,yold,zold;
   float *xnew,*ynew,*znew;
 {
@@ -258,13 +258,13 @@
             yold * transformation_matrix[1][0] +
                 zold * transformation_matrix[2][0] +
                     transformation_matrix[3][0];
-    
+
 	*ynew =
 	    xold * transformation_matrix[0][1] +
             yold * transformation_matrix[1][1] +
                 zold * transformation_matrix[2][1] +
                     transformation_matrix[3][1];
-    
+
 	*znew =
 	    xold * transformation_matrix[0][2] +
             yold * transformation_matrix[1][2] +
@@ -273,7 +273,7 @@
 }
 
 
-Inverse_Concatenate_Translation(matrix,xoffset,yoffset,zoffset)
+void Inverse_Concatenate_Translation(matrix,xoffset,yoffset,zoffset)
   float matrix[4][4],xoffset,yoffset,zoffset;
 {
 	float translation_matrix[4][4];
@@ -282,7 +282,7 @@
 }
 
 
-Inverse_Concatenate_Scaling(matrix,xscale,yscale,zscale)
+void Inverse_Concatenate_Scaling(matrix,xscale,yscale,zscale)
   float matrix[4][4],xscale,yscale,zscale;
 {
 	float scaling_matrix[4][4];
@@ -291,9 +291,9 @@
 }
 
 
-Inverse_Concatenate_Rotation(matrix,axis,angle)
+void Inverse_Concatenate_Rotation(matrix,axis,angle)
   float matrix[4][4],angle;
-  int axis;
+  long axis;
 {
 	float rotation_matrix[4][4];
 	Load_Rotation_Matrix(rotation_matrix,axis,angle);
@@ -301,10 +301,10 @@
 }
 
 
-Load_Identity_Matrix(matrix)
+void Load_Identity_Matrix(matrix)
   float matrix[4][4];
 {
-	int i,j;
+	long i,j;
 	for (i=0; i<4; i++) {
 		for (j=0; j<4; j++) {
 			matrix[i][j] = 0;
@@ -313,7 +313,7 @@
 	}
 }
 
-Load_Translation_Matrix(matrix,xoffset,yoffset,zoffset)
+void Load_Translation_Matrix(matrix,xoffset,yoffset,zoffset)
   float matrix[4][4],xoffset,yoffset,zoffset;
 {
 	Load_Identity_Matrix(matrix);
@@ -323,7 +323,7 @@
 }
 
 
-Load_Scaling_Matrix(matrix,xscale,yscale,zscale)
+void Load_Scaling_Matrix(matrix,xscale,yscale,zscale)
   float matrix[4][4],xscale,yscale,zscale;
 {
 	Load_Identity_Matrix(matrix);
@@ -333,9 +333,9 @@
 }
 
 
-Load_Rotation_Matrix(matrix,axis,angle)
+void Load_Rotation_Matrix(matrix,axis,angle)
   float matrix[4][4],angle;
-  int axis;
+  long axis;
 {
 	Load_Identity_Matrix(matrix);
 	if (axis == XAXIS) {
@@ -359,7 +359,7 @@
 }
 
 
-Concatenate_Transform(composite_matrix,transformation_matrix)
+void Concatenate_Transform(composite_matrix,transformation_matrix)
   float composite_matrix[][4],transformation_matrix[][4];
 {
 	float temp_matrix[4][4];
@@ -367,7 +367,7 @@
 	Copy_Matrix(temp_matrix,composite_matrix);
 }
 
-Inverse_Concatenate_Transform(composite_matrix,transformation_matrix)
+void Inverse_Concatenate_Transform(composite_matrix,transformation_matrix)
   float composite_matrix[][4],transformation_matrix[][4];
 {
 	float temp_matrix[4][4];
@@ -376,10 +376,10 @@
 }
 
 
-Multiply_Matrices(input_matrix1,input_matrix2,output_matrix)
+void Multiply_Matrices(input_matrix1,input_matrix2,output_matrix)
   float input_matrix1[][4],input_matrix2[][4],output_matrix[][4];
 {
-	int i,j;
+	long i,j;
 	for (i=0; i<4; i++) {
 		for (j=0; j<4; j++) {
 			output_matrix[i][j] =
@@ -396,15 +396,13 @@
 }
 
 
-Copy_Matrix(input_matrix,output_matrix)
+void Copy_Matrix(input_matrix,output_matrix)
 float input_matrix[][4],output_matrix[][4];
 {
-	int i,j;
+	long i,j;
 	for (i=0; i<4; i++) {
 		for (j=0; j<4; j++) {
 			output_matrix[i][j] = input_matrix[i][j];
 		}
 	}
 }
-
-
diff -Naur splash2/codes/apps/volrend/voxel.C splash2-modified/codes/apps/volrend/voxel.C
--- splash2/codes/apps/volrend/voxel.C	1994-10-14 01:01:13.000000000 -0400
+++ splash2-modified/codes/apps/volrend/voxel.C	1969-12-31 19:00:00.000000000 -0500
@@ -1,82 +0,0 @@
-/*************************************************************************/
-/*                                                                       */
-/*  Copyright (c) 1994 Stanford University                               */
-/*                                                                       */
-/*  All rights reserved.                                                 */
-/*                                                                       */
-/*  Permission is given to use, copy, and modify this software for any   */
-/*  non-commercial purpose as long as this copyright notice is not       */
-/*  removed.  All other uses, including redistribution in whole or in    */
-/*  part, are forbidden without prior written permission.                */
-/*                                                                       */
-/*  This software is provided with absolutely no warranty and no         */
-/*  support.                                                             */
-/*                                                                       */
-/*************************************************************************/
-
-/******************************************************************************
-*                                                                             *
-*    voxel.c:  Reformat maps into voxel map for better cache behavior?        *
-*               Not used in SPLASH version since not much perf. impact.       *
-*                                                                             *
-******************************************************************************/
-
-#include "incl.h"
-
-VOXEL *vox_address;
-short vox_len[NM];
-long vox_length;
-int vox_xlen,vox_xylen;
-
-EXTERN_ENV
-
-Voxel()
-{
-  int i;
-  NORMAL *local_norm_address;
-  OPACITY *local_opc_address;
-  VOXEL *local_vox_address;
-
-  for (i=0; i<NM; i++)
-    vox_len[i] = opc_len[i];
-  vox_length = norm_length + opc_length; /* opc_length = norm_length */
-  Allocate_Voxel(&vox_address,vox_length);
-  local_norm_address = norm_address;
-  local_opc_address = opc_address;
-  local_vox_address = vox_address;
-  for (i=0; i<opc_length; i++) {
-    *local_vox_address++ = *local_norm_address++;
-    *local_vox_address++ = *local_opc_address++;
-  }
-  vox_xlen = vox_len[X] * 2 + 3;
-  vox_xylen = vox_len[X] * vox_len[Y] * 2 + 3;
-  Deallocate_Normal(norm_address);
-  Deallocate_Opacity(opc_address);
-}
-
-
-Allocate_Voxel(address, length)
-     VOXEL **address;
-     long length;
-{
-  unsigned int i,j,size,type_per_page,count,block;
-  unsigned int p,numbytes;
-
-  printf("    Allocating voxel map of %ld bytes...\n",
-	 length*sizeof(VOXEL));
-
-  *address = (VOXEL *)NU_MALLOC(length*sizeof(VOXEL),0);
-
-  if (*address == NULL)
-    Error("    No space available for map.\n");
-
-/*  POSSIBLE ENHANCEMENT:  Here's where one might distribute the 
-    voxel map among physical memories if one wanted to.  If this 
-    routine were used at all, that is.
-*/
-
-  for (i=0; i<length; i++) *(*address+i) = 0;
-
-}
-
-
diff -Naur splash2/codes/apps/water-nsquared/bndry.C splash2-modified/codes/apps/water-nsquared/bndry.C
--- splash2/codes/apps/water-nsquared/bndry.C	1994-10-14 03:46:42.000000000 -0400
+++ splash2-modified/codes/apps/water-nsquared/bndry.C	2007-03-22 15:43:16.000000000 -0400
@@ -14,18 +14,19 @@
 /*                                                                       */
 /*************************************************************************/
 
+EXTERN_ENV
 #include "mdvar.h"
 #include "parameters.h"
 #include "mddata.h"
 #include "split.h"
+#include "global.h"
 
-BNDRY(ProcID)     /* this routine puts the molecules back inside the box if
-                     they are  out */
-  unsigned ProcID;
+/* this routine puts the molecules back inside the box if they are out */
+void BNDRY(long ProcID)
 {
-    int mol, dir; 
+    long mol, dir;
     double *extra_p;
-    
+
     /* for each molecule */
     for (mol = StartMol[ProcID]; mol < StartMol[ProcID+1]; mol++) {
         /* for each direction */
@@ -42,8 +43,7 @@
                 extra_p[H1] += BOXL;
                 extra_p[O]  += BOXL;
                 extra_p[H2] += BOXL;
-            } 
+            }
         } /* for dir */
     } /* for mol */
 } /* end of subroutine BNDRY */
-
diff -Naur splash2/codes/apps/water-nsquared/cnst.H splash2-modified/codes/apps/water-nsquared/cnst.H
--- splash2/codes/apps/water-nsquared/cnst.H	1994-10-14 03:46:42.000000000 -0400
+++ splash2-modified/codes/apps/water-nsquared/cnst.H	2007-03-22 14:45:49.000000000 -0400
@@ -14,8 +14,8 @@
 /*                                                                       */
 /*************************************************************************/
 
-  /*  This file contains declarations for some variables 
-  that are initialized to constants in the program and 
+  /*  This file contains declarations for some variables
+  that are initialized to constants in the program and
   then never modified */
-  
-  extern double UNITT,UNITL,UNITM,BOLTZ,AVGNO,PCC[11];
+
+extern double UNITT,UNITL,UNITM,BOLTZ,AVGNO,PCC[11];
diff -Naur splash2/codes/apps/water-nsquared/cnstnt.C splash2-modified/codes/apps/water-nsquared/cnstnt.C
--- splash2/codes/apps/water-nsquared/cnstnt.C	1994-10-14 03:46:42.000000000 -0400
+++ splash2-modified/codes/apps/water-nsquared/cnstnt.C	2007-03-22 15:42:47.000000000 -0400
@@ -14,6 +14,7 @@
 /*                                                                       */
 /*************************************************************************/
 
+EXTERN_ENV
 #include <stdio.h>
 #include "water.h"
 #include "wwpot.h"
@@ -21,19 +22,19 @@
 #include "frcnst.h"
 #include "fileio.h"
 #include "parameters.h"
+#include "global.h"
 
-CNSTNT(N,C)                     /* set up some constants */
-  
-  int N;		/* NORDER + 1 = 7 for a sixth-order method*/
-  double* C; 	/* DIMENSION C(N,N) */
+/* set up some constants
+ * N : NORDER + 1 = 7 for a sixth-order method
+ * C : DIMENSION C(N,N)
+ */
+void CNSTNT(long N, double *C)
 {
-    int NN,N1,K1;
+    long NN,N1,K1;
     double TN,TK,CM;
-    
-    int i;
-    
+
     /* molecular constants for water in angstrom, radian, and a.m.u. */
-    
+
     NATOMS = 3;
     ROH = 0.9572;
     ROHI = ONE/ROH;
@@ -42,17 +43,17 @@
     OMAS = 15.99945;
     HMAS = 1.007825;
     WTMOL = OMAS+TWO*HMAS;
-    
+
     /* units used to scale variables (in c.g.s.) */
-    
+
     UNITT = 1.0e-15;
     UNITL = 1.0e-8;
     UNITM = 1.6605655e-24;
     BOLTZ = 1.380662e-16;
     AVGNO = 6.022045e23;
-    
+
     /* force constants scaled (divided) by (UNITM/UNITT**2) */
-    
+
     FC11 =  0.512596;
     FC33 =  0.048098;
     FC12 = -0.005823;
@@ -72,9 +73,9 @@
     FC1133 = -0.0048;
     FC1233 =  0.0211;
     FC1333 =  0.006263;
-    
+
     /* water-water interaction parameters */
-    
+
     QQ = 0.07152158;
     A1 = 455.313100;
     B1 = 5.15271070;
@@ -93,28 +94,28 @@
     C2 = 0.50*CM;
     QQ2 = 2.00*QQ;
     QQ4 = 2.00*QQ2;
-    
+
     /*  calculate the coefficients of taylor series expansion */
     /*     for F(X), F"(X), F""(X), ...... (with DELTAT**N/N] included) */
     /*     in C(1,1),..... C(1,2),..... C(1,3),....... */
-    
+
     C[1] = ONE;
-    for (N1=2;N1<=N;N1++) {  
+    for (N1=2;N1<=N;N1++) {
         NN = N1-1;
         TN = NN;
         C[N1] = ONE;
         TK = ONE;
-        for (K1=2;K1<=N1;K1++) { 
+        for (K1=2;K1<=N1;K1++) {
             C[(K1-1)*N+NN] = C[(K1-2)*N+NN+1]*TN/TK;
             NN = NN-1;
             TN = TN-ONE;
             TK = TK+ONE;
         }
     }
-    
-    
+
+
     /* predictor-corrector constants for 2nd order differential equation */
-    
+
     PCC[2] = ONE;
     N1 = N-1;
     switch(N1) {
diff -Naur splash2/codes/apps/water-nsquared/cshift.C splash2-modified/codes/apps/water-nsquared/cshift.C
--- splash2/codes/apps/water-nsquared/cshift.C	1994-10-14 03:46:42.000000000 -0400
+++ splash2-modified/codes/apps/water-nsquared/cshift.C	2007-03-22 15:40:10.000000000 -0400
@@ -15,26 +15,23 @@
 /*************************************************************************/
 
 EXTERN_ENV
-
-#include <math.h> 
+#include <math.h>
+#include "global.h"
 
 /* return the value of a with the same sign as b */
 
-#define sign(a,b)  (b < 0 ) ? ( (a < 0) ? a : -a) : ( (a < 0) ? -a : a) 
+#define sign(a,b)  (b < 0 ) ? ( (a < 0) ? a : -a) : ( (a < 0) ? -a : a)
 
-CSHIFT(XA,XB,XMA,XMB,XL,BOXH,BOXL)
   /* compute some relevant distances between the two input molecules to
      this routine. if they are greater than the cutoff radius, compute
      these distances as if one of the particles were at its mirror image
      (periodic boundary conditions).
      used by the intermolecular interactions routines */
-  
-  double XA[], XB[], XL[];
-  double BOXH, BOXL, XMA, XMB;
+void CSHIFT(double *XA, double *XB, double XMA, double XMB, double *XL, double BOXH, double BOXL)
 {
-    
-    int I;
-    
+
+    long I;
+
     XL[0] = XMA-XMB;
     XL[1] = XMA-XB[0];
     XL[2] = XMA-XB[2];
@@ -49,7 +46,7 @@
     XL[11] = XA[1]-XB[2];
     XL[12] = XA[0]-XB[1];
     XL[13] = XA[2]-XB[1];
-    
+
     /* go through all 14 distances computed */
     for (I = 0; I <  14; I++) {
         /* if the value is greater than the cutoff radius */
diff -Naur splash2/codes/apps/water-nsquared/fileio.H splash2-modified/codes/apps/water-nsquared/fileio.H
--- splash2/codes/apps/water-nsquared/fileio.H	1994-10-14 03:46:42.000000000 -0400
+++ splash2-modified/codes/apps/water-nsquared/fileio.H	2007-03-22 14:45:24.000000000 -0400
@@ -14,9 +14,9 @@
 /*                                                                       */
 /*************************************************************************/
 
-  
+
   /* sets up files for i/o to match the device numbers used
   in the original FORTRAN program from the PERFECT Club */
-  
-  extern FILE *six;
-  
+
+extern FILE *six;
+
diff -Naur splash2/codes/apps/water-nsquared/frcnst.H splash2-modified/codes/apps/water-nsquared/frcnst.H
--- splash2/codes/apps/water-nsquared/frcnst.H	1994-10-14 03:46:42.000000000 -0400
+++ splash2-modified/codes/apps/water-nsquared/frcnst.H	2007-03-22 14:45:18.000000000 -0400
@@ -14,10 +14,8 @@
 /*                                                                       */
 /*************************************************************************/
 
-  /*  This file contains declarations for some variables 
-  needed for force calculation that are initialized in the program and 
+  /*  This file contains declarations for some variables
+  needed for force calculation that are initialized in the program and
   then never modified */
-  
-  extern double FC11,FC12,FC13,FC33, FC111,FC333,FC112,FC113,
-  FC123,FC133, FC1111,FC3333,FC1112,
-  FC1122,FC1113,FC1123,FC1133,FC1233,FC1333;
+
+extern double FC11,FC12,FC13,FC33,FC111,FC333,FC112,FC113,FC123,FC133,FC1111,FC3333,FC1112,FC1122,FC1113,FC1123,FC1133,FC1233,FC1333;
diff -Naur splash2/codes/apps/water-nsquared/global.H splash2-modified/codes/apps/water-nsquared/global.H
--- splash2/codes/apps/water-nsquared/global.H	1994-10-14 03:46:42.000000000 -0400
+++ splash2-modified/codes/apps/water-nsquared/global.H	2007-06-21 18:12:50.000000000 -0400
@@ -14,11 +14,11 @@
 /*                                                                       */
 /*************************************************************************/
 
-/*  This file contains the declaration of the GlobalMemory 
-structure and the maximum number of molecules allowed 
+/*  This file contains the declaration of the GlobalMemory
+structure and the maximum number of molecules allowed
 by the program. */
 
-#define MAXLCKS	4096
+#define MAXLCKS	4096L
 
 struct GlobalMemory {
     LOCKDEC(IOLock)
@@ -34,11 +34,11 @@
     BARDEC(start)
     BARDEC(InterfBar)
     BARDEC(PotengBar)
-    int Index;
+    long Index;
     double VIR;
     double SUM[3];
     double POTA, POTR, POTRF;
-    unsigned long createstart,createend,computestart,computeend;
+    unsigned long computestart,computeend;
     unsigned long trackstart, trackend, tracktime;
     unsigned long intrastart, intraend, intratime;
     unsigned long interstart, interend, intertime;
@@ -46,3 +46,41 @@
 
 extern struct GlobalMemory *gl;
 
+/* bndry.C */
+void BNDRY(long ProcID);
+
+/* cnstnt.C */
+void CNSTNT(long N, double *C);
+
+/* cshift.C */
+void CSHIFT(double *XA, double *XB, double XMA, double XMB, double *XL, double BOXH, double BOXL);
+
+/* initia.C */
+void INITIA(void);
+double xrand(double xl, double xh);
+
+/* interf.C */
+void INTERF(long DEST, double *VIR, long ProcID);
+void UPDATE_FORCES(long mol, long comp, double *XL, double *YL, double *ZL, double *FF, long ProcID);
+
+/* intraf.C */
+void INTRAF(double *VIR, long ProcID);
+
+/* kineti.C */
+void KINETI(double *SUM, double HMAS, double OMAS, long ProcID);
+
+/* mdmain.C */
+double MDMAIN(long NSTEP, long NPRINT, long NSAVE, long NORD1, long ProcID);
+
+/* poteng.C */
+void POTENG(double *POTA, double *POTR, double *PTRF, long ProcID);
+
+/* predcor.C */
+void PREDIC(double *C, long NOR1, long ProcID);
+void CORREC(double *PCC, long NOR1, long ProcID);
+
+/* syscons.C */
+void SYSCNS(void);
+
+/* water.C */
+void WorkStart(void);
diff -Naur splash2/codes/apps/water-nsquared/initia.C splash2-modified/codes/apps/water-nsquared/initia.C
--- splash2/codes/apps/water-nsquared/initia.C	1994-10-14 03:46:42.000000000 -0400
+++ splash2-modified/codes/apps/water-nsquared/initia.C	2007-03-22 18:14:16.000000000 -0400
@@ -15,7 +15,6 @@
 /*************************************************************************/
 
 EXTERN_ENV
-
 #include "math.h"
 #include "stdio.h"
 #include "mdvar.h"
@@ -25,39 +24,36 @@
 #include "parameters.h"
 #include "mddata.h"
 #include "split.h"
+#include "global.h"
 
-INITIA()
+void INITIA()
 {
     /*   this routine initializes the positions of the molecules along
          a regular cubical lattice, and randomizes the initial velocities of
-         the atoms.  The random numbers used in the initialization of velocities 
+         the atoms.  The random numbers used in the initialization of velocities
          are read from the file random.in, which must be in the current working
          directory in which the program is run  */
-    
-    static double XMIN = 0;
-    static double YMIN = 0;
-    static double ZMIN = 0;
+
     FILE *random_numbers;       /* points to input file containing
                                    pseudo-random numbers for initializing
                                    velocities */
-    double XMAS[4], XS, ZERO, WCOS, WSIN, XT[4], YT[4], Z;
+    double XMAS[4], XT[4], YT[4], Z;
     double SUX, SUY, SUZ, SUMX, SUMY, SUMZ, FAC;
-    int mol=0;
-    int atom=0;
-    int deriv;
-    double xrand();
-    
+    long mol=0;
+    long atom=0;
+    long deriv;
+
     random_numbers = fopen("random.in","r");
     if (random_numbers == NULL) {
         fprintf(stderr,"Error in opening file random.in\n");
         fflush(stderr);
         exit(-1);
     }
-    
+
     XMAS[1]=sqrt(OMAS*HMAS);
     XMAS[0]=HMAS;
     XMAS[2]=HMAS;
-    
+
     /* .....assign positions */
     {
         double NS = pow((double) NMOL, 1.0/3.0) - 0.00001;
@@ -65,8 +61,8 @@
         double ZERO = XS * 0.50;
         double WCOS = ROH * cos(ANGLE * 0.5);
         double WSIN = ROH * sin(ANGLE * 0.5);
-        int i,j,k;
-        
+        long i,j,k;
+
         printf("\nNS = %.16f\n",NS);
         printf("BOXL = %10f\n",BOXL);
         printf("CUTOFF = %10f\n",CUTOFF);
@@ -75,20 +71,20 @@
         printf("WCOS = %f\n",WCOS);
         printf("WSIN = %f\n",WSIN);
         fflush(stdout);
-        
+
 #ifdef RANDOM
         /* if we want to initialize to a random distribution of displacements
            for the molecules, rather than a distribution along a regular lattice
            spaced according to intermolecular distances in water */
-        srandom(1023);
+        srand(1023);
         for (i = 0; i < NMOL; i++) {
-            VAR[mol].F[DISP][XDIR][O] = xrand(0, BOXL); 
-            VAR[mol].F[DISP][XDIR][H1] = VAR[mol].F[DISP][XDIR][O] + WCOS; 
+            VAR[mol].F[DISP][XDIR][O] = xrand(0, BOXL);
+            VAR[mol].F[DISP][XDIR][H1] = VAR[mol].F[DISP][XDIR][O] + WCOS;
             VAR[mol].F[DISP][XDIR][H2] = VAR[mol].F[DISP][XDIR][H1];
-            VAR[mol].F[DISP][YDIR][O] = xrand(0, BOXL); 
-            VAR[mol].F[DISP][YDIR][H1] = VAR[mol].F[DISP][YDIR][O] + WSIN; 
-            VAR[mol].F[DISP][YDIR][H2] = VAR[mol].F[DISP][YDIR][O] - WSIN; 
-            VAR[mol].F[DISP][ZDIR][O] = xrand(0, BOXL); 
+            VAR[mol].F[DISP][YDIR][O] = xrand(0, BOXL);
+            VAR[mol].F[DISP][YDIR][H1] = VAR[mol].F[DISP][YDIR][O] + WSIN;
+            VAR[mol].F[DISP][YDIR][H2] = VAR[mol].F[DISP][YDIR][O] - WSIN;
+            VAR[mol].F[DISP][ZDIR][O] = xrand(0, BOXL);
             VAR[mol].F[DISP][ZDIR][H1] = VAR[mol].F[DISP][ZDIR][O];
             VAR[mol].F[DISP][ZDIR][H2] = VAR[mol].F[DISP][ZDIR][O];
         }
@@ -97,7 +93,7 @@
            lattice.  This is the default and the prefered initialization
            since random does not necessarily make sense from the viewpoint
            of preserving bond distances */
-        
+
         fprintf(six, "***** NEW RUN STARTING FROM REGULAR LATTICE *****\n");
         fflush(six);
         XT[2] = ZERO;
@@ -123,17 +119,17 @@
             }
             XT[2]=XT[2]+XS;
         }
-        
+
         if (NMOL != mol) {
-            printf("Lattice init error: total mol %d != NMOL %d\n", mol, NMOL);
+            printf("Lattice init error: total mol %ld != NMOL %ld\n", mol, NMOL);
             exit(-1);
         }
 #endif
     }
-    
+
     /* ASSIGN RANDOM MOMENTA */
     fscanf(random_numbers,"%lf",&SUX);
-    
+
     SUMX=0.0;
     SUMY=0.0;
     SUMZ=0.0;
@@ -153,12 +149,12 @@
             }
         } /* atoms */
     } /* molecules */
-    
+
     /* find average momenta per atom */
     SUMX=SUMX/(NATOMS*NMOL);
     SUMY=SUMY/(NATOMS*NMOL);
     SUMZ=SUMZ/(NATOMS*NMOL);
-    
+
     /*  find normalization factor so that <k.e.>=KT/2  */
     SUX=0.0;
     SUY=0.0;
@@ -167,11 +163,11 @@
         SUX = SUX + (pow( (VAR[mol].F[VEL][XDIR][H1] - SUMX),2.0)
                      +pow( (VAR[mol].F[VEL][XDIR][H2] - SUMX),2.0))/HMAS
                          +pow( (VAR[mol].F[VEL][XDIR][O]  - SUMX),2.0)/OMAS;
-        
+
         SUY = SUY + (pow( (VAR[mol].F[VEL][YDIR][H1] - SUMY),2.0)
                      +pow( (VAR[mol].F[VEL][YDIR][H2] - SUMY),2.0))/HMAS
                          +pow( (VAR[mol].F[VEL][YDIR][O]  - SUMY),2.0)/OMAS;
-        
+
         SUZ = SUZ + (pow( (VAR[mol].F[VEL][ZDIR][H1] - SUMZ),2.0)
                      +pow( (VAR[mol].F[VEL][ZDIR][H2] - SUMZ),2.0))/HMAS
                          +pow( (VAR[mol].F[VEL][ZDIR][O]  - SUMZ),2.0)/OMAS;
@@ -180,7 +176,7 @@
     SUX=sqrt(FAC/SUX);
     SUY=sqrt(FAC/SUY);
     SUZ=sqrt(FAC/SUZ);
-    
+
     /* normalize individual velocities so that there are no bulk
        momenta  */
     XMAS[1]=OMAS;
@@ -194,21 +190,19 @@
                                            SUMZ) * SUZ/XMAS[atom];
         } /* for atom */
     } /* for mol */
-    
+
     fclose(random_numbers);
-    
+
 } /* end of subroutine INITIA */
 
 /*
  * XRAND: generate floating-point random number.
  */
 
-double xrand(xl, xh)
-  double xl, xh;				/* lower, upper bounds on number */
+double xrand(double xl, double xh)
 {
-    long random ();
     double x;
-    
-    x=(xl + (xh - xl) * ((double) random()) / 2147483647.0);
+
+    x=(xl + (xh - xl) * ((double) rand()) / 2147483647.0);
     return (x);
 }
diff -Naur splash2/codes/apps/water-nsquared/interf.C splash2-modified/codes/apps/water-nsquared/interf.C
--- splash2/codes/apps/water-nsquared/interf.C	1994-10-14 03:46:42.000000000 -0400
+++ splash2-modified/codes/apps/water-nsquared/interf.C	2007-03-22 18:22:48.000000000 -0400
@@ -25,7 +25,7 @@
 #include "split.h"
 #include "global.h"
 
-extern double ****PFORCES;
+double ****PFORCES;
 
 /* in this version of interf, a private force array is maintained */
 /* for every process.  A process computes interactions into its   */
@@ -33,50 +33,47 @@
 /* array with locks, but only updates those locations that it     */
 /* computed something for                                         */
 
-INTERF(DEST,VIR,ProcID)
-  int DEST;
-  double *VIR;
-  unsigned ProcID;
+void INTERF(long DEST, double *VIR, long ProcID)
 {
     /* This routine gets called both from main() and from mdmain().
        When called from main(), it is used to estimate the initial
        accelerations by computing intermolecular forces.  When called
        from mdmain(), it is used to compute intermolecular forces.
-       The parameter DEST specifies whether results go into the 
+       The parameter DEST specifies whether results go into the
        accelerations or the forces. Uses routine UPDATE_FORCES in this
        file, and routine CSHIFT in file cshift.U */
     /*
       .....this routine calculates inter-molecular interaction forces
       the distances are arranged in the order  M-M, M-H1, M-H3, H1-M,
-      H3-M, H1-H3, H1-H1, H3-H1, H3-H3, O-O, O-H1, O-H3, H1-O, H3-O, 
+      H3-M, H1-H3, H1-H1, H3-H1, H3-H3, O-O, O-H1, O-H3, H1-O, H3-O,
       where the M are "centers" of the molecules.
       */
-    
-    int mol, comp, dir, icomp;
-    int comp_last, half_mol;
-    int    KC, K;
+
+    long mol, comp, dir, icomp;
+    long comp_last, half_mol;
+    long    KC, K;
     double YL[15], XL[15], ZL[15], RS[15], FF[15], RL[15]; /* per-
                                                               interaction arrays that hold some computed distances */
     double  FTEMP;
     double LVIR = 0.0;
     double *temp_p;
-    
+
     { /* initialize PFORCES array */
-        
-        int ct1,ct2,ct3;
-        
+
+        long ct1,ct2,ct3;
+
         for (ct1 = 0; ct1<NMOL; ct1++)
             for (ct2 = 0; ct2<NDIR; ct2++)
-                for (ct3 = 0; ct3<NATOM; ct3++) 
-                    PFORCES[ProcID][ct1][ct2][ct3] = 0; 
-        
-    } 
-    
+                for (ct3 = 0; ct3<NATOM; ct3++)
+                    PFORCES[ProcID][ct1][ct2][ct3] = 0;
+
+    }
+
     half_mol = NMOL/2;
     for (mol = StartMol[ProcID]; mol < StartMol[ProcID+1]; mol++) {
         comp_last = mol + half_mol;
         if (NMOL%2 == 0) {
-            if ((half_mol <= mol) && (mol%2 == 0)) { 
+            if ((half_mol <= mol) && (mol%2 == 0)) {
                 comp_last--;
             }
             if ((mol < half_mol) && (comp_last%2 == 1)) {
@@ -86,36 +83,36 @@
         for (icomp = mol+1; icomp <= comp_last; icomp++) {
             comp = icomp;
             if (comp > NMOL1) comp = comp%NMOL;
-            
+
             /*  compute some intermolecular distances */
-            
+
             CSHIFT(VAR[mol].F[DISP][XDIR],VAR[comp].F[DISP][XDIR],
                    VAR[mol].VM[XDIR],VAR[comp].VM[XDIR],XL,BOXH,BOXL);
             CSHIFT(VAR[mol].F[DISP][YDIR],VAR[comp].F[DISP][YDIR],
                    VAR[mol].VM[YDIR],VAR[comp].VM[YDIR],YL,BOXH,BOXL);
             CSHIFT(VAR[mol].F[DISP][ZDIR],VAR[comp].F[DISP][ZDIR],
                    VAR[mol].VM[ZDIR],VAR[comp].VM[ZDIR],ZL,BOXH,BOXL);
-            
+
             KC=0;
             for (K = 0; K < 9; K++) {
                 RS[K]=XL[K]*XL[K]+YL[K]*YL[K]+ZL[K]*ZL[K];
-                if (RS[K] > CUT2) 
+                if (RS[K] > CUT2)
                     KC++;
             } /* for K */
-            
+
             if (KC != 9) {
-                for (K = 0; K < 14; K++) 
+                for (K = 0; K < 14; K++)
                     FF[K]=0.0;
                 if (RS[0] < CUT2) {
                     FF[0]=QQ4/(RS[0]*sqrt(RS[0]))+REF4;
                     LVIR = LVIR + FF[0]*RS[0];
                 } /* if */
                 for (K = 1; K < 5; K++) {
-                    if (RS[K] < CUT2) { 
+                    if (RS[K] < CUT2) {
                         FF[K]= -QQ2/(RS[K]*sqrt(RS[K]))-REF2;
                         LVIR = LVIR + FF[K]*RS[K];
                     } /* if */
-                    if (RS[K+4] <= CUT2) { 
+                    if (RS[K+4] <= CUT2) {
                         RL[K+4]=sqrt(RS[K+4]);
                         FF[K+4]=QQ/(RS[K+4]*RL[K+4])+REF1;
                         LVIR = LVIR + FF[K+4]*RS[K+4];
@@ -126,7 +123,7 @@
                     RL[9]=sqrt(RS[9]);
                     FF[9]=AB1*exp(-B1*RL[9])/RL[9];
                     LVIR = LVIR + FF[9]*RS[9];
-                    for (K = 10; K < 14; K++) { 
+                    for (K = 10; K < 14; K++) {
                         FTEMP=AB2*exp(-B2*RL[K-5])/RL[K-5];
                         FF[K-5]=FF[K-5]+FTEMP;
                         LVIR= LVIR+FTEMP*RS[K-5];
@@ -136,26 +133,26 @@
                         LVIR = LVIR + FF[K]*RS[K];
                     } /* for K */
                 } /* if KC == 0 */
-                
+
                 UPDATE_FORCES(mol, comp, XL, YL, ZL, FF, ProcID);
-                
-            }  /* if KC != 9 */  
+
+            }  /* if KC != 9 */
         } /* for comp */
     } /* for mol */
-    
-    /*  accumulate the running sum from private 
+
+    /*  accumulate the running sum from private
         per-interaction partial sums   */
     LOCK(gl->InterfVirLock);
     *VIR = *VIR + LVIR;
     UNLOCK(gl->InterfVirLock);
-    
+
     /* at the end of the above force-computation, comp_last */
     /* contains the number of the last molecule (no modulo) */
     /* that this process touched                            */
-    
+
     if (comp_last > NMOL1) {
         for (mol = StartMol[ProcID]; mol < NMOL; mol++) {
-            ALOCK(gl->MolLock, mol % MAXLCKS); 
+            ALOCK(gl->MolLock, mol % MAXLCKS);
             for ( dir = XDIR; dir  <= ZDIR; dir++) {
                 temp_p = VAR[mol].F[DEST][dir];
                 temp_p[H1] += PFORCES[ProcID][mol][dir][H1];
@@ -166,7 +163,7 @@
         }
         comp = comp_last % NMOL;
         for (mol = 0; ((mol <= comp) && (mol < StartMol[ProcID])); mol++) {
-            ALOCK(gl->MolLock, mol % MAXLCKS); 
+            ALOCK(gl->MolLock, mol % MAXLCKS);
             for ( dir = XDIR; dir  <= ZDIR; dir++) {
                 temp_p = VAR[mol].F[DEST][dir];
                 temp_p[H1] += PFORCES[ProcID][mol][dir][H1];
@@ -178,7 +175,7 @@
     }
     else{
         for (mol = StartMol[ProcID]; mol <= comp_last; mol++) {
-            ALOCK(gl->MolLock, mol % MAXLCKS); 
+            ALOCK(gl->MolLock, mol % MAXLCKS);
             for ( dir = XDIR; dir  <= ZDIR; dir++) {
                 temp_p = VAR[mol].F[DEST][dir];
                 temp_p[H1] += PFORCES[ProcID][mol][dir][H1];
@@ -188,13 +185,13 @@
             AULOCK(gl->MolLock, mol % MAXLCKS);
         }
     }
-    
+
     /* wait till all forces are updated */
-    
+
     BARRIER(gl->InterfBar, NumProcs);
-    
+
     /* divide final forces by masses */
-    
+
     for (mol = StartMol[ProcID]; mol < StartMol[ProcID+1]; mol++) {
         for ( dir = XDIR; dir  <= ZDIR; dir++) {
             temp_p = VAR[mol].F[DEST][dir];
@@ -203,29 +200,26 @@
             temp_p[H2] = temp_p[H2] * FHM;
         } /* for dir */
     } /* for mol */
-    
+
 }/* end of subroutine INTERF */
 
-UPDATE_FORCES(mol, comp, XL, YL, ZL, FF, ProcID)
-  /* from the computed distances etc., compute the 
-     intermolecular forces and update the force (or 
+  /* from the computed distances etc., compute the
+     intermolecular forces and update the force (or
      acceleration) locations */
-  int mol, comp;
-  double XL[], YL[], ZL[], FF[];
-  unsigned ProcID;
+void UPDATE_FORCES(long mol, long comp, double *XL, double *YL, double *ZL, double *FF, long ProcID)
 {
-    int K;
+    long K;
     double G110[3], G23[3], G45[3], TT1[3], TT[3], TT2[3];
     double GG[15][3];
     double *tx_p, *ty_p, *tz_p;
-    
+
     /*   CALCULATE X-COMPONENT FORCES */
     for (K = 0; K < 14; K++)  {
         GG[K+1][XDIR] = FF[K]*XL[K];
         GG[K+1][YDIR] = FF[K]*YL[K];
         GG[K+1][ZDIR] = FF[K]*ZL[K];
     }
-    
+
     G110[XDIR] = GG[10][XDIR]+GG[1][XDIR]*C1;
     G110[YDIR] = GG[10][YDIR]+GG[1][YDIR]*C1;
     G110[ZDIR] = GG[10][ZDIR]+GG[1][ZDIR]*C1;
@@ -248,17 +242,17 @@
     tx_p = PFORCES[ProcID][mol][XDIR];
     ty_p = PFORCES[ProcID][mol][YDIR];
     tz_p = PFORCES[ProcID][mol][ZDIR];
-    tx_p[H1] += 
+    tx_p[H1] +=
         GG[6][XDIR]+GG[7][XDIR]+GG[13][XDIR]+TT[XDIR]+GG[4][XDIR];
     tx_p[O] +=
         G110[XDIR] + GG[11][XDIR] +GG[12][XDIR]+C1*G23[XDIR];
     tx_p[H2] +=
         GG[8][XDIR]+GG[9][XDIR]+GG[14][XDIR]+TT[XDIR]+GG[5][XDIR];
-    ty_p[H1] += 
+    ty_p[H1] +=
         GG[6][YDIR]+GG[7][YDIR]+GG[13][YDIR]+TT[YDIR]+GG[4][YDIR];
-    ty_p[O]  += 
+    ty_p[O]  +=
         G110[YDIR]+GG[11][YDIR]+GG[12][YDIR]+C1*G23[YDIR];
-    ty_p[H2] += 
+    ty_p[H2] +=
         GG[8][YDIR]+GG[9][YDIR]+GG[14][YDIR]+TT[YDIR]+GG[5][YDIR];
     tz_p[H1] +=
         GG[6][ZDIR]+GG[7][ZDIR]+GG[13][ZDIR]+TT[ZDIR]+GG[4][ZDIR];
@@ -266,7 +260,7 @@
         G110[ZDIR]+GG[11][ZDIR]+GG[12][ZDIR]+C1*G23[ZDIR];
     tz_p[H2] +=
         GG[8][ZDIR]+GG[9][ZDIR]+GG[14][ZDIR]+TT[ZDIR]+GG[5][ZDIR];
-    
+
     tx_p = PFORCES[ProcID][comp][XDIR];
     ty_p = PFORCES[ProcID][comp][YDIR];
     tz_p = PFORCES[ProcID][comp][ZDIR];
@@ -276,11 +270,11 @@
         -G110[XDIR]-GG[13][XDIR]-GG[14][XDIR]-C1*G45[XDIR];
     tx_p[H2] +=
         -GG[7][XDIR]-GG[9][XDIR]-GG[12][XDIR]-TT2[XDIR]-GG[3][XDIR];
-    ty_p[H1] += 
+    ty_p[H1] +=
         -GG[6][YDIR]-GG[8][YDIR]-GG[11][YDIR]-TT2[YDIR]-GG[2][YDIR];
-    ty_p[O] += 
+    ty_p[O] +=
         -G110[YDIR]-GG[13][YDIR]-GG[14][YDIR]-C1*G45[YDIR];
-    ty_p[H2] += 
+    ty_p[H2] +=
         -GG[7][YDIR]-GG[9][YDIR]-GG[12][YDIR]-TT2[YDIR]-GG[3][YDIR];
     tz_p[H1] +=
         -GG[6][ZDIR]-GG[8][ZDIR]-GG[11][ZDIR]-TT2[ZDIR]-GG[2][ZDIR];
@@ -289,6 +283,3 @@
     tz_p[H2] +=
         -GG[7][ZDIR]-GG[9][ZDIR]-GG[12][ZDIR]-TT2[ZDIR]-GG[3][ZDIR];
 }           /* end of subroutine UPDATE_FORCES */
-
-
-
diff -Naur splash2/codes/apps/water-nsquared/intraf.C splash2-modified/codes/apps/water-nsquared/intraf.C
--- splash2/codes/apps/water-nsquared/intraf.C	1994-10-14 03:46:42.000000000 -0400
+++ splash2-modified/codes/apps/water-nsquared/intraf.C	2007-03-22 15:32:14.000000000 -0400
@@ -25,26 +25,24 @@
 #include "split.h"
 #include "global.h"
 
-INTRAF(VIR,ProcID)
-  double *VIR;
-  unsigned ProcID;
+void INTRAF(double *VIR, long ProcID)
 {
     /*
       .....this routine calculates the intra-molecular force/mass acting on
-      each atom. 
+      each atom.
       FC11, FC12, FC13, AND FC33 are the quardratic force constants
       FC111, FC112, ....... ETC. are the cubic      force constants
       FC1111, FC1112 ...... ETC. are the quartic    force constants
       */
-    
+
     double SUM, R1, R2, VR1[4], VR2[4], COS, SIN;
     double DT, DTS, DR1, DR1S, DR2, DR2S, R1S, R2S, DR11[4], DR23[4];
     double DT1[4], DT3[4], F1, F2, F3, T1, T2;
-    int mol, dir, atom;
-    double LVIR;  /* process keeps a local copy of the sum, 
+    long mol, dir, atom;
+    double LVIR;  /* process keeps a local copy of the sum,
                      to reduce synchronized updates*/
     double *temp_p;
-    
+
     /* loop through the molecules */
     for (mol = StartMol[ProcID]; mol < StartMol[ProcID+1];  mol++) {
         SUM=0.0;
@@ -62,11 +60,11 @@
             R2 += VR2[dir] * VR2[dir];
             SUM += VR1[dir] * VR2[dir];
         } /* for dir */
-        
+
         R1=sqrt(R1);
         R2=sqrt(R2);
-        
-        /* calculate cos(THETA), sin(THETA), delta(R1), 
+
+        /* calculate cos(THETA), sin(THETA), delta(R1),
            delta(R2), and delta(THETA) */
         COS=SUM/(R1*R2);
         SIN=sqrt(ONE-COS*COS);
@@ -76,9 +74,9 @@
         DR1S=DR1*DR1;
         DR2=R2-ROH;
         DR2S=DR2*DR2;
-        
+
         /* calculate derivatives of R1/X1, R2/X3, THETA/X1, and THETA/X3 */
-        
+
         R1S=ROH/(R1*SIN);
         R2S=ROH/(R2*SIN);
         for (dir = XDIR; dir <= ZDIR; dir++) {
@@ -87,7 +85,7 @@
             DT1[dir]=(-DR23[dir]+DR11[dir]*COS)*R1S;
             DT3[dir]=(-DR11[dir]+DR23[dir]*COS)*R2S;
         } /* for dir */
-        
+
         /* calculate forces */
         F1=FC11*DR1+FC12*DR2+FC13*DT;
         F2=FC33*DT +FC13*(DR1+DR2);
@@ -110,8 +108,8 @@
                *DR1+2.0*FC1122*DR1S*DR2+3.0*FC1113*DR2S*DT
                +FC1123*(2.0*DR2+DR1)*DR1*DT+(2.0*FC1133*DR2
                                              +FC1233*DR1+FC1333*DT)*DTS)*ROHI2;
-        
-        for (dir = XDIR; dir <= ZDIR; dir++) { 
+
+        for (dir = XDIR; dir <= ZDIR; dir++) {
             temp_p = VAR[mol].F[FORCES][dir];
             T1=F1*DR11[dir]+F2*DT1[dir];
             temp_p[H1] = T1;
@@ -120,20 +118,18 @@
             temp_p[O] = -(T1+T2);
         } /* for dir */
     } /* for mol */
-    
-    /* calculate summation of the product of the displacement and computed 
+
+    /* calculate summation of the product of the displacement and computed
        force for every molecule, direction, and atom */
-    
+
     LVIR=0.0;
     for (mol = StartMol[ProcID]; mol < StartMol[ProcID+1];  mol++)
         for ( dir = XDIR; dir <= ZDIR; dir++)
             for (atom = 0; atom < NATOM; atom++)
-                LVIR += VAR[mol].F[DISP][dir][atom] * 
-                    VAR[mol].F[FORCES][dir][atom];	
-    
+                LVIR += VAR[mol].F[DISP][dir][atom] *
+                    VAR[mol].F[FORCES][dir][atom];
+
     LOCK(gl->IntrafVirLock);
     *VIR =  *VIR + LVIR;
     UNLOCK(gl->IntrafVirLock);
 } /* end of subroutine INTRAF */
-
-
diff -Naur splash2/codes/apps/water-nsquared/kineti.C splash2-modified/codes/apps/water-nsquared/kineti.C
--- splash2/codes/apps/water-nsquared/kineti.C	1994-10-14 03:46:42.000000000 -0400
+++ splash2-modified/codes/apps/water-nsquared/kineti.C	2007-03-22 15:45:04.000000000 -0400
@@ -22,25 +22,19 @@
 #include "split.h"
 #include "global.h"
 
-KINETI(NMOL,SUM,HMAS,OMAS,ProcID)
-  int NMOL;
-  double HMAS,OMAS;
-  double SUM[];
-  unsigned ProcID;
-  
-  /* this routine computes kinetic energy in each of the three
-     spatial dimensions, and puts the computed values in the
-     SUM array */ 
+  /* this routine computes kinetic energy in each of the three spatial
+     dimensions, and puts the computed values in the SUM array */
+void KINETI(double *SUM, double HMAS, double OMAS, long ProcID)
 {
-    int dir, mol;
+    long dir, mol;
     double S;
-    
+
     /* loop over the three directions */
     for (dir = XDIR; dir <= ZDIR; dir++) {
         S=0.0;
         /* loop over the molecules */
         for (mol = StartMol[ProcID]; mol < StartMol[ProcID+1]; mol++) {
-            double *tempptr = VAR[mol].F[VEL][dir]; 
+            double *tempptr = VAR[mol].F[VEL][dir];
             S += ( tempptr[H1] * tempptr[H1] +
                   tempptr[H2] * tempptr[H2] ) * HMAS
                       + (tempptr[O] * tempptr[O]) * OMAS;
diff -Naur splash2/codes/apps/water-nsquared/makefile splash2-modified/codes/apps/water-nsquared/makefile
--- splash2/codes/apps/water-nsquared/makefile	1994-11-13 17:49:05.000000000 -0500
+++ splash2-modified/codes/apps/water-nsquared/makefile	1969-12-31 19:00:00.000000000 -0500
@@ -1,46 +0,0 @@
-TARGET = WATER-NSQUARED
-
-OBJS = water.o mdmain.o syscons.o kineti.o bndry.o cnstnt.o initia.o \
-       interf.o intraf.o cshift.o poteng.o predcor.o
-CFLAGS = -O2 -Olimit 2000
-LDFLAGS = -lm 
-MACROS = ../../../null_macros/c.m4.null
-
-x = *
-
-
-.SUFFIXES:
-.SUFFIXES: .o .S .s .c .C .U .h .H
-
-.H.h:
-	m4 $(MACROS) $*.H > $*.h
-.C.c:
-	m4 $(MACROS) $*.C > $*.c
-.c.o:
-	cc -c $(CFLAGS) $*.c
-.C.o:
-	m4 $(MACROS) $*.C > $*.c
-	cc -c $(CFLAGS) $*.c
-
-$(TARGET): $(OBJS)
-	cc $(OBJS) $(CFLAGS) -o $(TARGET) $(LDFLAGS)
-
-cnstnt.c: cnstnt.C water.h wwpot.h cnst.h frcnst.h fileio.h parameters.h
-water.c: water.C parameters.h mdvar.h water.h wwpot.h cnst.h mddata.h \
-         fileio.h frcnst.h randno.h global.h split.h
-mdmain.c: mdmain.C  parameters.h mdvar.h water.h wwpot.h cnst.h \
-          mddata.h fileio.h frcnst.h randno.h global.h split.h
-syscons.c: syscons.C parameters.h mdvar.h water.h wwpot.h cnst.h mddata.h
-kineti.c: kineti.C global.h split.h mdvar.h parameters.h mddata.h
-bndry.c: bndry.C split.h mdvar.h parameters.h mddata.h
-initia.c: initia.C split.h mdvar.h water.h cnst.h fileio.h \
-           parameters.h mddata.h
-predcor.c: predcor.C split.h mdvar.h parameters.h mddata.h
-intraf.c: intraf.C frcnst.h mdvar.h water.h wwpot.h parameters.h \
-           mddata.h global.h split.h
-interf.c: interf.C mdvar.h water.h wwpot.h cnst.h global.h split.h \
-           parameters.h mddata.h
-cshift.c: cshift.C water.h
-poteng.c: poteng.C global.h split.h mdvar.h frcnst.h water.h wwpot.h \
-           parameters.h mddata.h
-
diff -Naur splash2/codes/apps/water-nsquared/Makefile splash2-modified/codes/apps/water-nsquared/Makefile
--- splash2/codes/apps/water-nsquared/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ splash2-modified/codes/apps/water-nsquared/Makefile	2007-03-22 18:23:48.000000000 -0400
@@ -0,0 +1,17 @@
+TARGET = WATER-NSQUARED
+OBJS = bndry.o cnstnt.o cshift.o initia.o interf.o intraf.o kineti.o mdmain.o poteng.o predcor.o syscons.o water.o
+
+include ../../Makefile.config
+
+bndry.o: bndry.C split.h mdvar.h parameters.h mddata.h global.h
+cnstnt.o: cnstnt.C water.h wwpot.h cnst.h frcnst.h fileio.h parameters.h global.h
+cshift.o: cshift.C water.h global.h
+initia.o: initia.C split.h mdvar.h water.h cnst.h fileio.h parameters.h mddata.h global.h
+interf.o: interf.C mdvar.h water.h wwpot.h cnst.h global.h split.h parameters.h mddata.h
+intraf.o: intraf.C frcnst.h mdvar.h water.h wwpot.h parameters.h mddata.h global.h split.h
+kineti.o: kineti.C global.h split.h mdvar.h parameters.h mddata.h
+mdmain.o: mdmain.C  parameters.h mdvar.h water.h wwpot.h cnst.h mddata.h fileio.h frcnst.h randno.h global.h split.h
+poteng.o: poteng.C global.h split.h mdvar.h frcnst.h water.h wwpot.h parameters.h mddata.h
+predcor.o: predcor.C split.h mdvar.h parameters.h mddata.h global.h
+syscons.o: syscons.C parameters.h mdvar.h water.h wwpot.h cnst.h mddata.h global.h
+water.o: water.C parameters.h mdvar.h water.h wwpot.h cnst.h mddata.h fileio.h frcnst.h randno.h global.h split.h
diff -Naur splash2/codes/apps/water-nsquared/mddata.H splash2-modified/codes/apps/water-nsquared/mddata.H
--- splash2/codes/apps/water-nsquared/mddata.H	1994-10-14 03:46:42.000000000 -0400
+++ splash2-modified/codes/apps/water-nsquared/mddata.H	2007-03-22 14:43:46.000000000 -0400
@@ -16,14 +16,14 @@
 
   /* this file contains the declarations of the main data
   structure types used by the program */
-  
+
   /* per molecule, there are 3*8 = 24 bytes for the VM array */
   /* and 9*3*3*8 = 648 bytes for the F array 		   */
-  /* that is, a total of 672 bytes		           */	
-  
+  /* that is, a total of 672 bytes		           */
+
   /* then there is some global memory, defined in global.H   */
   /* which mainly consists of an array of locks, one per mol */
-  
+
   /* PRIVATE DATA:  Every process has a private array of computed  */
   /* interactions, PFORCES, defined in interf.C.  The size of this */
   /* is nmol*3*3*8 = 72 * nmol bytes				 */
@@ -33,22 +33,22 @@
   /* These arrays are of size 15*8 = 120 bytes each, for a total   */
   /* of 720 bytes.  therefore per process data are                 */
   /* (72 * nmol) + 720 bytes.                                      */
-  
-  typedef double vm_type[3];
-  
-  typedef struct mol_dummy {
+
+typedef double vm_type[3];
+
+typedef struct mol_dummy {
       vm_type VM;
       double F[MXOD2][NDIR][NATOM];
-  } molecule_type;
-  
-  extern molecule_type *VAR;
-  
-  extern double ****PFORCES;
-  
-  extern double  TLC[100], FPOT, FKIN;
-  
+} molecule_type;
+
+extern molecule_type *VAR;
+
+extern double ****PFORCES;
+
+extern double  TLC[100], FPOT, FKIN;
+
 #define MAXPROCS 128
-  
-  extern int StartMol[MAXPROCS+1];
-  extern int MolsPerProc;
-  extern int NumProcs;
+
+extern long StartMol[MAXPROCS+1];
+extern long MolsPerProc;
+extern long NumProcs;
diff -Naur splash2/codes/apps/water-nsquared/mdmain.C splash2-modified/codes/apps/water-nsquared/mdmain.C
--- splash2/codes/apps/water-nsquared/mdmain.C	1995-09-26 20:02:09.000000000 -0400
+++ splash2-modified/codes/apps/water-nsquared/mdmain.C	2007-03-22 16:03:03.000000000 -0400
@@ -27,48 +27,43 @@
 #include "global.h"
 
 /************************************************************************/
-double  MDMAIN(NFSV,NFRST,NSTEP,NRST,NPRINT,NSAVE,LKT,NORD1,ProcID)
-  
-  /* routine that implements the time-steps. Called by main routine 
-     and calls others */
-  
-  int NFSV,NFRST,NSTEP,NRST,NPRINT,NSAVE,LKT,NORD1;
-  unsigned ProcID;
-  
+
+/* routine that implements the time-steps. Called by main routine and calls others */
+double MDMAIN(long NSTEP, long NPRINT, long NSAVE, long NORD1, long ProcID)
 {
     double XTT;
-    int i;
+    long i;
     double POTA,POTR,POTRF;
     double XVIR,AVGT,TEN;
     double TTMV = 0.0, TKIN = 0.0, TVIR = 0.0;
-    
+
     /*.......ESTIMATE ACCELERATION FROM F/M */
     INTRAF(&gl->VIR,ProcID);
-    
+
     BARRIER(gl->start, NumProcs);
-    
+
     INTERF(ACC,&gl->VIR,ProcID);
-    
+
     BARRIER(gl->start, NumProcs);
-    
+
     /* MOLECULAR DYNAMICS LOOP OVER ALL TIME-STEPS */
-    
+
     for (i=1;i <= NSTEP; i++) {
         TTMV=TTMV+1.00;
-        
+
         /* reset simulator stats at beginning of second time-step */
-        
-        /* POSSIBLE ENHANCEMENT:  Here's where one start measurements to avoid 
+
+        /* POSSIBLE ENHANCEMENT:  Here's where one start measurements to avoid
            cold-start effects.  Recommended to do this at the beginning of the
            second timestep; i.e. if (i == 2).
            */
-        
+
         /* initialize various shared sums */
         if (ProcID == 0) {
-            int dir;
+            long dir;
             if (i >= 2) {
                 CLOCK(gl->trackstart);
-            }                
+            }
             gl->VIR = 0.0;
             gl->POTA = 0.0;
             gl->POTR = 0.0;
@@ -76,99 +71,99 @@
             for (dir = XDIR; dir <= ZDIR; dir++)
                 gl->SUM[dir] = 0.0;
         }
-        
+
         if ((ProcID == 0) && (i >= 2)) {
             CLOCK(gl->intrastart);
         }
-        
+
         BARRIER(gl->start, NumProcs);
         PREDIC(TLC,NORD1,ProcID);
         INTRAF(&gl->VIR,ProcID);
         BARRIER(gl->start, NumProcs);
-        
+
         if ((ProcID == 0) && (i >= 2)) {
             CLOCK(gl->intraend);
             gl->intratime += gl->intraend - gl->intrastart;
         }
-        
-        
+
+
         if ((ProcID == 0) && (i >= 2)) {
             CLOCK(gl->interstart);
         }
-        
+
         INTERF(FORCES,&gl->VIR,ProcID);
-        
+
         if ((ProcID == 0) && (i >= 2)) {
             CLOCK(gl->interend);
             gl->intertime += gl->interend - gl->interstart;
         }
-        
+
         if ((ProcID == 0) && (i >= 2)) {
             CLOCK(gl->intrastart);
         }
-        
+
         CORREC(PCC,NORD1,ProcID);
-        
+
         BNDRY(ProcID);
-        
-        KINETI(NMOL,gl->SUM,HMAS,OMAS,ProcID);
-        
+
+        KINETI(gl->SUM,HMAS,OMAS,ProcID);
+
         BARRIER(gl->start, NumProcs);
-        
+
         if ((ProcID == 0) && (i >= 2)) {
             CLOCK(gl->intraend);
             gl->intratime += gl->intraend - gl->intrastart;
         }
-        
+
         TKIN=TKIN+gl->SUM[0]+gl->SUM[1]+gl->SUM[2];
         TVIR=TVIR-gl->VIR;
-        
+
         /*  check if potential energy is to be computed, and if
             printing and/or saving is to be done, this time step.
             Note that potential energy is computed once every NPRINT
             time-steps */
-        
+
         if (((i % NPRINT) == 0) || ( (NSAVE > 0) && ((i % NSAVE) == 0))){
-            
+
             if ((ProcID == 0) && (i >= 2)) {
                 CLOCK(gl->interstart);
             }
-            
+
             /*  call potential energy computing routine */
             POTENG(&gl->POTA,&gl->POTR,&gl->POTRF,ProcID);
             BARRIER(gl->start, NumProcs);
-            
+
             if ((ProcID == 0) && (i >= 2)) {
                 CLOCK(gl->interend);
                 gl->intertime += gl->interend - gl->interstart;
             }
-            
+
             POTA=gl->POTA*FPOT;
             POTR=gl->POTR*FPOT;
             POTRF=gl->POTRF*FPOT;
-            
+
             /* compute some values to print */
             XVIR=TVIR*FPOT*0.50/TTMV;
             AVGT=TKIN*FKIN*TEMP*2.00/(3.00*TTMV);
             TEN=(gl->SUM[0]+gl->SUM[1]+gl->SUM[2])*FKIN;
             XTT=POTA+POTR+POTRF+TEN;
-            
+
             if ((i % NPRINT) == 0 && ProcID == 0) {
-                fprintf(six,"     %5d %14.5lf %12.5lf %12.5lf  \
+                fprintf(six,"     %5ld %14.5lf %12.5lf %12.5lf  \
                 %12.5lf\n %16.3lf %16.5lf %16.5lf\n",
                         i,TEN,POTA,POTR,POTRF,XTT,AVGT,XVIR);
             }
         }
-        
+
         /* wait for everyone to finish time-step */
         BARRIER(gl->start, NumProcs);
-        
+
         if ((ProcID == 0) && (i >= 2)) {
             CLOCK(gl->trackend);
             gl->tracktime += gl->trackend - gl->trackstart;
         }
     } /* for i */
-    
+
     return(XTT);
-    
+
 } /* end of subroutine MDMAIN */
diff -Naur splash2/codes/apps/water-nsquared/mdvar.H splash2-modified/codes/apps/water-nsquared/mdvar.H
--- splash2/codes/apps/water-nsquared/mdvar.H	1994-10-14 03:46:42.000000000 -0400
+++ splash2-modified/codes/apps/water-nsquared/mdvar.H	2007-03-22 14:42:54.000000000 -0400
@@ -15,6 +15,6 @@
 /*************************************************************************/
 
   /* some variable declarations */
-  
-  extern double  TEMP,RHO,TSTEP,BOXL,BOXH,CUTOFF,CUT2;
-  extern int    NMOL,NORDER,NATMO,NATMO3,NMOL1;
+
+extern double  TEMP,RHO,TSTEP,BOXL,BOXH,CUTOFF,CUT2;
+extern long    NMOL,NORDER,NATMO,NATMO3,NMOL1;
diff -Naur splash2/codes/apps/water-nsquared/poteng.C splash2-modified/codes/apps/water-nsquared/poteng.C
--- splash2/codes/apps/water-nsquared/poteng.C	1994-10-14 03:46:42.000000000 -0400
+++ splash2-modified/codes/apps/water-nsquared/poteng.C	2007-03-22 15:28:06.000000000 -0400
@@ -25,25 +25,23 @@
 #include "split.h"
 #include "global.h"
 
-POTENG(POTA,POTR,PTRF,ProcID)
-  double *POTA, *POTR, *PTRF;     /* some shared sums computed by POTENG */
-  unsigned ProcID;
+void POTENG(double *POTA, double *POTR, double *PTRF, long ProcID)
 {
-    
+
     /*
       this routine calculates the potential energy of the system.
       FC11 ,FC12, FC13, and FC33 are the quardratic force constants
       */
-    
-    int mol,comp;
-    int half_mol;
-    int    KC, K;
-    double R1, R2, RX, COS, DT, DR1, DR2, DR1S, DR2S, DRP, DRS;
+
+    long mol,comp;
+    long half_mol;
+    long    KC, K;
+    double R1, R2, RX, COS, DT, DR1, DR2, DR1S, DR2S, DRP;
     double XL[15], YL[15], ZL[15], RS[15], RL[15];
     double DTS;
     double LPOTA, LPOTR, LPTRF;
     double *tx_p, *ty_p, *tz_p;
-    
+
     /*  compute intra-molecular potential energy */
     LPOTA=0.0;
     for (mol = StartMol[ProcID]; mol < StartMol[ProcID+1]; mol++) {
@@ -52,25 +50,25 @@
         ty_p = VAR[mol].F[DISP][YDIR];
         tz_p = VAR[mol].F[DISP][ZDIR];
         VAR[mol].VM[XDIR] = C1 * tx_p[ O] +
-            C2 * (tx_p[H1] + 
+            C2 * (tx_p[H1] +
                   tx_p[H2] );
         VAR[mol].VM[YDIR] = C1*ty_p[O] +
-            C2*(ty_p[H1] + 
+            C2*(ty_p[H1] +
                 ty_p[H2] );
         VAR[mol].VM[ZDIR] = C1*tz_p[O] +
-            C2*(tz_p[H1] + 
+            C2*(tz_p[H1] +
                 tz_p[H2] );
         dx1 = tx_p[O]-tx_p[H1];
         dy1 = ty_p[O]-ty_p[H1];
-        dz1 = tz_p[O]-tz_p[H1]; 
-        
+        dz1 = tz_p[O]-tz_p[H1];
+
         dx2 = tx_p[O]-tx_p[H2];
         dy2 = ty_p[O]-ty_p[H2];
-        dz2 = tz_p[O]-tz_p[H2]; 
+        dz2 = tz_p[O]-tz_p[H2];
         R1 = dx1*dx1 + dy1*dy1 + dz1*dz1;
-        R2 = dx2*dx2 + dy2*dy2 + dz2*dz2; 
+        R2 = dx2*dx2 + dy2*dy2 + dz2*dz2;
         RX = dx1*dx2 + dy1*dy2 + dz1*dz2;
-        
+
         R1=sqrt(R1);
         R2=sqrt(R2);
         COS=RX/(R1*R2);
@@ -91,18 +89,18 @@
                   FC1133*(DR1S+DR2S)*DTS+FC1233*DR1*DR2*DTS+
                   FC1333*DRP*DTS*DT)*ROHI2;
     } /* for mol */
-    
+
     BARRIER(gl->PotengBar, NumProcs);
-    
+
     /*  compute inter-molecular potential energy */
     LPOTR=0.0;
     LPTRF=0.0;
     half_mol = NMOL/2;
     for (mol = StartMol[ProcID]; mol < StartMol[ProcID+1]; mol++) {
-        int comp_last = mol + half_mol;
-        int icomp;
+        long comp_last = mol + half_mol;
+        long icomp;
         if (NMOL%2 == 0) {
-            if ((half_mol <= mol) && (mol%2 == 0)) { 
+            if ((half_mol <= mol) && (mol%2 == 0)) {
                 comp_last--;
             }
             if ((mol < half_mol) && (comp_last%2 == 1)) {
@@ -121,7 +119,7 @@
             KC=0;
             for (K = 0; K < 9; K++) {
                 RS[K]=XL[K]*XL[K]+YL[K]*YL[K]+ZL[K]*ZL[K];
-                if (RS[K] > CUT2) 
+                if (RS[K] > CUT2)
                     KC=KC+1;
             } /* for k */
             if (KC != 9) {
@@ -139,7 +137,7 @@
                         +QQ4/RL[0];
                 LPTRF= LPTRF-REF2*RS[0]-REF1*((RS[5]+RS[6]+RS[7]+RS[8])*0.5
                                               -RS[1]-RS[2]-RS[3]-RS[4]);
-                
+
                 if (KC <= 0) {
                     for (K = 9; K <  14; K++) {
                         RL[K]=sqrt(XL[K]*XL[K]+YL[K]*YL[K]+ZL[K]*ZL[K]);
@@ -155,7 +153,7 @@
             } /* if KC != 9 */
         } /* for comp */
     } /* for mol */
-    
+
     /* update shared sums from computed  private sums */
     LOCK(gl->PotengSumLock);
     *POTA = *POTA + LPOTA;
diff -Naur splash2/codes/apps/water-nsquared/predcor.C splash2-modified/codes/apps/water-nsquared/predcor.C
--- splash2/codes/apps/water-nsquared/predcor.C	1994-10-14 03:46:43.000000000 -0400
+++ splash2-modified/codes/apps/water-nsquared/predcor.C	2007-03-22 15:25:47.000000000 -0400
@@ -19,21 +19,22 @@
 #include "parameters.h"
 #include "mddata.h"
 #include "split.h"
+#include "global.h"
 
-PREDIC(C,NOR1,ProcID)  /* predicts new values for displacement and its five
-                          derivatives */
-  double C[];
-  int NOR1;       /* NOR1 = NORDER + 1 = 7 (for a sixth-order method) */
-  unsigned ProcID;
+/* predicts new values for displacement and its five derivatives
+ *
+ * NOR1 : NOR1 = NORDER + 1 = 7 (for a sixth-order method)
+ */
+void PREDIC(double *C, long NOR1, long ProcID)
 {
     /*   this routine calculates predicted F(X), F'(X), F''(X), ... */
-    
-    int JIZ;
-    int  JI;
-    int  L;
+
+    long JIZ;
+    long  JI;
+    long  L;
     double S;
-    int func, mol, dir, atom;
-    
+    long func, mol, dir, atom;
+
     JIZ=2;
     /* .....loop over F(X), F'(X), F''(X), ..... */
     for (func = 0; func < NORDER; func++) {
@@ -53,31 +54,32 @@
     } /* for func */
 } /* end of subroutine PREDIC */
 
-CORREC(PCC,NOR1,ProcID)    /* corrects the predicted values, based on forces
-                              etc. computed in the interim */
-  double PCC[];       /* the predictor-corrector constants */
-  int NOR1;           /* NORDER + 1 = 7 for a sixth-order method) */
-  unsigned ProcID;
+/* corrects the predicted values, based on forces etc. computed in the interim
+ *
+ * PCC : the predictor-corrector constants
+ * NOR1: NORDER + 1 = 7 for a sixth-order method)
+ */
+
+void CORREC(double *PCC, long NOR1, long ProcID)
 {
     /*
       .....this routine calculates corrected F(X), F'(X), F"(X), ....
       from corrected F(X) = predicted F(X) + PCC(1)*(FR-SD)
-      where SD is predicted accl. F"(X) and FR is computed 
+      where SD is predicted accl. F"(X) and FR is computed
       accl. (force/mass) at predicted position
       */
-    
+
     double Y;
-    int mol, dir, atom, func;
-    
+    long mol, dir, atom, func;
+
     for (mol = StartMol[ProcID]; mol < StartMol[ProcID+1]; mol++) {
         for (dir = 0; dir < NDIR; dir++) {
             for (atom = 0; atom < NATOM; atom++) {
                 Y = VAR[mol].F[FORCES][dir][atom] - VAR[mol].F[ACC][dir][atom];
-                for ( func = 0; func < NOR1; func++) 
-                    VAR[mol].F[func][dir][atom] += PCC[func] * Y;   
-            } /* for atom */		
+                for ( func = 0; func < NOR1; func++)
+                    VAR[mol].F[func][dir][atom] += PCC[func] * Y;
+            } /* for atom */
         } /* for dir */
     } /* for mol */
-    
-} /* end of subroutine CORREC */
 
+} /* end of subroutine CORREC */
diff -Naur splash2/codes/apps/water-nsquared/randno.H splash2-modified/codes/apps/water-nsquared/randno.H
--- splash2/codes/apps/water-nsquared/randno.H	1994-10-14 03:46:43.000000000 -0400
+++ splash2-modified/codes/apps/water-nsquared/randno.H	2007-03-22 14:42:10.000000000 -0400
@@ -15,6 +15,6 @@
 /*************************************************************************/
 
   /* variable declarations needed for random numbers */
-  
-  extern double R3[128],R1;
-  extern int I2;
+
+extern double R3[128],R1;
+extern long I2;
diff -Naur splash2/codes/apps/water-nsquared/syscons.C splash2-modified/codes/apps/water-nsquared/syscons.C
--- splash2/codes/apps/water-nsquared/syscons.C	1994-10-14 03:46:43.000000000 -0400
+++ splash2-modified/codes/apps/water-nsquared/syscons.C	2007-03-22 15:21:28.000000000 -0400
@@ -14,6 +14,7 @@
 /*                                                                       */
 /*************************************************************************/
 
+EXTERN_ENV
 #include "stdio.h"
 #include <math.h>
 
@@ -23,8 +24,9 @@
 #include "wwpot.h"
 #include "cnst.h"
 #include "mddata.h"
+#include "global.h"
 
-SYSCNS()                    /* sets up some system constants */
+void SYSCNS()                    /* sets up some system constants */
 {
     TSTEP=TSTEP/UNITT;        /* time between steps */
     NATMO=NATOMS*NMOL;        /* total number of atoms in system */
@@ -35,27 +37,27 @@
                                                         length of the cubical "box".  Note that box size is
                                                         computed as being large enough to handle the input
                                                         number of water molecules */
-    
+
     BOXL=BOXL/UNITL;    /* normalized length of computational box */
-    
-    BOXH=BOXL*0.50; /* half the box length, used in 
+
+    BOXH=BOXL*0.50; /* half the box length, used in
                        computing cutoff radius */
-    
+
     if (CUTOFF == 0.0) {
-        CUTOFF=max(BOXH,CUTOFF);    /* cutoff radius is max of BOXH 
+        CUTOFF=max(BOXH,CUTOFF);    /* cutoff radius is max of BOXH
                                        and default (= 0); i.e. CUTOFF
                                        radius is set to half the normalized
                                        box length */
     }
-    if (CUTOFF > 11.0) CUTOFF = 11.0; /* cutoff never greater than 11 
+    if (CUTOFF > 11.0) CUTOFF = 11.0; /* cutoff never greater than 11
 					  Angstrom*/
-    
+
     REF1= -QQ/(CUTOFF*CUTOFF*CUTOFF);
     REF2=2.00*REF1;
     REF4=2.00*REF2;
-    CUT2=CUTOFF*CUTOFF;       /* square of cutoff radius,  used 
-                                 to actually decide whether an 
-                                 interaction should be computed in 
+    CUT2=CUTOFF*CUTOFF;       /* square of cutoff radius,  used
+                                 to actually decide whether an
+                                 interaction should be computed in
                                  INTERF and POTENG */
     FHM=(TSTEP*TSTEP*0.50)/HMAS;
     FOM=(TSTEP*TSTEP*0.50)/OMAS;
diff -Naur splash2/codes/apps/water-nsquared/water.C splash2-modified/codes/apps/water-nsquared/water.C
--- splash2/codes/apps/water-nsquared/water.C	1994-10-14 03:48:30.000000000 -0400
+++ splash2-modified/codes/apps/water-nsquared/water.C	2007-06-21 18:13:56.000000000 -0400
@@ -15,10 +15,10 @@
 /*************************************************************************/
 
 /*  Usage:   water < infile,
-    where infile has 10 fields which can be described in order as 
+    where infile has 10 fields which can be described in order as
     follows:
-    
-    TSTEP:   the physical time interval (in sec) between timesteps.  
+
+    TSTEP:   the physical time interval (in sec) between timesteps.
     Good default is 1e-15.
     NMOL:    the number of molecules to be simulated.
     NSTEP:   the number of timesteps to be simulated.
@@ -26,29 +26,29 @@
     set this to 6.
     NSAVE:   the frequency with which to save data in data collection.
     Set to 0 always.
-    NRST:    the frequency with which to write RST file: set to 0 always (not used). 
-    NPRINT:  the frequency with which to compute potential energy. 
+    NRST:    the frequency with which to write RST file: set to 0 always (not used).
+    NPRINT:  the frequency with which to compute potential energy.
     i.e. the routine POTENG is called every NPRINT timesteps.
     It also computes intermolecular as well as intramolecular
     interactions, and hence is very expensive.
     NFMC:    Not used (historical artifact).  Set to anything, say 0.
     NumProcs: the number of processors to be used.
-    CUTOFF:  the cutoff radius to be used (in Angstrom, 
+    CUTOFF:  the cutoff radius to be used (in Angstrom,
     floating-point).  In a real simulation, this
-    will be set to 0 here in which case the program will 
-    compute it itself (and set it to about 11 Angstrom.   
+    will be set to 0 here in which case the program will
+    compute it itself (and set it to about 11 Angstrom.
     It can be set by the user if they want
     to use an artificially small cutoff radius, for example
-    to control the number of boxes created for small problems 
-    (and not have fewer boxes than processors).  
+    to control the number of boxes created for small problems
+    (and not have fewer boxes than processors).
     */
 
 MAIN_ENV
-#include "stdio.h"
+#include <stdio.h>
+#include <string.h>
 #include "split.h"
 
 /*  include files for declarations  */
-#define extern
 #include "parameters.h"
 #include "mdvar.h"
 #include "water.h"
@@ -58,38 +58,47 @@
 #include "fileio.h"
 #include "frcnst.h"
 #include "global.h"
-/* #undef extern */
+
+long NMOL,NORDER,NATMO,NATMO3,NMOL1;
+long NATOMS;
+long I2;
+
+double TLC[100], FPOT, FKIN;
+double TEMP,RHO,TSTEP,BOXL,BOXH,CUTOFF,CUT2;
+double R3[128],R1;
+double UNITT,UNITL,UNITM,BOLTZ,AVGNO,PCC[11];
+double OMAS,HMAS,WTMOL,ROH,ANGLE,FHM,FOM,ROHI,ROHI2;
+double QQ,A1,B1,A2,B2,A3,B3,A4,B4,AB1,AB2,AB3,AB4,C1,C2,QQ2,QQ4,REF1,REF2,REF4;
+double FC11,FC12,FC13,FC33,FC111,FC333,FC112,FC113,FC123,FC133,FC1111,FC3333,FC1112,FC1122,FC1113,FC1123,FC1133,FC1233,FC1333;
+
+FILE *six;
+
+molecule_type *VAR;
 
 struct GlobalMemory *gl;        /* pointer to the Global Memory
                                    structure, which contains the lock,
                                    barrier, and some scalar variables */
 
 
-int NSTEP, NSAVE, NRST, NPRINT,NFMC;
-int NORD1;
-int II;                         /*  variables explained in common.h */
-int i;
-int NDATA;
-int   NFRST=11;
-int  NFSV=10;
-int  LKT=0;
+long NSTEP, NSAVE, NRST, NPRINT,NFMC;
+long NORD1;
+long II;                         /*  variables explained in common.h */
+long i;
+long NDATA;
+long NFRST=11;
+long NFSV=10;
+long LKT=0;
 
-int StartMol[MAXPROCS+1];       /* number of the first molecule
+long StartMol[MAXPROCS+1];       /* number of the first molecule
                                    to be handled by this process; used
-                                   for static scheduling     */ 
-int MolsPerProc;                /* number of mols per processor */ 
-int NumProcs;                   /* number of processors being used; 
+                                   for static scheduling     */
+long MolsPerProc;                /* number of mols per processor */
+long NumProcs;                   /* number of processors being used;
                                    run-time input           */
+double XTT;
 
-void WorkStart();
-
-main(argc, argv)
-  char **argv;
+int main(int argc, char **argv)
 {
-    int mol, func, dir, atom;
-    double XTT, MDMAIN();
-    unsigned ProcID = 0;
-    
     /* default values for the control parameters of the driver */
     /* are in parameters.h */
 
@@ -97,69 +106,69 @@
         printf("Usage:  WATER-NSQUARED < infile, where the contents of infile can be\nobtained from the comments at the top of water.C and the first scanf \nin main() in water.C\n\n");
         exit(0);
     }
-    
-    /*  POSSIBLE ENHANCEMENT:  Here's where one might bind the main process 
-        (process 0) to a processor if one wanted to. Others can be bound in 
+
+    /*  POSSIBLE ENHANCEMENT:  Here's where one might bind the main process
+        (process 0) to a processor if one wanted to. Others can be bound in
         the WorkStart routine.
         */
-    
+
     six = stdout;   /* output file */
-    
+
     TEMP  =298.0;
     RHO   =0.9980;
     CUTOFF=0.0;
-    
+
     /* read input */
-    
-    if (scanf("%lf%d%d%d%d%d%d%d%d%lf",&TSTEP, &NMOL, &NSTEP, &NORDER, 
+
+    if (scanf("%lf%ld%ld%ld%ld%ld%ld%ld%ld%lf",&TSTEP, &NMOL, &NSTEP, &NORDER,
               &NSAVE, &NRST, &NPRINT, &NFMC,&NumProcs, &CUTOFF) != 10)
         fprintf(stderr,"ERROR: Usage: water < infile, which must have 10 fields, see SPLASH documentation or comment at top of water.C\n");
-    
+
     if (NMOL > MAXLCKS) {
-        fprintf(stderr, "Just so you know ... Lock array in global.H has size %d < %d (NMOL)\n code will still run correctly but there may be lock contention\n\n", MAXLCKS, NMOL);
+        fprintf(stderr, "Just so you know ... Lock array in global.H has size %ld < %ld (NMOL)\n code will still run correctly but there may be lock contention\n\n", MAXLCKS, NMOL);
     }
-    
-    printf("Using %d procs on %d steps of %d mols\n", NumProcs, NSTEP, NMOL);
-    printf("Other parameters:\n\tTSTEP = %8.2e\n\tNORDER = %d\n\tNSAVE = %d\n",TSTEP,NORDER,NSAVE);
-    printf("\tNRST = %d\n\tNPRINT = %d\n\tNFMC = %d\n\tCUTOFF = %lf\n\n",NRST,NPRINT,NFMC,CUTOFF);
-    
-    
+
+    printf("Using %ld procs on %ld steps of %ld mols\n", NumProcs, NSTEP, NMOL);
+    printf("Other parameters:\n\tTSTEP = %8.2e\n\tNORDER = %ld\n\tNSAVE = %ld\n",TSTEP,NORDER,NSAVE);
+    printf("\tNRST = %ld\n\tNPRINT = %ld\n\tNFMC = %ld\n\tCUTOFF = %lf\n\n",NRST,NPRINT,NFMC,CUTOFF);
+
+
     /* SET UP SCALING FACTORS AND CONSTANTS */
-    
+
     NORD1=NORDER+1;
-    
+
     CNSTNT(NORD1,TLC);  /* sub. call to set up constants */
-    
-    
+
+
     { /* Do memory initializations */
-        int pid;
-        unsigned mol_size = sizeof(molecule_type) * NMOL;
-        unsigned gmem_size = sizeof(struct GlobalMemory);
-        
-        /*  POSSIBLE ENHANCEMENT:  One might bind the first process to 
-            a processor here, even before the other (child) processes are 
-            bound later in mdmain(). 
+        long pid;
+        long mol_size = sizeof(molecule_type) * NMOL;
+        long gmem_size = sizeof(struct GlobalMemory);
+
+        /*  POSSIBLE ENHANCEMENT:  One might bind the first process to
+            a processor here, even before the other (child) processes are
+            bound later in mdmain().
             */
-        
+
         MAIN_INITENV(,70000000,);  /* macro call to initialize
                                       shared memory etc. */
-        
+
         /* allocate space for main (VAR) data structure as well as
            synchronization variables */
-        
+
         /*  POSSIBLE ENHANCEMENT: One might want to allocate a process's
-            portion of the VAR array and what it points to in its local 
+            portion of the VAR array and what it points to in its local
             memory */
-        
+
         VAR = (molecule_type *) G_MALLOC(mol_size);
         gl = (struct GlobalMemory *) G_MALLOC(gmem_size);
-        
+
         /*  POSSIBLE ENHANCEMENT: One might want to allocate  process i's
             PFORCES[i] array in its local memory */
-        
+
         PFORCES = (double ****) G_MALLOC(NumProcs * sizeof (double ***));
-        { int i,j,k;
-          
+        { long i,j,k;
+
           for (i = 0; i < NumProcs; i++) {
               PFORCES[i] = (double ***) G_MALLOC(NMOL * sizeof (double **));
               for (j = 0; j < NMOL; j++) {
@@ -171,10 +180,10 @@
           }
       }
         /* macro calls to initialize synch varibles  */
-        
-        BARINIT(gl->start);
-        BARINIT(gl->InterfBar);
-        BARINIT(gl->PotengBar);
+
+        BARINIT(gl->start, NumProcs);
+	BARINIT(gl->InterfBar, NumProcs);
+	BARINIT(gl->PotengBar, NumProcs);
         LOCKINIT(gl->IOLock);
         LOCKINIT(gl->IndexLock);
         LOCKINIT(gl->IntrafVirLock);
@@ -190,9 +199,9 @@
         }
         LOCKINIT(gl->KinetiSumLock);
         LOCKINIT(gl->PotengSumLock);
-        
+
         /* set up control for static scheduling */
-        
+
         MolsPerProc = NMOL/NumProcs;
         StartMol[0] = 0;
         for (pid = 1; pid < NumProcs; pid += 1) {
@@ -200,87 +209,83 @@
         }
         StartMol[NumProcs] = NMOL;
     }
-    
+
     SYSCNS();    /* sub. call to initialize system constants  */
-    
+
     fprintf(six,"\nTEMPERATURE                = %8.2f K\n",TEMP);
     fprintf(six,"DENSITY                    = %8.5f G/C.C.\n",RHO);
-    fprintf(six,"NUMBER OF MOLECULES        = %8d\n",NMOL);
-    fprintf(six,"NUMBER OF PROCESSORS       = %8d\n",NumProcs);
+    fprintf(six,"NUMBER OF MOLECULES        = %8ld\n",NMOL);
+    fprintf(six,"NUMBER OF PROCESSORS       = %8ld\n",NumProcs);
     fprintf(six,"TIME STEP                  = %8.2e SEC\n",TSTEP);
-    fprintf(six,"ORDER USED TO SOLVE F=MA   = %8d \n",NORDER);
-    fprintf(six,"NO. OF TIME STEPS          = %8d \n",NSTEP);
-    fprintf(six,"FREQUENCY OF DATA SAVING   = %8d \n",NSAVE);
-    fprintf(six,"FREQUENCY TO WRITE RST FILE= %8d \n",NRST);
+    fprintf(six,"ORDER USED TO SOLVE F=MA   = %8ld \n",NORDER);
+    fprintf(six,"NO. OF TIME STEPS          = %8ld \n",NSTEP);
+    fprintf(six,"FREQUENCY OF DATA SAVING   = %8ld \n",NSAVE);
+    fprintf(six,"FREQUENCY TO WRITE RST FILE= %8ld \n",NRST);
     fprintf(six,"SPHERICAL CUTOFF RADIUS    = %8.4f ANGSTROM\n",CUTOFF);
     fflush(six);
-    
-    
+
+
     /* initialization routine; also reads displacements and
        sets up random velocities*/
     INITIA();
-    
+
     /*.....start molecular dynamic loop */
-    
+
     gl->tracktime = 0;
     gl->intratime = 0;
     gl->intertime = 0;
-    
-    /* initialize Index to 1 so that the first created child gets 
+
+    /* initialize Index to 1 so that the first created child gets
        id 1, not 0 */
-    
+
     gl->Index = 1;
-    
-    /* spawn helper processes, each getting its unique process id */
-    CLOCK(gl->createstart);
-    for (ProcID = 1; ProcID < NumProcs; ProcID += 1) {
-        CREATE(WorkStart);
-    }
-    CLOCK(gl->createend);
-    LOCK(gl->IOLock);
-    printf("CREATETIME = %d\n",gl->createend-gl->createstart);
-    UNLOCK(gl->IOLock);
-    
+
     if (NSAVE > 0)  /* not true for input decks provided */
-        fprintf(six,"COLLECTING X AND V DATA AT EVERY %4d TIME STEPS \n",NSAVE);
-    
-    /* call routine to do the timesteps, with own id passed as 0 */
+	fprintf(six,"COLLECTING X AND V DATA AT EVERY %4ld TIME STEPS \n",NSAVE);
+
+    /* spawn helper processes, each getting its unique process id */
     CLOCK(gl->computestart);
-    
-    XTT = MDMAIN(NFSV,NFRST,NSTEP,NRST,NPRINT,NSAVE,LKT,NORD1,0); 
-    
+    CREATE(WorkStart, NumProcs);
+
     /* macro to make main process wait for all others to finish */
-    WAIT_FOR_END(NumProcs-1)
-        CLOCK(gl->computeend);
-    
-    printf("COMPUTESTART (after initialization) = %u\n",gl->computestart);
-    printf("COMPUTEEND = %u\n",gl->computeend);
-    printf("COMPUTETIME (after initialization) = %u\n",gl->computeend-gl->computestart);
-    printf("Measured Time (2nd timestep onward) = %u\n",gl->tracktime);
-    printf("Intramolecular time only (2nd timestep onward) = %u\n",gl->intratime);
-    printf("Intermolecular time only (2nd timestep onward) = %u\n",gl->intertime);
-    printf("Other time (2nd timestep onward) = %u\n",gl->tracktime - gl->intratime - gl->intertime);
-    
+    WAIT_FOR_END(NumProcs);
+    CLOCK(gl->computeend);
+
+    printf("COMPUTESTART (after initialization) = %lu\n",gl->computestart);
+    printf("COMPUTEEND = %lu\n",gl->computeend);
+    printf("COMPUTETIME (after initialization) = %lu\n",gl->computeend-gl->computestart);
+    printf("Measured Time (2nd timestep onward) = %lu\n",gl->tracktime);
+    printf("Intramolecular time only (2nd timestep onward) = %lu\n",gl->intratime);
+    printf("Intermolecular time only (2nd timestep onward) = %lu\n",gl->intertime);
+    printf("Other time (2nd timestep onward) = %lu\n",gl->tracktime - gl->intratime - gl->intertime);
+
     printf("\nExited Happily with XTT = %g (note: XTT value is garbage if NPRINT > NSTEP)\n", XTT);
-    
+
     MAIN_END;
 } /* main.c */
 
 void WorkStart() /* routine that each created process starts at;
                     it simply calls the timestep routine */
 {
-    unsigned ProcID;
-    double MDMAIN();
-    
+    long ProcID;
+    double LocalXTT;
+
     LOCK(gl->IndexLock);
     ProcID = gl->Index++;
     UNLOCK(gl->IndexLock);
-    
-    ProcID = ProcID % NumProcs; 
-    
-    /*  POSSIBLE ENHANCEMENT:  Here's where one might bind processes 
+
+    BARINCLUDE(gl->start);
+    BARINCLUDE(gl->InterfBar);
+    BARINCLUDE(gl->PotengBar);
+
+    ProcID = ProcID % NumProcs;
+
+    /*  POSSIBLE ENHANCEMENT:  Here's where one might bind processes
         to processors if one wanted to.
         */
-    
-    MDMAIN(NFSV,NFRST,NSTEP,NRST,NPRINT,NSAVE,LKT,NORD1,ProcID);
+
+    LocalXTT = MDMAIN(NSTEP,NPRINT,NSAVE,NORD1,ProcID);
+    if (ProcID == 0) {
+	    XTT = LocalXTT;
+    }
 }
diff -Naur splash2/codes/apps/water-nsquared/water.H splash2-modified/codes/apps/water-nsquared/water.H
--- splash2/codes/apps/water-nsquared/water.H	1994-10-14 03:46:43.000000000 -0400
+++ splash2-modified/codes/apps/water-nsquared/water.H	2007-03-22 14:40:25.000000000 -0400
@@ -15,9 +15,9 @@
 /*************************************************************************/
 
   /* some variable declarations and some macro definitions */
-  
-  extern double OMAS,HMAS,WTMOL,ROH,ANGLE,FHM,FOM,ROHI,ROHI2;
-  extern int NATOMS;
+
+extern double OMAS,HMAS,WTMOL,ROH,ANGLE,FHM,FOM,ROHI,ROHI2;
+extern long NATOMS;
 #define max(a,b) ( (a) < (b) ) ? b : a
 #define min(a,b) ( (a) > (b) ) ? b : a
 #define ONE ((double) 1)
diff -Naur splash2/codes/apps/water-nsquared/wwpot.H splash2-modified/codes/apps/water-nsquared/wwpot.H
--- splash2/codes/apps/water-nsquared/wwpot.H	1994-10-14 03:46:43.000000000 -0400
+++ splash2-modified/codes/apps/water-nsquared/wwpot.H	2007-03-22 14:40:14.000000000 -0400
@@ -14,7 +14,6 @@
 /*                                                                       */
 /*************************************************************************/
 
-  /* some variable declarations */
-  
-  extern double  QQ,A1,B1,A2,B2,A3,B3,A4,B4,AB1,AB2,AB3,AB4,C1,C2,
-  QQ2,QQ4,REF1,REF2,REF4;
+/* some variable declarations */
+
+extern double  QQ,A1,B1,A2,B2,A3,B3,A4,B4,AB1,AB2,AB3,AB4,C1,C2,QQ2,QQ4,REF1,REF2,REF4;
diff -Naur splash2/codes/apps/water-spatial/bndry.C splash2-modified/codes/apps/water-spatial/bndry.C
--- splash2/codes/apps/water-spatial/bndry.C	1994-10-14 01:33:52.000000000 -0400
+++ splash2-modified/codes/apps/water-spatial/bndry.C	2007-03-22 19:24:59.000000000 -0400
@@ -17,46 +17,43 @@
 EXTERN_ENV
 
 #include <stdio.h>
-#include "global.h"
 #include "mdvar.h"
 #include "parameters.h"
 #include "mddata.h"
 #include "split.h"
+#include "global.h"
 
-
-BNDRY(ProcID)     /* this routine puts the molecules back inside the box if
-                     they are out */
-  unsigned ProcID;
+void BNDRY(long ProcID)     /* this routine puts the molecules back inside the box if they are out */
 {
-    int i, j, k, dir; 
-    int X_INDEX, Y_INDEX, Z_INDEX;
+    long i, j, k, dir;
+    long X_INDEX, Y_INDEX, Z_INDEX;
     struct link *curr_ptr, *last_ptr, *next_ptr, *temp_ptr;
     struct list_of_boxes *curr_box;
     double *extra_p;
-    
+
     /* for each box */
     curr_box = my_boxes[ProcID];
     while (curr_box) {
         i = curr_box->coord[XDIR];  /* X coordinate of box */
         j = curr_box->coord[YDIR];  /* Y coordinate of box */
         k = curr_box->coord[ZDIR];  /* Z coordinate of box */
-        
+
         last_ptr = NULL;
         curr_ptr = BOX[i][j][k].list;
-        
+
         /* Go through molecules in current box */
-        
-        while (curr_ptr) {  
+
+        while (curr_ptr) {
             next_ptr = curr_ptr->next_mol;
-            
+
             /* for each direction */
-            
+
             for ( dir = XDIR; dir <= ZDIR; dir++ ) {
                 extra_p = curr_ptr->mol.F[DISP][dir];
-                
+
                 /* if the oxygen atom is out of the box */
                 if (extra_p[O] > BOXL ) {
-                    
+
                     /* move all three atoms back in the box */
                     extra_p[H1] -= BOXL;
                     extra_p[O]  -= BOXL;
@@ -66,41 +63,40 @@
                     extra_p[H1] += BOXL;
                     extra_p[O]  += BOXL;
                     extra_p[H2] += BOXL;
-                } 
+                }
             } /* for dir */
-            
+
             /* If O atom moves out of current box, put it in correct box */
-            X_INDEX = (int) (curr_ptr->mol.F[DISP][XDIR][O] / BOX_LENGTH);
-            Y_INDEX = (int) (curr_ptr->mol.F[DISP][YDIR][O] / BOX_LENGTH);
-            Z_INDEX = (int) (curr_ptr->mol.F[DISP][ZDIR][O] / BOX_LENGTH);
-            
-            if ((X_INDEX != i) || 
+            X_INDEX = (long) (curr_ptr->mol.F[DISP][XDIR][O] / BOX_LENGTH);
+            Y_INDEX = (long) (curr_ptr->mol.F[DISP][YDIR][O] / BOX_LENGTH);
+            Z_INDEX = (long) (curr_ptr->mol.F[DISP][ZDIR][O] / BOX_LENGTH);
+
+            if ((X_INDEX != i) ||
                 (Y_INDEX != j) ||
                 (Z_INDEX != k)) {
-                
+
                 /* Remove link from BOX[i][j][k] */
-                
+
                 LOCK(BOX[i][j][k].boxlock);
-                if (last_ptr != NULL) 
+                if (last_ptr != NULL)
                     last_ptr->next_mol = curr_ptr->next_mol;
                 else
                     BOX[i][j][k].list = curr_ptr->next_mol;
                 UNLOCK(BOX[i][j][k].boxlock);
-                
+
                 /* Add link to BOX[X_INDEX][Y_INDEX][Z_INDEX] */
-                
+
                 LOCK(BOX[X_INDEX][Y_INDEX][Z_INDEX].boxlock);
                 temp_ptr = BOX[X_INDEX][Y_INDEX][Z_INDEX].list;
                 BOX[X_INDEX][Y_INDEX][Z_INDEX].list = curr_ptr;
                 curr_ptr->next_mol = temp_ptr;
                 UNLOCK(BOX[X_INDEX][Y_INDEX][Z_INDEX].boxlock);
-                
+
             }
             else last_ptr = curr_ptr;
             curr_ptr = next_ptr;   /* Go to next molecule in current box */
         } /* while curr_ptr */
         curr_box = curr_box->next_box;
     } /* for curr_box */
-    
-} /* end of subroutine BNDRY */
 
+} /* end of subroutine BNDRY */
diff -Naur splash2/codes/apps/water-spatial/cnst.H splash2-modified/codes/apps/water-spatial/cnst.H
--- splash2/codes/apps/water-spatial/cnst.H	1994-10-14 01:36:45.000000000 -0400
+++ splash2-modified/codes/apps/water-spatial/cnst.H	2007-03-22 18:40:57.000000000 -0400
@@ -14,8 +14,8 @@
 /*                                                                       */
 /*************************************************************************/
 
-  /*  This file contains declarations for some variables 
-  that are initialized to constants in the program and 
-  then never modified */
-  
-  extern double UNITT,UNITL,UNITM,BOLTZ,AVGNO,PCC[11];
+/*  This file contains declarations for some variables
+that are initialized to constants in the program and
+then never modified */
+
+extern double UNITT,UNITL,UNITM,BOLTZ,AVGNO,PCC[11];
diff -Naur splash2/codes/apps/water-spatial/cnstnt.C splash2-modified/codes/apps/water-spatial/cnstnt.C
--- splash2/codes/apps/water-spatial/cnstnt.C	1994-10-14 01:33:52.000000000 -0400
+++ splash2-modified/codes/apps/water-spatial/cnstnt.C	2007-03-22 19:24:07.000000000 -0400
@@ -23,23 +23,22 @@
 #include "frcnst.h"
 #include "fileio.h"
 #include "parameters.h"
+#include "mddata.h"
+#include "global.h"
 
-
-CNSTNT(N,C)                     /* set up some constants;
-                                   this routine is executed by
-                                   a single processor before others
-                                   are created */
-  
-  int N;		/* NORDER + 1 = 7 for a sixth-order method*/
-  double* C; 	/* DIMENSION C(N,N) */
+/* set up some constants; this routine is executed by
+ * a single processor before others are created
+ *
+ * N : NORDER + 1 = 7 for a sixth-order method
+ * C : DIMENSION C(N,N)
+ */
+void CNSTNT(long N, double *C)
 {
-    int NN,N1,K1;
+    long NN,N1,K1;
     double TN,TK,CM;
-    
-    int i;
-    
+
     /* molecular constants for water in angstrom, radian, and a.m.u. */
-    
+
     NATOMS = 3;
     ROH = 0.9572;
     ROHI = ONE/ROH;
@@ -48,17 +47,17 @@
     OMAS = 15.99945;
     HMAS = 1.007825;
     WTMOL = OMAS+TWO*HMAS;
-    
+
     /* units used to scale variables (in c.g.s.) */
-    
+
     UNITT = 1.0e-15;
     UNITL = 1.0e-8;
     UNITM = 1.6605655e-24;
     BOLTZ = 1.380662e-16;
     AVGNO = 6.022045e23;
-    
+
     /* force constants scaled (divided) by (UNITM/UNITT**2) */
-    
+
     FC11 =  0.512596;
     FC33 =  0.048098;
     FC12 = -0.005823;
@@ -78,9 +77,9 @@
     FC1133 = -0.0048;
     FC1233 =  0.0211;
     FC1333 =  0.006263;
-    
+
     /* water-water interaction parameters */
-    
+
     QQ = 0.07152158;
     A1 = 455.313100;
     B1 = 5.15271070;
@@ -99,28 +98,28 @@
     C2 = 0.50*CM;
     QQ2 = 2.00*QQ;
     QQ4 = 2.00*QQ2;
-    
+
     /*  calculate the coefficients of taylor series expansion */
     /*     for F(X), F"(X), F""(X), ...... (with DELTAT**N/N] included) */
     /*     in C(1,1),..... C(1,2),..... C(1,3),....... */
-    
+
     C[1] = ONE;
-    for (N1=2;N1<=N;N1++) {  
+    for (N1=2;N1<=N;N1++) {
         NN = N1-1;
         TN = NN;
         C[N1] = ONE;
         TK = ONE;
-        for (K1=2;K1<=N1;K1++) { 
+        for (K1=2;K1<=N1;K1++) {
             C[(K1-1)*N+NN] = C[(K1-2)*N+NN+1]*TN/TK;
             NN = NN-1;
             TN = TN-ONE;
             TK = TK+ONE;
         }
     }
-    
-    
+
+
     /* predictor-corrector constants for 2nd order differential equation */
-    
+
     PCC[2] = ONE;
     N1 = N-1;
     switch(N1) {
diff -Naur splash2/codes/apps/water-spatial/cshift.C splash2-modified/codes/apps/water-spatial/cshift.C
--- splash2/codes/apps/water-spatial/cshift.C	1994-10-14 01:33:52.000000000 -0400
+++ splash2-modified/codes/apps/water-spatial/cshift.C	2007-03-22 19:19:28.000000000 -0400
@@ -16,29 +16,26 @@
 
 EXTERN_ENV
 
+#include <math.h>
 #include "parameters.h"
 #include "mddata.h"
 #include "water.h"
-#include <math.h>
+#include "global.h"
 
 /* return the value of a with the same sign as b */
-#define sign(a,b)  (b < 0 ) ? ( (a < 0) ? a : -a) : ( (a < 0) ? -a : a) 
+#define sign(a,b)  (b < 0 ) ? ( (a < 0) ? a : -a) : ( (a < 0) ? -a : a)
 
-CSHIFT(XA,XB,XMA,XMB,XL,BOXH,BOXL)
   /* compute some relevant distances between the two input molecules to
      this routine. If they are greater than the cutoff radius, compute
      these distances as if one of the particles were at its mirror image
      (periodic boundary conditions).
      Used by the intermolecular interactions routines */
-  
-  double XA[], XB[], XL[];
-  double BOXH, BOXL, XMA, XMB;
-  
+void CSHIFT(double *XA, double *XB, double XMA, double XMB, double *XL, double BOXH, double BOXL)
 {
-    int I;
-    
+    long I;
+
     /* Compute some intermolecular distances */
-    
+
     XL[0] = XMA-XMB;
     XL[1] = XMA-XB[0];
     XL[2] = XMA-XB[2];
@@ -53,7 +50,7 @@
     XL[11] = XA[1]-XB[2];
     XL[12] = XA[0]-XB[1];
     XL[13] = XA[2]-XB[1];
-    
+
     /* go through all 14 distances computed */
     for (I = 0; I <  14; I++) {
         /* if the value is greater than the cutoff radius */
@@ -61,6 +58,5 @@
             XL[I]  =  XL[I] -(sign(BOXL,XL[I]));
         }
     } /* for */
-    
-} /* end of subroutine CSHIFT */
 
+} /* end of subroutine CSHIFT */
diff -Naur splash2/codes/apps/water-spatial/fileio.H splash2-modified/codes/apps/water-spatial/fileio.H
--- splash2/codes/apps/water-spatial/fileio.H	1994-10-14 01:36:45.000000000 -0400
+++ splash2-modified/codes/apps/water-spatial/fileio.H	2007-03-22 18:40:29.000000000 -0400
@@ -14,9 +14,9 @@
 /*                                                                       */
 /*************************************************************************/
 
-  
-  /* sets up files for i/o to match the device numbers used
-  in the original FORTRAN program from the PERFECT Club */
-  
-  extern FILE *six;
-  
+
+/* sets up files for i/o to match the device numbers used
+in the original FORTRAN program from the PERFECT Club */
+
+extern FILE *six;
+
diff -Naur splash2/codes/apps/water-spatial/frcnst.H splash2-modified/codes/apps/water-spatial/frcnst.H
--- splash2/codes/apps/water-spatial/frcnst.H	1994-10-14 01:36:45.000000000 -0400
+++ splash2-modified/codes/apps/water-spatial/frcnst.H	2007-03-22 18:40:23.000000000 -0400
@@ -14,10 +14,8 @@
 /*                                                                       */
 /*************************************************************************/
 
-  /*  This file contains declarations for some variables 
-  needed for force calculation that are initialized in the program and 
-  then never modified */
-  
-  extern double FC11,FC12,FC13,FC33, FC111,FC333,FC112,FC113,
-  FC123,FC133, FC1111,FC3333,FC1112,
-  FC1122,FC1113,FC1123,FC1133,FC1233,FC1333;
+/*  This file contains declarations for some variables
+needed for force calculation that are initialized in the program and
+then never modified */
+
+extern double FC11,FC12,FC13,FC33,FC111,FC333,FC112,FC113,FC123,FC133,FC1111,FC3333,FC1112,FC1122,FC1113,FC1123,FC1133,FC1233,FC1333;
diff -Naur splash2/codes/apps/water-spatial/global.H splash2-modified/codes/apps/water-spatial/global.H
--- splash2/codes/apps/water-spatial/global.H	1994-10-14 01:36:45.000000000 -0400
+++ splash2-modified/codes/apps/water-spatial/global.H	2007-06-21 18:14:07.000000000 -0400
@@ -14,8 +14,8 @@
 /*                                                                       */
 /*************************************************************************/
 
-/*  This file contains the declaration of the GlobalMemory 
-structure and the maximum number of molecules allowed 
+/*  This file contains the declaration of the GlobalMemory
+structure and the maximum number of molecules allowed
 by the program. */
 
 struct GlobalMemory {
@@ -28,11 +28,11 @@
     BARDEC(start)
     BARDEC(InterfBar)
     BARDEC(PotengBar)
-    int Index;
+    long Index;
     double VIR;
     double SUM[3];
     double POTA, POTR, POTRF;
-    unsigned long createstart,createend,computestart,computeend;
+    unsigned long computestart,computeend;
     unsigned long trackstart, trackend, tracktime;
     unsigned long intrastart, intraend, intratime;
     unsigned long interstart, interend, intertime;
@@ -40,3 +40,41 @@
 
 extern struct GlobalMemory *gl;
 
+/* bndry.C */
+void BNDRY(long ProcID);
+
+/* cnstnt.C */
+void CNSTNT(long N, double *C);
+
+/* cshift.C */
+void CSHIFT(double *XA, double *XB, double XMA, double XMB, double *XL, double BOXH, double BOXL);
+
+/* initia.C */
+void INITIA(void);
+double xrand(double xl, double xh);
+
+/* interf.C */
+void INTERF(long DEST, double *VIR, long ProcID);
+void UPDATE_FORCES(struct link *link_ptr, long DEST, double *XL, double *YL, double *ZL, double *FF);
+
+/* intraf.C */
+void INTRAF(double *VIR, long ProcID);
+
+/* kineti.C */
+void KINETI(double *SUM, double HMAS, double OMAS, long ProcID);
+
+/* mdmain.C */
+double MDMAIN(long NSTEP, long NPRINT, long NSAVE, long NORD1, long ProcID);
+
+/* poteng.C */
+void POTENG(double *POTA, double *POTR, double *PTRF, long ProcID);
+
+/* predcor.C */
+void PREDIC(double *C, long NOR1, long ProcID);
+void CORREC(double *PCC, long NOR1, long ProcID);
+
+/* syscons.C */
+void SYSCNS(void);
+
+/* water.C */
+void WorkStart(void);
diff -Naur splash2/codes/apps/water-spatial/initia.C splash2-modified/codes/apps/water-spatial/initia.C
--- splash2/codes/apps/water-spatial/initia.C	1994-10-14 01:33:52.000000000 -0400
+++ splash2-modified/codes/apps/water-spatial/initia.C	2007-03-22 19:32:51.000000000 -0400
@@ -25,97 +25,94 @@
 #include "parameters.h"
 #include "mddata.h"
 #include "split.h"
+#include "global.h"
 
-
-INITIA()
+void INITIA()
 {
     /*   this routine initializes the positions of the molecules along
          a regular cubical lattice, and randomizes the initial velocities of
-         the atoms.  The random numbers used in the initialization of velocities 
+         the atoms.  The random numbers used in the initialization of velocities
          are read from the file random.in, which must be in the current working
          directory in which the program is run  */
-    
-    static double XMIN = 0;
-    static double YMIN = 0;
-    static double ZMIN = 0;
+
     FILE *random_numbers;       /* points to input file containing
                                    pseudo-random numbers for initializing
                                    velocities */
-    double XMAS[4], XS, ZERO, WCOS, WSIN, XT[4], YT[4], Z;
+    double XMAS[4];
     double SUX, SUY, SUZ, SUMX, SUMY, SUMZ, FAC;
-    int X_INDEX, Y_INDEX, Z_INDEX;
-    int mol=0;
-    int atom=0;
-    int i, j, k, ii, kk;
+    long X_INDEX, Y_INDEX, Z_INDEX;
+    long atom=0;
+    long i, j, k;
     struct link *link_ptr, *curr_ptr, *last_ptr;
-    double xrand();
-    int srandom();
-    int Part_per_box, Unassigned, m, pid;
-    
-    
-    random_numbers = fopen("random.in","r"); 
+#ifdef RANDOM
+    long Part_per_box, Unassigned, m, pid;
+#else
+    long mol = 0, XT[4], YT[4], Z;
+#endif
+
+    random_numbers = fopen("random.in","r");
     if (random_numbers == NULL) {
         fprintf(stderr,"Error in opening file random.in\n");
         fflush(stderr);
         exit(-1);
     }
-    
+
     XMAS[1]=sqrt(OMAS*HMAS);
     XMAS[0]=HMAS;
     XMAS[2]=HMAS;
-    
+
     /* .....assign positions */
-    
-    {   
-        int deriv;
-        
+
+    {
+        long deriv;
+
         double NS = pow((double) NMOL, 1.0/3.0) - 0.00000000000001;
         double XS = BOXL/NS;
         double ZERO = XS * 0.50;
         double WCOS = ROH * cos(ANGLE * 0.5);
         double WSIN = ROH * sin(ANGLE * 0.5);
-        
+
         printf("\nNS = %.16f\n",NS);
         printf("BOXL = %10f\n",BOXL);
         printf("CUTOFF = %10f\n",CUTOFF);
         printf("BOX_LENGTH = %10f\n",BOX_LENGTH);
-        printf("BOX_PER_SIDE = %d\n",BOX_PER_SIDE);
+        printf("BOX_PER_SIDE = %ld\n",BOX_PER_SIDE);
         printf("XS = %10f\n",XS);
         printf("ZERO = %g\n",ZERO);
         printf("WCOS = %f\n",WCOS);
         printf("WSIN = %f\n",WSIN);
         fflush(stdout);
-        
+
 #ifdef RANDOM
         /* if we want to initialize to a random distribution of displacements
            for the molecules, rather than a distribution along a regular lattice
            spaced according to intermolecular distances in water */
-        
-        srandom(1023);
+
+        srand(1023);
         fscanf(random_numbers,"%lf",&SUX);
-        
+
         SUMX=0.0;
         SUMY=0.0;
         SUMZ=0.0;
-        
+
         Part_per_box = NMOL / (BOX_PER_SIDE * BOX_PER_SIDE * BOX_PER_SIDE);
         Unassigned = NMOL - (Part_per_box * BOX_PER_SIDE * BOX_PER_SIDE * BOX_PER_SIDE);
-        printf("Part_per_box = %d, BOX_PER_SIDE = %d, Unassigned = %d\n",Part_per_box, BOX_PER_SIDE, Unassigned);
+        printf("Part_per_box = %ld, BOX_PER_SIDE = %ld, Unassigned = %ld\n",Part_per_box, BOX_PER_SIDE, Unassigned);
         for (i = 0; i < BOX_PER_SIDE; i++)
             for (j = 0; j < BOX_PER_SIDE; j++)
-                for (k = 0; k < BOX_PER_SIDE; k++) 
+                for (k = 0; k < BOX_PER_SIDE; k++)
                     for (m = 0; m < Part_per_box; m++) {
                         link_ptr = (struct link *) G_MALLOC(sizeof(link_type));
-                        link_ptr->mol.F[DISP][XDIR][O] = xrand(BOX_LENGTH * i, BOX_LENGTH * (i+1)); 
-                        link_ptr->mol.F[DISP][XDIR][H1] = link_ptr->mol.F[DISP][XDIR][O] + WCOS; 
+                        link_ptr->mol.F[DISP][XDIR][O] = xrand(BOX_LENGTH * i, BOX_LENGTH * (i+1));
+                        link_ptr->mol.F[DISP][XDIR][H1] = link_ptr->mol.F[DISP][XDIR][O] + WCOS;
                         link_ptr->mol.F[DISP][XDIR][H2] = link_ptr->mol.F[DISP][XDIR][H1];
-                        link_ptr->mol.F[DISP][YDIR][O] = xrand(BOX_LENGTH * j, BOX_LENGTH * (j+1)); 
-                        link_ptr->mol.F[DISP][YDIR][H1] = link_ptr->mol.F[DISP][YDIR][O] + WSIN; 
-                        link_ptr->mol.F[DISP][YDIR][H2] = link_ptr->mol.F[DISP][YDIR][O] - WSIN; 
-                        link_ptr->mol.F[DISP][ZDIR][O] = xrand(BOX_LENGTH * k, BOX_LENGTH * (k+1)); 
+                        link_ptr->mol.F[DISP][YDIR][O] = xrand(BOX_LENGTH * j, BOX_LENGTH * (j+1));
+                        link_ptr->mol.F[DISP][YDIR][H1] = link_ptr->mol.F[DISP][YDIR][O] + WSIN;
+                        link_ptr->mol.F[DISP][YDIR][H2] = link_ptr->mol.F[DISP][YDIR][O] - WSIN;
+                        link_ptr->mol.F[DISP][ZDIR][O] = xrand(BOX_LENGTH * k, BOX_LENGTH * (k+1));
                         link_ptr->mol.F[DISP][ZDIR][H1] = link_ptr->mol.F[DISP][ZDIR][O];
-                        link_ptr->mol.F[DISP][ZDIR][H2] = link_ptr->mol.F[DISP][ZDIR][O];                     
-                        
+                        link_ptr->mol.F[DISP][ZDIR][H2] = link_ptr->mol.F[DISP][ZDIR][O];
+
                         for (atom = 0; atom < NATOMS; atom++) {
                             /* read random velocities from file random.in */
                             fscanf(random_numbers,"%lf",&link_ptr->mol.F[VEL][XDIR][atom]);
@@ -131,25 +128,25 @@
                                 link_ptr->mol.F[deriv][ZDIR][atom] = 0.0;
                             }
                         }
-                        
+
                         link_ptr->next_mol = NULL;        /* Terminating link */
-                        
+
                         /* update box indices in all three dimensions */
-                        X_INDEX = (int) (link_ptr->mol.F[DISP][XDIR][O]/BOX_LENGTH); 
-                        Y_INDEX = (int) (link_ptr->mol.F[DISP][YDIR][O]/BOX_LENGTH);
-                        Z_INDEX = (int) (link_ptr->mol.F[DISP][ZDIR][O]/BOX_LENGTH);
-                        
+                        X_INDEX = (long) (link_ptr->mol.F[DISP][XDIR][O]/BOX_LENGTH);
+                        Y_INDEX = (long) (link_ptr->mol.F[DISP][YDIR][O]/BOX_LENGTH);
+                        Z_INDEX = (long) (link_ptr->mol.F[DISP][ZDIR][O]/BOX_LENGTH);
+
                         /* Put X_, Y_, and Z_INDEX back in box */
-                        
+
                         if (X_INDEX >=BOX_PER_SIDE) X_INDEX -= 1;
                         if (Y_INDEX >=BOX_PER_SIDE) Y_INDEX -= 1;
                         if (Z_INDEX >=BOX_PER_SIDE) Z_INDEX -= 1;
-                        
+
                         /* get list ptr */
-                        curr_ptr = BOX[X_INDEX][Y_INDEX][Z_INDEX].list; 
-                        
+                        curr_ptr = BOX[X_INDEX][Y_INDEX][Z_INDEX].list;
+
                         if (curr_ptr == NULL) {             /* No links in box yet */
-                            BOX[X_INDEX][Y_INDEX][Z_INDEX].list = link_ptr; 
+                            BOX[X_INDEX][Y_INDEX][Z_INDEX].list = link_ptr;
                         } else {
                             while (curr_ptr) {               /* Scan to end of list */
                                 last_ptr = curr_ptr;
@@ -158,23 +155,23 @@
                             last_ptr->next_mol = link_ptr;    /* Add to end of list */
                         } /* if curr_ptr */
                     }
-        
+
         /* distribute the unassigned molecules evenly among processors */
         pid = 0;
         for (i = 0; i < Unassigned; i++) {
             link_ptr = (struct link *) G_MALLOC(sizeof(link_type));
-            link_ptr->mol.F[DISP][XDIR][O] = xrand(BOX_LENGTH * start_end[pid]->box[XDIR][FIRST], BOX_LENGTH * (start_end[pid]->box[XDIR][LAST] + 1)); 
-            link_ptr->mol.F[DISP][XDIR][H1] = link_ptr->mol.F[DISP][XDIR][O] + WCOS; 
+            link_ptr->mol.F[DISP][XDIR][O] = xrand(BOX_LENGTH * start_end[pid]->box[XDIR][FIRST], BOX_LENGTH * (start_end[pid]->box[XDIR][LAST] + 1));
+            link_ptr->mol.F[DISP][XDIR][H1] = link_ptr->mol.F[DISP][XDIR][O] + WCOS;
             link_ptr->mol.F[DISP][XDIR][H2] = link_ptr->mol.F[DISP][XDIR][H1];
-            link_ptr->mol.F[DISP][YDIR][O] = xrand(BOX_LENGTH * start_end[pid]->box[YDIR][FIRST], BOX_LENGTH * (start_end[pid]->box[YDIR][LAST] + 1)); 
-            link_ptr->mol.F[DISP][YDIR][H1] = link_ptr->mol.F[DISP][YDIR][O] + WSIN; 
-            link_ptr->mol.F[DISP][YDIR][H2] = link_ptr->mol.F[DISP][YDIR][O] - WSIN; 
-            link_ptr->mol.F[DISP][ZDIR][O] = xrand(BOX_LENGTH * start_end[pid]->box[ZDIR][FIRST], BOX_LENGTH * (start_end[pid]->box[ZDIR][LAST] + 1)); 
+            link_ptr->mol.F[DISP][YDIR][O] = xrand(BOX_LENGTH * start_end[pid]->box[YDIR][FIRST], BOX_LENGTH * (start_end[pid]->box[YDIR][LAST] + 1));
+            link_ptr->mol.F[DISP][YDIR][H1] = link_ptr->mol.F[DISP][YDIR][O] + WSIN;
+            link_ptr->mol.F[DISP][YDIR][H2] = link_ptr->mol.F[DISP][YDIR][O] - WSIN;
+            link_ptr->mol.F[DISP][ZDIR][O] = xrand(BOX_LENGTH * start_end[pid]->box[ZDIR][FIRST], BOX_LENGTH * (start_end[pid]->box[ZDIR][LAST] + 1));
             link_ptr->mol.F[DISP][ZDIR][H1] = link_ptr->mol.F[DISP][ZDIR][O];
             link_ptr->mol.F[DISP][ZDIR][H2] = link_ptr->mol.F[DISP][ZDIR][O];
-            
+
             pid = (pid + 1) % NumProcs;
-            
+
             /* read random velocities from file random.in */
             for (atom = 0; atom < NATOMS; atom++) {
                 fscanf(random_numbers,"%lf",&link_ptr->mol.F[VEL][XDIR][atom]);
@@ -190,26 +187,26 @@
                     link_ptr->mol.F[deriv][ZDIR][atom] = 0.0;
                 }
             }
-            
+
             link_ptr->next_mol = NULL;        /* Terminating link */
-            
+
             /* updated box indices in all dimensions */
-            
-            X_INDEX = (int) (link_ptr->mol.F[DISP][XDIR][O]/BOX_LENGTH); 
-            Y_INDEX = (int) (link_ptr->mol.F[DISP][YDIR][O]/BOX_LENGTH);
-            Z_INDEX = (int) (link_ptr->mol.F[DISP][ZDIR][O]/BOX_LENGTH);
-            
+
+            X_INDEX = (long) (link_ptr->mol.F[DISP][XDIR][O]/BOX_LENGTH);
+            Y_INDEX = (long) (link_ptr->mol.F[DISP][YDIR][O]/BOX_LENGTH);
+            Z_INDEX = (long) (link_ptr->mol.F[DISP][ZDIR][O]/BOX_LENGTH);
+
             /* Put X_, Y_, and Z_INDEX back in box */
-            
+
             if (X_INDEX >=BOX_PER_SIDE) X_INDEX -= 1;
             if (Y_INDEX >=BOX_PER_SIDE) Y_INDEX -= 1;
             if (Z_INDEX >=BOX_PER_SIDE) Z_INDEX -= 1;
-            
+
             /* get list ptr */
-            curr_ptr = BOX[X_INDEX][Y_INDEX][Z_INDEX].list; 
-            
+            curr_ptr = BOX[X_INDEX][Y_INDEX][Z_INDEX].list;
+
             if (curr_ptr == NULL) {             /* No links in box yet */
-                BOX[X_INDEX][Y_INDEX][Z_INDEX].list = link_ptr; 
+                BOX[X_INDEX][Y_INDEX][Z_INDEX].list = link_ptr;
             } else {
                 while (curr_ptr) {               /* Scan to end of list */
                     last_ptr = curr_ptr;
@@ -218,25 +215,25 @@
                 last_ptr->next_mol = link_ptr;    /* Add to end of list */
             } /* if curr_ptr */
         }
-        
+
 #else
         /* not random initial placement, but rather along a regular
            lattice.  This is the default and the prefered initialization
            since random does not necessarily make sense from the viewpoint
            of preserving bond distances */
-        
+
         fprintf(six, "***** NEW RUN STARTING FROM REGULAR LATTICE *****\n");
         fflush(six);
         XT[2] = ZERO;
         mol = 0;
         fscanf(random_numbers,"%lf",&SUX);
-        
+
         SUMX=0.0;
         SUMY=0.0;
         SUMZ=0.0;
-        
+
         /* Generate displacements along a regular lattice */
-        
+
         for (i=0; i < NS; i++) {
             XT[1]=XT[2]+WCOS;
             XT[3]=XT[1];
@@ -248,12 +245,12 @@
                 for (k = 0; k < NS; k++) {
                     link_ptr = (struct link *) G_MALLOC(sizeof(link_type));
                     for (atom = 0; atom < NATOMS; atom++) {
-                        
+
                         /* displacements for atom */
                         link_ptr->mol.F[DISP][XDIR][atom] = XT[atom+1];
                         link_ptr->mol.F[DISP][YDIR][atom] = YT[atom+1];
                         link_ptr->mol.F[DISP][ZDIR][atom] = Z;
-                        
+
                         /* read random velocities from file random.in */
                         fscanf(random_numbers,"%lf",&link_ptr->mol.F[VEL][XDIR][atom]);
                         fscanf(random_numbers,"%lf",&link_ptr->mol.F[VEL][YDIR][atom]);
@@ -267,28 +264,28 @@
                             link_ptr->mol.F[deriv][ZDIR][atom] = 0.0;
                         }
                     }
-                    
+
                     link_ptr->next_mol = NULL;        /* Terminating link */
                     mol++;
                     Z += XS;
-                    
+
                     /* update box numbers in all dimensions */
-                    
-                    X_INDEX = (int) (link_ptr->mol.F[DISP][XDIR][O]/BOX_LENGTH); 
-                    Y_INDEX = (int) (link_ptr->mol.F[DISP][YDIR][O]/BOX_LENGTH);
-                    Z_INDEX = (int) (link_ptr->mol.F[DISP][ZDIR][O]/BOX_LENGTH);
-                    
+
+                    X_INDEX = (long) (link_ptr->mol.F[DISP][XDIR][O]/BOX_LENGTH);
+                    Y_INDEX = (long) (link_ptr->mol.F[DISP][YDIR][O]/BOX_LENGTH);
+                    Z_INDEX = (long) (link_ptr->mol.F[DISP][ZDIR][O]/BOX_LENGTH);
+
                     /* Put X_, Y_, and Z_INDEX back in box */
-                    
+
                     if (X_INDEX >=BOX_PER_SIDE) X_INDEX -= 1;
                     if (Y_INDEX >=BOX_PER_SIDE) Y_INDEX -= 1;
                     if (Z_INDEX >=BOX_PER_SIDE) Z_INDEX -= 1;
-                    
+
                     /* get list ptr */
-                    curr_ptr = BOX[X_INDEX][Y_INDEX][Z_INDEX].list; 
-                    
+                    curr_ptr = BOX[X_INDEX][Y_INDEX][Z_INDEX].list;
+
                     if (curr_ptr == NULL) {             /* No links in box yet */
-                        BOX[X_INDEX][Y_INDEX][Z_INDEX].list = link_ptr; 
+                        BOX[X_INDEX][Y_INDEX][Z_INDEX].list = link_ptr;
                     } else {
                         while (curr_ptr) {               /* Scan to end of list */
                             last_ptr = curr_ptr;
@@ -296,65 +293,65 @@
                         } /* while curr_ptr */
                         last_ptr->next_mol = link_ptr;    /* Add to end of list */
                     } /* if curr_ptr */
-                    
+
                 } /* for k */
                 YT[2] += XS;
             } /* for j */
             XT[2] += XS;
         } /* for i */
-        
+
         if (NMOL != mol) {
-            printf("Lattice init error: total mol %d != NMOL %d\n", mol, NMOL);
+            printf("Lattice init error: total mol %ld != NMOL %ld\n", mol, NMOL);
             exit(-1);
         }
 #endif
     }
     /* assign random momenta */
     /* find average momenta per atom */
-    
+
     SUMX=SUMX/(NATOMS*NMOL);
     SUMY=SUMY/(NATOMS*NMOL);
     SUMZ=SUMZ/(NATOMS*NMOL);
-    
+
     /*  find normalization factor so that <k.e.>=KT/2  */
-    
+
     SUX=0.0;
     SUY=0.0;
     SUZ=0.0;
-    
+
     for (i=0; i<BOX_PER_SIDE; i++) {
         for (j=0; j<BOX_PER_SIDE; j++) {
             for (k=0; k<BOX_PER_SIDE; k++) {
                 curr_ptr = BOX[i][j][k].list;
                 while (curr_ptr) {
-                    SUX = SUX + 
+                    SUX = SUX +
                         (pow( (curr_ptr->mol.F[VEL][XDIR][H1] - SUMX),2.0)
                          +pow( (curr_ptr->mol.F[VEL][XDIR][H2] - SUMX),2.0))/HMAS
                              +pow( (curr_ptr->mol.F[VEL][XDIR][O]  - SUMX),2.0)/OMAS;
-                    
-                    SUY = SUY + 
+
+                    SUY = SUY +
                         (pow( (curr_ptr->mol.F[VEL][YDIR][H1] - SUMY),2.0)
                          +pow( (curr_ptr->mol.F[VEL][YDIR][H2] - SUMY),2.0))/HMAS
                              +pow( (curr_ptr->mol.F[VEL][YDIR][O]  - SUMY),2.0)/OMAS;
-                    
-                    SUZ = SUZ + 
+
+                    SUZ = SUZ +
                         (pow( (curr_ptr->mol.F[VEL][ZDIR][H1] - SUMZ),2.0)
                          + pow( (curr_ptr->mol.F[VEL][ZDIR][H2] - SUMZ),2.0))/HMAS
                              +pow( (curr_ptr->mol.F[VEL][ZDIR][O]  - SUMZ),2.0)/OMAS;
-                    
+
                     curr_ptr = curr_ptr->next_mol;
                 } /* while curr_ptr */
             }
         }
     } /* for boxes */
-    
+
     FAC=BOLTZ*TEMP*NATMO/UNITM * pow((UNITT*TSTEP/UNITL),2.0);
     SUX=sqrt(FAC/SUX);
     SUY=sqrt(FAC/SUY);
     SUZ=sqrt(FAC/SUZ);
-    
+
     /* normalize individual velocities so that there are no bulk momenta  */
-    
+
     XMAS[1]=OMAS;
     for (i=0; i<BOX_PER_SIDE; i++) {
         for (j=0; j<BOX_PER_SIDE; j++) {
@@ -362,13 +359,13 @@
                 curr_ptr = BOX[i][j][k].list;
                 while (curr_ptr) {
                     for (atom = 0; atom < NATOMS; atom++) {
-                        curr_ptr->mol.F[VEL][XDIR][atom] = 
+                        curr_ptr->mol.F[VEL][XDIR][atom] =
                             ( curr_ptr->mol.F[VEL][XDIR][atom] -
                              SUMX) * SUX/XMAS[atom];
-                        curr_ptr->mol.F[VEL][YDIR][atom] = 
+                        curr_ptr->mol.F[VEL][YDIR][atom] =
                             ( curr_ptr->mol.F[VEL][YDIR][atom] -
                              SUMY) * SUY/XMAS[atom];
-                        curr_ptr->mol.F[VEL][ZDIR][atom] = 
+                        curr_ptr->mol.F[VEL][ZDIR][atom] =
                             ( curr_ptr->mol.F[VEL][ZDIR][atom] -
                              SUMZ) * SUZ/XMAS[atom];
                     } /* for atom */
@@ -377,7 +374,7 @@
             }
         }
     } /* for box */
-    
+
     fclose(random_numbers);
 } /* end of subroutine INITIA */
 
@@ -385,13 +382,11 @@
  * XRAND: generate floating-point random number.
  */
 
-double xrand(xl, xh)
-  double xl, xh;                   /* lower, upper bounds on number */
+double xrand(double xl, double xh)	/* lower, upper bounds on number */
 {
-    long random ();
     double x;
-    
-    x=(xl + (xh - xl) * ((double) random()) / 2147483647.0);
+
+    x=(xl + (xh - xl) * ((double) rand()) / 2147483647.0);
     return (x);
 }
 
diff -Naur splash2/codes/apps/water-spatial/interf.C splash2-modified/codes/apps/water-spatial/interf.C
--- splash2/codes/apps/water-spatial/interf.C	1994-10-14 01:33:52.000000000 -0400
+++ splash2-modified/codes/apps/water-spatial/interf.C	2007-03-22 20:26:34.000000000 -0400
@@ -27,67 +27,63 @@
 #include "split.h"
 #include "global.h"
 
-INTERF(DEST,VIR,ProcID)
-  int DEST;
-  double *VIR;
-  unsigned ProcID;
-  
+void INTERF(long DEST, double *VIR, long ProcID)
 {
-    
-    /* This is the routine that computes intermolecular interactions and 
-     * hence takes up most of the execution time.  It is 
+
+    /* This is the routine that computes intermolecular interactions and
+     * hence takes up most of the execution time.  It is
      * called both from main() and from mdmain().
      * When called from main(), it is used to estimate the initial
      * accelerations by computing intermolecular forces.  When called
      * from mdmain(), it is used to compute intermolecular forces.
-     * The parameter DEST specifies whether results go into the 
-     * accelerations or the forces. It uses the routine UPDATE_FORCES 
-     * which is defined in this file, and routine CSHIFT in file cshift.U 
+     * The parameter DEST specifies whether results go into the
+     * accelerations or the forces. It uses the routine UPDATE_FORCES
+     * which is defined in this file, and routine CSHIFT in file cshift.U
      *
      * This routine calculates inter-molecular interaction forces.
      * the distances are arranged in the order  M-M, M-H1, M-H2, H1-M,
-     * H2-M, H1-H2, H1-H1, H2-H1, H2-H2, O-O, O-H1, O-H2, H1-O, H2-O, 
+     * H2-M, H1-H2, H1-H1, H2-H1, H2-H2, O-O, O-H1, O-H2, H1-O, H2-O,
      * where the M are "centers" of the molecules.
      */
-    
-    int dir;
-    int KC, K;
-    int i, j, k, ii, kk;
-    
-    int XBOX, YBOX, ZBOX, X_NUM, Y_NUM, Z_NUM;
+
+    long dir;
+    long KC, K;
+    long i, j, k;
+
+    long XBOX, YBOX, ZBOX, X_NUM, Y_NUM, Z_NUM;
     /* per interaction arrays that hold some computed distances */
-    double YL[15], XL[15], ZL[15], RS[15], FF[15], RL[15]; 
+    double YL[15], XL[15], ZL[15], RS[15], FF[15], RL[15];
     double  FTEMP;
     double LVIR = 0.0;
     struct link *curr_ptr, *neighbor_ptr;
     struct list_of_boxes *curr_box;
     double *temp_p;
-    
+
     curr_box = my_boxes[ProcID];
     while (curr_box) {
-        
+
         i = curr_box->coord[XDIR];  /* X coordinate of box */
         j = curr_box->coord[YDIR];  /* Y coordinate of box */
         k = curr_box->coord[ZDIR];  /* Z coordinate of box */
-        
+
         /* loop over nearest neighbor boxes */
-        
+
         for (XBOX=i-1; XBOX<=i+1; XBOX++) {
             for (YBOX=j-1; YBOX<=j+1; YBOX++) {
                 for (ZBOX=k-1; ZBOX<=k+1; ZBOX++) {
-                    
+
                     /* Special case for two boxes per side */
-                    
+
                     if ((BOX_PER_SIDE == 2) && ((XBOX < 0) || (XBOX == 2) ||
                                                 (YBOX < 0) || (YBOX == 2) || (ZBOX < 0) || (ZBOX == 2)))
                         continue;
-                    
+
                     X_NUM = XBOX;
                     Y_NUM = YBOX;
                     Z_NUM = ZBOX;
-                    
+
                     /* Make box number valid if out of box */
-                    
+
                     if (X_NUM == -1)
                         X_NUM += BOX_PER_SIDE;
                     else if (X_NUM >= BOX_PER_SIDE)
@@ -100,74 +96,74 @@
                         Z_NUM += BOX_PER_SIDE;
                     else if (Z_NUM >= BOX_PER_SIDE)
                         Z_NUM -= BOX_PER_SIDE;
-                    
+
                     /* Don't do current box more than once */
-                    
+
                     if ((X_NUM == i) && (Y_NUM == j) && (Z_NUM == k) &&
                         ((XBOX != i) || (YBOX != j) || (ZBOX !=k))) {
                         continue;
                     }
-                    
+
                     neighbor_ptr = BOX[X_NUM][Y_NUM][Z_NUM].list;
-                    
+
                     while (neighbor_ptr) {
-                        
+
                         /* go through current box list */
-                        
+
                         curr_ptr = BOX[i][j][k].list;
                         while (curr_ptr) {
-                            
+
                             /* Don't do interaction with same molecule */
-                            
+
                             if (curr_ptr == neighbor_ptr) {
                                 curr_ptr = curr_ptr->next_mol;
-                                continue;   
+                                continue;
                             }
-                            
+
                             /*  compute some intermolecular distances;
                                 first call CSHIFT to implement periodic boundary conditions */
-                            
+
                             CSHIFT(curr_ptr->mol.F[DISP][XDIR],neighbor_ptr->mol.F[DISP][XDIR],
                                    curr_ptr->mol.VM[XDIR],neighbor_ptr->mol.VM[XDIR],XL,BOXH,BOXL);
                             CSHIFT(curr_ptr->mol.F[DISP][YDIR],neighbor_ptr->mol.F[DISP][YDIR],
                                    curr_ptr->mol.VM[YDIR],neighbor_ptr->mol.VM[YDIR],YL,BOXH,BOXL);
                             CSHIFT(curr_ptr->mol.F[DISP][ZDIR],neighbor_ptr->mol.F[DISP][ZDIR],
                                    curr_ptr->mol.VM[ZDIR],neighbor_ptr->mol.VM[ZDIR],ZL,BOXH,BOXL);
-                            
+
                             KC=0;
                             for (K = 0; K < 9; K++) {
                                 RS[K]=XL[K]*XL[K]+YL[K]*YL[K]+ZL[K]*ZL[K];
-                                if (RS[K] > CUT2) 
+                                if (RS[K] > CUT2)
                                     KC++;
                             } /* for K */
-                            
+
                             if (KC != 9) {
-                                for (K = 0; K < 14; K++) 
+                                for (K = 0; K < 14; K++)
                                     FF[K]=0.0;
                                 if (RS[0] < CUT2) {
                                     FF[0]=QQ4/(RS[0]*sqrt(RS[0]))+REF4;
                                     LVIR = LVIR + FF[0]*RS[0];
                                 } /* if */
-                                
-                                
+
+
                                 for (K = 1; K < 5; K++) {
-                                    if (RS[K] < CUT2) { 
+                                    if (RS[K] < CUT2) {
                                         FF[K]= -QQ2/(RS[K]*sqrt(RS[K]))-REF2;
                                         LVIR = LVIR + FF[K]*RS[K];
                                     } /* if */
-                                    if (RS[K+4] <= CUT2) { 
+                                    if (RS[K+4] <= CUT2) {
                                         RL[K+4]=sqrt(RS[K+4]);
                                         FF[K+4]=QQ/(RS[K+4]*RL[K+4])+REF1;
                                         LVIR = LVIR + FF[K+4]*RS[K+4];
                                     } /* if */
                                 } /* for K */
-                                
+
                                 if (KC == 0) {
                                     RS[9]=XL[9]*XL[9]+YL[9]*YL[9]+ZL[9]*ZL[9];
                                     RL[9]=sqrt(RS[9]);
                                     FF[9]=AB1*exp(-B1*RL[9])/RL[9];
                                     LVIR = LVIR + FF[9]*RS[9];
-                                    for (K = 10; K < 14; K++) { 
+                                    for (K = 10; K < 14; K++) {
                                         FTEMP=AB2*exp(-B2*RL[K-5])/RL[K-5];
                                         FF[K-5]=FF[K-5]+FTEMP;
                                         LVIR= LVIR+FTEMP*RS[K-5];
@@ -177,42 +173,42 @@
                                         LVIR = LVIR + FF[K]*RS[K];
                                     } /* for K */
                                 } /* if KC == 0 */
-                                
-                                UPDATE_FORCES(curr_ptr, DEST, XL, YL, ZL, FF); 
-                            }  /* if KC != 9 */  
-                            
+
+                                UPDATE_FORCES(curr_ptr, DEST, XL, YL, ZL, FF);
+                            }  /* if KC != 9 */
+
                             curr_ptr = curr_ptr->next_mol;
                         } /* while curr_ptr */
-                        
+
                         neighbor_ptr = neighbor_ptr->next_mol;
                     } /* while neighbor_ptr */
-                    
+
                 }
-            }  
+            }
         }  /* neighbor boxes' for loops */
-        
+
         curr_box = curr_box->next_box;
     }  /* while mybox */
-    
+
     /*  accumulate running sum from private partial sums */
-    
+
     LOCK(gl->InterfVirLock);
     *VIR = *VIR + LVIR/2.0;
     UNLOCK(gl->InterfVirLock);
-    
+
     /* wait till all forces are updated */
-    
+
     BARRIER(gl->InterfBar, NumProcs);
-    
+
     /* divide final forces by masses */
-    
+
     curr_box = my_boxes[ProcID];
     while (curr_box) {
-        
+
         i = curr_box->coord[XDIR];  /* X coordinate of box */
         j = curr_box->coord[YDIR];  /* Y coordinate of box */
         k = curr_box->coord[ZDIR];  /* Z coordinate of box */
-        
+
         curr_ptr = BOX[i][j][k].list;
         while (curr_ptr) {
             for ( dir = XDIR; dir <= ZDIR; dir++) {
@@ -221,49 +217,45 @@
                 temp_p[O]  = temp_p[O] * FOM;
                 temp_p[H2] = temp_p[H2] * FHM;
             } /* for dir */
-            
+
             curr_ptr = curr_ptr->next_mol;
         } /* while curr_ptr */
         curr_box = curr_box->next_box;
     } /* while curr_box */
-    
+
 }/* end of subroutine INTERF */
 
 
 /*************    UPDATE FORCES SUBROUTINE     *************/
 
-UPDATE_FORCES(link_ptr, DEST, XL, YL, ZL, FF)
-  struct link *link_ptr;
-  int DEST;
-  double XL[], YL[], ZL[], FF[];
-  
+void UPDATE_FORCES(struct link *link_ptr, long DEST, double *XL, double *YL, double *ZL, double *FF)
 {
-    /* From the computed distances etc., compute the 
-     * intermolecular forces and update the force (or 
+    /* From the computed distances etc., compute the
+     * intermolecular forces and update the force (or
      * acceleration) locations.
      */
-    
-    int K;
+
+    long K;
     double G110[3], G23[3], G45[3], TT1[3], TT[3], TT2[3];
     double GG[15][3];
-    
-    /* tx_p, ty_p, tz_p are temporary pointers used to avoid too much 
+
+    /* tx_p, ty_p, tz_p are temporary pointers used to avoid too much
        pointer (and array) dereferencing.  Since the pointers dereferenced
        otherwise are global pointers probably stored in processor 0's memory,
-       this can also have the effect of reducing hot-spotting and remote 
+       this can also have the effect of reducing hot-spotting and remote
        references when cache misses are incurred on these pointers. */
-    
+
     double *tx_p, *ty_p, *tz_p;
-    
-    
+
+
     /*   CALCULATE X-COMPONENT FORCES */
-    
+
     for (K = 0; K < 14; K++)  {
         GG[K+1][XDIR] = FF[K]*XL[K];
         GG[K+1][YDIR] = FF[K]*YL[K];
         GG[K+1][ZDIR] = FF[K]*ZL[K];
     }
-    
+
     G110[XDIR] = GG[10][XDIR]+GG[1][XDIR]*C1;
     G110[YDIR] = GG[10][YDIR]+GG[1][YDIR]*C1;
     G110[ZDIR] = GG[10][ZDIR]+GG[1][ZDIR]*C1;
@@ -282,24 +274,24 @@
     TT2[XDIR]=G45[XDIR]*C2+TT1[XDIR];
     TT2[YDIR]=G45[YDIR]*C2+TT1[YDIR];
     TT2[ZDIR]=G45[ZDIR]*C2+TT1[ZDIR];
-    
+
     /* Update force or acceleration for link */
-    
+
     tx_p = link_ptr->mol.F[DEST][XDIR];
     ty_p = link_ptr->mol.F[DEST][YDIR];
     tz_p = link_ptr->mol.F[DEST][ZDIR];
-    
-    tx_p[H1] += 
+
+    tx_p[H1] +=
         GG[6][XDIR]+GG[7][XDIR]+GG[13][XDIR]+TT[XDIR]+GG[4][XDIR];
     tx_p[O] +=
         G110[XDIR] + GG[11][XDIR] +GG[12][XDIR]+C1*G23[XDIR];
     tx_p[H2] +=
         GG[8][XDIR]+GG[9][XDIR]+GG[14][XDIR]+TT[XDIR]+GG[5][XDIR];
-    ty_p[H1] += 
+    ty_p[H1] +=
         GG[6][YDIR]+GG[7][YDIR]+GG[13][YDIR]+TT[YDIR]+GG[4][YDIR];
-    ty_p[O]  += 
+    ty_p[O]  +=
         G110[YDIR]+GG[11][YDIR]+GG[12][YDIR]+C1*G23[YDIR];
-    ty_p[H2] += 
+    ty_p[H2] +=
         GG[8][YDIR]+GG[9][YDIR]+GG[14][YDIR]+TT[YDIR]+GG[5][YDIR];
     tz_p[H1] +=
         GG[6][ZDIR]+GG[7][ZDIR]+GG[13][ZDIR]+TT[ZDIR]+GG[4][ZDIR];
@@ -307,5 +299,5 @@
         G110[ZDIR]+GG[11][ZDIR]+GG[12][ZDIR]+C1*G23[ZDIR];
     tz_p[H2] +=
         GG[8][ZDIR]+GG[9][ZDIR]+GG[14][ZDIR]+TT[ZDIR]+GG[5][ZDIR];
-    
+
 } /* end of subroutine UPDATE_FORCES */
diff -Naur splash2/codes/apps/water-spatial/intraf.C splash2-modified/codes/apps/water-spatial/intraf.C
--- splash2/codes/apps/water-spatial/intraf.C	1994-10-14 01:33:52.000000000 -0400
+++ splash2-modified/codes/apps/water-spatial/intraf.C	2007-03-22 19:12:53.000000000 -0400
@@ -27,61 +27,58 @@
 #include "split.h"
 #include "global.h"
 
-INTRAF(VIR,ProcID)
-  double *VIR;
-  unsigned ProcID;
-  
+void INTRAF(double *VIR, long ProcID)
 {
-    
+
     /* This routine calculates the intra-molecular force
-     * acting on each atom. 
+     * acting on each atom.
      * FC11, FC12, FC13, AND FC33 are the quardratic force constants
      * FC111, FC112, ....... ETC. are the cubic      force constants
      * FC1111, FC1112 ...... ETC. are the quartic    force constants
      */
-    
+
     double SUM, R1, R2, VR1[4], VR2[4], COS, SIN;
     double DT, DTS, DR1, DR1S, DR2, DR2S, R1S, R2S, DR11[4], DR23[4];
     double DT1[4], DT3[4], F1, F2, F3, T1, T2;
-    
+
     double LVIR;    /* private copy of global sum to reduce synchronized updates */
-    int dir, atom;
-    int i, j, k;
-    struct link *curr_ptr, *t_ptr;
+    long dir, atom;
+    long i, j, k;
+    struct link *curr_ptr;
     struct list_of_boxes *curr_box;
     double *temp_p;
-    
+
     curr_box = my_boxes[ProcID];
     while (curr_box) {
         i = curr_box->coord[XDIR];  /* X coordinate of box */
         j = curr_box->coord[YDIR];  /* Y coordinate of box */
         k = curr_box->coord[ZDIR];  /* Z coordinate of box */
-        
+
         curr_ptr = BOX[i][j][k].list;
         while (curr_ptr) {
             SUM=0.0;
             R1=0.0;
             R2=0.0;
-            
+
             /* loop through the three directions */
-            
+
             for (dir=XDIR; dir<=ZDIR; dir++) {
                 temp_p = curr_ptr->mol.F[DISP][dir];
                 curr_ptr->mol.VM[dir] = C1 * temp_p[O]
                     + C2 * (temp_p[H1] +
                             temp_p[H2] );
-                VR1[dir] = temp_p[O] - temp_p[H1];	
+                VR1[dir] = temp_p[O] - temp_p[H1];
                 R1 += VR1[dir] * VR1[dir];
                 VR2[dir] = temp_p[O] - temp_p[H2];
                 R2 += VR2[dir] * VR2[dir];
                 SUM += VR1[dir] * VR2[dir];
             } /* for dir */
-            
+
             R1=sqrt(R1);
             R2=sqrt(R2);
-            
+
             /*calc cos(THETA), sin(THETA), delta(R1), delta(R2), delta(THETA)*/
-            
+
             COS=SUM/(R1*R2);
             SIN=sqrt(ONE-COS*COS);
             DT=(acos(COS)-ANGLE)*ROH;
@@ -90,21 +87,21 @@
             DR1S=DR1*DR1;
             DR2=R2-ROH;
             DR2S=DR2*DR2;
-            
+
             /* calculate derivatives of R1/X1, R2/X3, THETA/X1, and THETA/X3 */
-            
+
             R1S=ROH/(R1*SIN);
             R2S=ROH/(R2*SIN);
-            
+
             for (dir = XDIR; dir <= ZDIR; dir++) {
                 DR11[dir]=VR1[dir]/R1;
                 DR23[dir]=VR2[dir]/R2;
                 DT1[dir]=(-DR23[dir]+DR11[dir]*COS)*R1S;
                 DT3[dir]=(-DR11[dir]+DR23[dir]*COS)*R2S;
             } /* for dir */
-            
+
             /* calculate forces */
-            
+
             F1=FC11*DR1+FC12*DR2+FC13*DT;
             F2=FC33*DT +FC13*(DR1+DR2);
             F3=FC11*DR2+FC12*DR1+FC13*DT;
@@ -126,53 +123,51 @@
                    *DR1+2.0*FC1122*DR1S*DR2+3.0*FC1113*DR2S*DT
                    +FC1123*(2.0*DR2+DR1)*DR1*DT+(2.0*FC1133*DR2
                                                  +FC1233*DR1+FC1333*DT)*DTS)*ROHI2;
-            
+
             /* Update forces */
-            
-            for (dir = XDIR; dir <= ZDIR; dir++) { 
+
+            for (dir = XDIR; dir <= ZDIR; dir++) {
                 temp_p = curr_ptr->mol.F[FORCES][dir];
-                
+
                 T1=F1*DR11[dir]+F2*DT1[dir];
                 temp_p[H1] = T1;
                 T2=F3*DR23[dir]+F2*DT3[dir];
                 temp_p[H2] = T2;
                 temp_p[O] = -(T1+T2);
             } /* for dir */
-            
+
             curr_ptr = curr_ptr->next_mol;
         } /* while curr_ptr */
         curr_box = curr_box->next_box;
     }   /* while curr_box */
-    
-    /* calculate summation of the product of the displacement and computed 
+
+    /* calculate summation of the product of the displacement and computed
        force for every molecule, direction, and atom */
-    
+
     LVIR=0.0;
-    
+
     curr_box = my_boxes[ProcID];
     while (curr_box) {
-        
+
         i = curr_box->coord[XDIR];  /* X coordinate of box */
         j = curr_box->coord[YDIR];  /* Y coordinate of box */
         k = curr_box->coord[ZDIR];  /* Z coordinate of box */
-        
+
         curr_ptr = BOX[i][j][k].list;
         while (curr_ptr) {
             for ( dir = XDIR; dir <= ZDIR; dir++)
                 for (atom = 0; atom < NATOM; atom++)
-                    LVIR += curr_ptr->mol.F[DISP][dir][atom] * 
+                    LVIR += curr_ptr->mol.F[DISP][dir][atom] *
                         curr_ptr->mol.F[FORCES][dir][atom];
             curr_ptr = curr_ptr->next_mol;
         } /* while curr_ptr */
         curr_box = curr_box->next_box;
     } /* while curr_box */
-    
+
     /* Update potential energy */
-    
+
     LOCK(gl->IntrafVirLock);
     *VIR =  *VIR + LVIR;
     UNLOCK(gl->IntrafVirLock);
-    
-} /* end of subroutine INTRAF */
-
 
+} /* end of subroutine INTRAF */
diff -Naur splash2/codes/apps/water-spatial/kineti.C splash2-modified/codes/apps/water-spatial/kineti.C
--- splash2/codes/apps/water-spatial/kineti.C	1994-10-14 01:33:52.000000000 -0400
+++ splash2-modified/codes/apps/water-spatial/kineti.C	2007-03-22 19:25:47.000000000 -0400
@@ -23,38 +23,32 @@
 #include "split.h"
 #include "global.h"
 
-KINETI(NMOL,SUM,HMAS,OMAS,ProcID)
-  int NMOL;
-  double HMAS,OMAS;
-  double SUM[];
-  unsigned ProcID;
-  
-  /* this routine computes kinetic energy in each of the three
-     spatial dimensions, and puts the computed values in the
-     SUM array */ 
+/* this routine computes kinetic energy in each of the three spatial
+   dimensions, and puts the computed values in the SUM array */
+void KINETI(double *SUM, double HMAS, double OMAS, long ProcID)
 {
-    int dir, i, j, k;
+    long dir, i, j, k;
     double S;
     struct link *curr_ptr;
     struct list_of_boxes *curr_box;
     double *tempptr;
-    
+
     /* Loop over three directions */
-    
+
     for (dir = XDIR; dir <= ZDIR; dir++) {
         S=0.0;
-        
+
         /* loop over processor's boxes */
         curr_box = my_boxes[ProcID];
-        
+
         while (curr_box) {
-            
+
             i = curr_box->coord[XDIR];  /* X coordinate of box */
             j = curr_box->coord[YDIR];  /* Y coordinate of box */
             k = curr_box->coord[ZDIR];  /* Z coordinate of box */
-            
+
             /* loop over the molecules */
-            
+
             curr_ptr = BOX[i][j][k].list;
             while (curr_ptr) {
                 tempptr = curr_ptr->mol.F[VEL][dir];
@@ -63,15 +57,15 @@
                           (tempptr[O] * tempptr[O]) * OMAS;
                 curr_ptr = curr_ptr->next_mol;
             } /* while curr_ptr */
-            
+
             curr_box = curr_box->next_box;
-            
-        } /* while curr_box */ 
-        
+
+        } /* while curr_box */
+
         LOCK(gl->KinetiSumLock);
         SUM[dir]+=S;
         UNLOCK(gl->KinetiSumLock);
-        
+
     } /* for dir */
-    
+
 } /* end of subroutine KINETI */
diff -Naur splash2/codes/apps/water-spatial/makefile splash2-modified/codes/apps/water-spatial/makefile
--- splash2/codes/apps/water-spatial/makefile	1994-11-13 17:48:48.000000000 -0500
+++ splash2-modified/codes/apps/water-spatial/makefile	1969-12-31 19:00:00.000000000 -0500
@@ -1,46 +0,0 @@
-TARGET = WATER-SPATIAL
-
-OBJS = water.o mdmain.o syscons.o kineti.o bndry.o cnstnt.o initia.o \
-       interf.o intraf.o cshift.o poteng.o predcor.o
-CFLAGS = -O2 -Olimit 2000
-LDFLAGS = -lm
-MACROS = ../../../null_macros/c.m4.null
-
-x = *
-
-
-.SUFFIXES:
-.SUFFIXES: .o .S .s .c .C .U .h .H
-
-.H.h:
-	m4 $(MACROS) $*.H > $*.h
-.C.c:
-	m4 $(MACROS) $*.C > $*.c
-.c.o:
-	cc -c $(CFLAGS) $*.c
-.C.o:
-	m4 $(MACROS) $*.C > $*.c
-	cc -c $(CFLAGS) $*.c
-
-$(TARGET): $(OBJS)
-	cc $(OBJS) $(CFLAGS) -o $(TARGET) $(LDFLAGS)
-
-cnstnt.c: cnstnt.C water.h wwpot.h cnst.h frcnst.h fileio.h parameters.h
-water.c: water.C parameters.h mdvar.h water.h wwpot.h cnst.h mddata.h \
-         fileio.h frcnst.h randno.h global.h split.h
-mdmain.c: mdmain.C  parameters.h mdvar.h water.h wwpot.h cnst.h \
-          mddata.h fileio.h frcnst.h randno.h global.h split.h
-syscons.c: syscons.C parameters.h mdvar.h water.h wwpot.h cnst.h mddata.h
-kineti.c: kineti.C global.h split.h mdvar.h parameters.h mddata.h
-bndry.c: bndry.C split.h mdvar.h parameters.h mddata.h
-initia.c: initia.C split.h mdvar.h water.h cnst.h fileio.h \
-           parameters.h mddata.h
-predcor.c: predcor.C split.h mdvar.h parameters.h mddata.h
-intraf.c: intraf.C frcnst.h mdvar.h water.h wwpot.h parameters.h \
-           mddata.h global.h split.h
-interf.c: interf.C mdvar.h water.h wwpot.h cnst.h global.h split.h \
-           parameters.h mddata.h
-cshift.c: cshift.C water.h
-poteng.c: poteng.C global.h split.h mdvar.h frcnst.h water.h wwpot.h \
-           parameters.h mddata.h
-
diff -Naur splash2/codes/apps/water-spatial/Makefile splash2-modified/codes/apps/water-spatial/Makefile
--- splash2/codes/apps/water-spatial/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ splash2-modified/codes/apps/water-spatial/Makefile	2007-03-22 19:33:04.000000000 -0400
@@ -0,0 +1,17 @@
+TARGET = WATER-SPATIAL
+OBJS = bndry.o cnstnt.o cshift.o initia.o interf.o intraf.o kineti.o mdmain.o poteng.o predcor.o syscons.o water.o
+
+include ../../Makefile.config
+
+bndry.o: bndry.C split.h mdvar.h parameters.h mddata.h global.h
+cnstnt.o: cnstnt.C water.h wwpot.h cnst.h frcnst.h fileio.h parameters.h global.h
+cshift.o: cshift.C water.h global.h
+initia.o: initia.C split.h mdvar.h water.h cnst.h fileio.h parameters.h mddata.h global.h
+interf.o: interf.C mdvar.h water.h wwpot.h cnst.h global.h split.h parameters.h mddata.h
+intraf.o: intraf.C frcnst.h mdvar.h water.h wwpot.h parameters.h mddata.h global.h split.h
+kineti.o: kineti.C global.h split.h mdvar.h parameters.h mddata.h
+mdmain.o: mdmain.C  parameters.h mdvar.h water.h wwpot.h cnst.h mddata.h fileio.h frcnst.h randno.h global.h split.h
+poteng.o: poteng.C global.h split.h mdvar.h frcnst.h water.h wwpot.h parameters.h mddata.h
+predcor.o: predcor.C split.h mdvar.h parameters.h mddata.h global.h
+syscons.o: syscons.C parameters.h mdvar.h water.h wwpot.h cnst.h mddata.h global.h
+water.o: water.C parameters.h mdvar.h water.h wwpot.h cnst.h mddata.h fileio.h frcnst.h randno.h global.h split.h
diff -Naur splash2/codes/apps/water-spatial/mddata.H splash2-modified/codes/apps/water-spatial/mddata.H
--- splash2/codes/apps/water-spatial/mddata.H	1994-10-14 01:36:45.000000000 -0400
+++ splash2-modified/codes/apps/water-spatial/mddata.H	2007-03-22 18:38:46.000000000 -0400
@@ -16,42 +16,42 @@
 
   /* this file contains the declarations of the main data
   structure types used by the program */
-  
+
 #define BOTH 2
-  typedef double vm_type[3];
-  
-  typedef struct mol_dummy {
+typedef double vm_type[3];
+
+typedef struct mol_dummy {
       vm_type VM;
       double F[MXOD2][NDIR][NATOM];
-  } molecule_type;
-  
-  typedef struct link {
+} molecule_type;
+
+typedef struct link {
       molecule_type mol;
       struct link *next_mol;
-  } link_type;
-  
-  typedef struct box_dummy {
+} link_type;
+
+typedef struct box_dummy {
       struct link *list;
       LOCKDEC(boxlock)
-  } box_type;
-  
-  extern box_type ***BOX;
-  
-  typedef struct array_dummy {
-      int box[NDIR][BOTH];
-  } first_last_array;
-  
-  extern first_last_array **start_end;
-  
-  typedef struct list_of_boxes {
-      int coord[3];
-      struct list_of_boxes *next_box;    
-  } box_list;
-  
-  extern box_list **my_boxes;
-  
-  extern double  TLC[100], FPOT, FKIN;
-  extern int IX[3*MXOD2+1], IRST,NVAR,NXYZ,NXV,IXF,IYF,IZF,IMY,IMZ;
-  
-  extern int NumProcs;
-  extern int NumBoxes;
+} box_type;
+
+extern box_type ***BOX;
+
+typedef struct array_dummy {
+      long box[NDIR][BOTH];
+} first_last_array;
+
+extern first_last_array **start_end;
+
+typedef struct list_of_boxes {
+      long coord[3];
+      struct list_of_boxes *next_box;
+} box_list;
+
+extern box_list **my_boxes;
+
+extern double  TLC[100], FPOT, FKIN;
+extern long IX[3*MXOD2+1], IRST,NVAR,NXYZ,NXV,IXF,IYF,IZF,IMY,IMZ;
+
+extern long NumProcs;
+extern long NumBoxes;
diff -Naur splash2/codes/apps/water-spatial/mdmain.C splash2-modified/codes/apps/water-spatial/mdmain.C
--- splash2/codes/apps/water-spatial/mdmain.C	1995-09-26 20:02:31.000000000 -0400
+++ splash2-modified/codes/apps/water-spatial/mdmain.C	2007-03-22 19:27:59.000000000 -0400
@@ -30,22 +30,17 @@
 
 /************************************************************************/
 
-double  MDMAIN(NFSV,NFRST,NSTEP,NRST,NPRINT,NSAVE,LKT,NORD1,ProcID)
-  int NFSV,NFRST,NSTEP,NRST,NPRINT,NSAVE,LKT,NORD1;
-  unsigned ProcID;
-  
+double MDMAIN(long NSTEP, long NPRINT, long NSAVE, long NORD1, long ProcID)
 {
-    
     double TVIR = 0.0;
     double TTMV = 0.0;
     double TKIN = 0.0;
     double XTT;
-    int i,j,k;
+    long i,j,k;
     double POTA,POTR,POTRF;
     double XVIR,AVGT,TEN;
-    struct link *curr_ptr;
     struct list_of_boxes *new_box, *curr_box;
-    
+
     for (i=start_end[ProcID]->box[XDIR][FIRST]; i<=start_end[ProcID]->box[XDIR][LAST]; i++) {
         for (j=start_end[ProcID]->box[YDIR][FIRST]; j<=start_end[ProcID]->box[YDIR][LAST]; j++) {
             for (k=start_end[ProcID]->box[ZDIR][FIRST]; k<=start_end[ProcID]->box[ZDIR][LAST]; k++) {
@@ -65,33 +60,33 @@
             }
         }
     }
-    
+
     /* calculate initial value for acceleration */
-    
+
     INTRAF(&gl->VIR,ProcID);
-    
+
     BARRIER(gl->start,NumProcs);
-    
+
     INTERF(ACC,&gl->VIR,ProcID);
-    
+
     BARRIER(gl->start, NumProcs);
-    
+
     /* MOLECULAR DYNAMICS LOOP */
-    
+
     for (i=1;i <= NSTEP; i++) {
         TTMV=TTMV+1.00;
-        
-        /* POSSIBLE ENHANCEMENT:  Here's where one start measurements to avoid 
+
+        /* POSSIBLE ENHANCEMENT:  Here's where one start measurements to avoid
            cold-start effects.  Recommended to do this at the beginning of the
            second timestep; i.e. if (i == 2).
            */
-        
+
         /* initialize various shared sums */
         if (ProcID == 0) {
-            int dir;
+            long dir;
             if (i >= 2) {
                 CLOCK(gl->trackstart);
-            }                
+            }
             gl->VIR = 0.0;
             gl->POTA = 0.0;
             gl->POTR = 0.0;
@@ -99,71 +94,71 @@
             for (dir = XDIR; dir <= ZDIR; dir++)
                 gl->SUM[dir] = 0.0;
         }
-        
+
         if ((ProcID == 0) && (i >= 2)) {
             CLOCK(gl->intrastart);
         }
-        
+
         BARRIER(gl->start, NumProcs);
 
         PREDIC(TLC,NORD1,ProcID);
         INTRAF(&gl->VIR,ProcID);
-        
+
         BARRIER(gl->start, NumProcs);
-        
+
         if ((ProcID == 0) && (i >= 2)) {
             CLOCK(gl->intraend);
             gl->intratime += gl->intraend - gl->intrastart;
         }
-        
+
         if ((ProcID == 0) && (i >= 2)) {
             CLOCK(gl->interstart);
         }
-        
-        INTERF(FORCES,&gl->VIR,ProcID); 
-        
+
+        INTERF(FORCES,&gl->VIR,ProcID);
+
         if ((ProcID == 0) && (i >= 2)) {
             CLOCK(gl->interend);
             gl->intertime += gl->interend - gl->interstart;
         }
-        
+
         CORREC(PCC,NORD1,ProcID);
-        
+
         BNDRY(ProcID);
-        
-        KINETI(NMOL,gl->SUM,HMAS,OMAS,ProcID);
-        
+
+        KINETI(gl->SUM,HMAS,OMAS,ProcID);
+
         BARRIER(gl->start, NumProcs);
-        
+
         if ((ProcID == 0) && (i >= 2)) {
             CLOCK(gl->intraend);
             gl->intratime += gl->intraend - gl->interend;
         }
-        
+
         TKIN=TKIN+gl->SUM[0]+gl->SUM[1]+gl->SUM[2];
         TVIR=TVIR-gl->VIR;
-        
+
         /* CHECK if  PRINTING AND/OR SAVING IS TO BE DONE */
-        
+
         if ( ((i % NPRINT) == 0) || ((NSAVE > 0) && ((i % NSAVE) == 0))) {
-            
+
             /* if so, call poteng to compute potential energy.  Note
                that we are attributing all the time in poteng to intermolecular
                computation although some of it is intramolecular (see poteng.C) */
-            
+
             if ((ProcID == 0) && (i >= 2)) {
                 CLOCK(gl->interstart);
             }
-            
+
             POTENG(&gl->POTA,&gl->POTR,&gl->POTRF,ProcID);
-            
+
             BARRIER(gl->start, NumProcs);
-            
+
             if ((ProcID == 0) && (i >= 2)) {
                 CLOCK(gl->interend);
                 gl->intertime += gl->interend - gl->interstart;
             }
-            
+
             POTA=gl->POTA*FPOT;
             POTR=gl->POTR*FPOT;
             POTRF=gl->POTRF*FPOT;
@@ -171,30 +166,28 @@
             AVGT=TKIN*FKIN*TEMP*2.00/(3.00*TTMV);
             TEN=(gl->SUM[0]+gl->SUM[1]+gl->SUM[2])*FKIN;
             XTT=POTA+POTR+POTRF+TEN;
-            
-            /* if it is time to print output as well ... */      
+
+            /* if it is time to print output as well ... */
             if ((i % NPRINT) == 0 && ProcID == 0) {
                 LOCK(gl->IOLock);
-                fprintf(six,"     %5d %14.5lf %12.5lf %12.5lf %12.5lf \n"
+                fprintf(six,"     %5ld %14.5lf %12.5lf %12.5lf %12.5lf \n"
                         ,i,TEN,POTA,POTR,POTRF);
                 fprintf(six," %16.3lf %16.5lf %16.5lf\n",XTT,AVGT,XVIR);
                 fflush(six);
                 UNLOCK(gl->IOLock);
             }
-            
+
         }
-        
+
         BARRIER(gl->start, NumProcs);
-        
+
         if ((ProcID == 0) && (i >= 2)) {
             CLOCK(gl->trackend);
             gl->tracktime += gl->trackend - gl->trackstart;
         }
-        
+
     } /* for i */
-    
-    return(XTT);
-    
-} /* mdmain.c */
 
+    return(XTT);
 
+} /* mdmain.c */
diff -Naur splash2/codes/apps/water-spatial/mdvar.H splash2-modified/codes/apps/water-spatial/mdvar.H
--- splash2/codes/apps/water-spatial/mdvar.H	1994-10-14 01:36:45.000000000 -0400
+++ splash2-modified/codes/apps/water-spatial/mdvar.H	2007-03-22 18:37:50.000000000 -0400
@@ -14,9 +14,9 @@
 /*                                                                       */
 /*************************************************************************/
 
-  /* some variable declarations */
-  
-  extern double  TEMP,RHO,TSTEP,BOXL,BOXH,CUTOFF,CUT2;
-  extern double  BOX_LENGTH;
-  extern int    NMOL,NORDER,NATMO,NATMO3,NMOL1;
-  extern int    BOX_PER_SIDE, BPS_SQRD;
+/* some variable declarations */
+
+extern double  TEMP,RHO,TSTEP,BOXL,BOXH,CUTOFF,CUT2;
+extern double  BOX_LENGTH;
+extern long    NMOL,NORDER,NATMO,NATMO3,NMOL1;
+extern long    BOX_PER_SIDE, BPS_SQRD;
diff -Naur splash2/codes/apps/water-spatial/parameters.H splash2-modified/codes/apps/water-spatial/parameters.H
--- splash2/codes/apps/water-spatial/parameters.H	1994-10-14 01:36:45.000000000 -0400
+++ splash2-modified/codes/apps/water-spatial/parameters.H	2007-03-22 18:37:38.000000000 -0400
@@ -14,10 +14,10 @@
 /*                                                                       */
 /*************************************************************************/
 
-  /* contains the definitions of certain system constants */
-  
+/* contains the definitions of certain system constants */
+
 #define MAXODR 7                    /* Order of predictor-corrector method + 1 */
-#define NATOM 3                     /* Atoms per molecule, H-O-H */ 
+#define NATOM 3                     /* Atoms per molecule, H-O-H */
 #define MXOD2 (MAXODR+2)            /* Variables maintained per mol */
 #define NDIR 3                      /* Number of spatial directions */
 
diff -Naur splash2/codes/apps/water-spatial/poteng.C splash2-modified/codes/apps/water-spatial/poteng.C
--- splash2/codes/apps/water-spatial/poteng.C	1994-10-14 01:33:52.000000000 -0400
+++ splash2-modified/codes/apps/water-spatial/poteng.C	2007-03-22 19:03:08.000000000 -0400
@@ -26,24 +26,21 @@
 #include "split.h"
 #include "global.h"
 
-POTENG(POTA,POTR,PTRF,ProcID)
-  double *POTA, *POTR, *PTRF;     /* some shared sums computed by POTENG */
-  unsigned ProcID;
-  
+void POTENG(double *POTA, double *POTR, double *PTRF, long ProcID)
 {
-    
+
     /*
       this routine calculates the potential energy of the system.  it is only
       called at periods specified by the user, typically in those
       time-steps when the user wants to print output.
       FC11 ,FC12, FC13, and FC33 are the quardratic force constants
       */
-    
-    int KC, K;
-    int XBOX, YBOX, ZBOX;
-    int X_NUM, Y_NUM, Z_NUM;
-    int i, j, k;
-    double R1, R2, RX, COS, DT, DR1, DR2, DR1S, DR2S, DRP, DRS;
+
+    long KC, K;
+    long XBOX, YBOX, ZBOX;
+    long X_NUM, Y_NUM, Z_NUM;
+    long i, j, k;
+    double R1, R2, RX, COS, DT, DR1, DR2, DR1S, DR2S, DRP;
     double XL[15], YL[15], ZL[15], RS[15], RL[15];
     double DTS;
     double LPOTA, LPOTR, LPTRF;
@@ -51,34 +48,34 @@
     struct list_of_boxes *curr_box;
     double *tx_p, *ty_p, *tz_p;
     double tempa, tempb, tempc;
-    
+
     /*  compute intra-molecular potential energy */
-    
+
     LPOTA=0.0;
     curr_box = my_boxes[ProcID];
     while (curr_box) {
-        
+
         i = curr_box->coord[XDIR];  /* X coordinate of box */
         j = curr_box->coord[YDIR];  /* Y coordinate of box */
         k = curr_box->coord[ZDIR];  /* Z coordinate of box */
-        
+
         /* Go through the molecules in a box */
-        
+
         curr_ptr = BOX[i][j][k].list;
         while (curr_ptr) {
-            
+
             tx_p = curr_ptr->mol.F[DISP][XDIR];
             ty_p = curr_ptr->mol.F[DISP][YDIR];
             tz_p = curr_ptr->mol.F[DISP][ZDIR];
-            
+
             curr_ptr->mol.VM[XDIR] = C1 * tx_p[O] +
-                C2 * (tx_p[H1] + 
+                C2 * (tx_p[H1] +
                       tx_p[H2]);
             curr_ptr->mol.VM[YDIR] = C1*ty_p[O] +
-                C2*(ty_p[H1] + 
+                C2*(ty_p[H1] +
                     ty_p[H2]);
             curr_ptr->mol.VM[ZDIR] = C1*tz_p[O] +
-                C2*(tz_p[H1] + 
+                C2*(tz_p[H1] +
                     tz_p[H2]);
             tempa = tx_p[O] - tx_p[H1];
             tempb = ty_p[O] - ty_p[H1];
@@ -88,14 +85,14 @@
             tempb = ty_p[O] - ty_p[H2];
             tempc = tz_p[O] - tz_p[H2];
             R2 = tempa * tempa + tempb * tempb + tempc * tempc;
-            
+
             RX = ((tx_p[O] - tx_p[H1]) *
                   (tx_p[O] - tx_p[H2])) +
                       ((ty_p[O] - ty_p[H1]) *
                        (ty_p[O] - ty_p[H2])) +
                            ((tz_p[O] - tz_p[H1]) *
                             (tz_p[O] - tz_p[H2]));
-            
+
             R1=sqrt(R1);
             R2=sqrt(R2);
             COS=RX/(R1*R2);
@@ -110,49 +107,49 @@
                 +FC12*DR1*DR2+FC13*DRP*DT
                     +(FC111*(DR1S*DR1+DR2S*DR2)+FC333*DTS*DT+FC112*DRP*DR1*DR2+
                       FC113*(DR1S+DR2S)*DT+FC123*DR1*DR2*DT+FC133*DRP*DTS)*ROHI;
-            
+
             LPOTA += (FC1111*(DR1S*DR1S+DR2S*DR2S)+FC3333*DTS*DTS+
                       FC1112*(DR1S+DR2S)*DR1*DR2+FC1122*DR1S*DR2S+
                       FC1113*(DR1S*DR1+DR2S*DR2)*DT+FC1123*DRP*DR1*DR2*DT+
                       FC1133*(DR1S+DR2S)*DTS+FC1233*DR1*DR2*DTS+
                       FC1333*DRP*DTS*DT)*ROHI2;
-            
+
             curr_ptr = curr_ptr->next_mol;
         } /* while curr_ptr */
         curr_box = curr_box->next_box;
     } /* while curr_box */
-    
-    
+
+
     BARRIER(gl->PotengBar, NumProcs);
-    
+
     /*  compute inter-molecular potential energy */
-    
+
     LPOTR=0.0;
     LPTRF=0.0;
     curr_box = my_boxes[ProcID];
     while (curr_box) {
-        
+
         i = curr_box->coord[XDIR];  /* X coordinate of box */
         j = curr_box->coord[YDIR];  /* Y coordinate of box */
         k = curr_box->coord[ZDIR];  /* Z coordinate of box */
-        
+
         /* loop over nearest neighbor boxes */
-        
+
         for (XBOX=i-1; XBOX<=i+1; XBOX++) {
             for (YBOX=j-1; YBOX<=j+1; YBOX++) {
                 for (ZBOX=k-1; ZBOX<=k+1; ZBOX++) {
-                    
+
                     X_NUM = XBOX;
                     Y_NUM = YBOX;
                     Z_NUM = ZBOX;
-                    
+
                     if ((BOX_PER_SIDE == 2) && ((XBOX < 0) || (XBOX == 2) ||
-                                                (YBOX < 0) || (YBOX == 2) || 
+                                                (YBOX < 0) || (YBOX == 2) ||
                                                 (ZBOX < 0) || (ZBOX == 2)))
                         continue;
-                    
+
                     /* Make box number valid if out of box */
-                    
+
                     if (X_NUM == -1)
                         X_NUM += BOX_PER_SIDE;
                     else if (X_NUM >= BOX_PER_SIDE)
@@ -165,27 +162,27 @@
                         Z_NUM += BOX_PER_SIDE;
                     else if (Z_NUM >= BOX_PER_SIDE)
                         Z_NUM -= BOX_PER_SIDE;
-                    
-                    
+
+
                     /* Don't do current box more than once */
                     if ((X_NUM == i) && (Y_NUM == j) && (Z_NUM == k) &&
                         ((XBOX != i) || (YBOX != j) || (ZBOX !=k))) {
                         continue;
                     }
-                    
+
                     neighbor_ptr = BOX[X_NUM][Y_NUM][Z_NUM].list;
                     while (neighbor_ptr) {
                         /* go through current box list */
                         curr_ptr = BOX[i][j][k].list;
                         while (curr_ptr) {
-                            
+
                             /* Don't do interaction with same molecule */
-                            
+
                             if (curr_ptr == neighbor_ptr) {
                                 curr_ptr = curr_ptr->next_mol;
                                 continue;
                             }
-                            
+
                             /*  compute some intermolecular distances */
                             CSHIFT(curr_ptr->mol.F[DISP][XDIR],neighbor_ptr->mol.F[DISP][XDIR],
                                    curr_ptr->mol.VM[XDIR],neighbor_ptr->mol.VM[XDIR],XL,BOXH,BOXL);
@@ -193,16 +190,16 @@
                                    curr_ptr->mol.VM[YDIR],neighbor_ptr->mol.VM[YDIR],YL,BOXH,BOXL);
                             CSHIFT(curr_ptr->mol.F[DISP][ZDIR],neighbor_ptr->mol.F[DISP][ZDIR],
                                    curr_ptr->mol.VM[ZDIR],neighbor_ptr->mol.VM[ZDIR],ZL,BOXH,BOXL);
-                            
-                            
+
+
                             KC=0;
                             for (K = 0; K < 9; K++) {
                                 RS[K]=XL[K]*XL[K]+YL[K]*YL[K]+ZL[K]*ZL[K];
-                                if (RS[K] > CUT2) 
+                                if (RS[K] > CUT2)
                                     KC++;
                             } /* for K */
-                            
-                            
+
+
                             if (KC != 9) {
                                 for (K = 0; K < 9; K++) {
                                     if (RS[K] <= CUT2) {
@@ -213,19 +210,19 @@
                                         RS[K]=CUT2;
                                     } /* else */
                                 } /* for K */
-                                
+
                                 LPOTR= LPOTR-QQ2/RL[1]-QQ2/RL[2]-QQ2/RL[3]-QQ2/RL[4]
                                     + QQ/RL[5]+ QQ/RL[6]+ QQ/RL[7]+ QQ/RL[8]
                                         + QQ4/RL[0];
-                                
+
                                 LPTRF= LPTRF-REF2*RS[0]-REF1*((RS[5]+RS[6]+RS[7]+RS[8])*0.5
                                                               -RS[1]-RS[2]-RS[3]-RS[4]);
-                                
+
                                 if (KC <= 0) {
                                     for (K = 9; K <  14; K++)  {
                                         RL[K]=sqrt(XL[K]*XL[K]+YL[K]*YL[K]+ZL[K]*ZL[K]);
                                     }
-                                    
+
                                     LPOTR= LPOTR+A1* exp(-B1*RL[9])
                                         +A2*(exp(-B2*RL[ 5])+exp(-B2*RL[ 6])
                                              +exp(-B2*RL[ 7])+exp(-B2*RL[ 8]))
@@ -234,8 +231,8 @@
                                                 -A4*(exp(-B4*RL[10])+exp(-B4*RL[11])
                                                      +exp(-B4*RL[12])+exp(-B4*RL[13]));
                                 } /* if KC <= 0 */
-                                
-                                
+
+
                             } /* if KC != 9 */
                             curr_ptr = curr_ptr->next_mol;
                         }
@@ -246,16 +243,16 @@
         } /* neighbor boxes for loops */
         curr_box = curr_box->next_box;
     } /* while curr_box */
-    
+
     LPOTR = LPOTR/2.0;
     LPTRF = LPTRF/2.0;
-    
+
     /* update shared sums from computed private sums */
-    
+
     LOCK(gl->PotengSumLock);
     *POTA = *POTA + LPOTA;
     *POTR = *POTR + LPOTR;
     *PTRF = *PTRF + LPTRF;
     UNLOCK(gl->PotengSumLock);
-    
+
 } /* end of subroutine POTENG */
diff -Naur splash2/codes/apps/water-spatial/predcor.C splash2-modified/codes/apps/water-spatial/predcor.C
--- splash2/codes/apps/water-spatial/predcor.C	1994-10-14 01:33:52.000000000 -0400
+++ splash2-modified/codes/apps/water-spatial/predcor.C	2007-03-22 19:23:18.000000000 -0400
@@ -16,47 +16,47 @@
 
 EXTERN_ENV
 
-#include "global.h"
 #include "mdvar.h"
 #include "parameters.h"
 #include "mddata.h"
 #include "split.h"
+#include "global.h"
 
-PREDIC(C,NOR1,ProcID)  /* predicts new values for displacement and its five
-                          derivatives using Gear's sixth-order
-                          predictor-corrector method */
-  double C[];
-  int NOR1;       /* NOR1 = NORDER + 1 = 7 (for a sixth-order method) */
-  unsigned ProcID;
+/* predicts new values for displacement and its five derivatives
+ *  using Gear's sixth-order predictor-corrector method
+ *
+ * NOR1 : NOR1 = NORDER + 1 = 7 (for a sixth-order method)
+ */
+void PREDIC(double *C, long NOR1, long ProcID)
 {
     /*   this routine calculates predicted F(X), F'(X), F''(X), ... */
-    
-    int JIZ;
-    int  JI;
-    int  L;
-    int func, i, j, k, dir, atom;
+
+    long JIZ;
+    long  JI;
+    long  L;
+    long func, i, j, k, dir, atom;
     double S;
     struct link *curr_ptr;
     struct list_of_boxes *curr_box;
-    
+
     curr_box = my_boxes[ProcID];
-    
+
     while (curr_box) {
-        
+
         i = curr_box->coord[XDIR];  /* X coordinate of box */
         j = curr_box->coord[YDIR];  /* Y coordinate of box */
         k = curr_box->coord[ZDIR];  /* Z coordinate of box */
-        
+
         /* Loop through the current box's molecules */
-        
+
         curr_ptr = BOX[i][j][k].list;
-        
+
         while (curr_ptr) {
-            
+
             JIZ = 2;
-            
+
             /* loop over F(X), F'(X), F''(X), etc. */
-            
+
             for (func = 0; func < NORDER; func++) {
                 for ( dir = 0; dir < NDIR; dir++)
                     for ( atom = 0; atom < NATOM; atom++ ) {
@@ -75,54 +75,52 @@
         } /* while curr_ptr */
         curr_box = curr_box->next_box;
     } /* while curr_box */
-    
+
 } /* end of subroutine PREDIC */
 
-CORREC(PCC,NOR1,ProcID)
-  double PCC[];       /* the predictor-corrector constants */
-  int NOR1;           /* NORDER + 1 = 7 for a sixth-order method) */
-  unsigned ProcID; 
-  
-  /* corrects the predicted values */
-  
+/* corrects the predicted values
+ *
+ * PCC  : the predictor-corrector constants
+ * NOR1 : NORDER + 1 = 7 for a sixth-order method)
+ */
+void CORREC(double *PCC, long NOR1, long ProcID)
 {
-    
+
     /*   This routine calculates corrected F(X), F'(X), F"(X),
      *   from corrected F(X) = predicted F(X) + PCC(1)*(FR-SD)
-     *   where SD is predicted accl. F"(X) and FR is computed 
+     *   where SD is predicted accl. F"(X) and FR is computed
      *   accl. (force/mass) at predicted position
      */
-    
+
     double Y;
-    int i, j, k, dir, atom, func;
+    long i, j, k, dir, atom, func;
     struct link *curr_ptr;
     box_list *curr_box;
-    
+
     curr_box = my_boxes[ProcID];
-    
+
     while (curr_box) {
-        
+
         i = curr_box->coord[XDIR];  /* X coordinate of box */
         j = curr_box->coord[YDIR];  /* Y coordinate of box */
         k = curr_box->coord[ZDIR];  /* Z coordinate of box */
-        
+
         /* Loop through the current box's molecules */
-        
+
         curr_ptr = BOX[i][j][k].list;
         while (curr_ptr) {
-            
+
             for (dir = 0; dir < NDIR; dir++) {
                 for (atom = 0; atom < NATOM; atom++) {
-                    Y = curr_ptr->mol.F[FORCES][dir][atom] - 
+                    Y = curr_ptr->mol.F[FORCES][dir][atom] -
                         curr_ptr->mol.F[ACC][dir][atom];
-                    for ( func = 0; func < NOR1; func++) 
-                        curr_ptr->mol.F[func][dir][atom] += PCC[func] * Y;   
-                } /* for atom */		
+                    for ( func = 0; func < NOR1; func++)
+                        curr_ptr->mol.F[func][dir][atom] += PCC[func] * Y;
+                } /* for atom */
             } /* for dir */
             curr_ptr= curr_ptr->next_mol;
         } /* while curr_ptr */
         curr_box = curr_box->next_box;
     } /* while curr_box */
-    
-} /* end of subroutine CORREC */
 
+} /* end of subroutine CORREC */
diff -Naur splash2/codes/apps/water-spatial/randno.H splash2-modified/codes/apps/water-spatial/randno.H
--- splash2/codes/apps/water-spatial/randno.H	1994-10-14 01:36:45.000000000 -0400
+++ splash2-modified/codes/apps/water-spatial/randno.H	2007-03-22 18:37:09.000000000 -0400
@@ -14,7 +14,7 @@
 /*                                                                       */
 /*************************************************************************/
 
-  /* variable declarations needed for random numbers */
-  
-  extern double R3[128],R1;
-  extern int I2;
+/* variable declarations needed for random numbers */
+
+extern double R3[128],R1;
+extern long I2;
diff -Naur splash2/codes/apps/water-spatial/syscons.C splash2-modified/codes/apps/water-spatial/syscons.C
--- splash2/codes/apps/water-spatial/syscons.C	1994-10-14 01:33:52.000000000 -0400
+++ splash2-modified/codes/apps/water-spatial/syscons.C	2007-03-22 18:54:35.000000000 -0400
@@ -25,70 +25,68 @@
 #include "wwpot.h"
 #include "cnst.h"
 #include "mddata.h"
+#include "global.h"
 
-
-SYSCNS()                    /* sets up some system constants */
+void SYSCNS()                    /* sets up some system constants */
 {
     TSTEP=TSTEP/UNITT;        /* time between steps */
     NATMO=NATOMS*NMOL;        /* total number of atoms in system */
     NATMO3=NATMO*3; /* number of atoms * number of spatial dimensions */
     FPOT= UNITM * pow((UNITL/UNITT),2.0) / (BOLTZ*TEMP*NATMO);
     FKIN=FPOT*0.50/(TSTEP*TSTEP);
-    
+
     /* computed length of the cubical "box".  Note that box size is
-     * computed as being large enough to handle the input number of 
+     * computed as being large enough to handle the input number of
      * water molecules
      */
-    
-    BOXL= pow( (NMOL*WTMOL*UNITM/RHO),(1.00/3.00));  
-    
+
+    BOXL= pow( (NMOL*WTMOL*UNITM/RHO),(1.00/3.00));
+
     /* normalized length of computational box (in Angstroms) */
-    
-    BOXL=BOXL/UNITL;    
-    
+
+    BOXL=BOXL/UNITL;
+
     /* # of boxes per side */
-    
+
     BOXH = BOXL*0.50;
-    
+
     /* set cutoff radius if it was not already read in nonzero from
        the input file in water.C.  If it was defined in the input file,
        then that definition is retained. */
-    
+
     if (CUTOFF == 0.0) {
-        CUTOFF=max(BOXH,CUTOFF);    /* cutoff radius is max of BOXH 
+        CUTOFF=max(BOXH,CUTOFF);    /* cutoff radius is max of BOXH
                                        and default (= 0); i.e. CUTOFF
                                        radius is set to half the normalized
                                        box length */
     }
-    
-    if (CUTOFF > 11.0) CUTOFF = 11.0; /* cutoff never greater than 11 
+
+    if (CUTOFF > 11.0) CUTOFF = 11.0; /* cutoff never greater than 11
                                          Angstrom */
-    
-    BOX_PER_SIDE = ( BOXL / CUTOFF);      
-    
+
+    BOX_PER_SIDE = ( BOXL / CUTOFF);
+
     /* BOX_PER_SIDE is always >=1 */
     if (!BOX_PER_SIDE) BOX_PER_SIDE = 1;
-    
+
     /* Length of a box in Angstroms */
-    
+
     BOX_LENGTH = BOXL / ( (double) BOX_PER_SIDE);
-    
+
     BPS_SQRD = BOX_PER_SIDE * BOX_PER_SIDE;
-    
+
     NumBoxes = BOX_PER_SIDE * BOX_PER_SIDE * BOX_PER_SIDE;
-    
+
     REF1= -QQ/(CUTOFF*CUTOFF*CUTOFF);
     REF2=2.00*REF1;
     REF4=2.00*REF2;
-    CUT2=CUTOFF*CUTOFF;        /* square of cutoff radius,  used 
-                                  to actually decide whether an 
-                                  interaction should be computed in 
+    CUT2=CUTOFF*CUTOFF;        /* square of cutoff radius,  used
+                                  to actually decide whether an
+                                  interaction should be computed in
                                   INTERF and POTENG */
-    
+
     FHM=(TSTEP*TSTEP*0.50)/HMAS;
     FOM=(TSTEP*TSTEP*0.50)/OMAS;
     NMOL1=NMOL-1;
-    
-}       /* end of subroutine SYSCNS */
-
 
+}       /* end of subroutine SYSCNS */
diff -Naur splash2/codes/apps/water-spatial/water.C splash2-modified/codes/apps/water-spatial/water.C
--- splash2/codes/apps/water-spatial/water.C	1994-10-14 01:39:39.000000000 -0400
+++ splash2-modified/codes/apps/water-spatial/water.C	2007-06-21 18:14:25.000000000 -0400
@@ -17,10 +17,10 @@
 MAIN_ENV
 
 /*  Usage:   water < infile,
-    where infile has 10 fields which can be described in order as 
+    where infile has 10 fields which can be described in order as
     follows:
-    
-    TSTEP:   the physical time interval (in sec) between timesteps.  
+
+    TSTEP:   the physical time interval (in sec) between timesteps.
     Good default is 1e-15.
     NMOL:    the number of molecules to be simulated.
     NSTEP:   the number of timesteps to be simulated.
@@ -28,32 +28,31 @@
     set this to 6.
     NSAVE:   the frequency with which to save data in data collection.
     Set to 0 always.
-    NRST:    the frequency with which to write RST file: set to 0 always (not used). 
-    NPRINT:  the frequency with which to compute potential energy. 
+    NRST:    the frequency with which to write RST file: set to 0 always (not used).
+    NPRINT:  the frequency with which to compute potential energy.
     i.e. the routine POTENG is called every NPRINT timesteps.
     It also computes intermolecular as well as intramolecular
     interactions, and hence is very expensive.
     NFMC:    Not used (historical artifact).  Set to anything, say 0.
     NumProcs: the number of processors to be used.
-    CUTOFF:  the cutoff radius to be used (in Angstrom, 
+    CUTOFF:  the cutoff radius to be used (in Angstrom,
     floating-point).  In a real simulation, this
-    will be set to 0 here in which case the program will 
-    compute it itself (and set it to about 11 Angstrom.   
+    will be set to 0 here in which case the program will
+    compute it itself (and set it to about 11 Angstrom.
     It can be set by the user if they want
     to use an artificially small cutoff radius, for example
-    to control the number of boxes created for small problems 
-    (and not have fewer boxes than processors).  
+    to control the number of boxes created for small problems
+    (and not have fewer boxes than processors).
     */
 
 #include <stdio.h>
+#include <string.h>
 #include <math.h>
 
 /*  include files for declarations  */
-#define extern
 #include "cnst.h"
 #include "fileio.h"
 #include "frcnst.h"
-#include "global.h"
 #include "mdvar.h"
 #include "parameters.h"
 #include "randno.h"
@@ -61,44 +60,59 @@
 #include "water.h"
 #include "wwpot.h"
 #include "mddata.h"
-#undef extern
+#include "global.h"
+
+long NATOMS;
+long I2;
+long NMOL,NORDER,NATMO,NATMO3,NMOL1;
+long BOX_PER_SIDE, BPS_SQRD;
+long IX[3*MXOD2+1], IRST,NVAR,NXYZ,NXV,IXF,IYF,IZF,IMY,IMZ;
+long NumBoxes;
+
+double UNITT,UNITL,UNITM,BOLTZ,AVGNO,PCC[11];
+double FC11,FC12,FC13,FC33,FC111,FC333,FC112,FC113,FC123,FC133,FC1111,FC3333,FC1112,FC1122,FC1113,FC1123,FC1133,FC1233,FC1333;
+double TLC[100], FPOT, FKIN;
+double TEMP,RHO,TSTEP,BOXL,BOXH,CUTOFF,CUT2;
+double BOX_LENGTH;
+double R3[128],R1;
+double OMAS,HMAS,WTMOL,ROH,ANGLE,FHM,FOM,ROHI,ROHI2;
+double QQ,A1,B1,A2,B2,A3,B3,A4,B4,AB1,AB2,AB3,AB4,C1,C2,QQ2,QQ4,REF1,REF2,REF4;
+
+FILE *six;
+
+box_type ***BOX;
+
+box_list **my_boxes;
 
 struct GlobalMemory *gl;        /* pointer to the Global Memory
                                    structure, which contains the lock,
                                    barrier, and some scalar variables */
 
-int NSTEP, NSAVE, NRST, NPRINT,NFMC;
-int NORD1;
-int II;                         /*  variables explained in common.h */
-int i;
-int NDATA;
-int NFRST=11;
-int NFSV=10;
-int LKT=0;
+long NSTEP, NSAVE, NRST, NPRINT,NFMC;
+long NORD1;
+long II;                         /*  variables explained in common.h */
+long i;
+long NDATA;
+long NFRST=11;
+long NFSV=10;
+long LKT=0;
 
 first_last_array **start_end; /* ptr to array of start/end box #s */
-int NumProcs;                 /* number of processors being used; 
+long NumProcs;                 /* number of processors being used;
                                  run-time input           */
 
-void WorkStart();
+double XTT;
 
-main(argc, argv)
-  char **argv;
-  
+int main(int argc, char **argv)
 {
-    int func, dir, atom;
-    double XTT, MDMAIN();
-    struct link *curr_ptr;
-    unsigned ProcID;
-    
     /* default values for the control parameters of the driver */
     /* are in parameters.h */
-    
+
     if ((argc == 2) && ((strncmp(argv[1],"-h",strlen("-h")) == 0) || (strncmp(argv[1],"-H",strlen("-H")) == 0))) {
         printf("Usage:  WATER-SPATIAL < infile, where the contents of infile can be\nobtained from the comments at the top of water.C and the first scanf \nin main() in water.C\n\n");
         exit(0);
     }
-    
+
         /*  POSSIBLE ENHANCEMENT:  One might bind the first process to a processor
             here, even before the other (child) processes are bound later in mdmain().
             */
@@ -107,84 +121,83 @@
 
     TEMP  =298.0;
     RHO   =0.9980;
-    
+
     /* read input */
-    
-    if (scanf("%lf%d%d%d%d%d%d%d%d%lf",&TSTEP, &NMOL, &NSTEP, &NORDER, 
+
+    if (scanf("%lf%ld%ld%ld%ld%ld%ld%ld%ld%lf",&TSTEP, &NMOL, &NSTEP, &NORDER,
               &NSAVE, &NRST, &NPRINT, &NFMC,&NumProcs, &CUTOFF) != 10)
         fprintf(stderr,"ERROR: Usage: water < infile, which must have 10 fields, see SPLASH documentation or comment at top of water.C\n");
-    
-    printf("Using %d procs on %d steps of %d mols\n", NumProcs, NSTEP, NMOL);
-    printf("Other parameters:\n\tTSTEP = %8.2e\n\tNORDER = %d\n\tNSAVE = %d\n",TSTEP,NORDER,NSAVE);
-    printf("\tNRST = %d\n\tNPRINT = %d\n\tNFMC = %d\n\tCUTOFF = %lf\n\n",NRST,NPRINT,NFMC,CUTOFF);
-    
+
+    printf("Using %ld procs on %ld steps of %ld mols\n", NumProcs, NSTEP, NMOL);
+    printf("Other parameters:\n\tTSTEP = %8.2e\n\tNORDER = %ld\n\tNSAVE = %ld\n",TSTEP,NORDER,NSAVE);
+    printf("\tNRST = %ld\n\tNPRINT = %ld\n\tNFMC = %ld\n\tCUTOFF = %lf\n\n",NRST,NPRINT,NFMC,CUTOFF);
+
     /* set up scaling factors and constants */
-    
+
     NORD1=NORDER+1;
-    
+
     CNSTNT(NORD1,TLC);  /* sub. call to set up constants */
-    
+
     SYSCNS();    /* sub. call to initialize system constants  */
-    
-    printf("%d boxes with %d processors\n\n",
+
+    printf("%ld boxes with %ld processors\n\n",
            BOX_PER_SIDE * BOX_PER_SIDE * BOX_PER_SIDE, NumProcs);
-    
+
     if (NumProcs > (BOX_PER_SIDE * BOX_PER_SIDE * BOX_PER_SIDE)) {
-        fprintf(stderr,"ERROR: less boxes (%d) than processors (%d)\n",
+        fprintf(stderr,"ERROR: less boxes (%ld) than processors (%ld)\n",
                 BOX_PER_SIDE * BOX_PER_SIDE * BOX_PER_SIDE, NumProcs);
         fflush(stderr);
         exit(-1);
     }
-    
+
     fprintf(six,"\nTEMPERATURE                = %8.2f K\n",TEMP);
     fprintf(six,"DENSITY                    = %8.5f G/C.C.\n",RHO);
-    fprintf(six,"NUMBER OF MOLECULES        = %8d\n",NMOL);
-    fprintf(six,"NUMBER OF PROCESSORS       = %8d\n",NumProcs);
+    fprintf(six,"NUMBER OF MOLECULES        = %8ld\n",NMOL);
+    fprintf(six,"NUMBER OF PROCESSORS       = %8ld\n",NumProcs);
     fprintf(six,"TIME STEP                  = %8.2e SEC\n",TSTEP);
-    fprintf(six,"ORDER USED TO SOLVE F=MA   = %8d \n",NORDER);
-    fprintf(six,"NO. OF TIME STEPS          = %8d \n",NSTEP);
-    fprintf(six,"FREQUENCY OF DATA SAVING   = %8d \n",NSAVE);
-    fprintf(six,"FREQUENCY TO WRITE RST FILE= %8d \n",NRST);
+    fprintf(six,"ORDER USED TO SOLVE F=MA   = %8ld \n",NORDER);
+    fprintf(six,"NO. OF TIME STEPS          = %8ld \n",NSTEP);
+    fprintf(six,"FREQUENCY OF DATA SAVING   = %8ld \n",NSAVE);
+    fprintf(six,"FREQUENCY TO WRITE RST FILE= %8ld \n",NRST);
     fflush(six);
-    
+
     { /* do memory initializations */
-        
-        int pid, procnum, i, j, k, l;
-        struct list_of_boxes *new_box;
+
+        long procnum, i, j, k, l;
         struct list_of_boxes *temp_box;
-        int xprocs, yprocs, zprocs;
-        int x_inc, y_inc, z_inc;
-        int x_ct, y_ct, z_ct;
-        int x_left, y_left, z_left;
-        int x_first, y_first, z_first;
-        int x_last, y_last, z_last;
+        long xprocs, yprocs, zprocs;
+        long x_inc, y_inc, z_inc;
+        long x_ct, y_ct, z_ct;
+        long x_left, y_left, z_left;
+        long x_first, y_first, z_first;
+        long x_last, y_last, z_last;
         double proccbrt;
-        unsigned gmem_size = sizeof(struct GlobalMemory);
-        
+        long gmem_size = sizeof(struct GlobalMemory);
+
         MAIN_INITENV(,40000000,);  /* macro call to initialize
                                       shared memory etc. */
-        
-        
+
+
         /* Allocate space for main (BOX) data structure as well as
-         * synchronization variables 
+         * synchronization variables
          */
-        
-        start_end = (first_last_array **) 
+
+        start_end = (first_last_array **)
             G_MALLOC(sizeof(first_last_array *) * NumProcs);
         for (i=0; i < NumProcs; i++) {
             start_end[i] = (first_last_array *)
                 G_MALLOC(sizeof(first_last_array));
         }
-        
+
         /* Calculate start and finish box numbers for processors */
-        
+
         xprocs = 0;
         yprocs = 0;
         proccbrt = (double) pow((double) NumProcs, 1.0/3.0) + 0.00000000000001;
-        j = (int) proccbrt;
+        j = (long) proccbrt;
         if (j<1) j = 1;
         while ((xprocs == 0) && (j>0)) {
-            k = (int) sqrt((double) (NumProcs / j));
+            k = (long) sqrt((double) (NumProcs / j));
             if (k<1) k=1;
             while ((yprocs == 0) && (k>0)) {
                 l = NumProcs/(j*k);
@@ -197,26 +210,26 @@
             } /* while yprocs && k */
             j--;
         } /* while xprocs && j */
-        
-        printf("xprocs = %d\typrocs = %d\tzprocs = %d\n",
+
+        printf("xprocs = %ld\typrocs = %ld\tzprocs = %ld\n",
                xprocs, yprocs, zprocs);
         fflush(stdout);
-        
+
         /* Fill in start_end array values */
-        
+
         procnum = 0;
         x_inc = BOX_PER_SIDE/xprocs;
         y_inc = BOX_PER_SIDE/yprocs;
         z_inc = BOX_PER_SIDE/zprocs;
-        
+
         x_left = BOX_PER_SIDE - (xprocs*x_inc);
         y_left = BOX_PER_SIDE - (yprocs*y_inc);
         z_left = BOX_PER_SIDE - (zprocs*z_inc);
-        printf("x_inc = %d\t y_inc = %d\t z_inc = %d\n",x_inc,y_inc,z_inc);
-        printf("x_left = %d\t y_left = %d\t z_left = %d\n",x_left,y_left,z_left);
+        printf("x_inc = %ld\t y_inc = %ld\t z_inc = %ld\n",x_inc,y_inc,z_inc);
+        printf("x_left = %ld\t y_left = %ld\t z_left = %ld\n",x_left,y_left,z_left);
         fflush(stdout);
-        
-        
+
+
         x_first = 0;
         x_ct = x_left;
         x_last = -1;
@@ -239,13 +252,13 @@
                     if (z_ct == 0) z_inc--;
                     z_last += z_inc;
                     start_end[procnum]->box[XDIR][FIRST] = x_first;
-                    start_end[procnum]->box[XDIR][LAST] = 
+                    start_end[procnum]->box[XDIR][LAST] =
                         min(x_last, BOX_PER_SIDE - 1);
                     start_end[procnum]->box[YDIR][FIRST] = y_first;
-                    start_end[procnum]->box[YDIR][LAST] = 
+                    start_end[procnum]->box[YDIR][LAST] =
                         min(y_last, BOX_PER_SIDE - 1);
                     start_end[procnum]->box[ZDIR][FIRST] = z_first;
-                    start_end[procnum]->box[ZDIR][LAST] = 
+                    start_end[procnum]->box[ZDIR][LAST] =
                         min(z_last, BOX_PER_SIDE - 1);
                     z_first = z_last + 1;
                     z_ct--;
@@ -257,24 +270,24 @@
             x_first = x_last + 1;
             x_ct--;
         }
-        
+
         /* Allocate space for my_boxes array */
-        
+
         my_boxes = (box_list **) G_MALLOC(NumProcs * sizeof(box_list *));
-        
+
         /* Set all box ptrs to null */
-        
+
         for (i=0; i<NumProcs; i++) my_boxes[i] = NULL;
-        
+
         /* Set up links for all boxes for initial interf and intraf */
-        
+
         temp_box = my_boxes[0];
         while (temp_box) {
             temp_box = temp_box->next_box;
         }
-        
+
         /* Allocate space for BOX array */
-        
+
         BOX = (box_type ***) G_MALLOC(BOX_PER_SIDE * sizeof(box_type **));
         for (i=0; i < BOX_PER_SIDE; i++) {
             BOX[i] = (box_type **) G_MALLOC( BOX_PER_SIDE * sizeof(box_type *));
@@ -286,14 +299,14 @@
                 }
             }
         } /* for i */
-        
+
         gl = (struct GlobalMemory *) G_MALLOC(gmem_size);
-        
+
         /* macro calls to initialize synch variables  */
-        
-        BARINIT(gl->start);
-        BARINIT(gl->InterfBar);
-        BARINIT(gl->PotengBar);
+
+        BARINIT(gl->start, NumProcs);
+        BARINIT(gl->InterfBar, NumProcs);
+        BARINIT(gl->PotengBar, NumProcs);
         LOCKINIT(gl->IOLock);
         LOCKINIT(gl->IndexLock);
         LOCKINIT(gl->IntrafVirLock);
@@ -301,84 +314,73 @@
         LOCKINIT(gl->KinetiSumLock);
         LOCKINIT(gl->PotengSumLock);
     }
-    
+
     fprintf(six,"SPHERICAL CUTOFF RADIUS    = %8.4f ANGSTROM\n",CUTOFF);
     fflush(six);
-    
+
     IRST=0;
-    
+
     /* call initialization routine */
-    
+
     INITIA();
-    
+
     gl->tracktime = 0;
     gl->intratime = 0;
     gl->intertime = 0;
-    
-    /* initialize Index to 1 so that the first created child gets 
+
+    /* initialize Index to 1 so that the first created child gets
        id 1, not 0 */
-    
+
     gl->Index = 1;
-    
-    /* spawn helper processes */
-    
-    CLOCK(gl->createstart);
-    for (ProcID = 1; ProcID < NumProcs; ProcID++) {
-        CREATE(WorkStart);
-    }
-    
-    CLOCK(gl->createend);
-    
-    LOCK(gl->IOLock);
-    printf("CREATETIME = %d\n",gl->createend-gl->createstart);
-    UNLOCK(gl->IOLock);
-    
+
     if (NSAVE > 0) {  /* not true for input decks provided */
-        LOCK(gl->IOLock);
-        fprintf(six,"COLLECTING X AND V DATA AT EVERY %4d TIME STEPS \n",NSAVE);
-        UNLOCK(gl->IOLock);
+        fprintf(six,"COLLECTING X AND V DATA AT EVERY %4ld TIME STEPS \n",NSAVE);
     }
-    
-    
-    /* CALL ROUTINE TO DO THE TIMESTEPS, with own id passed as 0 */
-    
+
+    /* spawn helper processes */
     CLOCK(gl->computestart);
-    
-    XTT = MDMAIN(NFSV,NFRST,NSTEP,NRST,NPRINT,NSAVE,LKT,NORD1,0); 
-    
+    CREATE(WorkStart, NumProcs);
+
     /* macro to make main process wait for all others to finish */
-    WAIT_FOR_END(NumProcs-1);
+    WAIT_FOR_END(NumProcs);
     CLOCK(gl->computeend);
-    
-    printf("COMPUTESTART (after initialization) = %u\n",gl->computestart);
-    printf("COMPUTEEND = %u\n",gl->computeend);
-    printf("COMPUTETIME (after initialization) = %u\n",gl->computeend-gl->computestart);
-    printf("Measured Time (2nd timestep onward) = %u\n",gl->tracktime);
-    printf("Intramolecular time only (2nd timestep onward) = %u\n",gl->intratime);
-    printf("Intermolecular time only (2nd timestep onward) = %u\n",gl->intertime);
-    printf("Other time (2nd timestep onward) = %u\n",gl->tracktime - gl->intratime - gl->intertime);
-    
+
+    printf("COMPUTESTART (after initialization) = %lu\n",gl->computestart);
+    printf("COMPUTEEND = %lu\n",gl->computeend);
+    printf("COMPUTETIME (after initialization) = %lu\n",gl->computeend-gl->computestart);
+    printf("Measured Time (2nd timestep onward) = %lu\n",gl->tracktime);
+    printf("Intramolecular time only (2nd timestep onward) = %lu\n",gl->intratime);
+    printf("Intermolecular time only (2nd timestep onward) = %lu\n",gl->intertime);
+    printf("Other time (2nd timestep onward) = %lu\n",gl->tracktime - gl->intratime - gl->intertime);
+
     printf("\nExited Happily with XTT = %g (note: XTT value is garbage if NPRINT > NSTEP)\n", XTT);
-    
+
     MAIN_END;
 } /* main.c */
 
 void WorkStart() /* routine that each created process starts at;
                     it simply calls the timestep routine */
 {
-    unsigned ProcID;
-    double MDMAIN();
-    
+    long ProcID;
+    double LocalXTT;
+
     LOCK(gl->IndexLock);
     ProcID = gl->Index++;
     UNLOCK(gl->IndexLock);
-    
-    ProcID = ProcID % NumProcs; 
-    
+
+    BARINCLUDE(gl->start);
+    BARINCLUDE(gl->InterfBar);
+    BARINCLUDE(gl->PotengBar);
+
+    ProcID = ProcID % NumProcs;
+
     /*  POSSIBLE ENHANCEMENT:  Here's where one might bind processes to processors
         if one wanted to.
         */
-    
-    MDMAIN(NFSV,NFRST,NSTEP,NRST,NPRINT,NSAVE,LKT,NORD1,ProcID);
+
+    LocalXTT = MDMAIN(NSTEP,NPRINT,NSAVE,NORD1,ProcID);
+    if (ProcID == 0) {
+	    XTT = LocalXTT;
+    }
 }
 
diff -Naur splash2/codes/apps/water-spatial/water.H splash2-modified/codes/apps/water-spatial/water.H
--- splash2/codes/apps/water-spatial/water.H	1994-10-14 01:36:45.000000000 -0400
+++ splash2-modified/codes/apps/water-spatial/water.H	2007-03-22 18:36:00.000000000 -0400
@@ -14,10 +14,10 @@
 /*                                                                       */
 /*************************************************************************/
 
-  /* some variable declarations and some macro definitions */
-  
-  extern double OMAS,HMAS,WTMOL,ROH,ANGLE,FHM,FOM,ROHI,ROHI2;
-  extern int NATOMS;
+/* some variable declarations and some macro definitions */
+
+extern double OMAS,HMAS,WTMOL,ROH,ANGLE,FHM,FOM,ROHI,ROHI2;
+extern long NATOMS;
 #define max(a,b) ( (a) < (b) ) ? b : a
 #define min(a,b) ( (a) > (b) ) ? b : a
 #define ONE ((double) 1)
diff -Naur splash2/codes/apps/water-spatial/wwpot.H splash2-modified/codes/apps/water-spatial/wwpot.H
--- splash2/codes/apps/water-spatial/wwpot.H	1994-10-14 01:36:45.000000000 -0400
+++ splash2-modified/codes/apps/water-spatial/wwpot.H	2007-03-22 18:35:51.000000000 -0400
@@ -14,7 +14,6 @@
 /*                                                                       */
 /*************************************************************************/
 
-  /* some variable declarations */
-  
-  extern double  QQ,A1,B1,A2,B2,A3,B3,A4,B4,AB1,AB2,AB3,AB4,C1,C2,
-  QQ2,QQ4,REF1,REF2,REF4;
+/* some variable declarations */
+
+extern double  QQ,A1,B1,A2,B2,A3,B3,A4,B4,AB1,AB2,AB3,AB4,C1,C2,QQ2,QQ4,REF1,REF2,REF4;
diff -Naur splash2/codes/kernels/cholesky/amal.C splash2-modified/codes/kernels/cholesky/amal.C
--- splash2/codes/kernels/cholesky/amal.C	1994-10-11 23:51:44.000000000 -0400
+++ splash2-modified/codes/kernels/cholesky/amal.C	2006-09-14 17:58:57.000000000 -0400
@@ -19,15 +19,16 @@
 #include <stdio.h>
 #include "matrix.h"
 
-int *next_in_super, *member_of, *super_parent;
-int *tree_firstchild, *tree_sibling;
-int *tree_original_firstchild, *tree_original_sibling;
-int ops_added;
+long *next_in_super, *member_of, *super_parent;
+long *tree_firstchild, *tree_sibling;
+long *tree_original_firstchild, *tree_original_sibling;
+long ops_added;
 double *crit;
+extern long *INVP;
 
-OpsFromSuper(size, nz)
+long OpsFromSuper(long size, long nz)
 {
-  int ops = 0;
+  long ops = 0;
 
   ops += size*(size+1)*(2*size+1)/6;
   ops += size*size*(nz-size);
@@ -36,10 +37,9 @@
   return(ops);
 }
 
-CountSupers(cols, node)
-int *node;
+long CountSupers(long cols, long *node)
 {
-  int i, supers;
+  long i, supers;
 
   supers = 0;
   for (i=0; i<cols; i+=node[i])
@@ -48,23 +48,21 @@
   return(supers);
 }
 
-Amalgamate2(join, M, T, nz, node, domain, target_size)
-SMatrix M;
-int *T, *nz, *node, *domain;
+void Amalgamate2(long join, SMatrix M, long *T, long *nz, long *node, long *domain, long target_size)
 {
-  int i, j;
-  int counter, supers_before, supers_after;
+  long i, j;
+  long counter, supers_before, supers_after;
   double g_ops_before;
   extern double *work_tree;
-  extern int *PERM, *INVP, *firstchild, *child;
+  extern long *PERM, *firstchild, *child;
 
-  tree_firstchild = (int *) malloc((M.n+1)*sizeof(int));
-  tree_sibling = (int *) malloc((M.n+1)*sizeof(int));
-  tree_original_firstchild = (int *) malloc((M.n+1)*sizeof(int));
-  tree_original_sibling = (int *) malloc((M.n+1)*sizeof(int));
-  next_in_super = (int *) malloc((M.n+1)*sizeof(int));
-  member_of = (int *) malloc((M.n+1)*sizeof(int));
-  super_parent = (int *) malloc((M.n+1)*sizeof(int));
+  tree_firstchild = (long *) malloc((M.n+1)*sizeof(long));
+  tree_sibling = (long *) malloc((M.n+1)*sizeof(long));
+  tree_original_firstchild = (long *) malloc((M.n+1)*sizeof(long));
+  tree_original_sibling = (long *) malloc((M.n+1)*sizeof(long));
+  next_in_super = (long *) malloc((M.n+1)*sizeof(long));
+  member_of = (long *) malloc((M.n+1)*sizeof(long));
+  super_parent = (long *) malloc((M.n+1)*sizeof(long));
 
   for (i=0; i<=M.n; i++)
     tree_firstchild[i] = -1;
@@ -117,27 +115,22 @@
 
   supers_after = CountSupers(M.n, node);
 
-  printf("%d/%d supers before/after\n", supers_before, supers_after);
+  printf("%ld/%ld supers before/after\n", supers_before, supers_after);
   printf("%.0f/%.0f (%.2f) ops before/after amalgamation\n",
 	 g_ops_before, work_tree[M.n], work_tree[M.n]/(double) g_ops_before);
   if (ops_added != work_tree[M.n]-g_ops_before)
-    printf("Model says %d ops added, really %.0f\n", ops_added,
+    printf("Model says %ld ops added, really %.0f\n", ops_added,
 	   work_tree[M.n]-g_ops_before);
 }
 
 
-ConsiderMerge(join, super, M, nz, node, domain, target_size, traversal_order)
-SMatrix M;
-int *nz, *node, *domain;
+void ConsiderMerge(long join, long super, SMatrix M, long *nz, long *node, long *domain, long target_size, long traversal_order)
 {
-  int i, parent;
-  int ops_before, ops_after, do_merge, do_merge_simple, possible;
-  int allow_critical_to_grow;
+  long i, parent;
+  long ops_before, ops_after, do_merge, do_merge_simple, possible;
+  long allow_critical_to_grow;
   double time_before, time_after, dummy, simple_diff;
   double path_grows;
-  extern int *T;
-  extern double *crit;
-  extern int BETA;
 
   super = member_of[super];
 
@@ -188,7 +181,7 @@
 
     if (do_merge) {
 
-      JoinTwoSupers2(nz, node, domain, super, parent, target_size);
+      JoinTwoSupers2(nz, node, super, parent);
       ops_added += (ops_after-ops_before);
 
     }
@@ -203,10 +196,9 @@
     }
 }
 
-JoinTwoSupers2(nz, node, domain, child, parent, target_size)
-int *nz, *node, *domain;
+void JoinTwoSupers2(long *nz, long *node, long child, long parent)
 {
-  int i, child_last, member, grandparent;
+  long i, child_last, member, grandparent;
 
   /* record new memberships */
   member = parent;
@@ -255,11 +247,9 @@
 }
 
 
-ReorderMatrix(M, super, node, counter, PERM)
-SMatrix M;
-int *node, *counter, *PERM;
+void ReorderMatrix(SMatrix M, long super, long *node, long *counter, long *PERM)
 {
-  int child, member, which_member;
+  long child, member, which_member;
 
   if (super != M.n) {
     super = member_of[super];
@@ -282,15 +272,12 @@
 }
 
 
-FixNodeNZAndT(M, PERM, node, nz, T)
-SMatrix M;
-int *PERM, *node, *nz, *T;
+void FixNodeNZAndT(SMatrix M, long *PERM, long *node, long *nz, long *T)
 {
-  int super, j;
-  int *tmp;
-  extern int *panels, *INVP;
+  long super, j;
+  long *tmp;
 
-  tmp = (int *) malloc(M.n*sizeof(int));
+  tmp = (long *) malloc(M.n*sizeof(long));
 
   for (j=0; j<M.n; j++)
     tmp[j] = node[j];
@@ -317,10 +304,9 @@
   free(tmp);
 }
 
-InvertPerm(n, PERM, INVP)
-int *PERM, *INVP;
+void InvertPerm(long n, long *PERM, long *INVP)
 {
-  int i;
+  long i;
 
   for (i=0; i<=n; i++)
     INVP[i] = -1;
@@ -334,7 +320,7 @@
 }
 
 
-double PathLength(cols, rows, target_panel_size)
+double PathLength(long cols, long rows, long target_panel_size)
 {
   double path_length;
 
@@ -344,4 +330,3 @@
   return(path_length);
 }
 
-
diff -Naur splash2/codes/kernels/cholesky/assign.C splash2-modified/codes/kernels/cholesky/assign.C
--- splash2/codes/kernels/cholesky/assign.C	1994-10-11 23:51:44.000000000 -0400
+++ splash2-modified/codes/kernels/cholesky/assign.C	2006-09-14 18:04:13.000000000 -0400
@@ -25,15 +25,14 @@
 #define TIME(ops,misses) (ops+(misses)*MISS_COST)/(1.0+MISS_COST/BS)
 
 extern BMatrix LB;
-extern int P;
-extern int BS;
+extern long P;
+extern long BS;
 double *opStats = NULL;
 double seq_time, seq_ops, seq_misses;
 
-PDIV(src_col, src_nz, ops, misses, runtime)
-double *ops, *misses, *runtime;
+void PDIV(long src_col, long src_nz, double *ops, double *misses, double *runtime)
 {
-  int super_size, passes;
+  long super_size, passes;
   double this_ops, this_misses;
 
   super_size = src_col*src_nz - src_col*(src_col-1)/2;
@@ -49,10 +48,9 @@
 }
 
 
-PMOD(src_col, dest_col, dest_nz, ops, misses, runtime)
-double *ops, *misses, *runtime;
+void PMOD(long src_col, long dest_col, long dest_nz, double *ops, double *misses, double *runtime)
 {
-  int update_size, passes_src, passes_dest;
+  long update_size, passes_src, passes_dest;
   double this_ops, this_misses;
 
   update_size = dest_col*dest_nz - dest_col*(dest_col-1)/2;
@@ -71,8 +69,7 @@
   *runtime += TIME(this_ops, this_misses);
 }
 
-PADD(cols, rows, misses, runtime)
-double *misses, *runtime;
+void PADD(long cols, long rows, double *misses, double *runtime)
 {
   double this_misses;
 
@@ -83,9 +80,9 @@
 }
 
 
-AssignBlocksNow(distribute)
+void AssignBlocksNow()
 {
-  int i, j, which;
+  long i, j;
 
   if (P == 1) {
     for (j=0; j<LB.n; j+=LB.partition_size[j])
@@ -93,15 +90,15 @@
 	for (i=LB.col[j]; i<LB.col[j+1]; i++)
 	  BLOCK(i)->owner = 0;
   } else {
-    EmbedBlocks(P);
+    EmbedBlocks();
   }
 }
 
 
-EmbedBlocks(P)
+void EmbedBlocks()
 {
-  int j, block;
-  extern int scatter_decomposition;
+  long j, block;
+  extern long scatter_decomposition;
 
   /* number the block partitions */
 
diff -Naur splash2/codes/kernels/cholesky/bfac.C splash2-modified/codes/kernels/cholesky/bfac.C
--- splash2/codes/kernels/cholesky/bfac.C	1994-10-11 23:51:44.000000000 -0400
+++ splash2-modified/codes/kernels/cholesky/bfac.C	2007-03-07 17:02:09.000000000 -0500
@@ -19,22 +19,20 @@
 #include "matrix.h"
 #include <math.h>
 
-int vMiss=0, wMiss=0, xMiss=0, yMiss=0; /* Local but don't care */
-extern int BS;
+long vMiss=0, wMiss=0, xMiss=0, yMiss=0; /* Local but don't care */
+extern long BS;
 extern struct GlobalMemory *Global;
 extern BMatrix LB;
-extern int solution_method;
-extern int *node, *firstchild;  /* global */
-int *block_start, *all_blocks;
+extern long solution_method;
+extern long *node, *firstchild;  /* global */
+long *block_start, *all_blocks;
 
 /* arguments */
-extern int *T, P;
+extern long *T, P;
 
-BFac(diag, MyNum, lc)
-int MyNum;
-struct LocalCopies *lc;
+void BFac(long diag, struct LocalCopies *lc)
 {
-  int n, is, il, js, jl, ks, kl;
+  long n, is, il, js, jl, ks, kl;
   double *A;
 
   n = BLOCK(diag)->length;
@@ -48,11 +46,11 @@
     for (is=jl; is<n; is+=BS) {
       il = is+BS; if (il > n) il = n;
 
-      CopyBlock(A, lc->blktmp, n, is, js, il, jl, MyNum, lc);
+      CopyBlock(A, lc->blktmp, n, is, js, il, jl);
 
       OneDiv(&A[js+n*js], lc->blktmp, jl-js, il-is, n);
 
-      CopyBlockBack(A, lc->blktmp, n, is, js, il, jl, MyNum, lc);
+      CopyBlockBack(A, lc->blktmp, n, is, js, il, jl);
 
       for (ks=jl; ks<is; ks+=BS) {
         kl = ks+BS; if (kl > n) kl = n;
@@ -70,10 +68,9 @@
 
 /* Factor A (dim n1 by n1), stride n2 */
 
-OneFac(A, n1, n2)
-double *A;
+void OneFac(double *A, long n1, long n2)
 {
-  int i, j, k;
+  long i, j, k;
 
   for (j=0; j<n1; j++) {
     for (k=0; k<j; k++)
@@ -86,13 +83,9 @@
 }
 
 
-BDiv(diag, below, n1, n3, diag_nz, below_nz, MyNum, lc)
-int diag, below, MyNum;
-int n1, n3;
-double *diag_nz, *below_nz;
-struct LocalCopies *lc;
+void BDiv(long n1, long n3, double *diag_nz, double *below_nz, struct LocalCopies *lc)
 {
-  int is, il, js, jl, ks, kl;
+  long is, il, js, jl, ks, kl;
   double *A, *B;
 
   /* diag block is A, dim n1 by n1 */
@@ -110,11 +103,11 @@
       for (is=0; is<n3; is+=BS) {
         il = is+BS; if (il > n3) il = n3;
 
-        CopyBlock(B, lc->blktmp, n3, is, js, il, jl, MyNum, lc);
+        CopyBlock(B, lc->blktmp, n3, is, js, il, jl);
 
         OneDiv(&A[js+js*n1], lc->blktmp, jl-js, il-is, n1);
 
-        CopyBlockBack(B, lc->blktmp, n3, is, js, il, jl, MyNum, lc);
+        CopyBlockBack(B, lc->blktmp, n3, is, js, il, jl);
 
         for (ks=jl; ks<n1; ks+=BS) {
           kl = ks+BS; if (kl > n1) kl = n1;
@@ -130,10 +123,9 @@
 /* below block is B, dim n3 by n1 */
 /* n4 is stride of A */
 
-OneDiv(A, B, n1, n3, n4)
-double *A, *B;
+void OneDiv(double *A, double *B, long n1, long n3, long n4)
 {
-  int i, j, k;
+  long i, j, k;
   double a_j0k0, a_j0k1, a_j0k2, a_j0k3;
   double a_j1k0, a_j1k1, a_j1k2, a_j1k3;
   double *b0, *b1, *b2, *b3;
@@ -193,13 +185,9 @@
 
 }
 
-BMod(top, bend, n1, n2, n3, top_nz, bend_nz, dest_nz, MyNum, lc)
-int top, bend, MyNum;
-int n1, n2, n3;
-double *top_nz, *bend_nz, *dest_nz;
-struct LocalCopies *lc;
+void BMod(long n1, long n2, long n3, double *top_nz, double *bend_nz, double *dest_nz, struct LocalCopies *lc)
 {
-  int is, il, ks, kl, hbs;
+  long is, il, ks, kl, hbs;
   double *B, *A, *C;
 
   /* three blocks form an L */
@@ -228,21 +216,16 @@
       il = is+BS; if (il > n3) il = n3;
       for (ks=0; ks<n2; ks+=BS) {
         kl = ks+BS; if (kl > n2) kl = n2;
-        CopyBlock(B, lc->blktmp, n3, is, ks, il, kl, MyNum, lc);
+        CopyBlock(B, lc->blktmp, n3, is, ks, il, kl);
         OneMatmat(lc->blktmp, &A[ks*n1], &C[is], n1, kl-ks, il-is, n3, n1);
       }
     }
   }
 }
 
-
-CopyBlock(B, dest, n3, is, ks, il, kl,MyNum,lc)
-double *B, *dest;
-int MyNum;
-struct LocalCopies *lc;
+void CopyBlock(double *B, double *dest, long n3, long is, long ks, long il, long kl/*, long MyNum, struct LocalCopies *lc*/)
 {
-  int i, k, bs;
-  double *destination, *bptr, *top_of_B;
+  long i, k, bs;
 
   bs = il-is;
   for (k=ks; k<kl; k++)
@@ -251,12 +234,9 @@
     }
 }
 
-
-
-CopyBlockBack(B, src, n3, is, ks, il, kl)
-double *B, *src;
+void CopyBlockBack(double *B, double *src, long n3, long is, long ks, long il, long kl)
 {
-  int i, k, bs;
+  long i, k, bs;
 
   bs = il-is;
   for (k=ks; k<kl; k++)
@@ -268,10 +248,9 @@
 /* Result added into C (C dim n3 by n1) */
 /* n4 is stride of C, n5 is stride of A */
 
-OneMatmat(B, A, C, n1, n2, n3, n4, n5)
-double *B, *A, *C;
+void OneMatmat(double *B, double *A, double *C, long n1, long n2, long n3, long n4, long n5)
 {
-  int i, j, k;
+  long i, j, k;
   double a_j0k0, a_j0k1, a_j0k2, a_j0k3;
   double a_j0k4, a_j0k5, a_j0k6, a_j0k7;
   double a_j1k0, a_j1k1, a_j1k2, a_j1k3;
@@ -377,12 +356,9 @@
 /* block is n1 by n2, with given nz */
 /* subtract lower triangle of AA^T from 'dest_nz' */
 
-BLMod(left, n1, n2, left_nz, dest_nz, MyNum, lc)
-int left, n1, n2, MyNum;
-double *left_nz, *dest_nz;
-struct LocalCopies *lc;
+void BLMod(long n1, long n2, double *left_nz, double *dest_nz, struct LocalCopies *lc)
 {
-  int is, ks, il, kl;
+  long is, ks, il, kl;
   double *A, *C;
 
   A = left_nz;
@@ -396,7 +372,7 @@
       il = is+BS; if (il > n1) il = n1;
       for (ks=0; ks<n2; ks+=BS) {
         kl = ks+BS; if (kl > n2) kl = n2;
-        CopyBlock(A, lc->blktmp, n1, is, ks, il, kl, MyNum, lc);
+        CopyBlock(A, lc->blktmp, n1, is, ks, il, kl);
         OneMatmat(lc->blktmp, &A[ks*n1], &C[is], is, kl-ks, il-is, n1, n1);
 	OneLower(lc->blktmp, &C[is+is*n1], il-is, kl-ks, n1);
       }
@@ -409,10 +385,9 @@
 /* result is lower triangle of square block, dim n1 by n1 */
 /* n3 is stride of C */
 
-OneLower(A, C, n1, n2, n3)
-double *A, *C;
+void OneLower(double *A, double *C, long n1, long n2, long n3)
 {
-  int i, j, k;
+  long i, j, k;
   double *tmp;
   double a_j0k0, a_j0k1, a_j0k2, a_j0k3;
   double a_j1k0, a_j1k1, a_j1k2, a_j1k3;
@@ -463,13 +438,10 @@
 }
 
 
-FindBlockUpdate(domain, bli, blj, update, stride)
-int domain, blj, bli;
-double **update;
-int *stride;
+void FindBlockUpdate(long domain, long bli, long blj, double **update, long *stride)
 {
-  int i;
-  int into_i, into_j, update_len;
+  long i;
+  long into_i, into_j, update_len;
   double *domain_update;
 
   into_j = 0;
@@ -486,3 +458,4 @@
   *update = &domain_update[into_j*update_len - into_j*(into_j+1)/2 + into_i];
   *stride = update_len - into_j - 1;
 }
+
diff -Naur splash2/codes/kernels/cholesky/bksolve.C splash2-modified/codes/kernels/cholesky/bksolve.C
--- splash2/codes/kernels/cholesky/bksolve.C	1994-10-11 23:51:44.000000000 -0400
+++ splash2-modified/codes/kernels/cholesky/bksolve.C	2006-09-14 18:38:19.000000000 -0400
@@ -19,12 +19,9 @@
 #include "matrix.h"
 #include <math.h>
 
-double *TriBSolve(LB, b, PERM, INVP)
-BMatrix LB;
-double *b;
-int *PERM, *INVP;
+double *TriBSolve(BMatrix LB, double *b, long *PERM)
 {
-  int i, j, i1, j1, bl, row;
+  long i, j, i1, j1, bl, row;
   double *y, *xp, *x, *bt;
 
   x = (double *) malloc(LB.n*sizeof(double));
@@ -128,11 +125,10 @@
   return(x);
 }
 
-double ComputeNorm(x, n)
-double *x;
+double ComputeNorm(double *x, long n)
 {
   double tmp = 0.0;
-  int i;
+  long i;
 
   for (i=0; i<n; i++)
     if (fabs(x[i]-1.0) > tmp)
@@ -141,11 +137,10 @@
   return(tmp);
 }
 
-double *CreateVector(M)
-SMatrix M;
+double *CreateVector(SMatrix M)
 {
-  int i, j;
-  double *b, Value();
+  long i, j;
+  double *b;
 
   b = NewVector(M.n);
 
@@ -161,9 +156,10 @@
   else {
     for (j=0; j<M.n; j++)
       for (i=M.col[j]; i<M.col[j+1]; i++) {
-	b[M.row[i]] += Value(M.row[i], j, M.n);
+	b[M.row[i]] += Value(M.row[i], j);
       }
   }
 
   return(b);
 }
+
diff -Naur splash2/codes/kernels/cholesky/block2.C splash2-modified/codes/kernels/cholesky/block2.C
--- splash2/codes/kernels/cholesky/block2.C	1994-10-11 23:51:44.000000000 -0400
+++ splash2-modified/codes/kernels/cholesky/block2.C	2006-09-14 19:28:03.000000000 -0400
@@ -19,27 +19,23 @@
 #include <math.h>
 #include "matrix.h"
 
-extern int *node;  /* ALL GLOBAL */
-extern int postpass_partition_size;
-extern int distribute;
+extern long *node;  /* ALL GLOBAL */
+extern long postpass_partition_size;
+extern long distribute;
 BMatrix LB;
 extern SMatrix L;
-int P_dimi, P_dimj;
+long P_dimi, P_dimj;
 
 /* perform symbolic factorization of original matrix into block form */
 
-CreateBlockedMatrix2(M, block_ub, T, firstchild, child,
-	PERM, INVP, domain, partition)
-SMatrix M;
-int *T, *firstchild, *child, *PERM, *INVP, *domain, *partition;
+void CreateBlockedMatrix2(SMatrix M, long block_ub, long *T, long *firstchild, long *child, long *PERM, long *INVP, long *domain, long *partition)
 {
-  int i, j, k, p, which, super, n_nz;
-  int *structure, *nz;
+  long i, j, k, p, which, super, n_nz;
+  long *structure, *nz;
   Block *blocks;
-  extern int P;
-  extern int *domains, *proc_domains;
-  extern double max_block_size;
-  int num_partitions, piece_size, piece, current;
+  extern long P;
+  extern long *domains, *proc_domains;
+  long num_partitions, piece_size, piece, current;
 
   LB.n = M.n;
   LB.domain = domain;
@@ -54,14 +50,14 @@
     LB.proc_domain_storage[i] = NULL;
 
   /* one dummy column for each domain */
-  LB.partition_size = (int *) MyMalloc((LB.n+LB.n_domains+1)*sizeof(int),
+  LB.partition_size = (long *) MyMalloc((LB.n+LB.n_domains+1)*sizeof(long),
 				    DISTRIBUTED);
-  LB.col = (int *) MyMalloc((LB.n+LB.n_domains+1)*sizeof(int), DISTRIBUTED);
+  LB.col = (long *) MyMalloc((LB.n+LB.n_domains+1)*sizeof(long), DISTRIBUTED);
 
   LB.entry = (Entry *) G_MALLOC(LB.entries_allocated*sizeof(Entry),0);
   MigrateMem(LB.entry, LB.entries_allocated*sizeof(Entry), DISTRIBUTED);
-  LB.row = (int *) G_MALLOC(LB.entries_allocated*sizeof(int), 0);
-  MigrateMem(LB.row, LB.entries_allocated*sizeof(int), DISTRIBUTED);
+  LB.row = (long *) G_MALLOC(LB.entries_allocated*sizeof(long), 0);
+  MigrateMem(LB.row, LB.entries_allocated*sizeof(long), DISTRIBUTED);
 
   FindMachineDimensions(P);
 
@@ -111,25 +107,25 @@
     LB.n_partitions = 1;
 
   /* determine numbering based on partitions only */
-  LB.renumbering = (int *) MyMalloc((LB.n+LB.n_domains)*sizeof(int),
+  LB.renumbering = (long *) MyMalloc((LB.n+LB.n_domains)*sizeof(long),
 				     DISTRIBUTED);
   ComputePartitionNumbering(LB.renumbering);
   for (j=0; j<LB.n_domains; j++)
     LB.renumbering[LB.n+j] = j%LB.n_partitions;
 
   /* determine mapping of rows/columns of blocks to rows/columns of procs */
-  LB.mapI = (int *) MyMalloc(LB.n_partitions*sizeof(int), DISTRIBUTED);
-  LB.mapJ = (int *) MyMalloc(LB.n_partitions*sizeof(int), DISTRIBUTED);
+  LB.mapI = (long *) MyMalloc(LB.n_partitions*sizeof(long), DISTRIBUTED);
+  LB.mapJ = (long *) MyMalloc(LB.n_partitions*sizeof(long), DISTRIBUTED);
   for (i=0; i<LB.n_partitions; i++)
     LB.mapI[i] = LB.mapJ[i] = i;
   printf("No redistribution\n");
 
   printf("Supers: "); DumpSizes(LB, domain, node);
   printf("Blocks: "); DumpSizes(LB, domain, LB.partition_size);
-  printf("%d partitions\n", LB.n_partitions);
+  printf("%ld partitions\n", LB.n_partitions);
 
-  structure = (int *) malloc(M.n*sizeof(int));
-  nz = (int *) malloc(M.n*sizeof(int));
+  structure = (long *) malloc(M.n*sizeof(long));
+  nz = (long *) malloc(M.n*sizeof(long));
   for (i=0; i<M.n; i++)
     structure[i] = 0;
 
@@ -170,7 +166,7 @@
   for (j=0; j<LB.n_domains; j++)
     LB.n_blocks += (LB.col[LB.n+j+1]-LB.col[LB.n+j]);
 
-  printf("%d partitions, %d blocks\n", LB.n_partitions, LB.n_blocks);
+  printf("%ld partitions, %ld blocks\n", LB.n_partitions, LB.n_blocks);
 
   /* now allocate storage for blocks and fill in simple info */
   blocks = (Block *) MyMalloc(LB.n_blocks*sizeof(Block), DISTRIBUTED);
@@ -183,7 +179,7 @@
         BLOCK(i)->j = j;
 	if (LB.renumbering[BLOCK(i)->i] < 0 ||
 	    LB.renumbering[BLOCK(i)->j] < 0) {
-	  printf("Block %d has bad structure\n");
+	  printf("Block %ld has bad structure\n", which);
 	  exit(-1);
 	}
 	BLOCK(i)->done = 0;
@@ -209,9 +205,9 @@
 
 }
 
-FindNumPartitions(set_size, piece_size)
+long FindNumPartitions(long set_size, long piece_size)
 {
-  int num_partitions;
+  long num_partitions;
 
   if (set_size <= 4*piece_size/3)
     num_partitions = 1;
@@ -226,10 +222,9 @@
 }
 
 
-ComputeBlockParents(T)
-int *T;
+void ComputeBlockParents(long *T)
 {
-  int b, i, parent_col;
+  long b, i, parent_col;
 
   /* compute block parents */
 
@@ -242,8 +237,7 @@
 	else if (BLOCK(i)->i <= BLOCK(i)->j)
 	  BLOCK(i)->parent = -1; /* above diag */
 	else {
-	  BLOCK(i)->parent = FindBlock(BLOCK(i)->i,
-						parent_col);
+	  BLOCK(i)->parent = FindBlock(BLOCK(i)->i, parent_col);
 	  if (BLOCK(i)->parent == -1)
 	    printf("Parent not found\n");
 	}
@@ -254,24 +248,21 @@
   for (b=0; b<LB.n_domains; b++)
     for (i=LB.col[LB.n+b]; i<LB.col[LB.n+b+1]; i++) {
       parent_col = T[LB.domains[b]];
-      BLOCK(i)->parent = FindBlock(BLOCK(i)->i,
-					    parent_col);
+      BLOCK(i)->parent = FindBlock(BLOCK(i)->i, parent_col);
     }
 }
 
 
 /* find non-zero structure of individual blocks */
 
-FillInStructure(M, firstchild, child, PERM, INVP)
-SMatrix M;
-int *firstchild, *child, *PERM, *INVP;
+void FillInStructure(SMatrix M, long *firstchild, long *child, long *PERM, long *INVP)
 {
-  int i, j, col, super;
-  int *structure, *nz, n_nz;
+  long i, j, col, super;
+  long *structure, *nz, n_nz;
 
   /* all procedures get structure=0, and return structure=0 */
-  structure = (int *) malloc(M.n*sizeof(int));
-  nz = (int *) malloc(M.n*sizeof(int));
+  structure = (long *) malloc(M.n*sizeof(long));
+  nz = (long *) malloc(M.n*sizeof(long));
   for (i=0; i<M.n; i++)
     structure[i] = 0;
 
@@ -300,11 +291,9 @@
 
 /* put original non-zero values into blocks */
 
-FillInNZ(M, PERM, INVP)
-SMatrix M;
-int *PERM, *INVP;
+void FillInNZ(SMatrix M, long *PERM, long *INVP)
 {
-  int i, j;
+  long j;
   double *scatter;
 
   scatter = (double *) malloc(M.n*sizeof(double));
@@ -319,10 +308,9 @@
 }
 
 
-FindDomStructure(super, nz, n_nz)
-int *nz;
+void FindDomStructure(long super, long *nz, long n_nz)
 {
-  int col, i;
+  long col, i;
 
   for (col=super; col<super+node[super]; col++) {
     LB.col[col+1] = LB.col[col] + n_nz - (col-super);
@@ -336,9 +324,9 @@
   }
 }
 
-FindDummyDomainStructure(which_domain)
+void FindDummyDomainStructure(long which_domain)
 {
-  int col, row, current_block, current_block_last;
+  long col, row, current_block, current_block_last;
 
   col = LB.domains[which_domain];
 
@@ -368,20 +356,17 @@
 }
 
 
-CheckColLength(col, n_nz)
+void CheckColLength(long col, long n_nz)
 {
-  extern int *nz;
+  extern long *nz;
 
   if (n_nz != nz[col])
-    printf("Col %d: %d vs %d\n", col, n_nz, nz[col]);
+    printf("Col %ld: %ld vs %ld\n", col, n_nz, nz[col]);
 }
 
-
-FindBlStructure(M, super, PERM, INVP, firstchild, child, structure, nz)
-SMatrix M;
-int *PERM, *INVP, *firstchild, *child, *structure, *nz;
+void FindBlStructure(SMatrix M, long super, long *PERM, long *INVP, long *firstchild, long *child, long *structure, long *nz)
 {
-  int truecol, i, c, col, the_child, bl, n_nz;
+  long truecol, i, c, col, the_child, bl, n_nz;
 
   n_nz = 0;
   for (col=super; col<super+node[super]; col++) {
@@ -429,12 +414,9 @@
 }
 
 
-FindSuperStructure(M, super, PERM, INVP, firstchild, child,
-		   structure, nz, n_nz)
-SMatrix M;
-int *PERM, *INVP, *firstchild, *child, *structure, *nz, *n_nz;
+void FindSuperStructure(SMatrix M, long super, long *PERM, long *INVP, long *firstchild, long *child, long *structure, long *nz, long *n_nz)
 {
-  int i, truecol, current, bl, c, the_child, row;
+  long i, truecol, current, bl, c, the_child, row;
 
   *n_nz = 0;
 
@@ -490,10 +472,9 @@
 }
 
 
-FindDetailedStructure(col, structure, nz, n_nz)
-int *structure, *nz;
+void FindDetailedStructure(long col, long *structure, long *nz, long n_nz)
 {
-  int i, j, row, n, owner;
+  long i, j, row, n, owner;
 
   for (i=0; i<n_nz; i++)
     structure[nz[i]] = 1;
@@ -512,8 +493,8 @@
     else {
       owner = EmbeddedOwner(i);
       if (owner < 0)
-	printf("%d,%d: %d\n", BLOCKROW(i), BLOCKCOL(i), owner);
-      BLOCK(i)->structure = (int *) MyMalloc(n*sizeof(int), owner);
+	printf("%ld,%ld: %ld\n", BLOCKROW(i), BLOCKCOL(i), owner);
+      BLOCK(i)->structure = (long *) MyMalloc(n*sizeof(long), owner);
       n = 0;
       for (j=0; j<LB.partition_size[row]; j++)
         if (structure[row+j])
@@ -527,16 +508,15 @@
 }
 
 
-AllocateNZ()
+void AllocateNZ()
 {
-  int i, j, b, size;
+  long i, j, b, size;
 
   for (j=0; j<LB.n; j+=LB.partition_size[j])
     if (!LB.domain[j]) {
       for (b=LB.col[j]; b<LB.col[j+1]; b++) {
 	size = LB.partition_size[j]*BLOCK(b)->length;
-	BLOCK(b)->nz = (double *) MyMalloc(size*sizeof(double),
-					    BLOCK(b)->owner);
+	BLOCK(b)->nz = (double *) MyMalloc(size*sizeof(double), BLOCK(b)->owner);
 	for (i=0; i<size; i++)
 	  BLOCK(b)->nz[i] = 0.0;
       }
@@ -545,13 +525,9 @@
 
 
 
-FillIn(M, col, PERM, INVP, scatter)
-SMatrix M;
-int *PERM, *INVP;
-double *scatter;
+void FillIn(SMatrix M, long col, long *PERM, long *INVP, double *scatter)
 {
-  int i, b, j1, row, truecol;
-  double Value();
+  long i, b, j1, row, truecol;
 
   truecol = PERM[col];
   if (LB.domain[col]) {
@@ -561,7 +537,7 @@
 	if (M.nz)
 	  scatter[row] = M.nz[i];
 	else
-	  scatter[row] = Value(M.row[i], truecol, M.n);
+	  scatter[row] = Value(M.row[i], truecol);
       }
 	
     }
@@ -580,7 +556,7 @@
 	  if (M.nz)
 	    scatter[row] = M.nz[i];
 	  else
-	    scatter[row] = Value(M.row[i], truecol, M.n);
+	    scatter[row] = Value(M.row[i], truecol);
 	}
       }
       for (b=LB.col[col]; b<LB.col[col+1]; b++) {
@@ -598,10 +574,9 @@
 }
 
 
-InsSort(nz, n)
-int *nz;
+void InsSort(long *nz, long n)
 {
-  int i, j, tmp;
+  long i, j, tmp;
 
   for (i=1; i<n; i++) {
     j = i;
@@ -612,13 +587,12 @@
 }
 
 
-
 /* determine relative indices for all blocks */
 
-BlDepth(col)
+long BlDepth(long col)
 {
-  int current, depth;
-  extern int *T;
+  long current, depth;
+  extern long *T;
 
   depth = 0;
   current = col;
@@ -631,10 +605,9 @@
 }
 
 /* must be stable, blocks in same column must remain in sorted order */
-SortByKey(n, blocks, keys)
-int *blocks, *keys;
+void SortByKey(long n, long *blocks, long *keys)
 {
-  int i, j, blocki, keyi;
+  long i, j, blocki, keyi;
 
   for (i=0; i<n; i++) {
     blocki = blocks[i];
@@ -653,18 +626,16 @@
 
 /* must be stable, blocks in same column must remain in sorted order */
 
-DumpSizes(LB, domain, sizes)
-BMatrix LB;
-int *domain, *sizes;
+void DumpSizes(BMatrix LB, long *domain, long *sizes)
 {
-  int i, *buckets, maxm;
+  long i, *buckets, maxm;
 
   maxm = 0;
   for (i=0; i<LB.n; i+=sizes[i])
     if (!domain[i] && sizes[i] > maxm)
       maxm = sizes[i];
 
-  buckets = (int *) malloc((maxm+1)*sizeof(int));
+  buckets = (long *) malloc((maxm+1)*sizeof(long));
   for (i=0; i<=maxm; i++)
     buckets[i] = 0;
 
@@ -676,7 +647,7 @@
     if (buckets[i] == 0)
       ;
     else
-      printf("%d: %d  ", i, buckets[i]);
+      printf("%ld: %ld  ", i, buckets[i]);
   }
   printf("\n");
 
@@ -684,10 +655,9 @@
 }
 
 
-ComputePartitionNumbering(numbering)
-int *numbering;
+void ComputePartitionNumbering(long *numbering)
 {
-  int j, which;
+  long j, which;
 
   for (j=0; j<LB.n; j++)
     numbering[j] = -1;
@@ -700,24 +670,24 @@
 
 
 /* factor P */
-FindMachineDimensions(P)
+void FindMachineDimensions(long P)
 {
-  int try, div;
+  long try = 0, div = 0;
 
-  for (try=(int) sqrt((double) P); try>0; try--) {
+  for (try=(long) sqrt((double) P); try>0; try--) {
     div = P/try;
     if (div*try == P)
       break;
   }
 
   P_dimi = div; P_dimj = try;
-  printf("Processor array is %d by %d\n", P_dimi, P_dimj);
+  printf("Processor array is %ld by %ld\n", P_dimi, P_dimj);
 }
 
 
-EmbeddedOwner(block)
+long EmbeddedOwner(long block)
 {
-  int row, col;
+  long row, col;
 
   row = LB.mapI[LB.renumbering[BLOCKROW(block)]] % P_dimi;
   col = LB.mapJ[LB.renumbering[BLOCKCOL(block)]] % P_dimj;
diff -Naur splash2/codes/kernels/cholesky/fo.C splash2-modified/codes/kernels/cholesky/fo.C
--- splash2/codes/kernels/cholesky/fo.C	1994-10-11 23:51:44.000000000 -0400
+++ splash2-modified/codes/kernels/cholesky/fo.C	2006-09-14 19:26:44.000000000 -0400
@@ -21,47 +21,43 @@
 
 extern struct GlobalMemory *Global;
 extern BMatrix LB;
-extern int P;
-extern int BS;
-extern int *node;  /* global */
+extern long P;
+extern long BS;
+extern long *node;  /* global */
+extern long scatter_decomposition, P_dimi, P_dimj;
 struct BlockList ***AllBlocks, ***DiagBlock;
-int **ToReceive, **NReceived;
+long **ToReceive, **NReceived;
 
 
-PreProcessFO(MyNum, lc)
-int MyNum;
-struct LocalCopies *lc;
+void PreProcessFO(long MyNum)
 {
-  InitRemainingFO(MyNum, lc);
-  InitReceivedFO(MyNum, lc);
+  InitRemainingFO(MyNum);
+  InitReceivedFO(MyNum);
 }
 
-PreAllocate1FO()
+void PreAllocate1FO()
 {
-  int i;
-  extern int P;
+  long i;
 
   AllBlocks = (struct BlockList ***) MyMalloc(P*sizeof(struct BlockList **),
 					       DISTRIBUTED);
   DiagBlock = (struct BlockList ***) MyMalloc(P*sizeof(struct BlockList **),
 					       DISTRIBUTED);
-  ToReceive = (int **) MyMalloc(P*sizeof(int *), DISTRIBUTED);
-  NReceived = (int **) MyMalloc(P*sizeof(int *), DISTRIBUTED);
+  ToReceive = (long **) MyMalloc(P*sizeof(long *), DISTRIBUTED);
+  NReceived = (long **) MyMalloc(P*sizeof(long *), DISTRIBUTED);
   for (i=0; i<P; i++) {
-    ToReceive[i] = (int *) MyMalloc(LB.n_partitions*sizeof(int), i);
-    NReceived[i] = (int *) MyMalloc(LB.n_partitions*sizeof(int), i);
+    ToReceive[i] = (long *) MyMalloc(LB.n_partitions*sizeof(long), i);
+    NReceived[i] = (long *) MyMalloc(LB.n_partitions*sizeof(long), i);
   }
 }
 
 
-PreAllocateFO(MyNum, lc)
-int MyNum;
-struct LocalCopies *lc;
+void PreAllocateFO(long MyNum, struct LocalCopies *lc)
 {
-  int i, j, stor_size, root, update_size;
+  long i, j, stor_size, root, update_size;
 
-  lc->link = (int *) MyMalloc((LB.n+1)*sizeof(int), MyNum);
-  lc->first = (int *) MyMalloc(LB.n*sizeof(int), MyNum);
+  lc->link = (long *) MyMalloc((LB.n+1)*sizeof(long), MyNum);
+  lc->first = (long *) MyMalloc(LB.n*sizeof(long), MyNum);
 
   for (i=0; i<LB.n; i++)
     lc->first[i] = lc->link[i] = 0;
@@ -89,7 +85,7 @@
   lc->updatetmp = (double *) MyMalloc(stor_size*sizeof(double), MyNum);
   for (i=0; i<stor_size; i++)
     lc->updatetmp[i] = 0.0;
-  lc->relative = (int *) MyMalloc(LB.max_partition*sizeof(int), MyNum);
+  lc->relative = (long *) MyMalloc(LB.max_partition*sizeof(long), MyNum);
 
   AllBlocks[MyNum] = (struct BlockList **)
     MyMalloc(LB.n_partitions*sizeof(struct BlockList *), MyNum);
@@ -116,11 +112,9 @@
 }
 
 
-BNumericSolveFO(MyNum, lc)
-int MyNum;
-struct LocalCopies *lc;
+void BNumericSolveFO(long MyNum, struct LocalCopies *lc)
 {
-  int i;
+  long i;
 
   for (i=0; i<LB.n; i++)
     lc->link[i] = -1;
@@ -137,12 +131,9 @@
 }
 
 
-DriveParallelFO(MyNum, lc)
-int MyNum;
-struct LocalCopies *lc;
+void DriveParallelFO(long MyNum, struct LocalCopies *lc)
 {
-  int some, j;
-  extern int *node, *firstchild;
+  long some, j;
 
   some = 0;
   for (j=0; j<LB.n; j+=node[j])
@@ -157,16 +148,14 @@
     while (HandleTaskFO(MyNum, lc))
       ;
 
-  if (TaskWaiting(MyNum, lc))
+  if (TaskWaiting(MyNum))
     printf("**** Termination error ***\n");
 }
 
 
-HandleTaskFO(MyNum, lc)
-int MyNum;
-struct LocalCopies *lc;
+long HandleTaskFO(long MyNum, struct LocalCopies *lc)
 {
-  int desti, destj, src;
+  long desti, destj, src;
   struct Update *update;
 
   GetBlock(&desti, &destj, &src, &update, MyNum, lc);
@@ -193,14 +182,12 @@
 
 /*  Receive a block.  Use it to produce updates to other blocks. */
 
-DiagReceived(diag,MyNum, lc)
-int MyNum;
-struct LocalCopies *lc;
+void DiagReceived(long diag, long MyNum, struct LocalCopies *lc)
 {
-  int i, column;
-  struct BlockList *diagbl, *CopyOneBlock();
+  long i, column;
+  struct BlockList *diagbl;
 
-  diagbl = CopyOneBlock(diag, MyNum, lc);
+  diagbl = CopyOneBlock(diag, MyNum);
   column = LB.renumbering[BLOCKCOL(diag)];
   diagbl->next = NULL;
   DiagBlock[MyNum][column] = diagbl;
@@ -209,8 +196,7 @@
   for (i=LB.col[column]+1; i<LB.col[column+1]; i++)
     if (BLOCK(i)->owner == MyNum &&
 	BLOCK(i)->remaining == 0) {
-      BDiv(diag, i, diagbl->length, BLOCK(i)->length,
-	   diagbl->nz, BLOCK(i)->nz, MyNum, lc);
+      BDiv(diagbl->length, BLOCK(i)->length, diagbl->nz, BLOCK(i)->nz, lc);
       BlockDoneFO(i, MyNum, lc);
     }
 
@@ -224,17 +210,15 @@
 
 /*  Receive a block.  Use it to produce updates to other blocks. */
 
-BlockReceived(block,MyNum, lc)
-int MyNum;
-struct LocalCopies *lc;
+void BlockReceived(long block, long MyNum, struct LocalCopies *lc)
 {
-  int column;
-  struct BlockList *thisbl, *bl, *CopyOneBlock();
+  long column;
+  struct BlockList *thisbl, *bl;
 
   column = LB.renumbering[BLOCKCOL(block)];
 
   /* add block to list for 'column' */
-  thisbl = CopyOneBlock(block, MyNum, lc);
+  thisbl = CopyOneBlock(block, MyNum);
   thisbl->next = AllBlocks[MyNum][column];
   AllBlocks[MyNum][column] = thisbl;
 
@@ -258,13 +242,9 @@
 /* if 'copy_across' is set, all relevant info is copied across */
 /* otherwise, structure points to info in home */
 
-struct BlockList *CopyOneBlock(block,MyNum, lc)
-int MyNum;
-struct LocalCopies *lc;
+struct BlockList *CopyOneBlock(long block, long MyNum)
 {
   struct BlockList *bl;
-  int i, size, num_nz, num_ind, copy_across;
-  extern int solution_method;
 
     bl = (struct BlockList *) MyMalloc(sizeof(struct BlockList), MyNum);
 
@@ -279,7 +259,7 @@
 }
 
 
-FreeColumnListFO(p, col)
+void FreeColumnListFO(long p, long col)
 {
   struct BlockList *bl;
   
@@ -293,13 +273,10 @@
     DiagBlock[p][col] = bl->next;
     MyFree(bl);
   }
-
 }
 
 
-DecrementRemaining(dest_block,MyNum, lc)
-int MyNum;
-struct LocalCopies *lc;
+void DecrementRemaining(long dest_block, long MyNum, struct LocalCopies *lc)
 {
   BLOCK(dest_block)->remaining--;
   if (BLOCK(dest_block)->remaining == 0)
@@ -309,14 +286,11 @@
 }
 
 
-PerformUpdate(above_bl, below_bl,MyNum, lc)
-struct BlockList *above_bl, *below_bl;
-int MyNum;
-struct LocalCopies *lc;
-{
-  int above, below;
-  int desti, destj, dest_block, is_diag;
-  int *relative_i, *relative_j;
+void PerformUpdate(struct BlockList *above_bl, struct BlockList *below_bl, long MyNum, struct LocalCopies *lc)
+{
+  long above, below;
+  long desti, destj, dest_block, is_diag;
+  long *relative_i, *relative_j;
   double *destination;
 
   above = above_bl->theBlock;
@@ -329,7 +303,7 @@
 
   dest_block = FindBlock(desti, destj);
   if (dest_block == -1)
-    printf("Couldn't find %d,%d\n", desti, destj);
+    printf("Couldn't find %ld,%ld\n", desti, destj);
   else if (BLOCK(dest_block)->owner != MyNum)
     return; /* not my block */
 
@@ -341,8 +315,7 @@
       destination = lc->updatetmp;
 
     /* modify diagonal block */
-    BLMod(below, below_bl->length, LB.partition_size[below_bl->col],
-	  below_bl->nz, destination, MyNum, lc);
+    BLMod(below_bl->length, LB.partition_size[below_bl->col], below_bl->nz, destination, lc);
 
     if (destination == lc->updatetmp) {
 
@@ -361,9 +334,7 @@
     else if (!BLOCK(dest_block)->structure)
       relative_i = below_bl->structure;
     else {
-      FindRelativeIndices(below_bl->structure, below_bl->length,
-			  BLOCK(dest_block)->structure,
-			  BLOCK(dest_block)->length, lc->relative);
+      FindRelativeIndices(below_bl->structure, below_bl->length, BLOCK(dest_block)->structure, lc->relative);
       relative_i = lc->relative;
     }
       
@@ -377,8 +348,7 @@
     else
       destination = lc->updatetmp;
 
-    BMod(above, below, above_bl->length, LB.partition_size[above_bl->col],
-	 below_bl->length, above_bl->nz, below_bl->nz, destination, MyNum, lc);
+    BMod(above_bl->length, LB.partition_size[above_bl->col], below_bl->length, above_bl->nz, below_bl->nz, destination, lc);
 
     if (destination == lc->updatetmp) {
 
@@ -387,21 +357,16 @@
 		      BLOCK(dest_block)->length,
 		      lc->updatetmp, BLOCK(dest_block)->nz);
 
-
     }
-
   }
-
   DecrementRemaining(dest_block, MyNum, lc);
 }
 
 
 
-DistributeUpdateFO(which_domain, MyNum, lc)
-int MyNum;
-struct LocalCopies *lc;
+void DistributeUpdateFO(long which_domain, long MyNum, struct LocalCopies *lc)
 {
-  int bi, bj, desti, destj, dest_block;
+  long bi, bj, desti, destj, dest_block;
 
   for (bi=LB.col[LB.n+which_domain]; bi<LB.col[LB.n+which_domain+1]; bi++) {
     for (bj=LB.col[LB.n+which_domain]; bj<=bi; bj++) {
@@ -416,30 +381,26 @@
 }
 
 
-HandleUpdate2FO(which_domain, bli, blj,MyNum, lc)
-int MyNum;
-struct LocalCopies *lc;
-{
-  int dest_block, desti, destj;
-  int *relative_i, *relative_j;
-  int stride;
+void HandleUpdate2FO(long which_domain, long bli, long blj, long MyNum, struct LocalCopies *lc)
+{
+  long dest_block, desti, destj;
+  long *relative_i, *relative_j;
+  long stride;
   double *update;
 
   desti = BLOCKROW(bli); destj = BLOCKROW(blj);
   dest_block = FindBlock(desti, destj);
 
   if (dest_block == -1)
-    printf("Couldn't find %d,%d\n", desti, destj);
+    printf("Couldn't find %ld,%ld\n", desti, destj);
   else if (BLOCK(dest_block)->owner != MyNum)
-    printf("Sent to wrong PE\n", desti, destj);
+    printf("Sent to wrong PE\n");
 
-  FindBlockUpdate(which_domain, bli, blj, &update, &stride, MyNum, lc);
+  FindBlockUpdate(which_domain, bli, blj, &update, &stride);
 
   if (BLOCK(bli)->structure && BLOCK(dest_block)->structure) {
     if (BLOCK(bli)->length != BLOCK(dest_block)->length) {
-      FindRelativeIndices(BLOCK(bli)->structure, BLOCK(bli)->length,
-			  BLOCK(dest_block)->structure,
-			  BLOCK(dest_block)->length, lc->relative);
+      FindRelativeIndices(BLOCK(bli)->structure, BLOCK(bli)->length, BLOCK(dest_block)->structure, lc->relative);
       relative_i = lc->relative;
     }
     else
@@ -464,11 +425,10 @@
 }
 
 
-FindRelativeIndices(src_structure, src_len, dest_structure, dest_len, relative)
-int *src_structure, src_len, *dest_structure, dest_len, *relative;
+void FindRelativeIndices(long *src_structure, long src_len, long *dest_structure, long *relative)
 {
-  int srci, desti;
-  int *leftRow, *rightRow, *last;
+  long srci, desti;
+  long *leftRow, *rightRow, *last;
 
   leftRow = src_structure;
   rightRow = dest_structure;
@@ -487,23 +447,20 @@
 }
 
 
-BlockReadyFO(block,MyNum, lc)
-int MyNum;
-struct LocalCopies *lc;
+void BlockReadyFO(long block, long MyNum, struct LocalCopies *lc)
 {
-  int column;
+  long column;
   struct BlockList *diagbl;
 
   if (BLOCKROW(block) == BLOCKCOL(block)) {
-    BFac(block, MyNum, lc);
+    BFac(block, lc);
     BlockDoneFO(block, MyNum, lc);
   }
   else {
     column = LB.renumbering[BLOCKCOL(block)];
     if (DiagBlock[MyNum][column]) {
       diagbl = DiagBlock[MyNum][column];
-      BDiv(LB.col[BLOCKCOL(block)], block, diagbl->length, BLOCK(block)->length,
-	   diagbl->nz, BLOCK(block)->nz, MyNum, lc);
+      BDiv(diagbl->length, BLOCK(block)->length, diagbl->nz, BLOCK(block)->nz, lc);
       BlockDoneFO(block, MyNum, lc);
     }
 
@@ -511,14 +468,10 @@
 }
 
 
-BlockDoneFO(block,MyNum, lc)
-int MyNum;
-struct LocalCopies *lc;
-{
-  int i;
-  int P_row, P_col;
-  extern int P_dimi, P_dimj;
-  extern int scatter_decomposition;
+void BlockDoneFO(long block, long MyNum, struct LocalCopies *lc)
+{
+  long i;
+  long P_row, P_col;
 
   if (scatter_decomposition) {
     P_row = LB.mapI[LB.renumbering[BLOCKROW(block)]]%P_dimi;
@@ -540,9 +493,9 @@
 }
 
 
-CheckRemaining()
+void CheckRemaining()
 {
-  int i, j, bogus=0;
+  long i, j, bogus=0;
   
   for (j=0; j<LB.n; j+=LB.partition_size[j])
     if (!LB.domain[j]) {
@@ -558,9 +511,9 @@
 }
 
 
-CheckReceived()
+void CheckReceived()
 {
-  int p, i, bogus=0;
+  long p, i, bogus=0;
 
   for (p=0; p<P; p++)
     for (i=0; i<LB.n_partitions; i++) {
@@ -577,10 +530,10 @@
 
 /* determine number of updates that must be performed on each block */
 
-ComputeRemainingFO()
+void ComputeRemainingFO()
 {
-  int i, j, k;
-  int desti, destj, dest_block;
+  long i, j, k;
+  long desti, destj, dest_block;
 
   for (j=0; j<LB.n; j++)
     if (!LB.domain[j]) {
@@ -621,11 +574,9 @@
 }
 
 
-InitRemainingFO(MyNum, lc)
-int MyNum;
-struct LocalCopies *lc;
+void InitRemainingFO(long MyNum)
 {
-  int i, k;
+  long i, k;
 
   /* block updates */
   for (k=0; k<LB.n; k++)
@@ -636,11 +587,10 @@
 }
 
 
-ComputeReceivedFO()
+void ComputeReceivedFO()
 {
-  int p, i, j, k, block;
-  int P_row, P_col, destp;
-  extern int scatter_decomposition, P_dimi, P_dimj;
+  long p, i, k, block;
+  long P_row, P_col, destp;
 
   for (p=0; p<P; p++)
     for (i=0; i<LB.n_partitions; i++)
@@ -678,11 +628,9 @@
 }
 
 
-InitReceivedFO(MyNum, lc)
-int MyNum;
-struct LocalCopies *lc;
+void InitReceivedFO(long MyNum)
 {
-  int i, p;
+  long i;
 
   for (i=0; i<LB.n_partitions; i++)
     NReceived[MyNum][i] = ToReceive[MyNum][i];
@@ -690,11 +638,9 @@
 
 
 
-ScatterUpdateFO(dimi, structi, dimj, structj, destdim, oldupdate, newupdate)
-int dimi, *structi, dimj, *structj;
-double *oldupdate, *newupdate;
+void ScatterUpdateFO(long dimi, long *structi, long dimj, long *structj, long destdim, double *oldupdate, double *newupdate)
 {
-  int i, j, top_of_destcol;
+  long i, j;
   double *srccol, *destcol;
 
   for (j=0; j<dimj; j++) {
@@ -718,12 +664,9 @@
 
 
 
-ScatterUpdateFO2(dimi, structi, dimj, structj, stride, destdim,
-		 oldupdate, newupdate)
-int dimi, *structi, dimj, *structj, stride;
-double *oldupdate, *newupdate;
+void ScatterUpdateFO2(long dimi, long *structi, long dimj, long *structj, long stride, long destdim, double *oldupdate, double *newupdate)
 {
-  int i, j, top_of_srccol, top_of_destcol;
+  long i, j, top_of_srccol, top_of_destcol;
 
   top_of_srccol = 0;
   for (j=0; j<dimj; j++) {
diff -Naur splash2/codes/kernels/cholesky/makefile splash2-modified/codes/kernels/cholesky/makefile
--- splash2/codes/kernels/cholesky/makefile	1994-10-11 23:59:00.000000000 -0400
+++ splash2-modified/codes/kernels/cholesky/makefile	1969-12-31 19:00:00.000000000 -0500
@@ -1,46 +0,0 @@
-TARGET = CHOLESKY
-OBJS = amal.o assign.o bfac.o bksolve.o block2.o fo.o mf.o numLL.o \
-     parts.o seg.o solve.o tree.o util.o malloc.o 
-
-CFLAGS = -O2 -Olimit 2000 -w 
-LDFLAGS = -lmpc -lm
-MACROS = ../../null_macros/c.m4.null
-
-
-x = *
-
-$(TARGET): $(OBJS)
-	cc $(OBJS) $(CFLAGS) -o $(TARGET) $(LDFLAGS)
-
-.SUFFIXES:
-.SUFFIXES:	.o .c .C .h .H
-
-.H.h:
-	m4 ${MACROS} $*.H > $*.h
-
-.C.c:
-	m4 $(MACROS) $*.C > $*.c
-
-.c.o:
-	cc -c $(CFLAGS) $*.c
-
-.C.o:
-	m4 $(MACROS) $*.C > $*.c
-	cc -c $(CFLAGS) $*.c
-
-matrix.h: matrix.H
-amal.c: matrix.h
-block2.c: matrix.h
-numLL.c: matrix.h
-tree.c: matrix.h
-assign.c: matrix.h
-fo.c: matrix.h
-parts.c: matrix.h
-util.c: matrix.h
-bfac.c: matrix.h
-malloc.c: matrix.h
-seg.c: matrix.h
-bksolve.c: matrix.h
-mf.c: matrix.h
-solve.c: matrix.h
-
diff -Naur splash2/codes/kernels/cholesky/Makefile splash2-modified/codes/kernels/cholesky/Makefile
--- splash2/codes/kernels/cholesky/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ splash2-modified/codes/kernels/cholesky/Makefile	2007-03-08 12:10:55.000000000 -0500
@@ -0,0 +1,22 @@
+TARGET = CHOLESKY
+OBJS = amal.o assign.o bfac.o bksolve.o block2.o fo.o malloc.o \
+       mf.o numLL.o parts.o seg.o solve.o tree.o util.o
+
+include ../../Makefile.config
+
+matrix.h: matrix.H
+amal.c: matrix.h
+block2.c: matrix.h
+numLL.c: matrix.h
+tree.c: matrix.h
+assign.c: matrix.h
+fo.c: matrix.h
+parts.c: matrix.h
+util.c: matrix.h
+bfac.c: matrix.h
+malloc.c: matrix.h
+seg.c: matrix.h
+bksolve.c: matrix.h
+mf.c: matrix.h
+solve.c: matrix.h
+
diff -Naur splash2/codes/kernels/cholesky/malloc.C splash2-modified/codes/kernels/cholesky/malloc.C
--- splash2/codes/kernels/cholesky/malloc.C	1994-10-11 23:51:44.000000000 -0400
+++ splash2-modified/codes/kernels/cholesky/malloc.C	2007-04-17 14:46:21.000000000 -0400
@@ -27,22 +27,22 @@
 
 #define SIZE(block) (block[-1]) /* in all blocks */
 #define HOME(block) (block[-2]) /* in all blocks */
-#define NEXTFREE(block) (*((unsigned **) block)) /* in free blocks */
+#define NEXTFREE(block) (*((long **) block)) /* in free blocks */
 
 struct MemPool {
 	LOCKDEC(memoryLock)
-	unsigned *volatile*freeBlock;
-	int tally, touched, maxm;
+	long *volatile*freeBlock;
+	long tally, touched, maxm;
 	} *mem_pool;
 
-int mallocP = 1, machineP = 1;
+long mallocP = 1, machineP = 1;
 
 extern struct GlobalMemory *Global;
 
 
-MallocInit(P)
+void MallocInit(long P)
 {
-  int p;
+  long p;
   
   mallocP = P;
 
@@ -56,20 +56,20 @@
 }
 
 
-InitOneFreeList(p)
+void InitOneFreeList(long p)
 {
-  int j;
+  long j;
 
   LOCKINIT(mem_pool[p].memoryLock);
   if (p > 0) {
-    mem_pool[p].freeBlock = (unsigned **)
-      G_MALLOC((MAXFAST+1)*sizeof(unsigned *), p);
-    MigrateMem(mem_pool[p].freeBlock, (MAXFAST+1)*sizeof(unsigned *), p);
+    mem_pool[p].freeBlock = (long **)
+      G_MALLOC((MAXFAST+1)*sizeof(long *), p);
+    MigrateMem(mem_pool[p].freeBlock, (MAXFAST+1)*sizeof(long *), p);
   }
   else {
-    mem_pool[p].freeBlock = (unsigned **)
-      G_MALLOC((MAXFAST+1)*sizeof(unsigned *), 0);
-    MigrateMem(mem_pool[p].freeBlock, (MAXFAST+1)*sizeof(unsigned *),
+    mem_pool[p].freeBlock = (long **)
+      G_MALLOC((MAXFAST+1)*sizeof(long *), 0);
+    MigrateMem(mem_pool[p].freeBlock, (MAXFAST+1)*sizeof(long *),
 	       DISTRIBUTED);
   }
   for (j=0; j<=MAXFAST; j++)
@@ -78,16 +78,16 @@
 }
 
 
-MallocStats()
+void MallocStats()
 {
-  int i;
+  long i;
 
   printf("Malloc max: ");
   for (i=0; i<mallocP; i++)
     if (mem_pool[i].touched > 0)
-      printf("%d* ", mem_pool[i].maxm);
+      printf("%ld* ", mem_pool[i].maxm);
     else
-      printf("%d ", mem_pool[i].maxm);
+      printf("%ld ", mem_pool[i].maxm);
   printf("\n");
 
 }
@@ -95,9 +95,9 @@
 
 /* returns first bucket where 2^bucket >= size */
 
-FindBucket(size)
+long FindBucket(long size)
 {
-  int bucket;
+  long bucket;
 
   if (size > MAXFASTBL)
     bucket = MAXFAST;
@@ -113,13 +113,10 @@
 
 /* size is in bytes */
 
-char *MyMalloc(size, home)
-int size, home;
+char *MyMalloc(long size, long home)
 {
-  int i, bucket, leftover, alloc_size;
-  unsigned *d, *result, *prev, *freespace, *freelast;
-  unsigned int block_size;
-  extern int MyNum;
+  long i, bucket, leftover, alloc_size, block_size;
+  long *d, *result, *prev, *freespace;
 
   if (size < ALIGN)
     size = ALIGN;
@@ -156,8 +153,8 @@
 
       if (block_size >= alloc_size) {  /* Found one! */
 
-	leftover = block_size - alloc_size - 2*sizeof(unsigned);
-        result = d + (leftover/sizeof(unsigned)) + 2;
+	leftover = block_size - alloc_size - 2*sizeof(long);
+        result = d + (leftover/sizeof(long)) + 2;
 	SIZE(result) = alloc_size;
 	HOME(result) = home;
 
@@ -196,16 +193,15 @@
     /* grab a big block, free it, then retry request */
     block_size = max(alloc_size, 4*(1<<MAXFAST));
     LOCK(Global->memLock);
-    freespace = (unsigned *) G_MALLOC(block_size+2*sizeof(unsigned),
-					   home);
-    MigrateMem(freespace, block_size+2*sizeof(unsigned), home);
+    freespace = (long *) G_MALLOC(block_size+2*sizeof(long), home);
+    MigrateMem(freespace, block_size+2*sizeof(long), home);
 
     mem_pool[home].touched++;
     UNLOCK(Global->memLock);
     freespace+=2;
     SIZE(freespace) = block_size;
     HOME(freespace) = home;
-    for (i=0; i<block_size/sizeof(unsigned); i++)
+    for (i=0; i<block_size/sizeof(long); i++)
       freespace[i] = 0;
     if (block_size == alloc_size)
       result = freespace;
@@ -215,7 +211,7 @@
 	mem_pool[home].maxm = mem_pool[home].tally;
       }
       MyFree(freespace);
-      result = (unsigned *) MyMalloc(alloc_size, home);
+      result = (long *) MyMalloc(alloc_size, home);
     }
   }
 
@@ -225,31 +221,29 @@
   }
 
   if (SIZE(result) < size)
-    printf("*** Bad size from malloc %d, %d\n", size, SIZE(result));
+    printf("*** Bad size from malloc %ld, %ld\n", size, SIZE(result));
 
   return((char *) result);
 
 }
 
 
-MigrateMem(start, length, home)
-unsigned int *start;
-int length, home;
+void MigrateMem(long *start, long length, long home)
 {
-  unsigned int *finish;
-  unsigned int currpage, endpage;
-  int i;
-  int j;
+/*  unsigned long *finish;
+  unsigned long currpage, endpage;
+  long i;
+  long j;*/
 
 /* POSSIBLE ENHANCEMENT:  Here is where one might distribute the memory
    pages across physically distributed memories as desired.
 
    One way to do this is as follows:
 
-   finish = (unsigned int *) (((char *) start) + length);
+   finish = (unsigned long *) (((char *) start) + length);
 
-   currpage = (unsigned int) start;
-   endpage = (unsigned int) finish;
+   currpage = (unsigned long) start;
+   endpage = (unsigned long) finish;
    if ((home == DISTRIBUTED) || (home < 0) || (home >= mallocP)) {
      j = 0;
      while (currpage < endpage) {
@@ -268,10 +262,9 @@
 }
     
 
-MyFree(block)
-unsigned *block;
+void MyFree(long *block)
 {
-  int home;
+  long home;
 
   home = HOME(block);
   LOCK(mem_pool[home].memoryLock)
@@ -280,21 +273,19 @@
 }
 
 
-MyFreeNow(block)
-unsigned *block;
+void MyFreeNow(long *block)
 {
-  int bucket, size, home;
-  extern int MyNum;
+  long bucket, size, home;
 
   size = SIZE(block);
   home = HOME(block);
 
   if (size <= 0) {
-    printf("Bad size %d\n", size);
+    printf("Bad size %ld\n", size);
     exit(-1);
   }
   if (home < -1 || home >= mallocP) {
-    printf("Bad home %d\n", home);
+    printf("Bad home %ld\n", home);
     exit(-1);
   }
 
@@ -310,7 +301,7 @@
   if (bucket == 0)
     return;
 
-  NEXTFREE(block) = (unsigned *) mem_pool[home].freeBlock[bucket];
+  NEXTFREE(block) = (long *) mem_pool[home].freeBlock[bucket];
   mem_pool[home].freeBlock[bucket] = block;
   mem_pool[home].tally -= size;
 
diff -Naur splash2/codes/kernels/cholesky/matrix.H splash2-modified/codes/kernels/cholesky/matrix.H
--- splash2/codes/kernels/cholesky/matrix.H	1994-10-11 23:51:47.000000000 -0400
+++ splash2-modified/codes/kernels/cholesky/matrix.H	2006-09-14 19:29:56.000000000 -0400
@@ -22,22 +22,22 @@
 #define PAGE_SIZE 4096
 
 typedef struct {
-	int n, m, *col, *startrow, *row;
+	long n, m, *col, *startrow, *row;
 	double *nz;
 	} SMatrix;
 
 struct Pair {
-	int block_num;
+	long block_num;
 	struct Pair *next;
 	};
 
 typedef struct {
-        int i, j, owner, remaining, nmod;
-	int length; /* number of full rows in block */
-	int parent; /* block number of parent block */
+        long i, j, owner, remaining, nmod;
+	long length; /* number of full rows in block */
+	long parent; /* block number of parent block */
 	double checksum;
-	volatile unsigned int done;
-	int *structure, *relative;
+	volatile unsigned long done;
+	long *structure, *relative;
 	double *nz;
 	struct Pair *pair;
       } Block;
@@ -48,10 +48,10 @@
       } Entry;
        
 typedef struct {
-        int n, *col, *row, n_blocks, n_entries, entries_allocated;
-	int *partition_size, *renumbering, *mapI, *mapJ;
-	int *domain, *domains, n_domains, *proc_domains;
-	int n_partitions, max_partition;
+        long n, *col, *row, n_blocks, n_entries, entries_allocated;
+	long *partition_size, *renumbering, *mapI, *mapJ;
+	long *domain, *domains, n_domains, *proc_domains;
+	long n_partitions, max_partition;
 	double **proc_domain_storage;
 	Entry *entry;
       } BMatrix;
@@ -62,14 +62,14 @@
 #define OWNER(bl_no) (BLOCK(bl_no)->owner)
 
 struct Update {
-	int i, j, src, remaining;
-	int dimi, dimj, *structi, *structj;
+	long i, j, src, remaining;
+	long dimi, dimj, *structi, *structj;
 	double *update;
 	struct Update *next;
       };
 
 struct Task {
-  int block_num, desti, destj, src;
+  long block_num, desti, destj, src;
   struct Update *update;
   struct Task *next;
   };
@@ -78,41 +78,36 @@
 	BARDEC(start)
 	LOCKDEC(waitLock)
 	LOCKDEC(memLock)
-	unsigned int runtime[MAX_PROC];
+	unsigned long runtime[MAX_PROC];
 	};
 
 struct BlockList {
-	int theBlock, row, col, length;
-	int *structure;
+	long theBlock, row, col, length;
+	long *structure;
 	double *nz;
 	struct BlockList *next;
 	};
 
 struct LocalCopies {
        double *blktmp;
-       int max_panel;
-       int *link;
-       int *first;
+       long max_panel;
+       long *link;
+       long *first;
        double *storage;
        double *updatetmp;
-       int *relative;
+       long *relative;
        struct Update *freeUpdate;
        struct Task *freeTask;
-       unsigned int rs;
-       unsigned int rf;
-       unsigned int us;
-       unsigned int uf;
-       unsigned int ss;
-       unsigned int sf;
-       unsigned int runtime;
-       unsigned int runs;
+       unsigned long rs;
+       unsigned long rf;
+       unsigned long us;
+       unsigned long uf;
+       unsigned long ss;
+       unsigned long sf;
+       unsigned long runtime;
+       unsigned long runs;
        };
 
-SMatrix ReadSparse(), NewMatrix();
-SMatrix SymbolicFactor();
-double *NewVector();
-char *MyMalloc();
-
 #define DISTRIBUTED 888
 
 #define max(a, b) ((a) > (b) ? (a) : (b))
@@ -126,64 +121,185 @@
 
 #define FAN_OUT 2
 
-int PreAllocate(int,struct LocalCopies *);
-int BNumericSolve(int,struct LocalCopies *);
-int DriveParallel(int,struct LocalCopies *);
-int DiagReady(int, int, int,struct LocalCopies *);
-int LowerReady(int, int, int, int,struct LocalCopies *);
-int BFac(int, int,struct LocalCopies *);
-int BDiv(int, int, int, int, double *, double *, int,struct LocalCopies *);
-int BMod(int, int, int, int, int, double *, double *, double *, int,struct LocalCopies *);
-int CopyBlock(double *, double *, int, int, int, int, int, int,struct LocalCopies *);
-int BLMod(int, int, int, double *, double *, int,struct LocalCopies *);
-int PreProcessFO(int,struct LocalCopies *);
-int PreAllocateFO(int,struct LocalCopies *);
-int BNumericSolveFO(int,struct LocalCopies *);
-int DriveParallelFO(int,struct LocalCopies *);
-int DriveSequentialFO(int,struct LocalCopies *);
-int HandleTaskFO(int,struct LocalCopies *);
-int DiagReceived(int, int,struct LocalCopies *);
-int BlockReceived(int, int,struct LocalCopies *);
-struct BlockList *CopyOneBlock(int, int,struct LocalCopies *);
-int DecrementRemaining(int, int,struct LocalCopies *);
-int PerformUpdate(struct BlockList *, struct BlockList *, int,struct LocalCopies *);
-int HandleUpdateFO(int, int, struct Update *, int,struct LocalCopies *);
-int HandleUpdate2FO(int, int, int, int,struct LocalCopies *);
-int BlockReadyFO(int, int,struct LocalCopies *);
-int BlockDoneFO(int, int,struct LocalCopies *);
-int InitRemainingFO(int,struct LocalCopies *);
-int InitReceivedFO(int,struct LocalCopies *);
-int RemoveUpdate(int, int, int, struct Update **, int,struct LocalCopies *);
-int FindUpdate(int, int, int, struct Update *, int *, struct Update **, int,struct LocalCopies *);
-int PrimeQueue(int,struct LocalCopies *);
-int Send(int, int, int, int, struct Update *, int, int,struct LocalCopies *);
-int TaskWaiting(int,struct LocalCopies *);
-int ActiveSpin(volatile unsigned int *, int,struct LocalCopies *);
-int GetBlock(int *, int *, int *, struct Update **, int,struct LocalCopies *);
-int RemoveUpdate(int, int, int, struct Update **, int,struct LocalCopies *);
-int FactorLLDomain(int, int,struct LocalCopies *);
-int HandleUpdate(int, int, int, int, double *,struct LocalCopies *);
-int HandleDiag(int, int, double *,struct LocalCopies *);
-int HandleBlock(int, int, double *,struct LocalCopies *);
-int DecrementRemainingSimFO(int, int, double *,struct LocalCopies *);
-int BlockReadySimFO(int, int, double *,struct LocalCopies *);
-int BlockDoneSimFO(int, int, double *,struct LocalCopies *);
-int SendProbe(int, int, int,struct LocalCopies *);
-int ReceiveProbe(int, int, int,struct LocalCopies *);
-int SendPing(int, int, int,struct LocalCopies *);
-int ReceivePing(int, int, int,struct LocalCopies *);
-int HandleTask(int,struct LocalCopies *);
-int DoOneMod(int, int, int,struct LocalCopies *);
-int DoOneLMod(int, int,struct LocalCopies *);
-int UpdateFinished(int, int, int, int,struct LocalCopies *);
-int PropOne(int, int, int, struct Update *, int,struct LocalCopies *);
-int DistributeUpdateFO(int, int,struct LocalCopies *);
-int DistributeUpdate(int, int, int,struct LocalCopies *);
-int DistributeUpdateOld(double *, int, int, int,struct LocalCopies *);
-int FactorMFDomain(int, int,struct LocalCopies *);
-int DumpUpdate(int, struct Update *, int,struct LocalCopies *);
-char *MyMalloc(int, int);
-int SimBlockFO(int, int, double *, double *, double *, struct LocalCopies *);
-int AssignBlocks3(int, int, int, struct LocalCopies *);
-int FireOffLeafs(double *, struct LocalCopies *);
+/*
+ * amal.C
+ */
+long OpsFromSuper(long size, long nz);
+long CountSupers(long cols, long *node);
+void Amalgamate2(long join, SMatrix M, long *T, long *nz, long *node, long *domain, long target_size);
+void ConsiderMerge(long join, long super, SMatrix M, long *nz, long *node, long *domain, long target_size, long traversal_order);
+void JoinTwoSupers2(long *nz, long *node, long child, long parent);
+void ReorderMatrix(SMatrix M, long super, long *node, long *counter, long *PERM);
+void FixNodeNZAndT(SMatrix M, long *PERM, long *node, long *nz, long *T);
+void InvertPerm(long n, long *PERM, long *INVP);
+double PathLength(long cols, long rows, long target_panel_size);
+
+/*
+ * assign.C
+ */
+void PDIV(long src_col, long src_nz, double *ops, double *misses, double *runtime);
+void PMOD(long src_col, long dest_col, long dest_nz, double *ops, double *misses, double *runtime);
+void PADD(long cols, long rows, double *misses, double *runtime);
+void AssignBlocksNow(void);
+void EmbedBlocks(void);
+
+/*
+ * bfac.C
+ */
+void BFac(long diag, struct LocalCopies *lc);
+void OneFac(double *A, long n1, long n2);
+void BDiv(long n1, long n3, double *diag_nz, double *below_nz, struct LocalCopies *lc);
+void OneDiv(double *A, double *B, long n1, long n3, long n4);
+void BMod(long n1, long n2, long n3, double *top_nz, double *bend_nz, double *dest_nz, struct LocalCopies *lc);
+void CopyBlock(double *B, double *dest, long n3, long is, long ks, long il, long kl);
+void CopyBlockBack(double *B, double *src, long n3, long is, long ks, long il, long kl);
+void OneMatmat(double *B, double *A, double *C, long n1, long n2, long n3, long n4, long n5);
+void BLMod(long n1, long n2, double *left_nz, double *dest_nz, struct LocalCopies *lc);
+void OneLower(double *A, double *C, long n1, long n2, long n3);
+void FindBlockUpdate(long domain, long blj, long bli, double **update, long *stride);
+
+/*
+ * bksolve.C
+ */
+double *TriBSolve(BMatrix LB, double *b, long *PERM);
+double ComputeNorm(double *x, long n);
+double *CreateVector(SMatrix M);
+
+/*
+ * block2.C
+ */
+void CreateBlockedMatrix2(SMatrix M, long block_ub, long *T, long *firstchild, long *child, long *PERM, long *INVP, long *domain, long *partition);
+long FindNumPartitions(long set_size, long piece_size);
+void ComputeBlockParents(long *T);
+void FillInStructure(SMatrix M, long *firstchild, long *child, long *PERM, long *INVP);
+void FillInNZ(SMatrix M, long *PERM, long *INVP);
+void FindDomStructure(long super, long *nz, long n_nz);
+void FindDummyDomainStructure(long which_domain);
+void CheckColLength(long col, long n_nz);
+void FindBlStructure(SMatrix M, long super, long *PERM, long *INVP, long *firstchild, long *child, long *structure, long *nz);
+void FindSuperStructure(SMatrix M, long super, long *PERM, long *INVP, long *firstchild, long *child, long *structure, long *nz, long *n_nz);
+void FindDetailedStructure(long col, long *structure, long *nz, long n_nz);
+void AllocateNZ(void);
+void FillIn(SMatrix M, long col, long *PERM, long *INVP, double *scatter);
+void InsSort(long *nz, long n);
+long BlDepth(long col);
+void SortByKey(long n, long *blocks, long *keys);
+void DumpSizes(BMatrix LB, long *domain, long *sizes);
+void ComputePartitionNumbering(long *numbering);
+void FindMachineDimensions(long P);
+long EmbeddedOwner(long block);
+
+/*
+ * fo.C
+ */
+void PreProcessFO(long MyNum);
+void PreAllocate1FO(void);
+void PreAllocateFO(long MyNum, struct LocalCopies *lc);
+void BNumericSolveFO(long MyNum, struct LocalCopies *lc);
+void DriveParallelFO(long MyNum, struct LocalCopies *lc);
+long HandleTaskFO(long MyNum, struct LocalCopies *lc);
+void DiagReceived(long diag, long MyNum, struct LocalCopies *lc);
+void BlockReceived(long block, long MyNum, struct LocalCopies *lc);
+struct BlockList *CopyOneBlock(long block, long MyNum);
+void FreeColumnListFO(long p, long col);
+void DecrementRemaining(long dest_block, long MyNum, struct LocalCopies *lc);
+void PerformUpdate(struct BlockList *above_bl, struct BlockList *below_bl, long MyNum, struct LocalCopies *lc);
+void DistributeUpdateFO(long which_domain, long MyNum, struct LocalCopies *lc);
+void HandleUpdate2FO(long which_domain, long bli, long blj, long MyNum, struct LocalCopies *lc);
+void FindRelativeIndices(long *src_structure, long src_len, long *dest_structure, long *relative);
+void BlockReadyFO(long block, long MyNum, struct LocalCopies *lc);
+void BlockDoneFO(long block, long MyNum, struct LocalCopies *lc);
+void CheckRemaining(void);
+void CheckReceived(void);
+void ComputeRemainingFO(void);
+void InitRemainingFO(long MyNum);
+void ComputeReceivedFO(void);
+void InitReceivedFO(long MyNum);
+void ScatterUpdateFO(long dimi, long *structi, long dimj, long *structj, long destdim, double *oldupdate, double *newupdate);
+void ScatterUpdateFO2(long dimi, long *structi, long dimj, long *structj, long stride, long destdim, double *oldupdate, double *newupdate);
+
+/*
+ * malloc.C
+ */
+void MallocInit(long P);
+void InitOneFreeList(long p);
+void MallocStats(void);
+long FindBucket(long size);
+char *MyMalloc(long size, long home);
+void MigrateMem(long *start, long length, long home);
+void MyFree(long *block);
+void MyFreeNow(long *block);
+
+/*
+ * mf.C
+ */
+void InitTaskQueues(long P);
+long FindBlock(long i, long j);
+void Send(long src_block, long dest_block, long desti, long destj, struct Update *update, long p, long MyNum, struct LocalCopies *lc);
+long TaskWaiting(long MyNum);
+void GetBlock(long *desti, long *destj, long *src, struct Update **update, long MyNum, struct LocalCopies *lc);
+
+/*
+ * numLL.C
+ */
+void FactorLLDomain(long which_domain, long MyNum, struct LocalCopies *lc);
+void CompleteSupernodeB(long super);
+void CompleteColumnB(long j);
+void FindRelativeIndicesLeft(long *src_structure, long rows_in_update, long offset, long *indices, long *relative);
+void ScatterSuperUpdate(double *update, long cols_in_update, long rows_in_update, double *dest_nz, long dest_len, long *relative);
+void ModifySuperByColumn(double *src_nz, long cols_in_update, long rows_in_update, double *dest_nz, long dest_len, long *relative);
+void SetDestIndices(long super, long *indices);
+void SetDomainIndices(long super, long *indices);
+void ModifySuperBySuper(long src, long theFirst, long theLast, long length, double *dest);
+void ModifyTwoBySupernodeB(long super, long lastcol, long theFirst, double *destination0, double *destination1);
+void ModifyBySupernodeB(long super, long lastcol, long theFirst, double *destination);
+
+/*
+ * parts.C
+ */
+void Partition(SMatrix M, long parts, long *T, long *assigned_ops, long *domain, long *domains, long *proc_domains);
+void MarkSubtreeAsDomain(long *domain, long root);
+void NumberPartition(long parts, long *assigned_ops, long distribute);
+long MaxBucket(long *assigned_ops, long parts);
+long MinBucket(long *assigned_ops, long parts);
+struct Chunk *NewChunk(void);
+struct Chunk *GetChunk(void);
+
+/*
+ * seg.C
+ */
+void ComputeTargetBlockSize(SMatrix M, long P);
+void FindMaxHeight(SMatrix L, long root, long height, long *maxm);
+void NoSegments(SMatrix M);
+void CreatePermutation(long n, long *PERM, long permutation_method);
+
+/*
+ * solve.C
+ */
+void Go(void);
+void PlaceDomains(long P);
+void ComposePerm(long *PERM1, long *PERM2, long n);
+
+/*
+ * tree.C
+ */
+void EliminationTreeFromA(SMatrix A, long *T, long *P, long *INVP);
+void ParentToChild(long *T, long n, long *firstchild, long *child);
+void ComputeNZ(SMatrix A, long *T, long *nz, long *PERM, long *INVP);
+void FindSupernodes(SMatrix A, long *T, long *nz, long *node);
+void ComputeWorkTree(SMatrix A, long *nz, double *work_tree);
+
+/*
+ * util.C
+ */
+SMatrix NewMatrix(long n, long m, long nz);
+void FreeMatrix(SMatrix M);
+double *NewVector(long n);
+double Value(long i, long j);
+SMatrix ReadSparse(char *name, char *probName);
+void DumpLine(FILE *fp);
+void ParseIntFormat(char *buf, long *num, long *size);
+void ReadVector(FILE *fp, long n, long *where, long perline, long persize);
+SMatrix LowerToFull(SMatrix L);
+void ISort(SMatrix M, long k);
 
diff -Naur splash2/codes/kernels/cholesky/mf.C splash2-modified/codes/kernels/cholesky/mf.C
--- splash2/codes/kernels/cholesky/mf.C	1994-10-11 23:51:45.000000000 -0400
+++ splash2-modified/codes/kernels/cholesky/mf.C	2007-03-04 22:50:54.000000000 -0500
@@ -20,14 +20,10 @@
 #define HashNum 1024
 #define Bucket(desti, destj, src) ((desti+destj+src)%HashNum)
 
-int uMiss = 0;
+long uMiss = 0;
 extern struct GlobalMemory *Global;
 struct Update **updateHash;
 
-struct hLock {
-	LOCKDEC(theLock)
-	} *hashLock;
-
 struct taskQ {
 	LOCKDEC(taskLock)
 	struct Task *volatile taskQ; 
@@ -38,9 +34,9 @@
 
 extern BMatrix LB;
 
-InitTaskQueues(P)
+void InitTaskQueues(long P)
 {
-  int i, j;
+  long i;
 
   tasks = (struct taskQ *) MyMalloc(P*sizeof(struct taskQ), DISTRIBUTED);
   for (i=0; i<P; i++) {
@@ -56,9 +52,9 @@
 
 /* Find block number of block at position (i,j) */
 
-FindBlock(i, j)
+long FindBlock(long i, long j)
 {
-  int lo, hi, probe;
+  long lo, hi, probe;
 
   lo = LB.col[j]; hi = LB.col[j+1];
   for (;;) {
@@ -82,12 +78,9 @@
 
 /* p is processor no if block_num = -1, ignored otherwise */
 
-Send(src_block, dest_block, desti, destj, update, p, MyNum, lc)
-struct Update *update;
-int MyNum;
-struct LocalCopies *lc;
+void Send(long src_block, long dest_block, long desti, long destj, struct Update *update, long p, long MyNum, struct LocalCopies *lc)
 {
-  int procnum, is_probe;
+  long procnum, is_probe;
   struct Task *t;
 
   procnum = p;
@@ -127,18 +120,13 @@
 }
 
 
-TaskWaiting(MyNum, lc)
-int MyNum;
-struct LocalCopies *lc;
+long TaskWaiting(long MyNum)
 {
   return(tasks[MyNum].taskQ != NULL);
 }
 
 
-GetBlock(desti, destj, src, update, MyNum, lc)
-int *desti, *destj, *src, MyNum;
-struct Update **update;
-struct LocalCopies *lc;
+void GetBlock(long *desti, long *destj, long *src, struct Update **update, long MyNum, struct LocalCopies *lc)
 {
   struct Task *t;
 
diff -Naur splash2/codes/kernels/cholesky/numLL.C splash2-modified/codes/kernels/cholesky/numLL.C
--- splash2/codes/kernels/cholesky/numLL.C	1994-10-11 23:51:45.000000000 -0400
+++ splash2-modified/codes/kernels/cholesky/numLL.C	2006-09-14 17:50:29.000000000 -0400
@@ -19,28 +19,26 @@
 #include "matrix.h"
 #include <math.h>
 
-#define AddMember(set, new) { int s, n; s = set; n = new; \
+#define AddMember(set, new) { long s, n; s = set; n = new; \
 			       lc->link[n] = lc->link[s]; lc->link[s] = n; }
 
 extern BMatrix LB;
 extern struct GlobalMemory *Global;
-extern int *node; /* global */
+extern long *node; /* global */
 
 
-FactorLLDomain(which_domain, MyNum, lc)
-int MyNum;
-struct LocalCopies *lc;
-{
-  int i, start, root;
-  int j, j_last, j_len, dest_super;
-  int k, k_length, update_size;
-  int theFirst, theLast;
-  int *relative, *indices;
+void FactorLLDomain(long which_domain, long MyNum, struct LocalCopies *lc)
+{
+  long i, start, root;
+  long j, j_last, j_len, dest_super;
+  long k, k_length, update_size;
+  long theFirst, theLast;
+  long *relative, *indices;
   double *domain_update;
-  extern int *firstchild, *child;
+  extern long *firstchild, *child;
 
-  relative = (int *) MyMalloc(LB.n*sizeof(int), MyNum);
-  indices = (int *) MyMalloc(LB.n*sizeof(int), MyNum);
+  relative = (long *) MyMalloc(LB.n*sizeof(long), MyNum);
+  indices = (long *) MyMalloc(LB.n*sizeof(long), MyNum);
 
   root = LB.domains[which_domain];
 
@@ -172,9 +170,9 @@
 }
 
 
-CompleteSupernodeB(super)
+void CompleteSupernodeB(long super)
 {
-  int i, length, fits, first, last;
+  long i, length, fits, first, last;
 
   if (node[super] == 1) {
     CompleteColumnB(super);
@@ -226,7 +224,7 @@
 
 
 
-CompleteColumnB(j)
+void CompleteColumnB(long j)
 {
   double recip, diag, *theNZ, *last;
 
@@ -235,7 +233,7 @@
 
   diag = *theNZ;
   if (diag <= 0.0) {
-    printf("Negative pivot, d[%d] = %f\n", j, diag);
+    printf("Negative pivot, d[%ld] = %f\n", j, diag);
     exit(0);
   }
   diag = sqrt(diag);
@@ -251,11 +249,9 @@
    and assuming that global 'indices' contains structure of dest,
    find relative indices */
 
-FindRelativeIndicesLeft(src_structure, rows_in_update, offset,
-			indices, relative)
-int *src_structure, *indices, *relative;
+void FindRelativeIndicesLeft(long *src_structure, long rows_in_update, long offset, long *indices, long *relative)
 {
-  int i, *leftRow, *last;
+  long i, *leftRow, *last;
 
   leftRow = src_structure;
   last = &src_structure[rows_in_update];
@@ -270,12 +266,9 @@
 /* given a panel update 'update' with given size and relative indices,
    scatter into into dest_nz */
 
-ScatterSuperUpdate(update, cols_in_update, rows_in_update,
-	dest_nz, dest_len, relative)
-double *update, *dest_nz;
-int *relative;
+void ScatterSuperUpdate(double *update, long cols_in_update, long rows_in_update, double *dest_nz, long dest_len, long *relative)
 {
-  int i, dest, *last, *leftRow;
+  long i, dest, *last, *leftRow;
   double *theTmp, *rightNZ;
 
   theTmp = update;
@@ -297,12 +290,9 @@
 /* given a panel update 'update' with given size and relative indices,
    scatter into into dest_nz */
 
-ModifySuperByColumn(src_nz, cols_in_update, rows_in_update,
-		    dest_nz, dest_len, relative)
-double *src_nz, *dest_nz;
-int *relative;
+void ModifySuperByColumn(double *src_nz, long cols_in_update, long rows_in_update, double *dest_nz, long dest_len, long *relative)
 {
-  int i, dest, *last, *leftRow;
+  long i, dest, *last, *leftRow;
   double ljk, *theTmp, *rightNZ;
 
   for (i=0; i<cols_in_update; i++) {
@@ -320,10 +310,9 @@
 }
 
 
-SetDestIndices(super, indices)
-int *indices;
+void SetDestIndices(long super, long *indices)
 {
-  int i, *rightRow, *lastRow;
+  long i, *rightRow, *lastRow;
 
   rightRow = &LB.row[LB.col[super]];
   lastRow = rightRow + (LB.col[super+1]-
@@ -334,10 +323,9 @@
 }
 
 
-SetDomainIndices(super, indices)
-int *indices;
+void SetDomainIndices(long super, long *indices)
 {
-  int i, *rightRow, *lastRow;
+  long i, *rightRow, *lastRow;
 
   rightRow = &LB.row[LB.col[super]+1];
   lastRow = rightRow-1 + (LB.col[super+1]-LB.col[super]);
@@ -347,12 +335,11 @@
 }
 
 
-ModifySuperBySuper(src, theFirst, theLast, length, dest)
-double *dest;
+void ModifySuperBySuper(long src, long theFirst, long theLast, long length, double *dest)
 {
-  int i, fits;
-  int first, last, lastcol;
-  int this_length;
+  long i, fits;
+  long first, last, lastcol;
+  long this_length;
   double *destination;
 
   fits = FitsInCache/length;
@@ -387,11 +374,9 @@
 }
 
 
-ModifyTwoBySupernodeB(super, lastcol, theFirst,
-		      destination0, destination1)
-double *destination0, *destination1;
+void ModifyTwoBySupernodeB(long super, long lastcol, long theFirst, double *destination0, double *destination1)
 {
-  int col, increment;
+  long col, increment;
   double ljk0_0, ljk0_1, ljk1_0, ljk1_1, ljk2_0, ljk2_1, ljk3_0, ljk3_1;
   double ljk4_0, ljk4_1, ljk5_0, ljk5_1, ljk6_0, ljk6_1, ljk7_0, ljk7_1;
   double d0, d1, tmp0, tmp1;
@@ -528,14 +513,13 @@
 }
 
 
-ModifyBySupernodeB(super, lastcol, theFirst, destination)
-double *destination;
+void ModifyBySupernodeB(long super, long lastcol, long theFirst, double *destination)
 {
   double t0, ljk0, ljk1, ljk2, ljk3, ljk4, ljk5, ljk6, ljk7;
-  int increment;
+  long increment;
   double *dest, *last;
   double *theNZ0, *theNZ1, *theNZ2, *theNZ3, *theNZ4, *theNZ5, *theNZ6,*theNZ7;
-  int j, col;
+  long j, col;
 
   j = LB.row[LB.col[super]+theFirst];
 
diff -Naur splash2/codes/kernels/cholesky/parts.C splash2-modified/codes/kernels/cholesky/parts.C
--- splash2/codes/kernels/cholesky/parts.C	1994-10-11 23:51:45.000000000 -0400
+++ splash2-modified/codes/kernels/cholesky/parts.C	2006-09-14 18:34:28.000000000 -0400
@@ -21,29 +21,29 @@
 
 
 struct Chunk {
-	int first, last, assign;
+	long first, last, assign;
 	struct Chunk *next;
 	} *chunks_head = NULL, *chunks_tail = NULL;
 
-int tolerance = 20;
+long tolerance = 20;
 
 double domain_ops;
 
 double *divide_lo=NULL, *divide_hi;
 
 extern double *work_tree;
-extern int *firstchild, *child;
+extern long *firstchild, *child;
 
+long Divide(struct Chunk *root);
+void AddInOrder(struct Chunk *t);
 
-Partition(M, parts, T, assigned_ops, domain, domains, proc_domains, distribute)
-SMatrix M;
-int *T, *assigned_ops, *domain, *domains, *proc_domains;
+void Partition(SMatrix M, long parts, long *T, long *assigned_ops, long *domain, long *domains, long *proc_domains)
 {
-  int i, p, start, minm, maxm, ops, change;
-  int which=0;
-  int *depth;
+  long i, p, start, minm, maxm, ops, change;
+  long which=0;
+  long *depth;
   double ave, maxo=0.0, maxd;
-  struct Chunk *t, *GetChunk(), *NewChunk();
+  struct Chunk *t;
 
   start = 0;
   for (i=0; i<M.n; i++)
@@ -98,7 +98,7 @@
     free(t);
   }
 
-  depth = (int *) malloc(proc_domains[parts]*sizeof(int));
+  depth = (long *) malloc(proc_domains[parts]*sizeof(long));
   for (p=0; p<parts; p++)
     for (i=proc_domains[p]; i<proc_domains[p+1]; i++)
       depth[i] = 1000000*p-BlDepth(domains[i]);
@@ -126,17 +126,16 @@
   }
   ave = domain_ops/(double) parts;
 
-  printf("Divide for %d P, %d domains, ", parts, proc_domains[parts]);
+  printf("Divide for %ld P, %ld domains, ", parts, proc_domains[parts]);
   printf("%.2f of work static, ", domain_ops/work_tree[M.n]);
   printf("%.2f eff, (%.2f overall)\n", ave/maxd, work_tree[M.n]/maxo/parts);
 }
 
 
-MarkSubtreeAsDomain(domain, root)
-int *domain;
+void MarkSubtreeAsDomain(long *domain, long root)
 {
-  int i, first, root_super;
-  extern int *node;
+  long i, first, root_super;
+  extern long *node;
 
   first = root;
   while (firstchild[first] != firstchild[first+1])
@@ -155,10 +154,9 @@
 }
 
 
-NumberPartition(parts, assigned_ops, distribute)
-int *assigned_ops;
+void NumberPartition(long parts, long *assigned_ops, long distribute)
 {
-  int i, minm;
+  long i, minm;
   struct Chunk *t, *old_t;
 
   for (i=0; i<parts; i++)
@@ -176,12 +174,11 @@
   }
 }
 
-Divide(root)
-struct Chunk *root;
+long Divide(struct Chunk *root)
 {
-  int i, first, first_in_super;
-  int change = 1;
-  struct Chunk *t2, *NewChunk();
+  long i, first, first_in_super;
+  long change = 1;
+  struct Chunk *t2;
 
   first_in_super = root->last-1;
   while (firstchild[first_in_super]+1 ==
@@ -203,10 +200,9 @@
 }
 
 
-MaxBucket(assigned_ops, parts)
-int *assigned_ops;
+long MaxBucket(long *assigned_ops, long parts)
 {
-	int i, maxm, ind;
+	long i, maxm, ind;
 
 	maxm = assigned_ops[0]; ind = 0;
 	for (i=1; i<parts; i++)
@@ -217,10 +213,9 @@
 	return(ind);
 }
 
-MinBucket(assigned_ops, parts)
-int *assigned_ops;
+long MinBucket(long *assigned_ops, long parts)
 {
-	int i, minm, ind;
+	long i, minm, ind;
 
 	minm = assigned_ops[0]; ind = 0;
 	for (i=1; i<parts; i++)
@@ -243,11 +238,10 @@
 
 
 
-AddInOrder(t)
-struct Chunk *t;
+void AddInOrder(struct Chunk *t)
 {
 	struct Chunk *current;
-	int work;
+	long work;
 
 	work = work_tree[t->last-1];
 	current = chunks_head;
diff -Naur splash2/codes/kernels/cholesky/seg.C splash2-modified/codes/kernels/cholesky/seg.C
--- splash2/codes/kernels/cholesky/seg.C	1994-10-11 23:51:45.000000000 -0400
+++ splash2-modified/codes/kernels/cholesky/seg.C	2007-04-18 15:21:19.000000000 -0400
@@ -19,18 +19,15 @@
 #include "matrix.h"
 #include <math.h>
 
-#define SWAP(x, y) {int tmp; tmp=x; x=y; y=tmp;}
-
 double max_block_size;
-extern int *node;
-int *boundary, *next_in_segment, *next_segment, *sets_affected, n_affected;
-int *partition;
-int *segment_perm;
+extern long *node;
+long *boundary, *next_in_segment, *next_segment, *sets_affected, n_affected;
+long *partition;
+long *segment_perm;
 
-ComputeTargetBlockSize(M, P)
-SMatrix M;
+void ComputeTargetBlockSize(SMatrix M, long P)
 {
-  int max_ht;
+  long max_ht;
   double total_ops;
   extern double *work_tree;
 
@@ -41,17 +38,15 @@
 
   max_block_size = sqrt(total_ops/(3*max_ht)/P);
 
-  printf("%d max height, %.0f ops, %.2f conc, %.2f bl for %d P\n",
+  printf("%ld max height, %.0f ops, %.2f conc, %.2f bl for %ld P\n",
 	 max_ht, total_ops, total_ops/(3*max_ht), max_block_size, P);
 
 }
 
-FindMaxHeight(L, root, height, maxm)
-SMatrix L;
-int *maxm;
+void FindMaxHeight(SMatrix L, long root, long height, long *maxm)
 {
-  int i;
-  extern int *firstchild, *child;
+  long i;
+  extern long *firstchild, *child;
 
   if (height > *maxm)
     *maxm = height;
@@ -61,23 +56,19 @@
 }
 
 
-NoSegments(M)
-SMatrix M;
+void NoSegments(SMatrix M)
 {
-  int i;
+  long i;
 
-  partition = (int *) MyMalloc(M.n*sizeof(int), DISTRIBUTED);
+  partition = (long *) MyMalloc(M.n*sizeof(long), DISTRIBUTED);
   for (i=0; i<M.n; i++)
     partition[i] = node[i];
 }
 
 
-CreatePermutation(n, node, PERM, permutation_method)
-int *node, *PERM;
+void CreatePermutation(long n, long *PERM, long permutation_method)
 {
-  int j, k;
-  int swap, tmp;
-  extern int *domain;
+  long j;
 
   PERM[n] = n;
   if (permutation_method == NO_PERM) {
diff -Naur splash2/codes/kernels/cholesky/solve.C splash2-modified/codes/kernels/cholesky/solve.C
--- splash2/codes/kernels/cholesky/solve.C	1994-10-11 23:51:45.000000000 -0400
+++ splash2-modified/codes/kernels/cholesky/solve.C	2007-06-19 15:52:49.000000000 -0400
@@ -43,61 +43,56 @@
 
 double CacheSize = DEFAULT_CS;
 double CS;
-int BS = 45;
-void Go();
+long BS = 45;
 
 struct GlobalMemory *Global;
 
-int *T, *nz, *node, *domain, *domains, *proc_domains;
+long *T, *nz, *node, *domain, *domains, *proc_domains;
 
-int *PERM, *INVP;
+long *PERM, *INVP;
 
-int solution_method = FAN_OUT*10+0;
+long solution_method = FAN_OUT*10+0;
 
-int distribute = -1;
+long distribute = -1;
 
-int target_partition_size = 0;
-int postpass_partition_size = DEFAULT_PPS;
-int permutation_method = 1;
-int join = 1; /* attempt to amalgamate supernodes */
-int scatter_decomposition = 0;
+long target_partition_size = 0;
+long postpass_partition_size = DEFAULT_PPS;
+long permutation_method = 1;
+long join = 1; /* attempt to amalgamate supernodes */
+long scatter_decomposition = 0;
 
-int P=DEFAULT_P;
-int iters = 1;
+long P=DEFAULT_P;
+long iters = 1;
 SMatrix M;      /* input matrix */
 
 char probname[80];
 
 extern struct Update *freeUpdate[MAX_PROC];
 extern struct Task *freeTask[MAX_PROC];
+extern long *firstchild, *child;
+extern BMatrix LB;
+extern char *optarg;
 
 struct gpid {
-  int pid;
-  unsigned int initdone;
-  unsigned int finish;
+  long pid;
+  unsigned long initdone;
+  unsigned long finish;
 } *gp;
 
-int do_test = 0;
-int do_stats = 0;
+long do_test = 0;
+long do_stats = 0;
 
-main(argc, argv)
-char *argv[];
+int main(int argc, char *argv[])
 {
-  SMatrix L;
-  double *b, *x, *CreateVector(), *TriangularSolve(), *TriBSolve();
-  double norm, ComputeNorm();
-  unsigned int elapsed;
-  extern BMatrix LB;
-  int i;
-  int c;
-  int *assigned_ops, num_nz, num_domain, num_alloc, ps;
-  int *PERM2;
-  extern char *optarg;
-  extern int *firstchild, *child, *nz, *node;
+  double *b, *x;
+  double norm;
+  long i;
+  long c;
+  long *assigned_ops, num_nz, num_domain, num_alloc, ps;
+  long *PERM2;
   extern double *work_tree;
-  extern int *domain, *partition;
-  extern int *block_start, *all_blocks;
-  unsigned int start;
+  extern long *partition;
+  unsigned long start;
   double mint, maxt, avgt;
 
   CLOCK(start)
@@ -106,10 +101,10 @@
     switch(c) {
     case 'B': postpass_partition_size = atoi(optarg); break;  
     case 'C': CacheSize = (double) atoi(optarg); break;  
-    case 'p': P = atoi(optarg); break;  
+    case 'p': P = atol(optarg); break;  
     case 's': do_stats = 1; break;  
     case 't': do_test = 1; break;  
-    case 'h': printf("Usage: SCHOL <options> file\n\n");
+    case 'h': printf("Usage: CHOLESKY <options> file\n\n");
               printf("options:\n");
               printf("  -Bb : Use a postpass partition size of b.\n");
               printf("  -Cc : Cache size in bytes.\n");
@@ -117,7 +112,7 @@
               printf("  -s  : Print individual processor timing statistics.\n");
               printf("  -t  : Test output.\n");
               printf("  -h  : Print out command line options.\n\n");
-              printf("Default: SCHOL -p%1d -B%1d -C%1d\n",
+              printf("Default: CHOLESKY -p%1d -B%1d -C%1d\n",
                      DEFAULT_P,DEFAULT_PPS,DEFAULT_CS);
               exit(0);
               break;
@@ -126,7 +121,7 @@
 
   CS = CacheSize / 8.0;
   CS = sqrt(CS);
-  BS = (int) floor(CS+0.5);
+  BS = (long) floor(CS+0.5);
 
   MAIN_INITENV(, SH_MEM_AMT)
 
@@ -134,7 +129,7 @@
   gp->pid = 0;
   Global = (struct GlobalMemory *)
     G_MALLOC(sizeof(struct GlobalMemory), 0);
-  BARINIT(Global->start)
+  BARINIT(Global->start, P)
   LOCKINIT(Global->waitLock)
   LOCKINIT(Global->memLock)
 
@@ -150,8 +145,8 @@
   printf("\n");
   printf("Sparse Cholesky Factorization\n");
   printf("     Problem: %s\n",probname);
-  printf("     %d Processors\n",P);
-  printf("     Postpass partition size: %d\n",postpass_partition_size);
+  printf("     %ld Processors\n",P);
+  printf("     Postpass partition size: %ld\n",postpass_partition_size);
   printf("     %0.0f byte cache\n",CacheSize);
   printf("\n");
   printf("\n");
@@ -167,50 +162,50 @@
 
   printf("No ordering\n");
 
-  PERM = (int *) MyMalloc((M.n+1)*sizeof(int), DISTRIBUTED);
-  INVP = (int *) MyMalloc((M.n+1)*sizeof(int), DISTRIBUTED);
+  PERM = (long *) MyMalloc((M.n+1)*sizeof(long), DISTRIBUTED);
+  INVP = (long *) MyMalloc((M.n+1)*sizeof(long), DISTRIBUTED);
 
-  CreatePermutation(M.n, (int *) NULL, PERM, NO_PERM);
+  CreatePermutation(M.n, PERM, NO_PERM);
 
   InvertPerm(M.n, PERM, INVP);
 
-  T = (int *) MyMalloc((M.n+1)*sizeof(int), DISTRIBUTED);
+  T = (long *) MyMalloc((M.n+1)*sizeof(long), DISTRIBUTED);
   EliminationTreeFromA(M, T, PERM, INVP);
 
-  firstchild = (int *) MyMalloc((M.n+2)*sizeof(int), DISTRIBUTED);
-  child = (int *) MyMalloc((M.n+1)*sizeof(int), DISTRIBUTED);
+  firstchild = (long *) MyMalloc((M.n+2)*sizeof(long), DISTRIBUTED);
+  child = (long *) MyMalloc((M.n+1)*sizeof(long), DISTRIBUTED);
   ParentToChild(T, M.n, firstchild, child);
 
-  nz = (int *) MyMalloc((M.n+1)*sizeof(int), DISTRIBUTED);
+  nz = (long *) MyMalloc((M.n+1)*sizeof(long), DISTRIBUTED);
   ComputeNZ(M, T, nz, PERM, INVP);
 
   work_tree = (double *) MyMalloc((M.n+1)*sizeof(double), DISTRIBUTED);
   ComputeWorkTree(M, nz, work_tree);
 
-  node = (int *) MyMalloc((M.n+1)*sizeof(int), DISTRIBUTED);
-  FindSupernodes(M, T, nz, node, PERM, INVP);
+  node = (long *) MyMalloc((M.n+1)*sizeof(long), DISTRIBUTED);
+  FindSupernodes(M, T, nz, node);
 
-  Amalgamate2(1, M, T, nz, node, (int *) NULL, 1);
+  Amalgamate2(1, M, T, nz, node, (long *) NULL, 1);
 
 
-  assigned_ops = (int *) malloc(P*sizeof(int));
-  domain = (int *) MyMalloc(M.n*sizeof(int), DISTRIBUTED);
-  domains = (int *) MyMalloc(M.n*sizeof(int), DISTRIBUTED);
-  proc_domains = (int *) MyMalloc((P+1)*sizeof(int), DISTRIBUTED);
+  assigned_ops = (long *) malloc(P*sizeof(long));
+  domain = (long *) MyMalloc(M.n*sizeof(long), DISTRIBUTED);
+  domains = (long *) MyMalloc(M.n*sizeof(long), DISTRIBUTED);
+  proc_domains = (long *) MyMalloc((P+1)*sizeof(long), DISTRIBUTED);
   printf("before partition\n");
   fflush(stdout);
-  Partition(M, P, T, assigned_ops, domain, domains, proc_domains, distribute);
+  Partition(M, P, T, assigned_ops, domain, domains, proc_domains);
   free(assigned_ops);
 
   {
-    int i, tot_domain_updates, tail_length;
+    long i, tot_domain_updates, tail_length;
 
     tot_domain_updates = 0;
     for (i=0; i<proc_domains[P]; i++) {
       tail_length = nz[domains[i]]-1;
       tot_domain_updates += tail_length*(tail_length+1)/2;
     }
-    printf("%d total domain updates\n", tot_domain_updates);
+    printf("%ld total domain updates\n", tot_domain_updates);
   }
 
   num_nz = num_domain = 0;
@@ -222,13 +217,13 @@
   
   ComputeTargetBlockSize(M, P);
 
-  printf("Target partition size %d, postpass size %d\n",
+  printf("Target partition size %ld, postpass size %ld\n",
 	 target_partition_size, postpass_partition_size);
 
   NoSegments(M);
 
-  PERM2 = (int *) malloc((M.n+1)*sizeof(int));
-  CreatePermutation(M.n, node, PERM2, permutation_method);
+  PERM2 = (long *) malloc((M.n+1)*sizeof(long));
+  CreatePermutation(M.n, PERM2, permutation_method);
   ComposePerm(PERM, PERM2, M.n);
   free(PERM2);
 
@@ -243,7 +238,7 @@
 
   FillInStructure(M, firstchild, child, PERM, INVP);
 
-  AssignBlocksNow(distribute);  /* distribute == 21 */
+  AssignBlocksNow();
 
   AllocateNZ();
 
@@ -252,17 +247,12 @@
 
   InitTaskQueues(P);
 
-  PreAllocate1FO(0);
+  PreAllocate1FO();
   ComputeRemainingFO();
   ComputeReceivedFO();
 
-  for (i=1; i<P; i++) {
-    CREATE(Go)
-  }
-
-  Go();
-
-  WAIT_FOR_END(P-1)
+  CREATE(Go, P);
+  WAIT_FOR_END(P);
 
   printf("%.0f operations for factorization\n", work_tree[M.n]);
 
@@ -270,7 +260,7 @@
   printf("                            PROCESS STATISTICS\n");
   printf("              Total\n");
   printf(" Proc         Time \n");
-  printf("    0    %10.0d\n", Global->runtime[0]);
+  printf("    0    %10.0ld\n", Global->runtime[0]);
   if (do_stats) {
     maxt = avgt = mint = Global->runtime[0];
     for (i=1; i<P; i++) {
@@ -284,7 +274,7 @@
     }
     avgt = avgt / P;
     for (i=1; i<P; i++) {
-      printf("  %3d    %10d\n",i,Global->runtime[i]);
+      printf("  %3ld    %10ld\n",i,Global->runtime[i]);
     }
     printf("  Avg    %10.0f\n",avgt);
     printf("  Min    %10.0f\n",mint);
@@ -293,21 +283,21 @@
   }
 
   printf("                            TIMING INFORMATION\n");
-  printf("Start time                        : %16d\n",
+  printf("Start time                        : %16lu\n",
           start);
-  printf("Initialization finish time        : %16d\n",
+  printf("Initialization finish time        : %16lu\n",
           gp->initdone);
-  printf("Overall finish time               : %16d\n",
+  printf("Overall finish time               : %16lu\n",
           gp->finish);
-  printf("Total time with initialization    : %16d\n",
+  printf("Total time with initialization    : %16lu\n",
           gp->finish-start);
-  printf("Total time without initialization : %16d\n",
+  printf("Total time without initialization : %16lu\n",
           gp->finish-gp->initdone);
   printf("\n");
 
   if (do_test) {
     printf("                             TESTING RESULTS\n");
-    x = TriBSolve(LB, b, PERM, INVP);
+    x = TriBSolve(LB, b, PERM);
     norm = ComputeNorm(x, LB.n);
     if (norm >= 0.0001) {
       printf("Max error is %10.9f\n", norm);
@@ -322,8 +312,7 @@
 
 void Go()
 {
-  int iter;
-  int MyNum;
+  long MyNum;
   struct LocalCopies *lc;
 
   LOCK(Global->waitLock)
@@ -331,6 +320,7 @@
     gp->pid++;
   UNLOCK(Global->waitLock)
 
+  BARINCLUDE(Global->start);
 /* POSSIBLE ENHANCEMENT:  Here is where one might pin processes to
    processors to avoid migration */
 
@@ -344,7 +334,7 @@
 
     /* initialize - put original non-zeroes in L */
 
-  PreProcessFO(MyNum,lc);
+  PreProcessFO(MyNum);
 
   BARRIER(Global->start, P);
 
@@ -384,13 +374,10 @@
 }
 
 
-PlaceDomains(P)
+void PlaceDomains(long P)
 {
-  int p, d, first;
+  long p, d, first;
   char *range_start, *range_end;
-  int page;
-  extern int *firstchild, *child;
-  extern BMatrix LB;
 
   for (p=P-1; p>=0; p--)
     for (d=LB.proc_domains[p]; d<LB.proc_domains[p+1]; d++) {
@@ -402,7 +389,7 @@
       range_start = (char *) &LB.row[LB.col[first]];
       range_end = (char *) &LB.row[LB.col[LB.domains[d]+1]];
       MigrateMem(&LB.row[LB.col[first]],
-		 (LB.col[LB.domains[d]+1]-LB.col[first])*sizeof(int),
+		 (LB.col[LB.domains[d]+1]-LB.col[first])*sizeof(long),
 		 p);
 
       /* place non-zeroes */
@@ -418,12 +405,11 @@
 
 /* Compute result of first doing PERM1, then PERM2 (placed back in PERM1) */
 
-ComposePerm(PERM1, PERM2, n)
-int *PERM1, *PERM2, n;
+void ComposePerm(long *PERM1, long *PERM2, long n)
 {
-  int i, *PERM3;
+  long i, *PERM3;
 
-  PERM3 = (int *) malloc((n+1)*sizeof(int));
+  PERM3 = (long *) malloc((n+1)*sizeof(long));
 
   for (i=0; i<n; i++)
     PERM3[i] = PERM1[PERM2[i]];
diff -Naur splash2/codes/kernels/cholesky/tree.C splash2-modified/codes/kernels/cholesky/tree.C
--- splash2/codes/kernels/cholesky/tree.C	1994-10-11 23:51:45.000000000 -0400
+++ splash2-modified/codes/kernels/cholesky/tree.C	2007-04-18 15:33:13.000000000 -0400
@@ -18,17 +18,15 @@
 
 #include "matrix.h"
 
-int *firstchild, *child;
+long *firstchild, *child;
 double *work_tree;
 
-EliminationTreeFromA(A, T, P, INVP)
-SMatrix A;
-int *T, *P, *INVP;
+void EliminationTreeFromA(SMatrix A, long *T, long *P, long *INVP)
 {
-  int *subtree;
-  int i, nd, nabor, j, r, nextr, root;
+  long *subtree;
+  long i, nd, nabor, j, r, nextr, root;
 
-  subtree = (int *) malloc((A.n+1)*sizeof(int));
+  subtree = (long *) malloc((A.n+1)*sizeof(long));
 
   for (i=0; i<=A.n; i++)
     T[i] = subtree[i] = A.n;
@@ -62,13 +60,12 @@
 }
 
 
-ParentToChild(T, n, firstchild, child)
-int *T, *firstchild, *child;
+void ParentToChild(long *T, long n, long *firstchild, long *child)
 {
-  int i, k, parent, count=0;
-  int *next;
+  long i, k, parent, count=0;
+  long *next;
 
-  next = (int *) malloc((n+1)*sizeof(int));
+  next = (long *) malloc((n+1)*sizeof(long));
 
   for (i=0; i<=n; i++)
     firstchild[i] = next[i] = -1;
@@ -96,14 +93,12 @@
 }
 
 
-ComputeNZ(A, T, nz, PERM, INVP)
-SMatrix A;
-int *T, *nz, *PERM, *INVP;
+void ComputeNZ(SMatrix A, long *T, long *nz, long *PERM, long *INVP)
 {
-  int i, j, nd, nabor, k;
-  int *marker;
+  long i, j, nd, nabor, k;
+  long *marker;
 
-  marker = (int *) malloc(A.n*sizeof(int));
+  marker = (long *) malloc(A.n*sizeof(long));
   for (i=0; i<A.n; i++)
     nz[i] = 1;
   nz[A.n] = 0;
@@ -126,15 +121,13 @@
 }
 
 
-FindSupernodes(A, T, nz, node, PERM, INVP)
-SMatrix A;
-int *T, *nz, *node, *PERM, *INVP;
+void FindSupernodes(SMatrix A, long *T, long *nz, long *node)
 {
-  int i;
-  int *nchild;
-  int supers, current, size, max_super = 0;
+  long i;
+  long *nchild;
+  long supers, current, size, max_super = 0;
 
-  nchild = (int *) malloc((A.n+1)*sizeof(int));
+  nchild = (long *) malloc((A.n+1)*sizeof(long));
   for (i=0; i<=A.n; i++)
     nchild[i] = 0;
 
@@ -164,20 +157,16 @@
     max_super = size;
   node[A.n] = 0;
 
-  printf("%d supers, %4.2f nodes/super, %d max super\n",
+  printf("%ld supers, %4.2f nodes/super, %ld max super\n",
 	 supers, A.n/(double) supers, max_super);  
 
   free(nchild);
 }
 
 
-ComputeWorkTree(A, nz, work_tree)
-SMatrix A;
-int *nz;
-double *work_tree;
+void ComputeWorkTree(SMatrix A, long *nz, double *work_tree)
 {
-  int i, j, nzj;
-  extern int *firstchild, *child;
+  long i, j, nzj;
 
   for (j=0; j<=A.n; j++) {
     if (j != A.n) {
diff -Naur splash2/codes/kernels/cholesky/util.C splash2-modified/codes/kernels/cholesky/util.C
--- splash2/codes/kernels/cholesky/util.C	1994-10-11 23:51:45.000000000 -0400
+++ splash2-modified/codes/kernels/cholesky/util.C	2007-06-19 15:53:23.000000000 -0400
@@ -21,36 +21,34 @@
 #include "matrix.h"
 
 #define Error(m) { printf(m); exit(0); }
-#define Outside(M, i) (i >= M.n || i < 0)
-#define AddMember(set, new) { int s, n; s = set; n = new; \
-			       link[n] = link[s]; link[s] = n; }
+#define AddMember(set, new) { long s, n; s = set; n = new; link[n] = link[s]; link[s] = n; }
 
+long maxm;
 
-int maxm;
-
-SMatrix NewMatrix(n, m, nz)
+SMatrix NewMatrix(long n, long m, long nz)
 {
   SMatrix M;
 
   M.n = n; M.m = m;
-  M.col = (int *) MyMalloc((n+1)*sizeof(int), DISTRIBUTED);
-  M.startrow = (int *) MyMalloc((n+1)*sizeof(int), DISTRIBUTED);
-  M.row = (int *) MyMalloc((m+n)*sizeof(int), DISTRIBUTED);
+  M.col = (long *) MyMalloc((n+1)*sizeof(long), DISTRIBUTED);
+  M.startrow = (long *) MyMalloc((n+1)*sizeof(long), DISTRIBUTED);
+  M.row = (long *) MyMalloc((m+n)*sizeof(long), DISTRIBUTED);
   if (nz) {
-    M.nz = (double *) MyMalloc((m+n)*sizeof(double), DISTRIBUTED);
+	M.nz = (double *) MyMalloc((m+n)*sizeof(double), DISTRIBUTED);
+  } else {
+	M.nz = NULL;
   }
-  else M.nz = NULL;
 
   if (!M.col || !M.row || (nz && !M.nz)) {
-    printf("NewMatrix %d %d: Out of memory\n", n, m);
+    printf("NewMatrix %ld %ld: Out of memory\n", n, m);
     exit(0);
   }
 
   return(M);
 }
 
-FreeMatrix(M)
-SMatrix M;
+
+void FreeMatrix(SMatrix M)
 {
   MyFree(M.col);
   MyFree(M.startrow);
@@ -60,14 +58,14 @@
 }
 
 
-double *NewVector(n)
+double *NewVector(long n)
 {
   double *v;
 
   v = (double *) MyMalloc(n*sizeof(double), DISTRIBUTED);
 
   if (!v && n) {
-    printf("Out of memory: NewVector(%d)\n", n);
+    printf("Out of memory: NewVector(%ld)\n", n);
     exit(0);
   }
 
@@ -75,35 +73,35 @@
 }
 
 
-double Value(i, j, n)
-int i, j, n;
+double Value(long i, long j)
 {
-  if (i == j)
-    return((double) maxm+0.1);
-  else if (0)
-    return(-1.0+(i+j)/(double) n);
-  else
-    return(-1.0);
+  if (i == j) {
+	return((double) maxm+0.1);
+  } else {
+	return(-1.0);
+  }
 }
 
 
-SMatrix ReadSparse(name, probName)
-char *name, *probName;
+SMatrix ReadSparse(char *name, char *probName)
 {
 	FILE *fp;
-	int n, m, i, j;
-	int n_rows, tmp;
-	int numer_lines;
-	int colnum, colsize, rownum, rowsize;
+	long n, m, i, j;
+	long n_rows, tmp;
+	long numer_lines;
+	long colnum, colsize, rownum, rowsize;
 	char buf[100], type[4];
-	SMatrix M, F, LowerToFull();
+	SMatrix M, F;
 
-	if (!name || name[0] == 0)
+	if (!name || name[0] == 0) {
 		fp = stdin;
-	else fp = fopen(name, "r");
+	} else {
+		fp = fopen(name, "r");
+	}
 
-	if (!fp) 
+	if (!fp) {
 		Error("Error opening file\n");
+	}
 
 	fscanf(fp, "%72c", buf);
 
@@ -113,7 +111,7 @@
 
 	for (i=0; i<5; i++) {
 	  fscanf(fp, "%14c", buf);
-	  sscanf(buf, "%d", &tmp);
+	  sscanf(buf, "%ld", &tmp);
 	  if (i == 3)
 	    numer_lines = tmp;
 	}
@@ -128,13 +126,13 @@
 
 	fscanf(fp, "%11c", buf); /* pad */
 
-	fscanf(fp, "%14c", buf); sscanf(buf, "%d", &n_rows);
+	fscanf(fp, "%14c", buf); sscanf(buf, "%ld", &n_rows);
 
-	fscanf(fp, "%14c", buf); sscanf(buf, "%d", &n);
+	fscanf(fp, "%14c", buf); sscanf(buf, "%ld", &n);
 
-	fscanf(fp, "%14c", buf); sscanf(buf, "%d", &m);
+	fscanf(fp, "%14c", buf); sscanf(buf, "%ld", &m);
 
-	fscanf(fp, "%14c", buf); sscanf(buf, "%d", &tmp);
+	fscanf(fp, "%14c", buf); sscanf(buf, "%ld", &tmp);
 	if (tmp != 0)
 	  printf("This is not an assembled matrix!\n");
 	if (n_rows != n)
@@ -177,7 +175,7 @@
 	if (F.nz) {
 	  for (j=0; j<n; j++)
 	    for (i=F.col[j]; i<F.col[j+1]; i++)
-	      F.nz[i] = Value(F.row[i], j, F.n);
+	      F.nz[i] = Value(F.row[i], j);
 	}
 
 	FreeMatrix(M);
@@ -185,18 +183,15 @@
 	return(F);
 }
 
-DumpLine(fp)
-FILE *fp;
+void DumpLine(FILE *fp)
 {
-	int c;
+	long c;
 
 	while ((c = fgetc(fp)) != '\n')
 		;
 }
 
-ParseIntFormat(buf, num, size)
-char *buf;
-int *num, *size;
+void ParseIntFormat(char *buf, long *num, long *size)
 {
   char *tmp;
 
@@ -204,19 +199,17 @@
 
   while (*tmp++ != '(')
     ;
-  sscanf(tmp, "%d", num);
+  sscanf(tmp, "%ld", num);
 
   while (*tmp++ != 'I')
     ;
-  sscanf(tmp, "%d", size);
+  sscanf(tmp, "%ld", size);
 }
 
 
-ReadVector(fp, n, where, perline, persize)
-FILE *fp;
-int *where;
+void ReadVector(FILE *fp, long n, long *where, long perline, long persize)
 {
-  int i, j, item;
+  long i, j, item;
   char tmp, buf[100];
 
   i = 0;
@@ -231,47 +224,49 @@
   }
 }
 
-
-SMatrix LowerToFull(L)
-SMatrix L;
+SMatrix LowerToFull(SMatrix L)
 {
   SMatrix M;
-  int *link, *first;
-  int i, j, nextj, ind = 0;
+  long *link, *first;
+  long i, j, nextj, ind = 0;
 
-  link = (int *) malloc(L.n*sizeof(int));
-  first = (int *) malloc(L.n*sizeof(int));
+  link = (long *) malloc(L.n*sizeof(long));
+  first = (long *) malloc(L.n*sizeof(long));
 
-  for (i=0; i<L.n; i++)
+  for (i=0; i<L.n; i++) {
     link[i] = first[i] = -1;
-    
+  }
+
   M = NewMatrix(L.n, 2*(L.m-L.n)+L.n, 0);
 
   for (i=0; i<L.n; i++) {
     M.col[i] = ind;
 
-    for (j=L.col[i]; j<L.col[i+1]; j++)
+    for (j=L.col[i]; j<L.col[i+1]; j++) {
       if (L.row[j] >= i) {
 	M.row[ind++] = L.row[j];
       }
+    }
 
     j = link[i];
     while (j != -1) {
       nextj = link[j];
       M.row[ind++] = j;
       first[j]++;
-      if (first[j] < L.col[j+1])
+      if (first[j] < L.col[j+1]) {
 	AddMember(L.row[first[j]], j);
+      }
       j = nextj;
     }
 
     first[i] = L.col[i];
-    if (L.row[first[i]] == i)
+    if (L.row[first[i]] == i) {
       first[i]++;
-    else {
-      fprintf(stderr, "Missing diagonal: %d: ", i);
-      for (j=L.col[i]; j<L.col[i+1]; j++)
-	fprintf(stderr, "%d ", L.row[j]);
+    } else {
+      fprintf(stderr, "Missing diagonal: %ld: ", i);
+      for (j=L.col[i]; j<L.col[i+1]; j++) {
+	fprintf(stderr, "%ld ", L.row[j]);
+      }
       fprintf(stderr, "\n");
     }
 
@@ -282,23 +277,24 @@
 
   M.col[M.n] = ind;
 
-  for (i=0; i<=L.n; i++)
+  for (i=0; i<=L.n; i++) {
     M.startrow[i] = M.col[i];
+  }
 
-  if (ind != M.m)
+  if (ind != M.m) {
     printf("Lost some\n");
+  }
 
   free(link); free(first);
 
   return(M);
 }
 
-ISort(M, k)
-SMatrix M;
+
+void ISort(SMatrix M, long k)
 {
-	int hi, lo;
-	int i, j, tmp;
-	double tmp2;
+	long hi, lo;
+	long i, j, tmp;
 
 	hi = M.col[k+1];
 	lo = M.col[k];
@@ -314,3 +310,4 @@
 		}
 
 }
+
diff -Naur splash2/codes/kernels/fft/fft.C splash2-modified/codes/kernels/fft/fft.C
--- splash2/codes/kernels/fft/fft.C	1994-10-11 23:29:13.000000000 -0400
+++ splash2-modified/codes/kernels/fft/fft.C	2007-06-21 17:00:35.000000000 -0400
@@ -54,75 +54,82 @@
 
 MAIN_ENV
 
-#define SWAP(a,b) {double tmp; tmp=a; a=b; b=tmp;}
+#define SWAP_VALS(a,b) {double tmp; tmp=a; a=b; b=tmp;}
 
 struct GlobalMemory {
-  int id;
+  long id;
   LOCKDEC(idlock)
   BARDEC(start)
-  int *transtimes;
-  int *totaltimes;
-  int starttime;
-  int finishtime;
-  int initdonetime;
+  long *transtimes;
+  long *totaltimes;
+  unsigned long starttime;
+  unsigned long finishtime;
+  unsigned long initdonetime;
 } *Global;
 
 
-int P = DEFAULT_P;
-int M = DEFAULT_M;
-int N;                  /* N = 2^M                                */
-int rootN;              /* rootN = N^1/2                          */
+long P = DEFAULT_P;
+long M = DEFAULT_M;
+long N;                  /* N = 2^M                                */
+long rootN;              /* rootN = N^1/2                          */
 double *x;              /* x is the original time-domain data     */
 double *trans;          /* trans is used as scratch space         */
 double *umain;          /* umain is roots of unity for 1D FFTs    */
 double *umain2;         /* umain2 is entire roots of unity matrix */
-int test_result = 0;
-int doprint = 0;
-int dostats = 0;
-int transtime = 0;
-int transtime2 = 0;
-int avgtranstime = 0;
-int avgcomptime = 0;
-unsigned int transstart = 0;
-unsigned int transend = 0;
-int maxtotal=0;
-int mintotal=0;
+long test_result = 0;
+long doprint = 0;
+long dostats = 0;
+long transtime = 0;
+long transtime2 = 0;
+long avgtranstime = 0;
+long avgcomptime = 0;
+unsigned long transstart = 0;
+unsigned long transend = 0;
+long maxtotal=0;
+long mintotal=0;
 double maxfrac=0;
 double minfrac=0;
 double avgfractime=0;
-int orig_num_lines = NUM_CACHE_LINES;     /* number of cache lines */
-int num_cache_lines = NUM_CACHE_LINES;    /* number of cache lines */
-int log2_line_size = LOG2_LINE_SIZE;
-int line_size;
-int rowsperproc;
+long orig_num_lines = NUM_CACHE_LINES;     /* number of cache lines */
+long num_cache_lines = NUM_CACHE_LINES;    /* number of cache lines */
+long log2_line_size = LOG2_LINE_SIZE;
+long line_size;
+long rowsperproc;
 double ck1;
 double ck3;                        /* checksums for testing answer */
-int pad_length;
+long pad_length;
 
-void SlaveStart();
-double TouchArray(double *,double *,double *,double *,int,int,int,int);
-void FFT1D(int,int,int,double *,double *,double *,double *,int,int *,int,
-	   int,int,int,int,int,int,struct GlobalMemory *);
-double CheckSum();
-double drand48();
-int log_2(int);
-void printerr(char *);
+void SlaveStart(void);
+double TouchArray(double *x, double *scratch, double *u, double *upriv, long MyFirst, long MyLast);
+double CheckSum(double *x);
+void InitX(double *x);
+void InitU(long N, double *u);
+void InitU2(long N, double *u, long n1);
+long BitReverse(long M, long k);
+void FFT1D(long direction, long M, long N, double *x, double *scratch, double *upriv, double *umain2,
+	   long MyNum, long *l_transtime, long MyFirst, long MyLast, long pad_length, long test_result, long dostats);
+void TwiddleOneCol(long direction, long n1, long j, double *u, double *x, long pad_length);
+void Scale(long n1, long N, double *x);
+void Transpose(long n1, double *src, double *dest, long MyNum, long MyFirst, long MyLast, long pad_length);
+void CopyColumn(long n1, double *src, double *dest);
+void Reverse(long N, long M, double *x);
+void FFT1DOnce(long direction, long M, long N, double *u, double *x);
+void PrintArray(long N, double *x);
+void printerr(char *s);
+long log_2(long number);
 
+void srand48(long int seedval);
+double drand48(void);
 
-main(argc, argv)
-
-int argc;
-char *argv;
-
+int main(int argc, char *argv[])
 {
-  int i; 
-  int j; 
-  int c;
+  long i; 
+  long c;
   extern char *optarg;
-  int m1;
-  int factor;
-  int pages;
-  unsigned int start;
+  long m1;
+  long factor;
+  long pages;
+  unsigned long start;
 
   CLOCK(start);
 
@@ -195,7 +202,7 @@
 
   line_size = 1 << log2_line_size;
   if (line_size < 2*sizeof(double)) {
-    printf("WARNING: Each element is a complex double (%d bytes)\n",2*sizeof(double));
+    printf("WARNING: Each element is a complex double (%ld bytes)\n",2*sizeof(double));
     printf("  => Less than one element per cache line\n");
     printf("     Computing transpose blocking factor\n");
     factor = (2*sizeof(double)) / line_size;
@@ -230,8 +237,8 @@
   umain = (double *) G_MALLOC(2*rootN*sizeof(double));  
   umain2 = (double *) G_MALLOC(2*(N+rootN*pad_length)*sizeof(double)+PAGE_SIZE);
 
-  Global->transtimes = (int *) G_MALLOC(P*sizeof(int));  
-  Global->totaltimes = (int *) G_MALLOC(P*sizeof(int));  
+  Global->transtimes = (long *) G_MALLOC(P*sizeof(long));  
+  Global->totaltimes = (long *) G_MALLOC(P*sizeof(long));  
   if (Global == NULL) {
     printerr("Could not malloc memory for Global\n");
     exit(-1);
@@ -249,9 +256,9 @@
     exit(-1);
   }
 
-  x = (double *) (((unsigned) x) + PAGE_SIZE - ((unsigned) x) % PAGE_SIZE);
-  trans = (double *) (((unsigned) trans) + PAGE_SIZE - ((unsigned) trans) % PAGE_SIZE);
-  umain2 = (double *) (((unsigned) umain2) + PAGE_SIZE - ((unsigned) umain2) % PAGE_SIZE);
+  x = (double *) (((unsigned long) x) + PAGE_SIZE - ((unsigned long) x) % PAGE_SIZE);
+  trans = (double *) (((unsigned long) trans) + PAGE_SIZE - ((unsigned long) trans) % PAGE_SIZE);
+  umain2 = (double *) (((unsigned long) umain2) + PAGE_SIZE - ((unsigned long) umain2) % PAGE_SIZE);
 
 /* In order to optimize data distribution, the data structures x, trans, 
    and umain2 have been aligned so that each begins on a page boundary. 
@@ -267,7 +274,7 @@
    One way to place data is as follows:
 
    double *base;
-   int i;
+   long i;
 
    i = ((N/P)+(rootN/P)*pad_length)*2;
    base = &(x[0]);
@@ -282,25 +289,25 @@
 
   printf("\n");
   printf("FFT with Blocking Transpose\n");
-  printf("   %d Complex Doubles\n",N);
-  printf("   %d Processors\n",P);
+  printf("   %ld Complex Doubles\n",N);
+  printf("   %ld Processors\n",P);
   if (num_cache_lines != orig_num_lines) {
-    printf("   %d Cache lines\n",orig_num_lines);
-    printf("   %d Cache lines for blocking transpose\n",num_cache_lines);
+    printf("   %ld Cache lines\n",orig_num_lines);
+    printf("   %ld Cache lines for blocking transpose\n",num_cache_lines);
   } else {
-    printf("   %d Cache lines\n",num_cache_lines);
+    printf("   %ld Cache lines\n",num_cache_lines);
   }
   printf("   %d Byte line size\n",(1 << log2_line_size));
   printf("   %d Bytes per page\n",PAGE_SIZE);
   printf("\n");
 
-  BARINIT(Global->start);
+  BARINIT(Global->start, P);
   LOCKINIT(Global->idlock);
   Global->id = 0;
-  InitX(N, x);                  /* place random values in x */
+  InitX(x);                  /* place random values in x */
 
   if (test_result) {
-    ck1 = CheckSum(N, x);
+    ck1 = CheckSum(x);
   }
   if (doprint) {
     printf("Original data values:\n");
@@ -311,12 +318,9 @@
   InitU2(N,umain2,rootN);
 
   /* fire off P processes */
-  for (i=1; i<P; i++) {
-    CREATE(SlaveStart);
-  }
-  SlaveStart();
 
-  WAIT_FOR_END(P-1)
+  CREATE(SlaveStart, P);
+  WAIT_FOR_END(P);
 
   if (doprint) {
     if (test_result) {
@@ -332,7 +336,7 @@
   printf("                 PROCESS STATISTICS\n");
   printf("            Computation      Transpose     Transpose\n");
   printf(" Proc          Time            Time        Fraction\n");
-  printf("    0        %10d     %10d      %8.5f\n",
+  printf("    0        %10ld     %10ld      %8.5f\n",
          Global->totaltimes[0],Global->transtimes[0],
          ((double)Global->transtimes[0])/Global->totaltimes[0]);
   if (dostats) {
@@ -363,7 +367,7 @@
       if (((double)Global->transtimes[i])/Global->totaltimes[i] < minfrac) {
         minfrac = ((double)Global->transtimes[i])/Global->totaltimes[i];
       }
-      printf("  %3d        %10d     %10d      %8.5f\n",
+      printf("  %3ld        %10ld     %10ld      %8.5f\n",
              i,Global->totaltimes[i],Global->transtimes[i],
              ((double)Global->transtimes[i])/Global->totaltimes[i]);
       avgtranstime += Global->transtimes[i];
@@ -372,32 +376,32 @@
     }
     printf("  Avg        %10.0f     %10.0f      %8.5f\n",
            ((double) avgcomptime)/P,((double) avgtranstime)/P,avgfractime/P);
-    printf("  Max        %10d     %10d      %8.5f\n",
+    printf("  Max        %10ld     %10ld      %8.5f\n",
 	   maxtotal,transtime,maxfrac);
-    printf("  Min        %10d     %10d      %8.5f\n",
+    printf("  Min        %10ld     %10ld      %8.5f\n",
 	   mintotal,transtime2,minfrac);
   }
   Global->starttime = start;
   printf("\n");
   printf("                 TIMING INFORMATION\n");
-  printf("Start time                        : %16d\n",
+  printf("Start time                        : %16lu\n",
 	  Global->starttime);
-  printf("Initialization finish time        : %16d\n",
+  printf("Initialization finish time        : %16lu\n",
 	  Global->initdonetime);
-  printf("Overall finish time               : %16d\n",
+  printf("Overall finish time               : %16lu\n",
 	  Global->finishtime);
-  printf("Total time with initialization    : %16d\n",
+  printf("Total time with initialization    : %16lu\n",
 	  Global->finishtime-Global->starttime);
-  printf("Total time without initialization : %16d\n",
+  printf("Total time without initialization : %16lu\n",
 	  Global->finishtime-Global->initdonetime);
-  printf("Overall transpose time            : %16d\n",
+  printf("Overall transpose time            : %16ld\n",
          transtime);
   printf("Overall transpose fraction        : %16.5f\n",
          ((double) transtime)/(Global->finishtime-Global->initdonetime));
   printf("\n");
 
   if (test_result) {
-    ck3 = CheckSum(N, x);
+    ck3 = CheckSum(x);
     printf("              INVERSE FFT TEST RESULTS\n");
     printf("Checksum difference is %.3f (%.3f, %.3f)\n",
 	   ck1-ck3, ck1, ck3);
@@ -414,22 +418,22 @@
 
 void SlaveStart()
 {
-  int i;
-  int j;
-  int MyNum;
-  double error;
+  long i;
+  long MyNum;
   double *upriv;
-  int initdone; 
-  int finish; 
-  int l_transtime=0;
-  int MyFirst; 
-  int MyLast;
+  long initdone; 
+  long finish; 
+  long l_transtime=0;
+  long MyFirst; 
+  long MyLast;
 
   LOCK(Global->idlock);
     MyNum = Global->id;
     Global->id++;
   UNLOCK(Global->idlock); 
 
+  BARINCLUDE(Global->start);
+
 /* POSSIBLE ENHANCEMENT:  Here is where one might pin processes to
    processors to avoid migration */
 
@@ -437,7 +441,7 @@
 
   upriv = (double *) malloc(2*(rootN-1)*sizeof(double));  
   if (upriv == NULL) {
-    fprintf(stderr,"Proc %d could not malloc memory for upriv\n",MyNum);
+    fprintf(stderr,"Proc %ld could not malloc memory for upriv\n",MyNum);
     exit(-1);
   }
   for (i=0;i<2*(rootN-1);i++) {
@@ -447,7 +451,7 @@
   MyFirst = rootN*MyNum/P;
   MyLast = rootN*(MyNum+1)/P;
 
-  TouchArray(x, trans, umain2, upriv, N, MyNum, MyFirst, MyLast);
+  TouchArray(x, trans, umain2, upriv, MyFirst, MyLast);
 
   BARRIER(Global->start, P);
 
@@ -460,12 +464,12 @@
 
   /* perform forward FFT */
   FFT1D(1, M, N, x, trans, upriv, umain2, MyNum, &l_transtime, MyFirst, 
-	MyLast, pad_length, P, test_result, doprint, dostats, Global);
+	MyLast, pad_length, test_result, dostats);
 
   /* perform backward FFT */
   if (test_result) {
     FFT1D(-1, M, N, x, trans, upriv, umain2, MyNum, &l_transtime, MyFirst, 
-	  MyLast, pad_length, P, test_result, doprint, dostats, Global);
+	  MyLast, pad_length, test_result, dostats);
   }  
 
   if ((MyNum == 0) || (dostats)) {
@@ -480,19 +484,9 @@
 }
 
 
-double TouchArray(x, scratch, u, upriv, N, MyNum, MyFirst, MyLast)
-
-double *x; 
-double *scratch; 
-double *u; 
-double *upriv;
-int N; 
-int MyNum;
-int MyFirst;
-int MyLast;
-
+double TouchArray(double *x, double *scratch, double *u, double *upriv, long MyFirst, long MyLast)
 {
-  int i,j,k;
+  long i,j,k;
   double tot = 0.0;
 
   /* touch my data */
@@ -511,13 +505,9 @@
 }
 
 
-double CheckSum(N, x)
-
-int N;
-double *x;
-
+double CheckSum(double *x)
 {
-  int i,j,k;
+  long i,j,k;
   double cks;
 
   cks = 0.0;
@@ -532,13 +522,9 @@
 }
 
 
-InitX(N, x)
-
-int N;
-double *x;
-
+void InitX(double *x)
 {
-  int i,j,k;
+  long i,j,k;
 
   srand48(0);
   for (j=0; j<rootN; j++) {
@@ -551,16 +537,12 @@
 }
 
 
-InitU(N, u)
-
-int N;
-double *u;
-
+void InitU(long N, double *u)
 {
-  int q; 
-  int j; 
-  int base; 
-  int n1;
+  long q; 
+  long j; 
+  long base; 
+  long n1;
 
   for (q=0; 1<<q<N; q++) {  
     n1 = 1<<q;
@@ -576,15 +558,9 @@
 }
 
 
-InitU2(N, u, n1)
-
-int N;
-double *u;
-int n1;
-
+void InitU2(long N, double *u, long n1)
 {
-  int i,j,k; 
-  int base;
+  long i,j,k; 
 
   for (j=0; j<n1; j++) {  
     k = j*(rootN+pad_length);
@@ -596,15 +572,11 @@
 }
 
 
-BitReverse(M, k)
-
-int M; 
-int k;
-
+long BitReverse(long M, long k)
 {
-  int i; 
-  int j; 
-  int tmp;
+  long i; 
+  long j; 
+  long tmp;
 
   j = 0;
   tmp = k;
@@ -616,35 +588,14 @@
 }
 
 
-void FFT1D(direction, M, N, x, scratch, upriv, umain2, MyNum, l_transtime, 
-           MyFirst, MyLast, pad_length, P, test_result, doprint, dostats, 
-	   Global)
-
-int direction; 
-int M; 
-int N; 
-int *l_transtime;
-double *x; 
-double *upriv; 
-double *scratch;
-double *umain2; 
-int MyFirst;
-int MyLast;
-int pad_length;
-int P;
-int test_result;
-int doprint;
-int dostats;
-struct GlobalMemory *Global;
-
-{
-  int i; 
-  int j;
-  int m1; 
-  int n1;
-  int flag = 0;
-  unsigned int clocktime1;
-  unsigned int clocktime2;
+void FFT1D(long direction, long M, long N, double *x, double *scratch, double *upriv, double *umain2,
+           long MyNum, long *l_transtime, long MyFirst, long MyLast, long pad_length, long test_result, long dostats)
+{
+  long j;
+  long m1; 
+  long n1;
+  unsigned long clocktime1;
+  unsigned long clocktime2;
 
   m1 = M/2;
   n1 = 1<<m1;
@@ -666,8 +617,7 @@
   /* do n1 1D FFTs on columns */
   for (j=MyFirst; j<MyLast; j++) {
     FFT1DOnce(direction, m1, n1, upriv, &scratch[2*j*(n1+pad_length)]);
-    TwiddleOneCol(direction, n1, N, j, umain2, &scratch[2*j*(n1+pad_length)],
-		  pad_length);
+    TwiddleOneCol(direction, n1, j, umain2, &scratch[2*j*(n1+pad_length)], pad_length);
   }  
 
   BARRIER(Global->start, P);
@@ -717,26 +667,13 @@
 }
 
 
-TwiddleOneCol(direction, n1, N, j, u, x, pad_length)
-
-int direction; 
-int n1;
-int N;
-int j;
-double *u;
-double *x;
-int pad_length;
-
+void TwiddleOneCol(long direction, long n1, long j, double *u, double *x, long pad_length)
 {
-  int i;
+  long i;
   double omega_r; 
   double omega_c; 
   double x_r; 
   double x_c;
-  double r1;
-  double c1;
-  double r2;
-  double c2;
 
   for (i=0; i<n1; i++) {
     omega_r = u[2*(j*(n1+pad_length)+i)];
@@ -749,14 +686,9 @@
 }
 
 
-Scale(n1, N, x)
-
-int n1; 
-int N;
-double *x;
-
+void Scale(long n1, long N, double *x)
 {
-  int i;
+  long i;
 
   for (i=0; i<n1; i++) {
     x[2*i] /= N;
@@ -765,31 +697,22 @@
 }
 
 
-Transpose(n1, src, dest, MyNum, MyFirst, MyLast, pad_length)
-
-int n1;
-double *src; 
-double *dest;
-int MyNum;
-int MyFirst;
-int MyLast;
-int pad_length;
-
-{
-  int i; 
-  int j; 
-  int k; 
-  int l; 
-  int m;
-  int blksize;
-  int numblks;
-  int firstfirst;
-  int h_off;
-  int v_off;
-  int v;
-  int h;
-  int n1p;
-  int row_count;
+void Transpose(long n1, double *src, double *dest, long MyNum, long MyFirst, long MyLast, long pad_length)
+{
+  long i; 
+  long j; 
+  long k; 
+  long l; 
+  long m;
+  long blksize;
+  long numblks;
+  long firstfirst;
+  long h_off;
+  long v_off;
+  long v;
+  long h;
+  long n1p;
+  long row_count;
 
   blksize = MyLast-MyFirst;
   numblks = (2*blksize)/num_cache_lines;
@@ -857,14 +780,9 @@
 }
 
 
-CopyColumn(n1, src, dest)
-
-int n1;
-double *src; 
-double *dest;
-
+void CopyColumn(long n1, double *src, double *dest)
 {
-  int i;
+  long i;
 
   for (i=0; i<n1; i++) {
     dest[2*i] = src[2*i];
@@ -873,40 +791,28 @@
 }
 
 
-Reverse(N, M, x)
-
-int N; 
-int M;
-double *x;
-
+void Reverse(long N, long M, double *x)
 {
-  int j, k;
+  long j, k;
 
   for (k=0; k<N; k++) {
     j = BitReverse(M, k);
     if (j > k) {
-      SWAP(x[2*j], x[2*k]);
-      SWAP(x[2*j+1], x[2*k+1]);
+      SWAP_VALS(x[2*j], x[2*k]);
+      SWAP_VALS(x[2*j+1], x[2*k+1]);
     }
   }
 }
 
 
-FFT1DOnce(direction, M, N, u, x)
-
-int direction; 
-int M; 
-int N;
-double *u; 
-double *x;
-
+void FFT1DOnce(long direction, long M, long N, double *u, double *x)
 {
-  int j; 
-  int k; 
-  int q; 
-  int L; 
-  int r; 
-  int Lstar;
+  long j; 
+  long k; 
+  long q; 
+  long L; 
+  long r; 
+  long Lstar;
   double *u1; 
   double *x1; 
   double *x2;
@@ -944,13 +850,9 @@
 }
 
 
-PrintArray(N, x)
-
-int N;
-double *x;
-
+void PrintArray(long N, double *x)
 {
-  int i, j, k;
+  long i, j, k;
 
   for (i=0; i<rootN; i++) {
     k = i*(rootN+pad_length);
@@ -969,23 +871,15 @@
 }
 
 
-void printerr(s)
-
-char *s;
-
+void printerr(char *s)
 {
   fprintf(stderr,"ERROR: %s\n",s);
 }
 
 
-int log_2(number)
-
-int number;
-
+long log_2(long number)
 {
-  int cumulative = 1;
-  int out = 0;
-  int done = 0;
+  long cumulative = 1, out = 0, done = 0;
 
   while ((cumulative < number) && (!done) && (out < 50)) {
     if (cumulative == number) {
diff -Naur splash2/codes/kernels/fft/makefile splash2-modified/codes/kernels/fft/makefile
--- splash2/codes/kernels/fft/makefile	1994-10-11 23:30:37.000000000 -0400
+++ splash2-modified/codes/kernels/fft/makefile	1969-12-31 19:00:00.000000000 -0500
@@ -1,27 +0,0 @@
-TARGET = FFT
-OBJS = fft.o
-CFLAGS = -O2 -Olimit 2000 -w 
-LDFLAGS = -lmpc -lm
-MACROS = ../../null_macros/c.m4.null
-
-x = *
-
-$(TARGET): $(OBJS)
-	cc $(OBJS) $(CFLAGS) -o $(TARGET) $(LDFLAGS)
-
-.SUFFIXES:
-.SUFFIXES:	.o .c .C .h .H
-
-.H.h:
-	m4 ${MACROS} $*.H > $*.h
-
-.C.c:
-	m4 $(MACROS) $*.C > $*.c
-
-.c.o:
-	cc -c $(CFLAGS) $*.c
-
-.C.o:
-	m4 $(MACROS) $*.C > $*.c
-	cc -c $(CFLAGS) $*.c
-
diff -Naur splash2/codes/kernels/fft/Makefile splash2-modified/codes/kernels/fft/Makefile
--- splash2/codes/kernels/fft/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ splash2-modified/codes/kernels/fft/Makefile	2006-09-13 15:57:51.000000000 -0400
@@ -0,0 +1,5 @@
+TARGET = FFT
+OBJS = fft.o
+
+include ../../Makefile.config
+
diff -Naur splash2/codes/kernels/lu/contiguous_blocks/lu.C splash2-modified/codes/kernels/lu/contiguous_blocks/lu.C
--- splash2/codes/kernels/lu/contiguous_blocks/lu.C	1995-09-26 18:30:34.000000000 -0400
+++ splash2-modified/codes/kernels/lu/contiguous_blocks/lu.C	2007-06-21 17:10:29.000000000 -0400
@@ -49,6 +49,8 @@
 #define DEFAULT_P                           1
 #define DEFAULT_B                          16
 #define min(a,b) ((a) < (b) ? (a) : (b))
+//#define PAGE_SIZE                       4096
+#define PAGE_SIZE			1024
 
 struct GlobalMemory {
   double *t_in_fac;   
@@ -56,11 +58,11 @@
   double *t_in_mod; 
   double *t_in_bar;
   double *completion;
-  unsigned int starttime; 
-  unsigned int rf; 
-  unsigned int rs; 
-  unsigned int done;
-  int id;
+  unsigned long starttime; 
+  unsigned long rf; 
+  unsigned long rs; 
+  unsigned long done;
+  long id;
   BARDEC(start)
   LOCKDEC(idlock)
 } *Global;
@@ -72,57 +74,51 @@
   double t_in_bar;
 };
 
-int n = DEFAULT_N;          /* The size of the matrix */
-int P = DEFAULT_P;          /* Number of processors */
-int block_size = DEFAULT_B; /* Block dimension */
-int nblocks;                /* Number of blocks in each dimension */
-int num_rows;               /* Number of processors per row of processor grid */
-int num_cols;               /* Number of processors per col of processor grid */
-double **a;                 /* a = lu; l and u both placed back in a */
+long n = DEFAULT_N;          /* The size of the matrix */
+long P = DEFAULT_P;          /* Number of processors */
+long block_size = DEFAULT_B; /* Block dimension */
+long nblocks;                /* Number of blocks in each dimension */
+long num_rows;               /* Number of processors per row of processor grid */
+long num_cols;               /* Number of processors per col of processor grid */
+double **a;                  /* a = lu; l and u both placed back in a */
 double *rhs;
-int *proc_bytes;            /* Bytes to malloc per processor to hold blocks 
-			       of A*/
-double **last_malloc;       /* Starting point of last block of A */
-
-int test_result = 0;        /* Test result of factorization? */
-int doprint = 0;            /* Print out matrix values? */
-int dostats = 0;            /* Print out individual processor statistics? */
-
-void SlaveStart();
-void OneSolve(int, int, double **, int, int);
-void lu0(double *,int, int);
-void bdiv(double *, double *, int, int, int, int);
-void bmodd(double *, double*, int, int, int, int);
-void bmod(double *, double *, double *, int, int, int, int, int, int);
-void daxpy(double *, double *, int, double);
-int BlockOwner(int, int);
-void lu(int, int, int, struct LocalCopies *, int);
-void InitA(double *);
-double TouchA(int, int);
-void PrintA();
-void CheckResult(int, double **, double *);
-void printerr(char *);
+long *proc_bytes;            /* Bytes to malloc per processor to hold blocks of A*/
+double **last_malloc;        /* Starting point of last block of A */
 
+long test_result = 0;        /* Test result of factorization? */
+long doprint = 0;            /* Print out matrix values? */
+long dostats = 0;            /* Print out individual processor statistics? */
+
+void SlaveStart(void);
+void OneSolve(long n, long block_size, long MyNum, long dostats);
+void lu0(double *a, long n, long stride);
+void bdiv(double *a, double *diag, long stride_a, long stride_diag, long dimi, long dimk);
+void bmodd(double *a, double *c, long dimi, long dimj, long stride_a, long stride_c);
+void bmod(double *a, double *b, double *c, long dimi, long dimj, long dimk, long stridea, long strideb, long stridec);
+void daxpy(double *a, double *b, long n, double alpha);
+long BlockOwner(long I, long J);
+long BlockOwnerColumn(long I, long J);
+long BlockOwnerRow(long I, long J);
+void lu(long n, long bs, long MyNum, struct LocalCopies *lc, long dostats);
+void InitA(double *rhs);
+double TouchA(long bs, long MyNum);
+void PrintA(void);
+void CheckResult(long n, double **a, double *rhs);
+void printerr(char *s);
 
-main(argc, argv)
-
-int argc;
-char *argv[];
-
+int main(int argc, char *argv[])
 {
-  int i, j;
-  int ch;
+  long i, j;
+  long ch;
   extern char *optarg;
-  int MyNum=0;
   double mint, maxt, avgt;
   double min_fac, min_solve, min_mod, min_bar;
   double max_fac, max_solve, max_mod, max_bar;
   double avg_fac, avg_solve, avg_mod, avg_bar;
-  int last_page;
-  int proc_num;
-  int edge;
-  int size;
-  unsigned int start;
+  long proc_num;
+  long edge;
+  long size;
+  unsigned long start;
 
   CLOCK(start)
 
@@ -156,13 +152,13 @@
 
   printf("\n");
   printf("Blocked Dense LU Factorization\n");
-  printf("     %d by %d Matrix\n",n,n);
-  printf("     %d Processors\n",P);
-  printf("     %d by %d Element Blocks\n",block_size,block_size);
+  printf("     %ld by %ld Matrix\n",n,n);
+  printf("     %ld Processors\n",P);
+  printf("     %ld by %ld Element Blocks\n",block_size,block_size);
   printf("\n");
   printf("\n");
 
-  num_rows = (int) sqrt((double) P);
+  num_rows = (long) sqrt((double) P);
   for (;;) {
     num_cols = P/num_rows;
     if (num_rows*num_cols == P)
@@ -178,8 +174,17 @@
   if (edge == 0) {
     edge = block_size;
   }
-  proc_bytes = (int *) malloc(P*sizeof(int));
+
+  proc_bytes = (long *) malloc(P*sizeof(long));
+  if (proc_bytes == NULL) {
+	  fprintf(stderr,"Could not malloc memory for proc_bytes.\n");
+	  exit(-1);
+  }
   last_malloc = (double **) G_MALLOC(P*sizeof(double *));
+  if (last_malloc == NULL) {
+	  fprintf(stderr,"Could not malloc memory for last_malloc.\n");
+	  exit(-1);
+  }
   for (i=0;i<P;i++) {
     proc_bytes[i] = 0;
     last_malloc[i] = NULL;
@@ -200,11 +205,11 @@
   for (i=0;i<P;i++) {
     last_malloc[i] = (double *) G_MALLOC(proc_bytes[i] + PAGE_SIZE)
     if (last_malloc[i] == NULL) {
-      fprintf(stderr,"Could not malloc memory blocks for proc %d\n",i);
+      fprintf(stderr,"Could not malloc memory blocks for proc %ld\n",i);
       exit(-1);
     } 
-    last_malloc[i] = (double *) (((unsigned) last_malloc[i]) + PAGE_SIZE -
-                     ((unsigned) last_malloc[i]) % PAGE_SIZE);
+    last_malloc[i] = (double *) (((unsigned long) last_malloc[i]) + PAGE_SIZE -
+                     ((unsigned long) last_malloc[i]) % PAGE_SIZE);
 
 /* Note that this causes all blocks to start out page-aligned, and that
    for block sizes that exceed cache line size, blocks start at cache-line
@@ -287,12 +292,9 @@
    }
 */
 
-  BARINIT(Global->start);
+  BARINIT(Global->start, P);
   LOCKINIT(Global->idlock);
   Global->id = 0;
-  for (i=1; i<P; i++) {
-    CREATE(SlaveStart);
-  }
 
   InitA(rhs);
   if (doprint) {
@@ -300,9 +302,8 @@
     PrintA();
   }
 
-  SlaveStart(MyNum);
-
-  WAIT_FOR_END(P-1)
+  CREATE(SlaveStart, P);
+  WAIT_FOR_END(P);
 
   if (doprint) {
     printf("\nMatrix after decomposition:\n");
@@ -371,7 +372,7 @@
           Global->t_in_bar[0]);
   if (dostats) {
     for (i=1; i<P; i++) {
-      printf("  %3d    %10.0f    %10.0f    %10.0f    %10.0f    %10.0f\n",
+      printf("  %3ld    %10.0f    %10.0f    %10.0f    %10.0f    %10.0f\n",
               i,Global->completion[i],Global->t_in_fac[i],
 	      Global->t_in_solve[i],Global->t_in_mod[i],
 	      Global->t_in_bar[i]);
@@ -386,16 +387,11 @@
   printf("\n");
   Global->starttime = start;
   printf("                            TIMING INFORMATION\n");
-  printf("Start time                        : %16d\n",
-          Global->starttime);
-  printf("Initialization finish time        : %16d\n",
-          Global->rs);
-  printf("Overall finish time               : %16d\n",
-          Global->rf);
-  printf("Total time with initialization    : %16d\n",
-          Global->rf-Global->starttime);
-  printf("Total time without initialization : %16d\n",
-          Global->rf-Global->rs);
+  printf("Start time                        : %16lu\n", Global->starttime);
+  printf("Initialization finish time        : %16lu\n", Global->rs);
+  printf("Overall finish time               : %16lu\n", Global->rf);
+  printf("Total time with initialization    : %16lu\n", Global->rf-Global->starttime);
+  printf("Total time without initialization : %16lu\n", Global->rf-Global->rs);
   printf("\n");
 
   if (test_result) {
@@ -408,13 +404,8 @@
 
 
 void SlaveStart()
-
 {
-  int i; 
-  int j; 
-  int cluster; 
-  int max_block;
-  int MyNum;
+  long MyNum;
 
   LOCK(Global->idlock)
     MyNum = Global->id;
@@ -424,28 +415,21 @@
 /* POSSIBLE ENHANCEMENT:  Here is where one might pin processes to
    processors to avoid migration */
 
-  OneSolve(n, block_size, a, MyNum, dostats);
+  BARINCLUDE(Global->start);
+  OneSolve(n, block_size, MyNum, dostats);
 }
 
 
-void OneSolve(n, block_size, a, MyNum, dostats)
-
-double **a;
-int n;
-int block_size;
-int MyNum;
-int dostats;
-
+void OneSolve(long n, long block_size, long MyNum, long dostats)
 {
-  unsigned int i; 
-  unsigned int myrs; 
-  unsigned int myrf; 
-  unsigned int mydone;
+  unsigned long myrs; 
+  unsigned long myrf; 
+  unsigned long mydone;
   struct LocalCopies *lc;
 
   lc = (struct LocalCopies *) malloc(sizeof(struct LocalCopies));
   if (lc == NULL) {
-    fprintf(stderr,"Proc %d could not malloc memory for lc\n",MyNum);
+    fprintf(stderr,"Proc %ld could not malloc memory for lc\n",MyNum);
     exit(-1);
   }
   lc->t_in_fac = 0.0;
@@ -492,16 +476,11 @@
 }
 
 
-void lu0(a, n, stride)
-
-double *a;
-int n; 
-int stride;
-
+void lu0(double *a, long n, long stride)
 {
-  int j; 
-  int k; 
-  int length;
+  long j; 
+  long k; 
+  long length;
   double alpha;
 
   for (k=0; k<n; k++) {
@@ -516,18 +495,10 @@
 }
 
 
-void bdiv(a, diag, stride_a, stride_diag, dimi, dimk)
-
-double *a; 
-double *diag;
-int stride_a; 
-int stride_diag; 
-int dimi; 
-int dimk;
-
+void bdiv(double *a, double *diag, long stride_a, long stride_diag, long dimi, long dimk)
 {
-  int j; 
-  int k;
+  long j; 
+  long k;
   double alpha;
 
   for (k=0; k<dimk; k++) {
@@ -539,20 +510,11 @@
 }
 
 
-void bmodd(a, c, dimi, dimj, stride_a, stride_c)
-
-double *a; 
-double *c;
-int dimi; 
-int dimj; 
-int stride_a; 
-int stride_c;
-
+void bmodd(double *a, double *c, long dimi, long dimj, long stride_a, long stride_c)
 {
-  int i; 
-  int j; 
-  int k; 
-  int length;
+  long j; 
+  long k; 
+  long length;
   double alpha;
 
   for (k=0; k<dimi; k++) {
@@ -566,22 +528,10 @@
 }
 
 
-void bmod(a, b, c, dimi, dimj, dimk, stridea, strideb, stridec)
-
-double *a; 
-double *b; 
-double *c;
-int dimi; 
-int dimj; 
-int dimk; 
-int stridea;
-int strideb;
-int stridec;
-
-{
-  int i; 
-  int j; 
-  int k;
+void bmod(double *a, double *b, double *c, long dimi, long dimj, long dimk, long stridea, long strideb, long stridec)
+{
+  long j; 
+  long k;
   double alpha;
 
   for (k=0; k<dimk; k++) {
@@ -593,15 +543,9 @@
 }
 
 
-void daxpy(a, b, n, alpha)
-
-double *a; 
-double *b; 
-double alpha;
-int n;
-
+void daxpy(double *a, double *b, long n, double alpha)
 {
-  int i;
+  long i;
 
   for (i=0; i<n; i++) {
     a[i] += alpha*b[i];
@@ -609,33 +553,29 @@
 }
 
 
-int BlockOwner(I, J)
-
-int I; 
-int J;
-
+long BlockOwner(long I, long J)
 {
-  return((J%num_cols) + (I%num_rows)*num_cols); 
+//	return((J%num_cols) + (I%num_rows)*num_cols); 
+	return((I + J) % P);
 }
 
+long BlockOwnerColumn(long I, long J)
+{
+	return(I % P);
+}
 
-void lu(n, bs, MyNum, lc, dostats)
-
-int n;
-int bs;
-int MyNum;
-struct LocalCopies *lc;
-int dostats;
+long BlockOwnerRow(long I, long J)
+{
+	return(((J % P) + (P / 2)) % P);
+}
 
+void lu(long n, long bs, long MyNum, struct LocalCopies *lc, long dostats)
 {
-  int i, il, j, jl, k, kl;
-  int I, J, K;
+  long i, il, j, jl, k, kl;
+  long I, J, K;
   double *A, *B, *C, *D;
-  int dimI, dimJ, dimK;
-  int strI, strJ, strK;
-  unsigned int t1, t2, t3, t4, t11, t22;
-  int diagowner;
-  int colowner;
+  long strI, strJ, strK;
+  unsigned long t1, t2, t3, t4, t11, t22;
 
   for (k=0, K=0; k<n; k+=bs, K++) {
     kl = k + bs; 
@@ -651,8 +591,7 @@
     }
 
     /* factor diagonal block */
-    diagowner = BlockOwner(K, K);
-    if (diagowner == MyNum) {
+    if (BlockOwner(K, K) == MyNum) {
       A = a[K+K*nblocks]; 
       lu0(A, strK, strK);
     }
@@ -670,7 +609,7 @@
     /* divide column k by diagonal block */
     D = a[K+K*nblocks];
     for (i=kl, I=K+1; i<n; i+=bs, I++) {
-      if (BlockOwner(I, K) == MyNum) {  /* parcel out blocks */
+      if (BlockOwnerColumn(I, K) == MyNum) {  /* parcel out blocks */
 	il = i + bs; 
 	if (il > n) {
 	  il = n;
@@ -684,7 +623,7 @@
     }
     /* modify row k by diagonal block */
     for (j=kl, J=K+1; j<n; j+=bs, J++) {
-      if (BlockOwner(K, J) == MyNum) {  /* parcel out blocks */
+      if (BlockOwnerRow(K, J) == MyNum) {  /* parcel out blocks */
 	jl = j+bs; 
 	if (jl > n) {
 	  jl = n;
@@ -716,7 +655,6 @@
       } else {
         strI = bs;
       }
-      colowner = BlockOwner(I,K);
       A = a[I+K*nblocks]; 
       for (j=kl, J=K+1; j<n; j+=bs, J++) {
 	jl = j + bs; 
@@ -745,16 +683,13 @@
 }
 
 
-void InitA(rhs)
-
-double *rhs;
-
+void InitA(double *rhs)
 {
-  int i, j;
-  int ii, jj;
-  int edge;
-  int ibs;
-  int jbs, skip;
+  long i, j;
+  long ii, jj;
+  long edge;
+  long ibs;
+  long jbs, skip;
 
   srand48((long) 1);
   edge = n%block_size;
@@ -810,16 +745,12 @@
 }
 
 
-double TouchA(bs, MyNum)
-
-int bs; 
-int MyNum;
-
+double TouchA(long bs, long MyNum)
 {
-  int i, j, I, J;
+  long i, j, I, J;
   double tot = 0.0;
-  int ibs;
-  int jbs;
+  long ibs;
+  long jbs;
 
   /* touch my portion of A[] */
 
@@ -855,12 +786,11 @@
 
 
 void PrintA()
-
 {
-  int i, j;
-  int ii, jj;
-  int edge;
-  int ibs, jbs, skip;
+  long i, j;
+  long ii, jj;
+  long edge;
+  long ibs, jbs, skip;
 
   edge = n%block_size;
   for (i=0; i<n; i++) {
@@ -889,18 +819,13 @@
 }
 
 
-void CheckResult(n, a, rhs)
-
-int n;
-double **a; 
-double *rhs;
-
+void CheckResult(long n, double **a, double *rhs)
 {
-  int i, j, bogus = 0;
+  long i, j, bogus = 0;
   double *y, diff, max_diff;
-  int ii, jj;
-  int edge;
-  int ibs, jbs, skip;
+  long ii, jj;
+  long edge;
+  long ibs, jbs, skip;
 
   edge = n%block_size;
   y = (double *) malloc(n*sizeof(double));  
@@ -979,10 +904,8 @@
 }
 
 
-void printerr(s)
-
-char *s;
-
+void printerr(char *s)
 {
   fprintf(stderr,"ERROR: %s\n",s);
 }
+
diff -Naur splash2/codes/kernels/lu/contiguous_blocks/makefile splash2-modified/codes/kernels/lu/contiguous_blocks/makefile
--- splash2/codes/kernels/lu/contiguous_blocks/makefile	1994-10-11 23:45:19.000000000 -0400
+++ splash2-modified/codes/kernels/lu/contiguous_blocks/makefile	1969-12-31 19:00:00.000000000 -0500
@@ -1,28 +0,0 @@
-TARGET = LU
-OBJS = lu.o
-CFLAGS = -O2 -Olimit 2000 -w
-LDFLAGS = -lmpc -lm
-MACROS = ../../../null_macros/c.m4.null
-
-
-x = *
-
-$(TARGET): $(OBJS)
-	cc $(OBJS) $(CFLAGS) -o $(TARGET) $(LDFLAGS)
-
-.SUFFIXES:
-.SUFFIXES:	.o .c .C .h .H
-
-.H.h:
-	m4 ${MACROS} $*.H > $*.h
-
-.C.c:
-	m4 $(MACROS) $*.C > $*.c
-
-.c.o:
-	cc -c $(CFLAGS) $*.c
-
-.C.o:
-	m4 $(MACROS) $*.C > $*.c
-	cc -c $(CFLAGS) $*.c
-
diff -Naur splash2/codes/kernels/lu/contiguous_blocks/Makefile splash2-modified/codes/kernels/lu/contiguous_blocks/Makefile
--- splash2/codes/kernels/lu/contiguous_blocks/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ splash2-modified/codes/kernels/lu/contiguous_blocks/Makefile	2006-09-16 21:32:53.000000000 -0400
@@ -0,0 +1,5 @@
+TARGET = LU
+OBJS = lu.o
+
+include ../../../Makefile.config
+
diff -Naur splash2/codes/kernels/lu/non_contiguous_blocks/lu.C splash2-modified/codes/kernels/lu/non_contiguous_blocks/lu.C
--- splash2/codes/kernels/lu/non_contiguous_blocks/lu.C	1994-10-11 23:40:51.000000000 -0400
+++ splash2-modified/codes/kernels/lu/non_contiguous_blocks/lu.C	2007-06-21 17:11:13.000000000 -0400
@@ -41,11 +41,12 @@
 #include <stdlib.h>
 MAIN_ENV
 
-#define MAXRAND                         32767.0
-#define DEFAULT_N                         128
-#define DEFAULT_P                           1
-#define DEFAULT_B                          16
+#define MAXRAND					32767.0
+#define DEFAULT_N				128
+#define DEFAULT_P				1
+#define DEFAULT_B				16
 #define min(a,b) ((a) < (b) ? (a) : (b))
+#define PAGE_SIZE				4096
 
 struct GlobalMemory {
   double *t_in_fac;
@@ -53,11 +54,11 @@
   double *t_in_mod;
   double *t_in_bar;
   double *completion;
-  unsigned int starttime;
-  unsigned int rf;
-  unsigned int rs;
-  unsigned int done;
-  int id;
+  unsigned long starttime;
+  unsigned long rf;
+  unsigned long rs;
+  unsigned long done;
+  long id;
   BARDEC(start)
   LOCKDEC(idlock)
 } *Global;
@@ -69,52 +70,45 @@
   double t_in_bar;
 };
 
-int n = DEFAULT_N;          /* The size of the matrix */
-int P = DEFAULT_P;          /* Number of processors */
-int block_size = DEFAULT_B; /* Block dimension */
-int nblocks;                /* Number of blocks in each dimension */
-int num_rows;               /* Number of processors per row of processor grid */
-int num_cols;               /* Number of processors per col of processor grid */
-double *a;                  /* a = lu; l and u both placed back in a */
+long n = DEFAULT_N;          /* The size of the matrix */
+long P = DEFAULT_P;          /* Number of processors */
+long block_size = DEFAULT_B; /* Block dimension */
+long nblocks;                /* Number of blocks in each dimension */
+long num_rows;               /* Number of processors per row of processor grid */
+long num_cols;               /* Number of processors per col of processor grid */
+double *a;                   /* a = lu; l and u both placed back in a */
 double *rhs;
-int *proc_bytes;            /* Bytes to malloc per processor to hold blocks
-                               of A*/
-int test_result = 0;        /* Test result of factorization? */
-int doprint = 0;            /* Print out matrix values? */
-int dostats = 0;            /* Print out individual processor statistics? */
-
-void SlaveStart();
-void OneSolve(int, int, double *, int, int);
-void lu0(double *,int, int);
-void bdiv(double *, double *, int, int, int, int);
-void bmodd(double *, double*, int, int, int, int);
-void bmod(double *, double *, double *, int, int, int, int);
-void daxpy(double *, double *, int, double);
-int BlockOwner(int, int);
-void lu(int, int, int, struct LocalCopies *, int);
-void InitA(double *);
-double TouchA(int, int);
-void PrintA();
-void CheckResult(int, double *, double *);
-void printerr(char *);
-
-
-main(argc, argv)
-
-int argc;
-char *argv[];
+long *proc_bytes;            /* Bytes to malloc per processor to hold blocks of A*/
+long test_result = 0;        /* Test result of factorization? */
+long doprint = 0;            /* Print out matrix values? */
+long dostats = 0;            /* Print out individual processor statistics? */
+
+void SlaveStart(void);
+void OneSolve(long n, long block_size, long MyNum, long dostats);
+void lu0(double *a, long n, long stride);
+void bdiv(double *a, double *diag, long stride_a, long stride_diag, long dimi, long dimk);
+void bmodd(double *a, double *c, long dimi, long dimj, long stride_a, long stride_c);
+void bmod(double *a, double *b, double *c, long dimi, long dimj, long dimk, long stride);
+void daxpy(double *a, double *b, long n, double alpha);
+long BlockOwner(long I, long J);
+long BlockOwnerColumn(long I, long J);
+long BlockOwnerRow(long I, long J);
+void lu(long n, long bs, long MyNum, struct LocalCopies *lc, long dostats);
+void InitA(double *rhs);
+double TouchA(long bs, long MyNum);
+void PrintA(void);
+void CheckResult(long n, double *a, double *rhs);
+void printerr(char *s);
 
+int main(int argc, char *argv[])
 {
-  int i, j;
-  int ch;
+  long i, ch;
   extern char *optarg;
-  int MyNum=0;
   double mint, maxt, avgt;
   double min_fac, min_solve, min_mod, min_bar;
   double max_fac, max_solve, max_mod, max_bar;
   double avg_fac, avg_solve, avg_mod, avg_bar;
-  int proc_num;
-  unsigned int start;
+  unsigned long start;
 
   CLOCK(start);
 
@@ -148,13 +142,13 @@
 
   printf("\n");
   printf("Blocked Dense LU Factorization\n");
-  printf("     %d by %d Matrix\n",n,n);
-  printf("     %d Processors\n",P);
-  printf("     %d by %d Element Blocks\n",block_size,block_size);
+  printf("     %ld by %ld Matrix\n",n,n);
+  printf("     %ld Processors\n",P);
+  printf("     %ld by %ld Element Blocks\n",block_size,block_size);
   printf("\n");
   printf("\n");
 
-  num_rows = (int) sqrt((double) P);
+  num_rows = (long) sqrt((double) P);
   for (;;) {
     num_cols = P/num_rows;
     if (num_rows*num_cols == P)
@@ -167,7 +161,15 @@
   }
 
   a = (double *) G_MALLOC(n*n*sizeof(double));
+  if (a == NULL) {
+	  printerr("Could not malloc memory for a.\n");
+	  exit(-1);
+  }
   rhs = (double *) G_MALLOC(n*sizeof(double));
+  if (rhs == NULL) {
+	  printerr("Could not malloc memory for rhs.\n");
+	  exit(-1);
+  }
 
   Global = (struct GlobalMemory *) G_MALLOC(sizeof(struct GlobalMemory));
   Global->t_in_fac = (double *) G_MALLOC(P*sizeof(double));
@@ -200,24 +202,18 @@
    matrix data across physically distributed memories in a 
    round-robin fashion as desired. */
 
-  BARINIT(Global->start);
+  BARINIT(Global->start, P);
   LOCKINIT(Global->idlock);
   Global->id = 0;
 
-  for (i=1; i<P; i++) {
-    CREATE(SlaveStart)
-  }
-
   InitA(rhs);
   if (doprint) {
     printf("Matrix before decomposition:\n");
     PrintA();
   }
 
-
-  SlaveStart(MyNum);
-
-  WAIT_FOR_END(P-1)
+  CREATE(SlaveStart, P);
+  WAIT_FOR_END(P);
 
   if (doprint) {
     printf("\nMatrix after decomposition:\n");
@@ -286,7 +282,7 @@
           Global->t_in_bar[0]);
   if (dostats) {
     for (i=1; i<P; i++) {
-      printf("  %3d    %10.0f    %10.0f    %10.0f    %10.0f    %10.0f\n",
+      printf("  %3ld    %10.0f    %10.0f    %10.0f    %10.0f    %10.0f\n",
               i,Global->completion[i],Global->t_in_fac[i],
               Global->t_in_solve[i],Global->t_in_mod[i],
               Global->t_in_bar[i]);
@@ -301,16 +297,11 @@
   printf("\n");
   Global->starttime = start;
   printf("                            TIMING INFORMATION\n");
-  printf("Start time                        : %16d\n",
-          Global->starttime);
-  printf("Initialization finish time        : %16d\n",
-          Global->rs);
-  printf("Overall finish time               : %16d\n",
-          Global->rf);
-  printf("Total time with initialization    : %16d\n",
-          Global->rf-Global->starttime);
-  printf("Total time without initialization : %16d\n",
-          Global->rf-Global->rs);
+  printf("Start time                        : %16lu\n", Global->starttime);
+  printf("Initialization finish time        : %16lu\n", Global->rs);
+  printf("Overall finish time               : %16lu\n", Global->rf);
+  printf("Total time with initialization    : %16lu\n", Global->rf-Global->starttime);
+  printf("Total time without initialization : %16lu\n", Global->rf-Global->rs);
   printf("\n");
 
   if (test_result) {
@@ -322,13 +313,8 @@
 }
 
 void SlaveStart()
-
 {
-  int i;
-  int j;
-  int cluster;
-  int max_block;
-  int MyNum;
+  long MyNum;
 
   LOCK(Global->idlock)
     MyNum = Global->id;
@@ -338,28 +324,19 @@
 /* POSSIBLE ENHANCEMENT:  Here is where one might pin processes to
    processors to avoid migration */
 
-  OneSolve(n, block_size, a, MyNum, dostats);
+  BARINCLUDE(Global->start);
+  OneSolve(n, block_size, MyNum, dostats);
 }
 
 
-void OneSolve(n, block_size, a, MyNum, dostats)
-
-double *a;
-int n;
-int block_size;
-int MyNum;
-int dostats;
-
+void OneSolve(long n, long block_size, long MyNum, long dostats)
 {
-  unsigned int i;
-  unsigned int myrs;
-  unsigned int myrf;
-  unsigned int mydone;
+  unsigned long myrs, myrf, mydone;
   struct LocalCopies *lc;
 
   lc = (struct LocalCopies *) malloc(sizeof(struct LocalCopies));
   if (lc == NULL) {
-    fprintf(stderr,"Proc %d could not malloc memory for lc\n",MyNum);
+    fprintf(stderr,"Proc %ld could not malloc memory for lc\n",MyNum);
     exit(-1);
   }
   lc->t_in_fac = 0.0;
@@ -406,16 +383,9 @@
 }
 
 
-void lu0(a, n, stride)
-
-double *a;
-int n;
-int stride;
-
+void lu0(double *a, long n, long stride)
 {
-  int j; 
-  int k;
-  int length;
+  long j, k, length;
   double alpha;
 
   for (k=0; k<n; k++) {
@@ -430,18 +400,9 @@
 }
 
 
-void bdiv(a, diag, stride_a, stride_diag, dimi, dimk)
-
-double *a;
-double *diag;
-int stride_a;
-int stride_diag;
-int dimi;
-int dimk;
-
+void bdiv(double *a, double *diag, long stride_a, long stride_diag, long dimi, long dimk)
 {
-  int j;
-  int k;
+  long j, k;
   double alpha;
 
   for (k=0; k<dimk; k++) {
@@ -453,20 +414,9 @@
 }
 
 
-void bmodd(a, c, dimi, dimj, stride_a, stride_c)
-
-double *a;
-double *c;
-int dimi;
-int dimj;
-int stride_a;
-int stride_c;
-
+void bmodd(double *a, double *c, long dimi, long dimj, long stride_a, long stride_c)
 {
-  int i;
-  int j;
-  int k;
-  int length;
+  long j, k, length;
   double alpha;
 
   for (k=0; k<dimi; k++)
@@ -479,20 +429,9 @@
 }
 
 
-void bmod(a, b, c, dimi, dimj, dimk, stride)
-
-double *a;
-double *b;
-double *c;
-int dimi;
-int dimj;
-int dimk;
-int stride;
-
+void bmod(double *a, double *b, double *c, long dimi, long dimj, long dimk, long stride)
 {
-  int i;
-  int j;
-  int k;
+  long j, k;
   double alpha;
 
   for (k=0; k<dimk; k++) {
@@ -504,15 +443,9 @@
 }
 
 
-void daxpy(a, b, n, alpha)
-
-double *a;
-double *b;
-double alpha;
-int n;
-
+void daxpy(double *a, double *b, long n, double alpha)
 {
-  int i;
+  long i;
 
   for (i=0; i<n; i++) {
     a[i] += alpha*b[i];
@@ -520,33 +453,28 @@
 }
 
 
-int BlockOwner(I, J)
-
-int I;
-int J;
-
+long BlockOwner(long I, long J)
 {
-  return((I%num_cols) + (J%num_rows)*num_cols);
+//	return((I%num_cols) + (J%num_rows)*num_cols);
+	return((I + J) % P);
 }
 
+long BlockOwnerColumn(long I, long J)
+{
+	return(I % P);
+}
 
-void lu(n, bs, MyNum, lc, dostats)
-
-int n;
-int bs;
-int MyNum;
-struct LocalCopies *lc;
-int dostats;
+long BlockOwnerRow(long I, long J)
+{
+	return(((J % P) + (P / 2)) % P);
+}
 
+void lu(long n, long bs, long MyNum, struct LocalCopies *lc, long dostats)
 {
-  int i, il, j, jl, k, kl;
-  int I, J, K;
+  long i, il, j, jl, k, kl, I, J, K;
   double *A, *B, *C, *D;
-  int dimI, dimJ, dimK;
-  int strI;
-  unsigned int t1, t2, t3, t4, t11, t22;
-  int diagowner;
-  int colowner;
+  long strI;
+  unsigned long t1, t2, t3, t4, t11, t22;
 
   strI = n;
   for (k=0, K=0; k<n; k+=bs, K++) {
@@ -560,8 +488,7 @@
     }
 
     /* factor diagonal block */
-    diagowner = BlockOwner(K, K);
-    if (diagowner == MyNum) {
+    if (BlockOwner(K, K) == MyNum) {
       A = &(a[k+k*n]); 
       lu0(A, kl-k, strI);
     }
@@ -579,7 +506,8 @@
     /* divide column k by diagonal block */
     D = &(a[k+k*n]);
     for (i=kl, I=K+1; i<n; i+=bs, I++) {
-      if (BlockOwner(I, K) == MyNum) {  /* parcel out blocks */
+      if (BlockOwner/*Column*/(I, K) == MyNum) {  /* parcel out blocks */
+	      /*if (K == 0) printf("C%lx\n", BlockOwnerColumn(I, K));*/
         il = i + bs;
         if (il > n) {
           il = n;
@@ -590,7 +518,8 @@
     }
     /* modify row k by diagonal block */
     for (j=kl, J=K+1; j<n; j+=bs, J++) {
-      if (BlockOwner(K, J) == MyNum) {  /* parcel out blocks */
+      if (BlockOwner/*Row*/(K, J) == MyNum) {  /* parcel out blocks */
+	      /*if (K == 0) printf("R%lx\n", BlockOwnerRow(K, J));*/
         jl = j+bs;
         if (jl > n) {
           jl = n;
@@ -616,7 +545,6 @@
       if (il > n) {
         il = n;
       }
-      colowner = BlockOwner(I,K);
       A = &(a[i+k*n]);
       for (j=kl, J=K+1; j<n; j+=bs, J++) {
         jl = j + bs;
@@ -624,6 +552,7 @@
           jl = n;
         }
         if (BlockOwner(I, J) == MyNum) {  /* parcel out blocks */
+//		if (K == 0) printf("%lx\n", BlockOwner(I, J));
           B = &(a[k+j*n]);
           C = &(a[i+j*n]);
           bmod(A, B, C, il-i, jl-j, kl-k, n);
@@ -641,12 +570,9 @@
 }
 
 
-void InitA(rhs)
-
-double *rhs;
-
+void InitA(double *rhs)
 {
-  int i, j;
+  long i, j;
 
   srand48((long) 1);
   for (j=0; j<n; j++) {
@@ -669,13 +595,9 @@
 }
 
 
-double TouchA(bs, MyNum)
-
-int bs;
-int MyNum;
-
+double TouchA(long bs, long MyNum)
 {
-  int i, j, I, J;
+  long i, j, I, J;
   double tot = 0.0;
 
   for (J=0; J*bs<n; J++) {
@@ -695,7 +617,7 @@
 
 void PrintA()
 {
-  int i, j;
+  long i, j;
 
   for (i=0; i<n; i++) {
     for (j=0; j<n; j++) {
@@ -706,14 +628,9 @@
 }
 
 
-void CheckResult(n, a, rhs)
-
-int n;
-double *a;
-double  *rhs;
-
+void CheckResult(long n, double *a, double *rhs)
 {
-  int i, j, bogus = 0;
+  long i, j, bogus = 0;
   double *y, diff, max_diff;
 
   y = (double *) malloc(n*sizeof(double));
@@ -754,10 +671,8 @@
 }
 
 
-void printerr(s)
-
-char *s;
-
+void printerr(char *s)
 {
   fprintf(stderr,"ERROR: %s\n",s);
 }
+
diff -Naur splash2/codes/kernels/lu/non_contiguous_blocks/makefile splash2-modified/codes/kernels/lu/non_contiguous_blocks/makefile
--- splash2/codes/kernels/lu/non_contiguous_blocks/makefile	1994-10-11 23:47:57.000000000 -0400
+++ splash2-modified/codes/kernels/lu/non_contiguous_blocks/makefile	1969-12-31 19:00:00.000000000 -0500
@@ -1,28 +0,0 @@
-TARGET = LU
-OBJS = lu.o
-CFLAGS = -O2 -Olimit 2000 -w
-LDFLAGS = -lmpc -lm
-MACROS = ../../../null_macros/c.m4.null
-
-
-x = *
-
-$(TARGET): $(OBJS)
-	cc $(OBJS) $(CFLAGS) -o $(TARGET) $(LDFLAGS)
-
-.SUFFIXES:
-.SUFFIXES:	.o .c .C .h .H
-
-.H.h:
-	m4 ${MACROS} $*.H > $*.h
-
-.C.c:
-	m4 $(MACROS) $*.C > $*.c
-
-.c.o:
-	cc -c $(CFLAGS) $*.c
-
-.C.o:
-	m4 $(MACROS) $*.C > $*.c
-	cc -c $(CFLAGS) $*.c
-
diff -Naur splash2/codes/kernels/lu/non_contiguous_blocks/Makefile splash2-modified/codes/kernels/lu/non_contiguous_blocks/Makefile
--- splash2/codes/kernels/lu/non_contiguous_blocks/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ splash2-modified/codes/kernels/lu/non_contiguous_blocks/Makefile	2007-03-07 20:44:18.000000000 -0500
@@ -0,0 +1,5 @@
+TARGET = LU
+OBJS = lu.o
+
+include ../../../Makefile.config
+
diff -Naur splash2/codes/kernels/radix/makefile splash2-modified/codes/kernels/radix/makefile
--- splash2/codes/kernels/radix/makefile	1994-10-17 20:35:12.000000000 -0400
+++ splash2-modified/codes/kernels/radix/makefile	1969-12-31 19:00:00.000000000 -0500
@@ -1,27 +0,0 @@
-TARGET = RADIX
-OBJS = radix.o
-CFLAGS = -O2 -Olimit 2000 -w 
-LDFLAGS = -lmpc -lm
-MACROS = ../../null_macros/c.m4.null
-
-x = *
-
-$(TARGET): $(OBJS)
-	cc $(OBJS) $(CFLAGS) -o $(TARGET) $(LDFLAGS)
-
-.SUFFIXES:
-.SUFFIXES:	.o .c .C .h .H
-
-.H.h:
-	m4 ${MACROS} $*.H > $*.h
-
-.C.c:
-	m4 $(MACROS) $*.C > $*.c
-
-.c.o:
-	cc -c $(CFLAGS) $*.c
-
-.C.o:
-	m4 $(MACROS) $*.C > $*.c
-	cc -c $(CFLAGS) $*.c
-
diff -Naur splash2/codes/kernels/radix/Makefile splash2-modified/codes/kernels/radix/Makefile
--- splash2/codes/kernels/radix/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ splash2-modified/codes/kernels/radix/Makefile	2006-09-13 15:59:59.000000000 -0400
@@ -0,0 +1,5 @@
+TARGET = RADIX
+OBJS = radix.o
+
+include ../../Makefile.config
+
diff -Naur splash2/codes/kernels/radix/radix.C splash2-modified/codes/kernels/radix/radix.C
--- splash2/codes/kernels/radix/radix.C	1995-07-31 02:48:41.000000000 -0400
+++ splash2-modified/codes/kernels/radix/radix.C	2007-06-19 15:54:42.000000000 -0400
@@ -38,6 +38,7 @@
 
 #include <stdio.h>
 #include <math.h>
+#include <unistd.h>
 
 #define DEFAULT_P                    1
 #define DEFAULT_N               262144
@@ -55,95 +56,79 @@
 MAIN_ENV
 
 struct prefix_node {
-   int densities[MAX_RADIX];
-   int ranks[MAX_RADIX];
+   long densities[MAX_RADIX];
+   long ranks[MAX_RADIX];
    PAUSEDEC(done)
    char pad[PAGE_SIZE];
 };
 
 struct global_memory {
-   int Index;                             /* process ID */
+   long Index;                             /* process ID */
    LOCKDEC(lock_Index)                    /* for fetch and add to get ID */
    LOCKDEC(rank_lock)                     /* for fetch and add to get ID */
-   ALOCKDEC(section_lock,MAX_PROCESSORS)  /* key locks */
+/*   ALOCKDEC(section_lock,MAX_PROCESSORS)*/  /* key locks */
    BARDEC(barrier_rank)                   /* for ranking process */
    BARDEC(barrier_key)                    /* for key sorting process */
    double *ranktime;
    double *sorttime;
    double *totaltime;
-   int final;
-   unsigned int starttime;
-   unsigned int rs;
-   unsigned int rf;
+   long final;
+   unsigned long starttime;
+   unsigned long rs;
+   unsigned long rf;
    struct prefix_node prefix_tree[2 * MAX_PROCESSORS];
 } *global;
 
 struct global_private {
   char pad[PAGE_SIZE];
-  int *rank_ff;         /* overall processor ranks */
+  long *rank_ff;         /* overall processor ranks */
 } gp[MAX_PROCESSORS];
 
-int *key[2];            /* sort from one index into the other */
-int **rank_me;          /* individual processor ranks */
-int *key_partition;     /* keys a processor works on */
-int *rank_partition;    /* ranks a processor works on */
-
-int number_of_processors = DEFAULT_P;
-int max_num_digits;
-int radix = DEFAULT_R;
-int num_keys = DEFAULT_N;
-int max_key = DEFAULT_M;
-int log2_radix;
-int log2_keys;
-int dostats = 0;
-int test_result = 0;
-int doprint = 0;
-
-double ran_num_init(unsigned int,double,double);
-double product_mod_46(double,double);
-int get_max_digits(int);
-int get_log2_radix(int);
-int get_log2_keys(int);
-void slave_sort();
-int log_2(int);
-void printerr(char *);
-void init(int,int,int);
-void test_sort(int);
-void printout();
-
-
-main(argc, argv)
-
-int argc;
-char *argv;
-
-{
-   int i;
-   int p;
-   int quotient;
-   int remainder;
-   int sum_i; 
-   int sum_f;
-   int mistake=0;
-   int size;
-   int **temp;
-   int **temp2;
-   int *a;
-   int c;
-   int n1;
-   extern char *optarg;
+long *key[2];            /* sort from one index into the other */
+long **rank_me;          /* individual processor ranks */
+long *key_partition;     /* keys a processor works on */
+long *rank_partition;    /* ranks a processor works on */
+
+long number_of_processors = DEFAULT_P;
+long max_num_digits;
+long radix = DEFAULT_R;
+long num_keys = DEFAULT_N;
+long max_key = DEFAULT_M;
+long log2_radix;
+long log2_keys;
+long dostats = 0;
+long test_result = 0;
+long doprint = 0;
+
+void slave_sort(void);
+double product_mod_46(double t1, double t2);
+double ran_num_init(unsigned long k, double b, double t);
+long get_max_digits(long max_key);
+long get_log2_radix(long rad);
+long get_log2_keys(long num_keys);
+long log_2(long number);
+void printerr(char *s);
+void init(long key_start, long key_stop, long from);
+void test_sort(long final);
+void printout(void);
+
+int main(int argc, char *argv[])
+{
+   long i;
+   long p;
+   long quotient;
+   long remainder;
+   long sum_i; 
+   long sum_f;
+   long size;
+   long **temp;
+   long **temp2;
+   long *a;
+   long c;
    double mint, maxt, avgt;
    double minrank, maxrank, avgrank;
    double minsort, maxsort, avgsort;
-   unsigned int start;
-   int done = 0;
-   int start_p;
-   int end_p;
-   int level;
-   int index;
-   int base;
-   int offset;
-   int toffset;
+   unsigned long start;
 
 
    CLOCK(start)
@@ -209,39 +194,42 @@
 
    log2_radix = log_2(radix); 
    log2_keys = log_2(num_keys);
-   global = (struct global_memory *) G_MALLOC(sizeof(struct global_memory))
-   key[0] = (int *) G_MALLOC(num_keys*sizeof(int));
-   key[1] = (int *) G_MALLOC(num_keys*sizeof(int));
-   key_partition = (int *) G_MALLOC((number_of_processors+1)*sizeof(int));
-   rank_partition = (int *) G_MALLOC((number_of_processors+1)*sizeof(int));
+   global = (struct global_memory *) G_MALLOC(sizeof(struct global_memory));
+   if (global == NULL) {
+	   fprintf(stderr,"ERROR: Cannot malloc enough memory for global\n");
+	   exit(-1);
+   }
+   key[0] = (long *) G_MALLOC(num_keys*sizeof(long));
+   key[1] = (long *) G_MALLOC(num_keys*sizeof(long));
+   key_partition = (long *) G_MALLOC((number_of_processors+1)*sizeof(long));
+   rank_partition = (long *) G_MALLOC((number_of_processors+1)*sizeof(long));
    global->ranktime = (double *) G_MALLOC(number_of_processors*sizeof(double));
    global->sorttime = (double *) G_MALLOC(number_of_processors*sizeof(double));
    global->totaltime = (double *) G_MALLOC(number_of_processors*sizeof(double));
-   size = number_of_processors*(radix*sizeof(int)+sizeof(int *));
-   rank_me = (int **) G_MALLOC(size);
-   if ((global == NULL) || (key[0] == NULL) || (key[1] == NULL) ||
-       (key_partition == NULL) || (rank_partition == NULL) || 
-       (rank_me == NULL)) {
+   size = number_of_processors*(radix*sizeof(long)+sizeof(long *));
+   rank_me = (long **) G_MALLOC(size);
+   if ((key[0] == NULL) || (key[1] == NULL) || (key_partition == NULL) || (rank_partition == NULL) || 
+       (global->ranktime == NULL) || (global->sorttime == NULL) || (global->totaltime == NULL) || (rank_me == NULL)) {
      fprintf(stderr,"ERROR: Cannot malloc enough memory\n");
      exit(-1); 
    }
 
    temp = rank_me;
    temp2 = temp + number_of_processors;
-   a = (int *) temp2;
+   a = (long *) temp2;
    for (i=0;i<number_of_processors;i++) {
-     *temp = (int *) a;
+     *temp = (long *) a;
      temp++;
      a += radix;
    }
    for (i=0;i<number_of_processors;i++) {
-     gp[i].rank_ff = (int *) G_MALLOC(radix*sizeof(int)+PAGE_SIZE);
+     gp[i].rank_ff = (long *) G_MALLOC(radix*sizeof(long)+PAGE_SIZE);
    }
    LOCKINIT(global->lock_Index)
    LOCKINIT(global->rank_lock)
-   ALOCKINIT(global->section_lock,MAX_PROCESSORS)
-   BARINIT(global->barrier_rank)
-   BARINIT(global->barrier_key)
+/*   ALOCKINIT(global->section_lock,MAX_PROCESSORS)*/
+   BARINIT(global->barrier_rank, number_of_processors)
+   BARINIT(global->barrier_key, number_of_processors)
    
    for (i=0; i<2*number_of_processors; i++) {
      PAUSEINIT(global->prefix_tree[i].done);
@@ -251,10 +239,10 @@
    max_num_digits = get_max_digits(max_key);
    printf("\n");
    printf("Integer Radix Sort\n");
-   printf("     %d Keys\n",num_keys);
-   printf("     %d Processors\n",number_of_processors);
-   printf("     Radix = %d\n",radix);
-   printf("     Max key = %d\n",max_key);
+   printf("     %ld Keys\n",num_keys);
+   printf("     %ld Processors\n",number_of_processors);
+   printf("     Radix = %ld\n",radix);
+   printf("     Max key = %ld\n",max_key);
    printf("\n");
 
    quotient = num_keys / number_of_processors;
@@ -323,13 +311,8 @@
 
    /* Fill the random-number array. */
    
-   for (i = 1; i < number_of_processors; i++) {
-      CREATE(slave_sort)
-   }
-
-   slave_sort();
-
-   WAIT_FOR_END(number_of_processors - 1)
+   CREATE(slave_sort, number_of_processors);
+   WAIT_FOR_END(number_of_processors);
 
    printf("\n");
    printf("                 PROCESS STATISTICS\n");
@@ -369,7 +352,7 @@
      avgrank = avgrank / number_of_processors;
      avgsort = avgsort / number_of_processors;
      for (i=1; i<number_of_processors; i++) {
-       printf("  %3d     %10.0f      %10.0f      %10.0f\n",
+       printf("  %3ld     %10.0f      %10.0f      %10.0f\n",
                i,global->totaltime[i],global->ranktime[i],
                global->sorttime[i]);
      }
@@ -382,15 +365,15 @@
    printf("\n");
    global->starttime = start;
    printf("                 TIMING INFORMATION\n");
-   printf("Start time                        : %16d\n",
+   printf("Start time                        : %16lu\n",
            global->starttime);
-   printf("Initialization finish time        : %16d\n",
+   printf("Initialization finish time        : %16lu\n",
            global->rs);
-   printf("Overall finish time               : %16d\n",
+   printf("Overall finish time               : %16lu\n",
            global->rf);
-   printf("Total time with initialization    : %16d\n",
+   printf("Total time with initialization    : %16lu\n",
            global->rf-global->starttime);
-   printf("Total time without initialization : %16d\n",
+   printf("Total time without initialization : %16lu\n",
            global->rf-global->rs);
    printf("\n");
 
@@ -406,48 +389,43 @@
 
 void slave_sort()
 {
-   int i, j, k, kk, Ind;
-   int MyNum;
-   int this_key;
-   int tmp;
-   int last_key;
-   int loopnum;
-   double ran_num;
-   double sum;
-   int shiftnum;
-   int bb;
-   int my_key;
-   int key_start;
-   int key_stop;
-   int rank_start;
-   int rank_stop;
-   int from=0;
-   int to=1;
-   int *key_density;       /* individual processor key densities */
-   unsigned int time1;
-   unsigned int time2;
-   unsigned int time3;
-   unsigned int time4;
-   unsigned int time5;
-   unsigned int time6;
+   long i;
+   long MyNum;
+   long this_key;
+   long tmp;
+   long loopnum;
+   long shiftnum;
+   long bb;
+   long my_key;
+   long key_start;
+   long key_stop;
+   long rank_start;
+   long rank_stop;
+   long from=0;
+   long to=1;
+   long *key_density;       /* individual processor key densities */
+   unsigned long time1;
+   unsigned long time2;
+   unsigned long time3;
+   unsigned long time4;
+   unsigned long time5;
+   unsigned long time6;
    double ranktime=0;
    double sorttime=0;
-   int *key_from;
-   int *key_to;
-   int *rank_me_mynum;
-   int *rank_me_i;
-   int *rank_ff_mynum;
-   int stats;
+   long *key_from;
+   long *key_to;
+   long *rank_me_mynum;
+   long *rank_ff_mynum;
+   long stats;
    struct prefix_node* n;
    struct prefix_node* r;
    struct prefix_node* l;
    struct prefix_node* my_node;
    struct prefix_node* their_node;
-   volatile int* prefx;
-   int index;
-   int level;
-   int base;
-   int offset;
+   long index;
+   long level;
+   long base;
+   long offset;
 
    stats = dostats;
 
@@ -456,10 +434,13 @@
      global->Index++;
    UNLOCK(global->lock_Index)
 
+   BARINCLUDE(global->barrier_key);
+   BARINCLUDE(global->barrier_rank);
+
 /* POSSIBLE ENHANCEMENT:  Here is where one might pin processes to
    processors to avoid migration */
 
-   key_density = (int *) malloc(radix*sizeof(int));
+   key_density = (long *) G_MALLOC(radix*sizeof(long));
 
    /* Fill the random-number array. */
 
@@ -501,8 +482,8 @@
      for (i = 0; i < radix; i++) {
        rank_me_mynum[i] = 0;
      }  
-     key_from = (int *) key[from];
-     key_to = (int *) key[to];
+     key_from = (long *) key[from];
+     key_to = (long *) key[to];
      for (i=key_start;i<key_stop;i++) {
        my_key = key_from[i] & bb;
        my_key = my_key >> shiftnum;  
@@ -662,38 +643,35 @@
 
 }
 
-double product_mod_46(t1, t2)   /* product_mod_46() returns the product 
-				   (mod 2^46) of t1 and t2.  */
-double t1; 
-double t2;
-
+/*
+ * product_mod_46() returns the product (mod 2^46) of t1 and t2.
+ */
+double product_mod_46(double t1, double t2)
 {
    double a1;
    double b1;
    double a2;
    double b2;
 			
-   a1 = (double)((int)(t1 / RADIX_S));    /* Decompose the arguments.  */
+   a1 = (double)((long)(t1 / RADIX_S));    /* Decompose the arguments.  */
    a2 = t1 - a1 * RADIX_S;
-   b1 = (double)((int)(t2 / RADIX_S));
+   b1 = (double)((long)(t2 / RADIX_S));
    b2 = t2 - b1 * RADIX_S;
    t1 = a1 * b2 + a2 * b1;      /* Multiply the arguments.  */
-   t2 = (double)((int)(t1 / RADIX_S));
+   t2 = (double)((long)(t1 / RADIX_S));
    t2 = t1 - t2 * RADIX_S;
    t1 = t2 * RADIX_S + a2 * b2;
-   t2 = (double)((int)(t1 / RADIX));
+   t2 = (double)((long)(t1 / RADIX));
 
    return (t1 - t2 * RADIX);    /* Return the product.  */
 }
 
-double ran_num_init(k, b, t)    /* finds the (k)th random number,
-				   given the seed, b, and the ratio, t.  */
-unsigned int k;
-double b;
-double t;
-
+/*
+ * finds the (k)th random number, given the seed, b, and the ratio, t.
+ */
+double ran_num_init(unsigned long k, double b, double t)
 {
-   unsigned int j;
+   unsigned long j;
 
    while (k != 0) {             /* while() is executed m times
 				   such that 2^m > k.  */
@@ -708,14 +686,11 @@
    return b;
 }
 
-int get_max_digits(max_key)
-
-int max_key;
-
+long get_max_digits(long max_key)
 {
-  int done = 0;
-  int temp = 1;
-  int key_val;
+  long done = 0;
+  long temp = 1;
+  long key_val;
 
   key_val = max_key;
   while (!done) {
@@ -729,13 +704,10 @@
   return temp;
 }
 
-int get_log2_radix(rad)
-
-int rad;
-
+long get_log2_radix(long rad)
 {
-   int cumulative=1;
-   int out;
+   long cumulative=1;
+   long out;
 
    for (out = 0; out < 20; out++) {
      if (cumulative == rad) {
@@ -744,17 +716,14 @@
        cumulative = cumulative * 2;
      }
    }
-   fprintf(stderr,"ERROR: Radix %d not a power of 2\n", rad);
+   fprintf(stderr,"ERROR: Radix %ld not a power of 2\n", rad);
    exit(-1);
 }
 
-int get_log2_keys(num_keys)
-
-int num_keys;
-
+long get_log2_keys(long num_keys)
 {
-   int cumulative=1;
-   int out;
+   long cumulative=1;
+   long out;
 
    for (out = 0; out < 30; out++) {
      if (cumulative == num_keys) {
@@ -763,18 +732,15 @@
        cumulative = cumulative * 2;
      }
    }
-   fprintf(stderr,"ERROR: Number of keys %d not a power of 2\n", num_keys);
+   fprintf(stderr,"ERROR: Number of keys %ld not a power of 2\n", num_keys);
    exit(-1);
 }
 
-int log_2(number)
-
-int number;
-
+long log_2(long number)
 {
-  int cumulative = 1;
-  int out = 0;
-  int done = 0;
+  long cumulative = 1;
+  long out = 0;
+  long done = 0;
 
   while ((cumulative < number) && (!done) && (out < 50)) {
     if (cumulative == number) {
@@ -792,30 +758,22 @@
   }
 }
 
-void printerr(s)
-
-char *s;
-
+void printerr(char *s)
 {
   fprintf(stderr,"ERROR: %s\n",s);
 }
 
-void init(key_start,key_stop,from)
-
-int key_start;
-int key_stop;
-int from;
-
+void init(long key_start, long key_stop, long from)
 {
    double ran_num;
    double sum;
-   int tmp;
-   int i;
-   int *key_from;
+   long tmp;
+   long i;
+   long *key_from;
 
    ran_num = ran_num_init((key_start << 2) + 1, SEED, RATIO);
    sum = ran_num / RADIX;
-   key_from = (int *) key[from];
+   key_from = (long *) key[from];
    for (i = key_start; i < key_stop; i++) {
       ran_num = product_mod_46(ran_num, RATIO);
       sum = sum + ran_num / RADIX;
@@ -823,35 +781,32 @@
       sum = sum + ran_num / RADIX;
       ran_num = product_mod_46(ran_num, RATIO);
       sum = sum + ran_num / RADIX;
-      key_from[i] = (int) ((sum / 4.0) *  max_key);
-      tmp = (int) ((key_from[i])/100);
+      key_from[i] = (long) ((sum / 4.0) *  max_key);
+      tmp = (long) ((key_from[i])/100);
       ran_num = product_mod_46(ran_num, RATIO);
       sum = ran_num / RADIX;
    }
 }
 
-void test_sort(final)
-
-int final;
-
+void test_sort(long final)
 {
-   int i;
-   int mistake = 0;
-   int *key_final;
+   long i;
+   long mistake = 0;
+   long *key_final;
 
    printf("\n");
    printf("                  TESTING RESULTS\n");
    key_final = key[final];
    for (i = 0; i < num_keys-1; i++) {
      if (key_final[i] > key_final[i + 1]) {
-       fprintf(stderr,"error with key %d, value %d %d \n",
+       fprintf(stderr,"error with key %ld, value %ld %ld \n",
         i,key_final[i],key_final[i + 1]);
        mistake++;
      }
    }
 
    if (mistake) {
-      printf("FAILED: %d keys out of place.\n", mistake);
+      printf("FAILED: %ld keys out of place.\n", mistake);
    } else {
       printf("PASSED: All keys in place.\n");
    }
@@ -859,21 +814,20 @@
 }
 
 void printout()
-
 {
-   int i;
-   int mistake;
-   int *key_final;
+   long i;
+   long *key_final;
 
-   key_final = (int *) key[global->final];
+   key_final = (long *) key[global->final];
    printf("\n");
    printf("                 SORTED KEY VALUES\n");
-   printf("%8d ",key_final[0]);
+   printf("%8ld ",key_final[0]);
    for (i = 0; i < num_keys-1; i++) {
-     printf("%8d ",key_final[i+1]);
+     printf("%8ld ",key_final[i+1]);
      if ((i+2)%5 == 0) {
        printf("\n");
      }
    }
    printf("\n");
 }
+
diff -Naur splash2/codes/Makefile.config splash2-modified/codes/Makefile.config
--- splash2/codes/Makefile.config	1969-12-31 19:00:00.000000000 -0500
+++ splash2-modified/codes/Makefile.config	2007-06-19 16:43:27.000000000 -0400
@@ -0,0 +1,34 @@
+CC := gcc
+CFLAGS := -O3 -pthread -D_POSIX_C_SOURCE=200112
+#CFLAGS := -g3 -pthread -D_POSIX_C_SOURCE=200112
+CFLAGS := $(CFLAGS) -Wall -W -Wmissing-prototypes -Wmissing-declarations -Wredundant-decls -Wdisabled-optimization
+CFLAGS := $(CFLAGS) -Wpadded -Winline -Wpointer-arith -Wsign-compare -Wendif-labels
+LDFLAGS := -lm
+
+BASEDIR := $(HOME)/splash2/codes
+MACROS := $(BASEDIR)/null_macros/c.m4.null
+M4 := m4 -s -Ulen -Uindex
+
+x = *
+
+$(TARGET): $(OBJS)
+	$(CC) $(OBJS) $(CFLAGS) -o $(TARGET) $(LDFLAGS)
+
+clean:
+	rm -rf *.c *.h *.o $(TARGET)
+
+.SUFFIXES:
+.SUFFIXES:	.o .c .C .h .H
+
+.H.h:
+	$(M4) $(MACROS) $*.H > $*.h
+
+.C.c:
+	$(M4) $(MACROS) $*.C > $*.c
+
+.c.o:
+	$(CC) -c $(CFLAGS) $*.c
+
+.C.o:
+	$(M4) $(MACROS) $*.C > $*.c
+	$(CC) -c $(CFLAGS) $*.c
diff -Naur splash2/codes/null_macros/c.m4.null splash2-modified/codes/null_macros/c.m4.null
--- splash2/codes/null_macros/c.m4.null	1994-10-11 23:46:01.000000000 -0400
+++ splash2-modified/codes/null_macros/c.m4.null	2007-06-19 16:42:13.000000000 -0400
@@ -2,39 +2,43 @@
 define(NEWPROC,) dnl
 
 define(BARRIER, `{;}')
-define(BARDEC, `int ($1);')
+define(BARDEC, `long ($1);')
 define(BARINIT, `{;}')
 
-define(GSDEC, `int ($1);')
+define(BAREXCLUDE, `{;}')
+
+define(BARINCLUDE, `{;}')
+
+define(GSDEC, `long ($1);')
 define(GSINIT, `{ ($1) = 0; }')
-define(GETSUB, `{ 
-  if (($1)<=($3)) 
-    ($2) = ($1)++; 
-  else { 
-    ($2) = -1; 
-    ($1) = 0; 
+define(GETSUB, `{
+  if (($1)<=($3))
+    ($2) = ($1)++;
+  else {
+    ($2) = -1;
+    ($1) = 0;
   }
 }')
 
-define(NU_GSDEC, `int ($1);')
+define(NU_GSDEC, `long ($1);')
 define(NU_GSINIT, `{ ($1) = 0; }')
 define(NU_GETSUB, `GETSUB($1,$2,$3,$4)')
 
-define(ADEC, `int ($1);')
+define(ADEC, `long ($1);')
 define(AINIT, `{;}')
 define(PROBEND, `{;}')
 
-define(LOCKDEC, `int ($1);')
+define(LOCKDEC, `long ($1);')
 define(LOCKINIT, `{;}')
 define(LOCK, `{;}')
 define(UNLOCK, `{;}')
 
-define(NLOCKDEC, `int ($1);')
+define(NLOCKDEC, `long ($1);')
 define(NLOCKINIT, `{;}')
 define(NLOCK, `{;}')
 define(NUNLOCK, `{;}')
 
-define(ALOCKDEC, `int ($1);')
+define(ALOCKDEC, `long ($1);')
 define(ALOCKINIT, `{;}')
 define(ALOCK, `{;}')
 define(AULOCK, `{;}')
diff -Naur splash2/codes/null_macros/c.m4.null.POSIX splash2-modified/codes/null_macros/c.m4.null.POSIX
--- splash2/codes/null_macros/c.m4.null.POSIX	1969-12-31 19:00:00.000000000 -0500
+++ splash2-modified/codes/null_macros/c.m4.null.POSIX	2007-03-09 22:31:28.000000000 -0500
@@ -0,0 +1,228 @@
+divert(-1)
+define(NEWPROC,) dnl
+
+define(BARRIER, `{
+	unsigned long	Error, Cycle;
+	long		Cancel, Temp;
+
+	Error = pthread_mutex_lock(&($1).mutex);
+	if (Error != 0) {
+		printf("Error while trying to get lock in barrier.\n");
+		exit(-1);
+	}
+
+	Cycle = ($1).cycle;
+	if (++($1).counter != ($2)) {
+		pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &Cancel);
+		while (Cycle == ($1).cycle) {
+			Error = pthread_cond_wait(&($1).cv, &($1).mutex);
+			if (Error != 0) {
+				break;
+			}
+		}
+		pthread_setcancelstate(Cancel, &Temp);
+	} else {
+		($1).cycle = !($1).cycle;
+		($1).counter = 0;
+		Error = pthread_cond_broadcast(&($1).cv);
+	}
+	pthread_mutex_unlock(&($1).mutex);
+}')
+
+define(BARDEC, `
+struct {
+	pthread_mutex_t	mutex;
+	pthread_cond_t	cv;
+	unsigned long	counter;
+	unsigned long	cycle;
+} ($1);
+')
+
+define(BARINIT, `{
+	unsigned long	Error;
+
+	Error = pthread_mutex_init(&($1).mutex, NULL);
+	if (Error != 0) {
+		printf("Error while initializing barrier.\n");
+		exit(-1);
+	}
+
+	Error = pthread_cond_init(&($1).cv, NULL);
+	if (Error != 0) {
+		printf("Error while initializing barrier.\n");
+		pthread_mutex_destroy(&($1).mutex);
+		exit(-1);
+	}
+
+	($1).counter = 0;
+	($1).cycle = 0;
+}')
+
+define(BAREXCLUDE, `{;}')
+
+define(BARINCLUDE, `{;}')
+
+define(GSDEC, `long ($1);')
+define(GSINIT, `{ ($1) = 0; }')
+define(GETSUB, `{
+  if (($1)<=($3))
+    ($2) = ($1)++;
+  else {
+    ($2) = -1;
+    ($1) = 0;
+  }
+}')
+
+define(NU_GSDEC, `long ($1);')
+define(NU_GSINIT, `{ ($1) = 0; }')
+define(NU_GETSUB, `GETSUB($1,$2,$3,$4)')
+
+define(ADEC, `long ($1);')
+define(AINIT, `{;}')
+define(PROBEND, `{;}')
+
+define(LOCKDEC, `pthread_mutex_t ($1);')
+define(LOCKINIT, `{pthread_mutex_init(&($1), NULL);}')
+define(LOCK, `{pthread_mutex_lock(&($1));}')
+define(UNLOCK, `{pthread_mutex_unlock(&($1));}')
+
+define(NLOCKDEC, `long ($1);')
+define(NLOCKINIT, `{;}')
+define(NLOCK, `{;}')
+define(NUNLOCK, `{;}')
+
+define(ALOCKDEC, `pthread_mutex_t $1[$2];')
+define(ALOCKINIT, `{
+	unsigned long	i, Error;
+
+	for (i = 0; i < $2; i++) {
+		Error = pthread_mutex_init(&$1[i], NULL);
+		if (Error != 0) {
+			printf("Error while initializing array of locks.\n");
+			exit(-1);
+		}
+	}
+}')
+define(ALOCK, `{pthread_mutex_lock(&$1[$2]);}')
+define(AULOCK, `{pthread_mutex_unlock(&$1[$2]);}')
+
+define(PAUSEDEC, `
+struct {
+	pthread_mutex_t	Mutex;
+	pthread_cond_t	CondVar;
+	unsigned long	Flag;
+} $1;
+')
+define(PAUSEINIT, `{
+	pthread_mutex_init(&$1.Mutex, NULL);
+	pthread_cond_init(&$1.CondVar, NULL);
+	$1.Flag = 0;
+}
+')
+define(CLEARPAUSE, `{
+	$1.Flag = 0;
+	pthread_mutex_unlock(&$1.Mutex);}
+')
+define(SETPAUSE, `{
+	pthread_mutex_lock(&$1.Mutex);
+	$1.Flag = 1;
+	pthread_cond_broadcast(&$1.CondVar);
+	pthread_mutex_unlock(&$1.Mutex);}
+')
+define(EVENT, `{;}')
+define(WAITPAUSE, `{
+	pthread_mutex_lock(&$1.Mutex);
+	if ($1.Flag == 0) {
+		pthread_cond_wait(&$1.CondVar, &$1.Mutex);
+	}
+}')
+define(PAUSE, `{;}')
+
+define(AUG_ON, ` ')
+define(AUG_OFF, ` ')
+define(TRACE_ON, ` ')
+define(TRACE_OFF, ` ')
+define(REF_TRACE_ON, ` ')
+define(REF_TRACE_OFF, ` ')
+define(DYN_TRACE_ON, `;')
+define(DYN_TRACE_OFF, `;')
+define(DYN_REF_TRACE_ON, `;')
+define(DYN_REF_TRACE_OFF, `;')
+define(DYN_SIM_ON, `;')
+define(DYN_SIM_OFF, `;')
+define(DYN_SCHED_ON, `;')
+define(DYN_SCHED_OFF, `;')
+define(AUG_SET_LOLIMIT, `;')
+define(AUG_SET_HILIMIT, `;')
+
+define(MENTER, `{;}')
+define(DELAY, `{;}')
+define(CONTINUE, `{;}')
+define(MEXIT, `{;}')
+define(MONINIT, `{;}')
+
+define(WAIT_FOR_END, `{
+	unsigned long	i, Error;
+	for (i = 0; i < ($1) - 1; i++) {
+		Error = pthread_join(PThreadTable[i], NULL);
+		if (Error != 0) {
+			printf("Error in pthread_join().\n");
+			exit(-1);
+		}
+	}
+}')
+
+define(CREATE, `{
+	long	i, Error;
+
+	for (i = 0; i < ($2) - 1; i++) {
+		Error = pthread_create(&PThreadTable[i], NULL, (void * (*)(void *))($1), NULL);
+		if (Error != 0) {
+			printf("Error in pthread_create().\n");
+			exit(-1);
+		}
+	}
+
+	$1();
+}')
+
+define(MAIN_INITENV, `{;}')
+define(MAIN_END, `{exit(0);}')
+
+define(MAIN_ENV,`
+#include <pthread.h>
+#include <sys/time.h>
+#include <unistd.h>
+#include <stdlib.h>
+#define MAX_THREADS 32
+pthread_t PThreadTable[MAX_THREADS];
+')
+
+define(ENV, ` ')
+define(EXTERN_ENV, `
+#include <pthread.h>
+#include <sys/time.h>
+#include <unistd.h>
+#include <stdlib.h>
+extern pthread_t PThreadTable[];
+')
+
+define(G_MALLOC, `valloc($1);')
+define(G_FREE, `;')
+define(G_MALLOC_F, `valloc($1)')
+define(NU_MALLOC, `valloc($1);')
+define(NU_FREE, `;')
+define(NU_MALLOC_F, `valloc($1)')
+
+define(GET_HOME, `{($1) = 0;}')
+define(GET_PID, `{($1) = 0;}')
+define(AUG_DELAY, `{sleep ($1);}')
+define(ST_LOG, `{;}')
+define(SET_HOME, `{;}')
+define(CLOCK, `{
+	struct timeval	FullTime;
+
+	gettimeofday(&FullTime, NULL);
+	($1) = (unsigned long)(FullTime.tv_usec + FullTime.tv_sec * 1000000);
+}')
+divert(0)
diff -Naur splash2/codes/null_macros/c.m4.null.POSIX_BARRIER splash2-modified/codes/null_macros/c.m4.null.POSIX_BARRIER
--- splash2/codes/null_macros/c.m4.null.POSIX_BARRIER	1969-12-31 19:00:00.000000000 -0500
+++ splash2-modified/codes/null_macros/c.m4.null.POSIX_BARRIER	2007-03-09 22:31:42.000000000 -0500
@@ -0,0 +1,185 @@
+divert(-1)
+define(NEWPROC,) dnl
+
+define(BARRIER, `{
+	pthread_barrier_wait(&($1));
+}')
+
+define(BARDEC, `
+pthread_barrier_t	($1);
+')
+
+define(BARINIT, `{
+	pthread_barrier_init(&($1), NULL, $2);
+}')
+
+define(BAREXCLUDE, `{;}')
+
+define(BARINCLUDE, `{;}')
+
+define(GSDEC, `long ($1);')
+define(GSINIT, `{ ($1) = 0; }')
+define(GETSUB, `{
+  if (($1)<=($3))
+    ($2) = ($1)++;
+  else {
+    ($2) = -1;
+    ($1) = 0;
+  }
+}')
+
+define(NU_GSDEC, `long ($1);')
+define(NU_GSINIT, `{ ($1) = 0; }')
+define(NU_GETSUB, `GETSUB($1,$2,$3,$4)')
+
+define(ADEC, `long ($1);')
+define(AINIT, `{;}')
+define(PROBEND, `{;}')
+
+define(LOCKDEC, `pthread_mutex_t ($1);')
+define(LOCKINIT, `{pthread_mutex_init(&($1), NULL);}')
+define(LOCK, `{pthread_mutex_lock(&($1));}')
+define(UNLOCK, `{pthread_mutex_unlock(&($1));}')
+
+define(NLOCKDEC, `long ($1);')
+define(NLOCKINIT, `{;}')
+define(NLOCK, `{;}')
+define(NUNLOCK, `{;}')
+
+define(ALOCKDEC, `pthread_mutex_t $1[$2];')
+define(ALOCKINIT, `{
+	unsigned long	i, Error;
+
+	for (i = 0; i < $2; i++) {
+		Error = pthread_mutex_init(&$1[i], NULL);
+		if (Error != 0) {
+			printf("Error while initializing array of locks.\n");
+			exit(-1);
+		}
+	}
+}')
+define(ALOCK, `{pthread_mutex_lock(&$1[$2]);}')
+define(AULOCK, `{pthread_mutex_unlock(&$1[$2]);}')
+
+define(PAUSEDEC, `
+struct {
+	pthread_mutex_t	Mutex;
+	pthread_cond_t	CondVar;
+	unsigned long	Flag;
+} $1;
+')
+define(PAUSEINIT, `{
+	pthread_mutex_init(&$1.Mutex, NULL);
+	pthread_cond_init(&$1.CondVar, NULL);
+	$1.Flag = 0;
+}
+')
+define(CLEARPAUSE, `{
+	$1.Flag = 0;
+	pthread_mutex_unlock(&$1.Mutex);}
+')
+define(SETPAUSE, `{
+	pthread_mutex_lock(&$1.Mutex);
+	$1.Flag = 1;
+	pthread_cond_broadcast(&$1.CondVar);
+	pthread_mutex_unlock(&$1.Mutex);}
+')
+define(EVENT, `{;}')
+define(WAITPAUSE, `{
+	pthread_mutex_lock(&$1.Mutex);
+	if ($1.Flag == 0) {
+		pthread_cond_wait(&$1.CondVar, &$1.Mutex);
+	}
+}')
+define(PAUSE, `{;}')
+
+define(AUG_ON, ` ')
+define(AUG_OFF, ` ')
+define(TRACE_ON, ` ')
+define(TRACE_OFF, ` ')
+define(REF_TRACE_ON, ` ')
+define(REF_TRACE_OFF, ` ')
+define(DYN_TRACE_ON, `;')
+define(DYN_TRACE_OFF, `;')
+define(DYN_REF_TRACE_ON, `;')
+define(DYN_REF_TRACE_OFF, `;')
+define(DYN_SIM_ON, `;')
+define(DYN_SIM_OFF, `;')
+define(DYN_SCHED_ON, `;')
+define(DYN_SCHED_OFF, `;')
+define(AUG_SET_LOLIMIT, `;')
+define(AUG_SET_HILIMIT, `;')
+
+define(MENTER, `{;}')
+define(DELAY, `{;}')
+define(CONTINUE, `{;}')
+define(MEXIT, `{;}')
+define(MONINIT, `{;}')
+
+define(WAIT_FOR_END, `{
+	long	i, Error;
+	for (i = 0; i < ($1) - 1; i++) {
+		Error = pthread_join(PThreadTable[i], NULL);
+		if (Error != 0) {
+			printf("Error in pthread_join().\n");
+			exit(-1);
+		}
+	}
+}')
+
+define(CREATE, `{
+	long	i, Error;
+
+	for (i = 0; i < ($2) - 1; i++) {
+		Error = pthread_create(&PThreadTable[i], NULL, (void * (*)(void *))($1), NULL);
+		if (Error != 0) {
+			printf("Error in pthread_create().\n");
+			exit(-1);
+		}
+	}
+
+	$1();
+}')
+
+define(MAIN_INITENV, `{;}')
+define(MAIN_END, `{exit(0);}')
+
+define(MAIN_ENV,`
+#include <pthread.h>
+#include <sys/time.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <malloc.h>
+#define MAX_THREADS 32
+pthread_t PThreadTable[MAX_THREADS];
+')
+
+define(ENV, ` ')
+define(EXTERN_ENV, `
+#include <pthread.h>
+#include <sys/time.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <malloc.h>
+extern pthread_t PThreadTable[];
+')
+
+define(G_MALLOC, `valloc($1);')
+define(G_FREE, `;')
+define(G_MALLOC_F, `valloc($1)')
+define(NU_MALLOC, `valloc($1);')
+define(NU_FREE, `;')
+define(NU_MALLOC_F, `valloc($1)')
+
+define(GET_HOME, `{($1) = 0;}')
+define(GET_PID, `{($1) = 0;}')
+define(AUG_DELAY, `{sleep ($1);}')
+define(ST_LOG, `{;}')
+define(SET_HOME, `{;}')
+define(CLOCK, `{
+	struct timeval	FullTime;
+
+	gettimeofday(&FullTime, NULL);
+	($1) = (unsigned long)(FullTime.tv_usec + FullTime.tv_sec * 1000000);
+}')
+divert(0)
